(self.webpackChunkpwb_website_base =
  self.webpackChunkpwb_website_base || []).push([
  [240],
  {
    8792: (e) => {
      "use strict";
      e.exports = function e(t, n) {
        if (t === n) return !0;
        if (t && n && "object" == typeof t && "object" == typeof n) {
          if (t.constructor !== n.constructor) return !1;
          var i, r, s;
          if (Array.isArray(t)) {
            if ((i = t.length) != n.length) return !1;
            for (r = i; 0 != r--; ) if (!e(t[r], n[r])) return !1;
            return !0;
          }
          if (t.constructor === RegExp)
            return t.source === n.source && t.flags === n.flags;
          if (t.valueOf !== Object.prototype.valueOf)
            return t.valueOf() === n.valueOf();
          if (t.toString !== Object.prototype.toString)
            return t.toString() === n.toString();
          if ((i = (s = Object.keys(t)).length) !== Object.keys(n).length)
            return !1;
          for (r = i; 0 != r--; )
            if (!Object.prototype.hasOwnProperty.call(n, s[r])) return !1;
          for (r = i; 0 != r--; ) {
            var a = s[r];
            if (!e(t[a], n[a])) return !1;
          }
          return !0;
        }
        return t != t && n != n;
      };
    },
    7629: (e, t, n) => {
      "use strict";
      function i(e) {
        if (void 0 === e)
          throw new ReferenceError(
            "this hasn't been initialised - super() hasn't been called"
          );
        return e;
      }
      function r(e, t) {
        (e.prototype = Object.create(t.prototype)),
          (e.prototype.constructor = e),
          (e.__proto__ = t);
      }
      n.d(t, { Ay: () => Yi });
      var s,
        a,
        o,
        l,
        c,
        u,
        h,
        d,
        p,
        f,
        A,
        g,
        m,
        v,
        y,
        x = {
          autoSleep: 120,
          force3D: "auto",
          nullTargetWarn: 1,
          units: { lineHeight: "" },
        },
        _ = { duration: 0.5, overwrite: !1, delay: 0 },
        b = 1e8,
        E = 1e-8,
        w = 2 * Math.PI,
        C = w / 4,
        I = 0,
        S = Math.sqrt,
        M = Math.cos,
        T = Math.sin,
        B = function (e) {
          return "string" == typeof e;
        },
        R = function (e) {
          return "function" == typeof e;
        },
        D = function (e) {
          return "number" == typeof e;
        },
        P = function (e) {
          return void 0 === e;
        },
        L = function (e) {
          return "object" == typeof e;
        },
        U = function (e) {
          return !1 !== e;
        },
        F = function () {
          return "undefined" != typeof window;
        },
        N = function (e) {
          return R(e) || B(e);
        },
        O =
          ("function" == typeof ArrayBuffer && ArrayBuffer.isView) ||
          function () {},
        Q = Array.isArray,
        k = /(?:-?\.?\d|\.)+/gi,
        G = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
        H = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
        z = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
        V = /[+-]=-?[.\d]+/,
        W = /[^,'"\[\]\s]+/gi,
        j = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
        q = {},
        Y = {},
        X = function (e) {
          return (Y = we(e, q)) && In;
        },
        K = function (e, t) {
          return console.warn(
            "Invalid property",
            e,
            "set to",
            t,
            "Missing plugin? gsap.registerPlugin()"
          );
        },
        J = function (e, t) {
          return !t && console.warn(e);
        },
        Z = function (e, t) {
          return (e && (q[e] = t) && Y && (Y[e] = t)) || q;
        },
        $ = function () {
          return 0;
        },
        ee = { suppressEvents: !0, isStart: !0, kill: !1 },
        te = { suppressEvents: !0, kill: !1 },
        ne = { suppressEvents: !0 },
        ie = {},
        re = [],
        se = {},
        ae = {},
        oe = {},
        le = 30,
        ce = [],
        ue = "",
        he = function (e) {
          var t,
            n,
            i = e[0];
          if ((L(i) || R(i) || (e = [e]), !(t = (i._gsap || {}).harness))) {
            for (n = ce.length; n-- && !ce[n].targetTest(i); );
            t = ce[n];
          }
          for (n = e.length; n--; )
            (e[n] && (e[n]._gsap || (e[n]._gsap = new Qt(e[n], t)))) ||
              e.splice(n, 1);
          return e;
        },
        de = function (e) {
          return e._gsap || he(nt(e))[0]._gsap;
        },
        pe = function (e, t, n) {
          return (n = e[t]) && R(n)
            ? e[t]()
            : (P(n) && e.getAttribute && e.getAttribute(t)) || n;
        },
        fe = function (e, t) {
          return (e = e.split(",")).forEach(t) || e;
        },
        Ae = function (e) {
          return Math.round(1e5 * e) / 1e5 || 0;
        },
        ge = function (e) {
          return Math.round(1e7 * e) / 1e7 || 0;
        },
        me = function (e, t) {
          var n = t.charAt(0),
            i = parseFloat(t.substr(2));
          return (
            (e = parseFloat(e)),
            "+" === n ? e + i : "-" === n ? e - i : "*" === n ? e * i : e / i
          );
        },
        ve = function (e, t) {
          for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n; );
          return i < n;
        },
        ye = function () {
          var e,
            t,
            n = re.length,
            i = re.slice(0);
          for (se = {}, re.length = 0, e = 0; e < n; e++)
            (t = i[e]) &&
              t._lazy &&
              (t.render(t._lazy[0], t._lazy[1], !0)._lazy = 0);
        },
        xe = function (e, t, n, i) {
          re.length && !a && ye(),
            e.render(t, n, i || (a && t < 0 && (e._initted || e._startAt))),
            re.length && !a && ye();
        },
        _e = function (e) {
          var t = parseFloat(e);
          return (t || 0 === t) && (e + "").match(W).length < 2
            ? t
            : B(e)
            ? e.trim()
            : e;
        },
        be = function (e) {
          return e;
        },
        Ee = function (e, t) {
          for (var n in t) n in e || (e[n] = t[n]);
          return e;
        },
        we = function (e, t) {
          for (var n in t) e[n] = t[n];
          return e;
        },
        Ce = function e(t, n) {
          for (var i in n)
            "__proto__" !== i &&
              "constructor" !== i &&
              "prototype" !== i &&
              (t[i] = L(n[i]) ? e(t[i] || (t[i] = {}), n[i]) : n[i]);
          return t;
        },
        Ie = function (e, t) {
          var n,
            i = {};
          for (n in e) n in t || (i[n] = e[n]);
          return i;
        },
        Se = function (e) {
          var t,
            n = e.parent || l,
            i = e.keyframes
              ? ((t = Q(e.keyframes)),
                function (e, n) {
                  for (var i in n)
                    i in e ||
                      ("duration" === i && t) ||
                      "ease" === i ||
                      (e[i] = n[i]);
                })
              : Ee;
          if (U(e.inherit))
            for (; n; ) i(e, n.vars.defaults), (n = n.parent || n._dp);
          return e;
        },
        Me = function (e, t, n, i, r) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var s,
            a = e[i];
          if (r) for (s = t[r]; a && a[r] > s; ) a = a._prev;
          return (
            a
              ? ((t._next = a._next), (a._next = t))
              : ((t._next = e[n]), (e[n] = t)),
            t._next ? (t._next._prev = t) : (e[i] = t),
            (t._prev = a),
            (t.parent = t._dp = e),
            t
          );
        },
        Te = function (e, t, n, i) {
          void 0 === n && (n = "_first"), void 0 === i && (i = "_last");
          var r = t._prev,
            s = t._next;
          r ? (r._next = s) : e[n] === t && (e[n] = s),
            s ? (s._prev = r) : e[i] === t && (e[i] = r),
            (t._next = t._prev = t.parent = null);
        },
        Be = function (e, t) {
          e.parent &&
            (!t || e.parent.autoRemoveChildren) &&
            e.parent.remove &&
            e.parent.remove(e),
            (e._act = 0);
        },
        Re = function (e, t) {
          if (e && (!t || t._end > e._dur || t._start < 0))
            for (var n = e; n; ) (n._dirty = 1), (n = n.parent);
          return e;
        },
        De = function (e, t, n, i) {
          return (
            e._startAt &&
            (a
              ? e._startAt.revert(te)
              : (e.vars.immediateRender && !e.vars.autoRevert) ||
                e._startAt.render(t, !0, i))
          );
        },
        Pe = function e(t) {
          return !t || (t._ts && e(t.parent));
        },
        Le = function (e) {
          return e._repeat
            ? Ue(e._tTime, (e = e.duration() + e._rDelay)) * e
            : 0;
        },
        Ue = function (e, t) {
          var n = Math.floor((e /= t));
          return e && n === e ? n - 1 : n;
        },
        Fe = function (e, t) {
          return (
            (e - t._start) * t._ts +
            (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
          );
        },
        Ne = function (e) {
          return (e._end = ge(
            e._start + (e._tDur / Math.abs(e._ts || e._rts || E) || 0)
          ));
        },
        Oe = function (e, t) {
          var n = e._dp;
          return (
            n &&
              n.smoothChildTiming &&
              e._ts &&
              ((e._start = ge(
                n._time -
                  (e._ts > 0
                    ? t / e._ts
                    : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)
              )),
              Ne(e),
              n._dirty || Re(n, e)),
            e
          );
        },
        Qe = function (e, t) {
          var n;
          if (
            ((t._time ||
              (!t._dur && t._initted) ||
              (t._start < e._time && (t._dur || !t.add))) &&
              ((n = Fe(e.rawTime(), t)),
              (!t._dur || Je(0, t.totalDuration(), n) - t._tTime > E) &&
                t.render(n, !0)),
            Re(e, t)._dp && e._initted && e._time >= e._dur && e._ts)
          ) {
            if (e._dur < e.duration())
              for (n = e; n._dp; )
                n.rawTime() >= 0 && n.totalTime(n._tTime), (n = n._dp);
            e._zTime = -1e-8;
          }
        },
        ke = function (e, t, n, i) {
          return (
            t.parent && Be(t),
            (t._start = ge(
              (D(n) ? n : n || e !== l ? Ye(e, n, t) : e._time) + t._delay
            )),
            (t._end = ge(
              t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)
            )),
            Me(e, t, "_first", "_last", e._sort ? "_start" : 0),
            Ve(t) || (e._recent = t),
            i || Qe(e, t),
            e._ts < 0 && Oe(e, e._tTime),
            e
          );
        },
        Ge = function (e, t) {
          return (
            (q.ScrollTrigger || K("scrollTrigger", t)) &&
            q.ScrollTrigger.create(t, e)
          );
        },
        He = function (e, t, n, i, r) {
          return (
            qt(e, t, r),
            e._initted
              ? !n &&
                e._pt &&
                !a &&
                ((e._dur && !1 !== e.vars.lazy) || (!e._dur && e.vars.lazy)) &&
                p !== It.frame
                ? (re.push(e), (e._lazy = [r, i]), 1)
                : void 0
              : 1
          );
        },
        ze = function e(t) {
          var n = t.parent;
          return (
            n && n._ts && n._initted && !n._lock && (n.rawTime() < 0 || e(n))
          );
        },
        Ve = function (e) {
          var t = e.data;
          return "isFromStart" === t || "isStart" === t;
        },
        We = function (e, t, n, i) {
          var r = e._repeat,
            s = ge(t) || 0,
            a = e._tTime / e._tDur;
          return (
            a && !i && (e._time *= s / e._dur),
            (e._dur = s),
            (e._tDur = r
              ? r < 0
                ? 1e10
                : ge(s * (r + 1) + e._rDelay * r)
              : s),
            a > 0 && !i && Oe(e, (e._tTime = e._tDur * a)),
            e.parent && Ne(e),
            n || Re(e.parent, e),
            e
          );
        },
        je = function (e) {
          return e instanceof Gt ? Re(e) : We(e, e._dur);
        },
        qe = { _start: 0, endTime: $, totalDuration: $ },
        Ye = function e(t, n, i) {
          var r,
            s,
            a,
            o = t.labels,
            l = t._recent || qe,
            c = t.duration() >= b ? l.endTime(!1) : t._dur;
          return B(n) && (isNaN(n) || n in o)
            ? ((s = n.charAt(0)),
              (a = "%" === n.substr(-1)),
              (r = n.indexOf("=")),
              "<" === s || ">" === s
                ? (r >= 0 && (n = n.replace(/=/, "")),
                  ("<" === s ? l._start : l.endTime(l._repeat >= 0)) +
                    (parseFloat(n.substr(1)) || 0) *
                      (a ? (r < 0 ? l : i).totalDuration() / 100 : 1))
                : r < 0
                ? (n in o || (o[n] = c), o[n])
                : ((s = parseFloat(n.charAt(r - 1) + n.substr(r + 1))),
                  a && i && (s = (s / 100) * (Q(i) ? i[0] : i).totalDuration()),
                  r > 1 ? e(t, n.substr(0, r - 1), i) + s : c + s))
            : null == n
            ? c
            : +n;
        },
        Xe = function (e, t, n) {
          var i,
            r,
            s = D(t[1]),
            a = (s ? 2 : 1) + (e < 2 ? 0 : 1),
            o = t[a];
          if ((s && (o.duration = t[1]), (o.parent = n), e)) {
            for (i = o, r = n; r && !("immediateRender" in i); )
              (i = r.vars.defaults || {}), (r = U(r.vars.inherit) && r.parent);
            (o.immediateRender = U(i.immediateRender)),
              e < 2 ? (o.runBackwards = 1) : (o.startAt = t[a - 1]);
          }
          return new Zt(t[0], o, t[a + 1]);
        },
        Ke = function (e, t) {
          return e || 0 === e ? t(e) : t;
        },
        Je = function (e, t, n) {
          return n < e ? e : n > t ? t : n;
        },
        Ze = function (e, t) {
          return B(e) && (t = j.exec(e)) ? t[1] : "";
        },
        $e = [].slice,
        et = function (e, t) {
          return (
            e &&
            L(e) &&
            "length" in e &&
            ((!t && !e.length) || (e.length - 1 in e && L(e[0]))) &&
            !e.nodeType &&
            e !== c
          );
        },
        tt = function (e, t, n) {
          return (
            void 0 === n && (n = []),
            e.forEach(function (e) {
              var i;
              return (B(e) && !t) || et(e, 1)
                ? (i = n).push.apply(i, nt(e))
                : n.push(e);
            }) || n
          );
        },
        nt = function (e, t, n) {
          return o && !t && o.selector
            ? o.selector(e)
            : !B(e) || n || (!u && St())
            ? Q(e)
              ? tt(e, n)
              : et(e)
              ? $e.call(e, 0)
              : e
              ? [e]
              : []
            : $e.call((t || h).querySelectorAll(e), 0);
        },
        it = function (e) {
          return (
            (e = nt(e)[0] || J("Invalid scope") || {}),
            function (t) {
              var n = e.current || e.nativeElement || e;
              return nt(
                t,
                n.querySelectorAll
                  ? n
                  : n === e
                  ? J("Invalid scope") || h.createElement("div")
                  : e
              );
            }
          );
        },
        rt = function (e) {
          return e.sort(function () {
            return 0.5 - Math.random();
          });
        },
        st = function (e) {
          if (R(e)) return e;
          var t = L(e) ? e : { each: e },
            n = Lt(t.ease),
            i = t.from || 0,
            r = parseFloat(t.base) || 0,
            s = {},
            a = i > 0 && i < 1,
            o = isNaN(i) || a,
            l = t.axis,
            c = i,
            u = i;
          return (
            B(i)
              ? (c = u = { center: 0.5, edges: 0.5, end: 1 }[i] || 0)
              : !a && o && ((c = i[0]), (u = i[1])),
            function (e, a, h) {
              var d,
                p,
                f,
                A,
                g,
                m,
                v,
                y,
                x,
                _ = (h || t).length,
                E = s[_];
              if (!E) {
                if (!(x = "auto" === t.grid ? 0 : (t.grid || [1, b])[1])) {
                  for (
                    v = -b;
                    v < (v = h[x++].getBoundingClientRect().left) && x < _;

                  );
                  x < _ && x--;
                }
                for (
                  E = s[_] = [],
                    d = o ? Math.min(x, _) * c - 0.5 : i % x,
                    p = x === b ? 0 : o ? (_ * u) / x - 0.5 : (i / x) | 0,
                    v = 0,
                    y = b,
                    m = 0;
                  m < _;
                  m++
                )
                  (f = (m % x) - d),
                    (A = p - ((m / x) | 0)),
                    (E[m] = g =
                      l ? Math.abs("y" === l ? A : f) : S(f * f + A * A)),
                    g > v && (v = g),
                    g < y && (y = g);
                "random" === i && rt(E),
                  (E.max = v - y),
                  (E.min = y),
                  (E.v = _ =
                    (parseFloat(t.amount) ||
                      parseFloat(t.each) *
                        (x > _
                          ? _ - 1
                          : l
                          ? "y" === l
                            ? _ / x
                            : x
                          : Math.max(x, _ / x)) ||
                      0) * ("edges" === i ? -1 : 1)),
                  (E.b = _ < 0 ? r - _ : r),
                  (E.u = Ze(t.amount || t.each) || 0),
                  (n = n && _ < 0 ? Dt(n) : n);
              }
              return (
                (_ = (E[e] - E.min) / E.max || 0),
                ge(E.b + (n ? n(_) : _) * E.v) + E.u
              );
            }
          );
        },
        at = function (e) {
          var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
          return function (n) {
            var i = ge(Math.round(parseFloat(n) / e) * e * t);
            return (i - (i % 1)) / t + (D(n) ? 0 : Ze(n));
          };
        },
        ot = function (e, t) {
          var n,
            i,
            r = Q(e);
          return (
            !r &&
              L(e) &&
              ((n = r = e.radius || b),
              e.values
                ? ((e = nt(e.values)), (i = !D(e[0])) && (n *= n))
                : (e = at(e.increment))),
            Ke(
              t,
              r
                ? R(e)
                  ? function (t) {
                      return (i = e(t)), Math.abs(i - t) <= n ? i : t;
                    }
                  : function (t) {
                      for (
                        var r,
                          s,
                          a = parseFloat(i ? t.x : t),
                          o = parseFloat(i ? t.y : 0),
                          l = b,
                          c = 0,
                          u = e.length;
                        u--;

                      )
                        (r = i
                          ? (r = e[u].x - a) * r + (s = e[u].y - o) * s
                          : Math.abs(e[u] - a)) < l && ((l = r), (c = u));
                      return (
                        (c = !n || l <= n ? e[c] : t),
                        i || c === t || D(t) ? c : c + Ze(t)
                      );
                    }
                : at(e)
            )
          );
        },
        lt = function (e, t, n, i) {
          return Ke(Q(e) ? !t : !0 === n ? !!(n = 0) : !i, function () {
            return Q(e)
              ? e[~~(Math.random() * e.length)]
              : (n = n || 1e-5) &&
                  (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) &&
                  Math.floor(
                    Math.round(
                      (e - n / 2 + Math.random() * (t - e + 0.99 * n)) / n
                    ) *
                      n *
                      i
                  ) / i;
          });
        },
        ct = function (e, t, n) {
          return Ke(n, function (n) {
            return e[~~t(n)];
          });
        },
        ut = function (e) {
          for (var t, n, i, r, s = 0, a = ""; ~(t = e.indexOf("random(", s)); )
            (i = e.indexOf(")", t)),
              (r = "[" === e.charAt(t + 7)),
              (n = e.substr(t + 7, i - t - 7).match(r ? W : k)),
              (a +=
                e.substr(s, t - s) +
                lt(r ? n : +n[0], r ? 0 : +n[1], +n[2] || 1e-5)),
              (s = i + 1);
          return a + e.substr(s, e.length - s);
        },
        ht = function (e, t, n, i, r) {
          var s = t - e,
            a = i - n;
          return Ke(r, function (t) {
            return n + (((t - e) / s) * a || 0);
          });
        },
        dt = function (e, t, n) {
          var i,
            r,
            s,
            a = e.labels,
            o = b;
          for (i in a)
            (r = a[i] - t) < 0 == !!n &&
              r &&
              o > (r = Math.abs(r)) &&
              ((s = i), (o = r));
          return s;
        },
        pt = function (e, t, n) {
          var i,
            r,
            s,
            a = e.vars,
            l = a[t],
            c = o,
            u = e._ctx;
          if (l)
            return (
              (i = a[t + "Params"]),
              (r = a.callbackScope || e),
              n && re.length && ye(),
              u && (o = u),
              (s = i ? l.apply(r, i) : l.call(r)),
              (o = c),
              s
            );
        },
        ft = function (e) {
          return (
            Be(e),
            e.scrollTrigger && e.scrollTrigger.kill(!!a),
            e.progress() < 1 && pt(e, "onInterrupt"),
            e
          );
        },
        At = [],
        gt = function (e) {
          if (e)
            if (((e = (!e.name && e.default) || e), F() || e.headless)) {
              var t = e.name,
                n = R(e),
                i =
                  t && !n && e.init
                    ? function () {
                        this._props = [];
                      }
                    : e,
                r = {
                  init: $,
                  render: ln,
                  add: Wt,
                  kill: un,
                  modifier: cn,
                  rawVars: 0,
                },
                s = {
                  targetTest: 0,
                  get: 0,
                  getSetter: rn,
                  aliases: {},
                  register: 0,
                };
              if ((St(), e !== i)) {
                if (ae[t]) return;
                Ee(i, Ee(Ie(e, r), s)),
                  we(i.prototype, we(r, Ie(e, s))),
                  (ae[(i.prop = t)] = i),
                  e.targetTest && (ce.push(i), (ie[t] = 1)),
                  (t =
                    ("css" === t
                      ? "CSS"
                      : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin");
              }
              Z(t, i), e.register && e.register(In, i, pn);
            } else At.push(e);
        },
        mt = 255,
        vt = {
          aqua: [0, mt, mt],
          lime: [0, mt, 0],
          silver: [192, 192, 192],
          black: [0, 0, 0],
          maroon: [128, 0, 0],
          teal: [0, 128, 128],
          blue: [0, 0, mt],
          navy: [0, 0, 128],
          white: [mt, mt, mt],
          olive: [128, 128, 0],
          yellow: [mt, mt, 0],
          orange: [mt, 165, 0],
          gray: [128, 128, 128],
          purple: [128, 0, 128],
          green: [0, 128, 0],
          red: [mt, 0, 0],
          pink: [mt, 192, 203],
          cyan: [0, mt, mt],
          transparent: [mt, mt, mt, 0],
        },
        yt = function (e, t, n) {
          return (
            ((6 * (e += e < 0 ? 1 : e > 1 ? -1 : 0) < 1
              ? t + (n - t) * e * 6
              : e < 0.5
              ? n
              : 3 * e < 2
              ? t + (n - t) * (2 / 3 - e) * 6
              : t) *
              mt +
              0.5) |
            0
          );
        },
        xt = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o,
            l,
            c,
            u,
            h,
            d,
            p = e ? (D(e) ? [e >> 16, (e >> 8) & mt, e & mt] : 0) : vt.black;
          if (!p) {
            if (
              ("," === e.substr(-1) && (e = e.substr(0, e.length - 1)), vt[e])
            )
              p = vt[e];
            else if ("#" === e.charAt(0)) {
              if (
                (e.length < 6 &&
                  ((i = e.charAt(1)),
                  (r = e.charAt(2)),
                  (s = e.charAt(3)),
                  (e =
                    "#" +
                    i +
                    i +
                    r +
                    r +
                    s +
                    s +
                    (5 === e.length ? e.charAt(4) + e.charAt(4) : ""))),
                9 === e.length)
              )
                return [
                  (p = parseInt(e.substr(1, 6), 16)) >> 16,
                  (p >> 8) & mt,
                  p & mt,
                  parseInt(e.substr(7), 16) / 255,
                ];
              p = [
                (e = parseInt(e.substr(1), 16)) >> 16,
                (e >> 8) & mt,
                e & mt,
              ];
            } else if ("hsl" === e.substr(0, 3))
              if (((p = d = e.match(k)), t)) {
                if (~e.indexOf("="))
                  return (p = e.match(G)), n && p.length < 4 && (p[3] = 1), p;
              } else
                (a = (+p[0] % 360) / 360),
                  (o = +p[1] / 100),
                  (i =
                    2 * (l = +p[2] / 100) -
                    (r = l <= 0.5 ? l * (o + 1) : l + o - l * o)),
                  p.length > 3 && (p[3] *= 1),
                  (p[0] = yt(a + 1 / 3, i, r)),
                  (p[1] = yt(a, i, r)),
                  (p[2] = yt(a - 1 / 3, i, r));
            else p = e.match(k) || vt.transparent;
            p = p.map(Number);
          }
          return (
            t &&
              !d &&
              ((i = p[0] / mt),
              (r = p[1] / mt),
              (s = p[2] / mt),
              (l = ((c = Math.max(i, r, s)) + (u = Math.min(i, r, s))) / 2),
              c === u
                ? (a = o = 0)
                : ((h = c - u),
                  (o = l > 0.5 ? h / (2 - c - u) : h / (c + u)),
                  (a =
                    c === i
                      ? (r - s) / h + (r < s ? 6 : 0)
                      : c === r
                      ? (s - i) / h + 2
                      : (i - r) / h + 4),
                  (a *= 60)),
              (p[0] = ~~(a + 0.5)),
              (p[1] = ~~(100 * o + 0.5)),
              (p[2] = ~~(100 * l + 0.5))),
            n && p.length < 4 && (p[3] = 1),
            p
          );
        },
        _t = function (e) {
          var t = [],
            n = [],
            i = -1;
          return (
            e.split(Et).forEach(function (e) {
              var r = e.match(H) || [];
              t.push.apply(t, r), n.push((i += r.length + 1));
            }),
            (t.c = n),
            t
          );
        },
        bt = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o = "",
            l = (e + o).match(Et),
            c = t ? "hsla(" : "rgba(",
            u = 0;
          if (!l) return e;
          if (
            ((l = l.map(function (e) {
              return (
                (e = xt(e, t, 1)) &&
                c +
                  (t
                    ? e[0] + "," + e[1] + "%," + e[2] + "%," + e[3]
                    : e.join(",")) +
                  ")"
              );
            })),
            n && ((s = _t(e)), (i = n.c).join(o) !== s.c.join(o)))
          )
            for (a = (r = e.replace(Et, "1").split(H)).length - 1; u < a; u++)
              o +=
                r[u] +
                (~i.indexOf(u)
                  ? l.shift() || c + "0,0,0,0)"
                  : (s.length ? s : l.length ? l : n).shift());
          if (!r)
            for (a = (r = e.split(Et)).length - 1; u < a; u++) o += r[u] + l[u];
          return o + r[a];
        },
        Et = (function () {
          var e,
            t =
              "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b";
          for (e in vt) t += "|" + e + "\\b";
          return new RegExp(t + ")", "gi");
        })(),
        wt = /hsl[a]?\(/,
        Ct = function (e) {
          var t,
            n = e.join(" ");
          if (((Et.lastIndex = 0), Et.test(n)))
            return (
              (t = wt.test(n)),
              (e[1] = bt(e[1], t)),
              (e[0] = bt(e[0], t, _t(e[1]))),
              !0
            );
        },
        It = (function () {
          var e,
            t,
            n,
            i,
            r,
            s,
            a = Date.now,
            o = 500,
            l = 33,
            p = a(),
            f = p,
            g = 1e3 / 240,
            m = g,
            v = [],
            y = function n(c) {
              var u,
                h,
                d,
                A,
                y = a() - f,
                x = !0 === c;
              if (
                ((y > o || y < 0) && (p += y - l),
                ((u = (d = (f += y) - p) - m) > 0 || x) &&
                  ((A = ++i.frame),
                  (r = d - 1e3 * i.time),
                  (i.time = d /= 1e3),
                  (m += u + (u >= g ? 4 : g - u)),
                  (h = 1)),
                x || (e = t(n)),
                h)
              )
                for (s = 0; s < v.length; s++) v[s](d, r, A, c);
            };
          return (i = {
            time: 0,
            frame: 0,
            tick: function () {
              y(!0);
            },
            deltaRatio: function (e) {
              return r / (1e3 / (e || 60));
            },
            wake: function () {
              d &&
                (!u &&
                  F() &&
                  ((c = u = window),
                  (h = c.document || {}),
                  (q.gsap = In),
                  (c.gsapVersions || (c.gsapVersions = [])).push(In.version),
                  X(Y || c.GreenSockGlobals || (!c.gsap && c) || {}),
                  At.forEach(gt)),
                (n =
                  "undefined" != typeof requestAnimationFrame &&
                  requestAnimationFrame),
                e && i.sleep(),
                (t =
                  n ||
                  function (e) {
                    return setTimeout(e, (m - 1e3 * i.time + 1) | 0);
                  }),
                (A = 1),
                y(2));
            },
            sleep: function () {
              (n ? cancelAnimationFrame : clearTimeout)(e), (A = 0), (t = $);
            },
            lagSmoothing: function (e, t) {
              (o = e || 1 / 0), (l = Math.min(t || 33, o));
            },
            fps: function (e) {
              (g = 1e3 / (e || 240)), (m = 1e3 * i.time + g);
            },
            add: function (e, t, n) {
              var r = t
                ? function (t, n, s, a) {
                    e(t, n, s, a), i.remove(r);
                  }
                : e;
              return i.remove(e), v[n ? "unshift" : "push"](r), St(), r;
            },
            remove: function (e, t) {
              ~(t = v.indexOf(e)) && v.splice(t, 1) && s >= t && s--;
            },
            _listeners: v,
          });
        })(),
        St = function () {
          return !A && It.wake();
        },
        Mt = {},
        Tt = /^[\d.\-M][\d.\-,\s]/,
        Bt = /["']/g,
        Rt = function (e) {
          for (
            var t,
              n,
              i,
              r = {},
              s = e.substr(1, e.length - 3).split(":"),
              a = s[0],
              o = 1,
              l = s.length;
            o < l;
            o++
          )
            (n = s[o]),
              (t = o !== l - 1 ? n.lastIndexOf(",") : n.length),
              (i = n.substr(0, t)),
              (r[a] = isNaN(i) ? i.replace(Bt, "").trim() : +i),
              (a = n.substr(t + 1).trim());
          return r;
        },
        Dt = function (e) {
          return function (t) {
            return 1 - e(1 - t);
          };
        },
        Pt = function e(t, n) {
          for (var i, r = t._first; r; )
            r instanceof Gt
              ? e(r, n)
              : !r.vars.yoyoEase ||
                (r._yoyo && r._repeat) ||
                r._yoyo === n ||
                (r.timeline
                  ? e(r.timeline, n)
                  : ((i = r._ease),
                    (r._ease = r._yEase),
                    (r._yEase = i),
                    (r._yoyo = n))),
              (r = r._next);
        },
        Lt = function (e, t) {
          return (
            (e &&
              (R(e)
                ? e
                : Mt[e] ||
                  (function (e) {
                    var t,
                      n,
                      i,
                      r,
                      s = (e + "").split("("),
                      a = Mt[s[0]];
                    return a && s.length > 1 && a.config
                      ? a.config.apply(
                          null,
                          ~e.indexOf("{")
                            ? [Rt(s[1])]
                            : ((t = e),
                              (n = t.indexOf("(") + 1),
                              (i = t.indexOf(")")),
                              (r = t.indexOf("(", n)),
                              t.substring(
                                n,
                                ~r && r < i ? t.indexOf(")", i + 1) : i
                              ))
                                .split(",")
                                .map(_e)
                        )
                      : Mt._CE && Tt.test(e)
                      ? Mt._CE("", e)
                      : a;
                  })(e))) ||
            t
          );
        },
        Ut = function (e, t, n, i) {
          void 0 === n &&
            (n = function (e) {
              return 1 - t(1 - e);
            }),
            void 0 === i &&
              (i = function (e) {
                return e < 0.5 ? t(2 * e) / 2 : 1 - t(2 * (1 - e)) / 2;
              });
          var r,
            s = { easeIn: t, easeOut: n, easeInOut: i };
          return (
            fe(e, function (e) {
              for (var t in ((Mt[e] = q[e] = s),
              (Mt[(r = e.toLowerCase())] = n),
              s))
                Mt[
                  r +
                    ("easeIn" === t
                      ? ".in"
                      : "easeOut" === t
                      ? ".out"
                      : ".inOut")
                ] = Mt[e + "." + t] = s[t];
            }),
            s
          );
        },
        Ft = function (e) {
          return function (t) {
            return t < 0.5
              ? (1 - e(1 - 2 * t)) / 2
              : 0.5 + e(2 * (t - 0.5)) / 2;
          };
        },
        Nt = function e(t, n, i) {
          var r = n >= 1 ? n : 1,
            s = (i || (t ? 0.3 : 0.45)) / (n < 1 ? n : 1),
            a = (s / w) * (Math.asin(1 / r) || 0),
            o = function (e) {
              return 1 === e
                ? 1
                : r * Math.pow(2, -10 * e) * T((e - a) * s) + 1;
            },
            l =
              "out" === t
                ? o
                : "in" === t
                ? function (e) {
                    return 1 - o(1 - e);
                  }
                : Ft(o);
          return (
            (s = w / s),
            (l.config = function (n, i) {
              return e(t, n, i);
            }),
            l
          );
        },
        Ot = function e(t, n) {
          void 0 === n && (n = 1.70158);
          var i = function (e) {
              return e ? --e * e * ((n + 1) * e + n) + 1 : 0;
            },
            r =
              "out" === t
                ? i
                : "in" === t
                ? function (e) {
                    return 1 - i(1 - e);
                  }
                : Ft(i);
          return (
            (r.config = function (n) {
              return e(t, n);
            }),
            r
          );
        };
      fe("Linear,Quad,Cubic,Quart,Quint,Strong", function (e, t) {
        var n = t < 5 ? t + 1 : t;
        Ut(
          e + ",Power" + (n - 1),
          t
            ? function (e) {
                return Math.pow(e, n);
              }
            : function (e) {
                return e;
              },
          function (e) {
            return 1 - Math.pow(1 - e, n);
          },
          function (e) {
            return e < 0.5
              ? Math.pow(2 * e, n) / 2
              : 1 - Math.pow(2 * (1 - e), n) / 2;
          }
        );
      }),
        (Mt.Linear.easeNone = Mt.none = Mt.Linear.easeIn),
        Ut("Elastic", Nt("in"), Nt("out"), Nt()),
        (g = 7.5625),
        (v = 1 / (m = 2.75)),
        Ut(
          "Bounce",
          function (e) {
            return 1 - y(1 - e);
          },
          (y = function (e) {
            return e < v
              ? g * e * e
              : e < 0.7272727272727273
              ? g * Math.pow(e - 1.5 / m, 2) + 0.75
              : e < 0.9090909090909092
              ? g * (e -= 2.25 / m) * e + 0.9375
              : g * Math.pow(e - 2.625 / m, 2) + 0.984375;
          })
        ),
        Ut("Expo", function (e) {
          return e ? Math.pow(2, 10 * (e - 1)) : 0;
        }),
        Ut("Circ", function (e) {
          return -(S(1 - e * e) - 1);
        }),
        Ut("Sine", function (e) {
          return 1 === e ? 1 : 1 - M(e * C);
        }),
        Ut("Back", Ot("in"), Ot("out"), Ot()),
        (Mt.SteppedEase =
          Mt.steps =
          q.SteppedEase =
            {
              config: function (e, t) {
                void 0 === e && (e = 1);
                var n = 1 / e,
                  i = e + (t ? 0 : 1),
                  r = t ? 1 : 0;
                return function (e) {
                  return (((i * Je(0, 0.99999999, e)) | 0) + r) * n;
                };
              },
            }),
        (_.ease = Mt["quad.out"]),
        fe(
          "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
          function (e) {
            return (ue += e + "," + e + "Params,");
          }
        );
      var Qt = function (e, t) {
          (this.id = I++),
            (e._gsap = this),
            (this.target = e),
            (this.harness = t),
            (this.get = t ? t.get : pe),
            (this.set = t ? t.getSetter : rn);
        },
        kt = (function () {
          function e(e) {
            (this.vars = e),
              (this._delay = +e.delay || 0),
              (this._repeat = e.repeat === 1 / 0 ? -2 : e.repeat || 0) &&
                ((this._rDelay = e.repeatDelay || 0),
                (this._yoyo = !!e.yoyo || !!e.yoyoEase)),
              (this._ts = 1),
              We(this, +e.duration, 1, 1),
              (this.data = e.data),
              o && ((this._ctx = o), o.data.push(this)),
              A || It.wake();
          }
          var t = e.prototype;
          return (
            (t.delay = function (e) {
              return e || 0 === e
                ? (this.parent &&
                    this.parent.smoothChildTiming &&
                    this.startTime(this._start + e - this._delay),
                  (this._delay = e),
                  this)
                : this._delay;
            }),
            (t.duration = function (e) {
              return arguments.length
                ? this.totalDuration(
                    this._repeat > 0 ? e + (e + this._rDelay) * this._repeat : e
                  )
                : this.totalDuration() && this._dur;
            }),
            (t.totalDuration = function (e) {
              return arguments.length
                ? ((this._dirty = 0),
                  We(
                    this,
                    this._repeat < 0
                      ? e
                      : (e - this._repeat * this._rDelay) / (this._repeat + 1)
                  ))
                : this._tDur;
            }),
            (t.totalTime = function (e, t) {
              if ((St(), !arguments.length)) return this._tTime;
              var n = this._dp;
              if (n && n.smoothChildTiming && this._ts) {
                for (
                  Oe(this, e), !n._dp || n.parent || Qe(n, this);
                  n && n.parent;

                )
                  n.parent._time !==
                    n._start +
                      (n._ts >= 0
                        ? n._tTime / n._ts
                        : (n.totalDuration() - n._tTime) / -n._ts) &&
                    n.totalTime(n._tTime, !0),
                    (n = n.parent);
                !this.parent &&
                  this._dp.autoRemoveChildren &&
                  ((this._ts > 0 && e < this._tDur) ||
                    (this._ts < 0 && e > 0) ||
                    (!this._tDur && !e)) &&
                  ke(this._dp, this, this._start - this._delay);
              }
              return (
                (this._tTime !== e ||
                  (!this._dur && !t) ||
                  (this._initted && Math.abs(this._zTime) === E) ||
                  (!e && !this._initted && (this.add || this._ptLookup))) &&
                  (this._ts || (this._pTime = e), xe(this, e, t)),
                this
              );
            }),
            (t.time = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    Math.min(this.totalDuration(), e + Le(this)) %
                      (this._dur + this._rDelay) || (e ? this._dur : 0),
                    t
                  )
                : this._time;
            }),
            (t.totalProgress = function (e, t) {
              return arguments.length
                ? this.totalTime(this.totalDuration() * e, t)
                : this.totalDuration()
                ? Math.min(1, this._tTime / this._tDur)
                : this.rawTime() > 0
                ? 1
                : 0;
            }),
            (t.progress = function (e, t) {
              return arguments.length
                ? this.totalTime(
                    this.duration() *
                      (!this._yoyo || 1 & this.iteration() ? e : 1 - e) +
                      Le(this),
                    t
                  )
                : this.duration()
                ? Math.min(1, this._time / this._dur)
                : this.rawTime() > 0
                ? 1
                : 0;
            }),
            (t.iteration = function (e, t) {
              var n = this.duration() + this._rDelay;
              return arguments.length
                ? this.totalTime(this._time + (e - 1) * n, t)
                : this._repeat
                ? Ue(this._tTime, n) + 1
                : 1;
            }),
            (t.timeScale = function (e, t) {
              if (!arguments.length) return -1e-8 === this._rts ? 0 : this._rts;
              if (this._rts === e) return this;
              var n =
                this.parent && this._ts
                  ? Fe(this.parent._time, this)
                  : this._tTime;
              return (
                (this._rts = +e || 0),
                (this._ts = this._ps || -1e-8 === e ? 0 : this._rts),
                this.totalTime(
                  Je(-Math.abs(this._delay), this._tDur, n),
                  !1 !== t
                ),
                Ne(this),
                (function (e) {
                  for (var t = e.parent; t && t.parent; )
                    (t._dirty = 1), t.totalDuration(), (t = t.parent);
                  return e;
                })(this)
              );
            }),
            (t.paused = function (e) {
              return arguments.length
                ? (this._ps !== e &&
                    ((this._ps = e),
                    e
                      ? ((this._pTime =
                          this._tTime ||
                          Math.max(-this._delay, this.rawTime())),
                        (this._ts = this._act = 0))
                      : (St(),
                        (this._ts = this._rts),
                        this.totalTime(
                          this.parent && !this.parent.smoothChildTiming
                            ? this.rawTime()
                            : this._tTime || this._pTime,
                          1 === this.progress() &&
                            Math.abs(this._zTime) !== E &&
                            (this._tTime -= E)
                        ))),
                  this)
                : this._ps;
            }),
            (t.startTime = function (e) {
              if (arguments.length) {
                this._start = e;
                var t = this.parent || this._dp;
                return (
                  t &&
                    (t._sort || !this.parent) &&
                    ke(t, this, e - this._delay),
                  this
                );
              }
              return this._start;
            }),
            (t.endTime = function (e) {
              return (
                this._start +
                (U(e) ? this.totalDuration() : this.duration()) /
                  Math.abs(this._ts || 1)
              );
            }),
            (t.rawTime = function (e) {
              var t = this.parent || this._dp;
              return t
                ? e &&
                  (!this._ts ||
                    (this._repeat && this._time && this.totalProgress() < 1))
                  ? this._tTime % (this._dur + this._rDelay)
                  : this._ts
                  ? Fe(t.rawTime(e), this)
                  : this._tTime
                : this._tTime;
            }),
            (t.revert = function (e) {
              void 0 === e && (e = ne);
              var t = a;
              return (
                (a = e),
                (this._initted || this._startAt) &&
                  (this.timeline && this.timeline.revert(e),
                  this.totalTime(-0.01, e.suppressEvents)),
                "nested" !== this.data && !1 !== e.kill && this.kill(),
                (a = t),
                this
              );
            }),
            (t.globalTime = function (e) {
              for (var t = this, n = arguments.length ? e : t.rawTime(); t; )
                (n = t._start + n / (Math.abs(t._ts) || 1)), (t = t._dp);
              return !this.parent && this._sat ? this._sat.globalTime(e) : n;
            }),
            (t.repeat = function (e) {
              return arguments.length
                ? ((this._repeat = e === 1 / 0 ? -2 : e), je(this))
                : -2 === this._repeat
                ? 1 / 0
                : this._repeat;
            }),
            (t.repeatDelay = function (e) {
              if (arguments.length) {
                var t = this._time;
                return (this._rDelay = e), je(this), t ? this.time(t) : this;
              }
              return this._rDelay;
            }),
            (t.yoyo = function (e) {
              return arguments.length ? ((this._yoyo = e), this) : this._yoyo;
            }),
            (t.seek = function (e, t) {
              return this.totalTime(Ye(this, e), U(t));
            }),
            (t.restart = function (e, t) {
              return this.play().totalTime(e ? -this._delay : 0, U(t));
            }),
            (t.play = function (e, t) {
              return null != e && this.seek(e, t), this.reversed(!1).paused(!1);
            }),
            (t.reverse = function (e, t) {
              return (
                null != e && this.seek(e || this.totalDuration(), t),
                this.reversed(!0).paused(!1)
              );
            }),
            (t.pause = function (e, t) {
              return null != e && this.seek(e, t), this.paused(!0);
            }),
            (t.resume = function () {
              return this.paused(!1);
            }),
            (t.reversed = function (e) {
              return arguments.length
                ? (!!e !== this.reversed() &&
                    this.timeScale(-this._rts || (e ? -1e-8 : 0)),
                  this)
                : this._rts < 0;
            }),
            (t.invalidate = function () {
              return (
                (this._initted = this._act = 0), (this._zTime = -1e-8), this
              );
            }),
            (t.isActive = function () {
              var e,
                t = this.parent || this._dp,
                n = this._start;
              return !(
                t &&
                !(
                  this._ts &&
                  this._initted &&
                  t.isActive() &&
                  (e = t.rawTime(!0)) >= n &&
                  e < this.endTime(!0) - E
                )
              );
            }),
            (t.eventCallback = function (e, t, n) {
              var i = this.vars;
              return arguments.length > 1
                ? (t
                    ? ((i[e] = t),
                      n && (i[e + "Params"] = n),
                      "onUpdate" === e && (this._onUpdate = t))
                    : delete i[e],
                  this)
                : i[e];
            }),
            (t.then = function (e) {
              var t = this;
              return new Promise(function (n) {
                var i = R(e) ? e : be,
                  r = function () {
                    var e = t.then;
                    (t.then = null),
                      R(i) && (i = i(t)) && (i.then || i === t) && (t.then = e),
                      n(i),
                      (t.then = e);
                  };
                (t._initted && 1 === t.totalProgress() && t._ts >= 0) ||
                (!t._tTime && t._ts < 0)
                  ? r()
                  : (t._prom = r);
              });
            }),
            (t.kill = function () {
              ft(this);
            }),
            e
          );
        })();
      Ee(kt.prototype, {
        _time: 0,
        _start: 0,
        _end: 0,
        _tTime: 0,
        _tDur: 0,
        _dirty: 0,
        _repeat: 0,
        _yoyo: !1,
        parent: null,
        _initted: !1,
        _rDelay: 0,
        _ts: 1,
        _dp: 0,
        ratio: 0,
        _zTime: -1e-8,
        _prom: 0,
        _ps: !1,
        _rts: 1,
      });
      var Gt = (function (e) {
        function t(t, n) {
          var r;
          return (
            void 0 === t && (t = {}),
            ((r = e.call(this, t) || this).labels = {}),
            (r.smoothChildTiming = !!t.smoothChildTiming),
            (r.autoRemoveChildren = !!t.autoRemoveChildren),
            (r._sort = U(t.sortChildren)),
            l && ke(t.parent || l, i(r), n),
            t.reversed && r.reverse(),
            t.paused && r.paused(!0),
            t.scrollTrigger && Ge(i(r), t.scrollTrigger),
            r
          );
        }
        r(t, e);
        var n = t.prototype;
        return (
          (n.to = function (e, t, n) {
            return Xe(0, arguments, this), this;
          }),
          (n.from = function (e, t, n) {
            return Xe(1, arguments, this), this;
          }),
          (n.fromTo = function (e, t, n, i) {
            return Xe(2, arguments, this), this;
          }),
          (n.set = function (e, t, n) {
            return (
              (t.duration = 0),
              (t.parent = this),
              Se(t).repeatDelay || (t.repeat = 0),
              (t.immediateRender = !!t.immediateRender),
              new Zt(e, t, Ye(this, n), 1),
              this
            );
          }),
          (n.call = function (e, t, n) {
            return ke(this, Zt.delayedCall(0, e, t), n);
          }),
          (n.staggerTo = function (e, t, n, i, r, s, a) {
            return (
              (n.duration = t),
              (n.stagger = n.stagger || i),
              (n.onComplete = s),
              (n.onCompleteParams = a),
              (n.parent = this),
              new Zt(e, n, Ye(this, r)),
              this
            );
          }),
          (n.staggerFrom = function (e, t, n, i, r, s, a) {
            return (
              (n.runBackwards = 1),
              (Se(n).immediateRender = U(n.immediateRender)),
              this.staggerTo(e, t, n, i, r, s, a)
            );
          }),
          (n.staggerFromTo = function (e, t, n, i, r, s, a, o) {
            return (
              (i.startAt = n),
              (Se(i).immediateRender = U(i.immediateRender)),
              this.staggerTo(e, t, i, r, s, a, o)
            );
          }),
          (n.render = function (e, t, n) {
            var i,
              r,
              s,
              o,
              c,
              u,
              h,
              d,
              p,
              f,
              A,
              g,
              m = this._time,
              v = this._dirty ? this.totalDuration() : this._tDur,
              y = this._dur,
              x = e <= 0 ? 0 : ge(e),
              _ = this._zTime < 0 != e < 0 && (this._initted || !y);
            if (
              (this !== l && x > v && e >= 0 && (x = v),
              x !== this._tTime || n || _)
            ) {
              if (
                (m !== this._time &&
                  y &&
                  ((x += this._time - m), (e += this._time - m)),
                (i = x),
                (p = this._start),
                (u = !(d = this._ts)),
                _ && (y || (m = this._zTime), (e || !t) && (this._zTime = e)),
                this._repeat)
              ) {
                if (
                  ((A = this._yoyo),
                  (c = y + this._rDelay),
                  this._repeat < -1 && e < 0)
                )
                  return this.totalTime(100 * c + e, t, n);
                if (
                  ((i = ge(x % c)),
                  x === v
                    ? ((o = this._repeat), (i = y))
                    : ((o = ~~(x / c)) && o === x / c && ((i = y), o--),
                      i > y && (i = y)),
                  (f = Ue(this._tTime, c)),
                  !m &&
                    this._tTime &&
                    f !== o &&
                    this._tTime - f * c - this._dur <= 0 &&
                    (f = o),
                  A && 1 & o && ((i = y - i), (g = 1)),
                  o !== f && !this._lock)
                ) {
                  var b = A && 1 & f,
                    w = b === (A && 1 & o);
                  if (
                    (o < f && (b = !b),
                    (m = b ? 0 : x % y ? y : x),
                    (this._lock = 1),
                    (this.render(m || (g ? 0 : ge(o * c)), t, !y)._lock = 0),
                    (this._tTime = x),
                    !t && this.parent && pt(this, "onRepeat"),
                    this.vars.repeatRefresh &&
                      !g &&
                      (this.invalidate()._lock = 1),
                    (m && m !== this._time) ||
                      u !== !this._ts ||
                      (this.vars.onRepeat && !this.parent && !this._act))
                  )
                    return this;
                  if (
                    ((y = this._dur),
                    (v = this._tDur),
                    w &&
                      ((this._lock = 2),
                      (m = b ? y : -1e-4),
                      this.render(m, !0),
                      this.vars.repeatRefresh && !g && this.invalidate()),
                    (this._lock = 0),
                    !this._ts && !u)
                  )
                    return this;
                  Pt(this, g);
                }
              }
              if (
                (this._hasPause &&
                  !this._forcing &&
                  this._lock < 2 &&
                  ((h = (function (e, t, n) {
                    var i;
                    if (n > t)
                      for (i = e._first; i && i._start <= n; ) {
                        if ("isPause" === i.data && i._start > t) return i;
                        i = i._next;
                      }
                    else
                      for (i = e._last; i && i._start >= n; ) {
                        if ("isPause" === i.data && i._start < t) return i;
                        i = i._prev;
                      }
                  })(this, ge(m), ge(i))),
                  h && (x -= i - (i = h._start))),
                (this._tTime = x),
                (this._time = i),
                (this._act = !d),
                this._initted ||
                  ((this._onUpdate = this.vars.onUpdate),
                  (this._initted = 1),
                  (this._zTime = e),
                  (m = 0)),
                !m && i && !t && !o && (pt(this, "onStart"), this._tTime !== x))
              )
                return this;
              if (i >= m && e >= 0)
                for (r = this._first; r; ) {
                  if (
                    ((s = r._next),
                    (r._act || i >= r._start) && r._ts && h !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (i - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (i - r._start) * r._ts,
                        t,
                        n
                      ),
                      i !== this._time || (!this._ts && !u))
                    ) {
                      (h = 0), s && (x += this._zTime = -1e-8);
                      break;
                    }
                  }
                  r = s;
                }
              else {
                r = this._last;
                for (var C = e < 0 ? e : i; r; ) {
                  if (
                    ((s = r._prev), (r._act || C <= r._end) && r._ts && h !== r)
                  ) {
                    if (r.parent !== this) return this.render(e, t, n);
                    if (
                      (r.render(
                        r._ts > 0
                          ? (C - r._start) * r._ts
                          : (r._dirty ? r.totalDuration() : r._tDur) +
                              (C - r._start) * r._ts,
                        t,
                        n || (a && (r._initted || r._startAt))
                      ),
                      i !== this._time || (!this._ts && !u))
                    ) {
                      (h = 0), s && (x += this._zTime = C ? -1e-8 : E);
                      break;
                    }
                  }
                  r = s;
                }
              }
              if (
                h &&
                !t &&
                (this.pause(),
                (h.render(i >= m ? 0 : -1e-8)._zTime = i >= m ? 1 : -1),
                this._ts)
              )
                return (this._start = p), Ne(this), this.render(e, t, n);
              this._onUpdate && !t && pt(this, "onUpdate", !0),
                ((x === v && this._tTime >= this.totalDuration()) ||
                  (!x && m)) &&
                  ((p !== this._start && Math.abs(d) === Math.abs(this._ts)) ||
                    this._lock ||
                    ((e || !y) &&
                      ((x === v && this._ts > 0) || (!x && this._ts < 0)) &&
                      Be(this, 1),
                    t ||
                      (e < 0 && !m) ||
                      (!x && !m && v) ||
                      (pt(
                        this,
                        x === v && e >= 0 ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(x < v && this.timeScale() > 0) &&
                        this._prom())));
            }
            return this;
          }),
          (n.add = function (e, t) {
            var n = this;
            if ((D(t) || (t = Ye(this, t, e)), !(e instanceof kt))) {
              if (Q(e))
                return (
                  e.forEach(function (e) {
                    return n.add(e, t);
                  }),
                  this
                );
              if (B(e)) return this.addLabel(e, t);
              if (!R(e)) return this;
              e = Zt.delayedCall(0, e);
            }
            return this !== e ? ke(this, e, t) : this;
          }),
          (n.getChildren = function (e, t, n, i) {
            void 0 === e && (e = !0),
              void 0 === t && (t = !0),
              void 0 === n && (n = !0),
              void 0 === i && (i = -b);
            for (var r = [], s = this._first; s; )
              s._start >= i &&
                (s instanceof Zt
                  ? t && r.push(s)
                  : (n && r.push(s),
                    e && r.push.apply(r, s.getChildren(!0, t, n)))),
                (s = s._next);
            return r;
          }),
          (n.getById = function (e) {
            for (var t = this.getChildren(1, 1, 1), n = t.length; n--; )
              if (t[n].vars.id === e) return t[n];
          }),
          (n.remove = function (e) {
            return B(e)
              ? this.removeLabel(e)
              : R(e)
              ? this.killTweensOf(e)
              : (Te(this, e),
                e === this._recent && (this._recent = this._last),
                Re(this));
          }),
          (n.totalTime = function (t, n) {
            return arguments.length
              ? ((this._forcing = 1),
                !this._dp &&
                  this._ts &&
                  (this._start = ge(
                    It.time -
                      (this._ts > 0
                        ? t / this._ts
                        : (this.totalDuration() - t) / -this._ts)
                  )),
                e.prototype.totalTime.call(this, t, n),
                (this._forcing = 0),
                this)
              : this._tTime;
          }),
          (n.addLabel = function (e, t) {
            return (this.labels[e] = Ye(this, t)), this;
          }),
          (n.removeLabel = function (e) {
            return delete this.labels[e], this;
          }),
          (n.addPause = function (e, t, n) {
            var i = Zt.delayedCall(0, t || $, n);
            return (
              (i.data = "isPause"),
              (this._hasPause = 1),
              ke(this, i, Ye(this, e))
            );
          }),
          (n.removePause = function (e) {
            var t = this._first;
            for (e = Ye(this, e); t; )
              t._start === e && "isPause" === t.data && Be(t), (t = t._next);
          }),
          (n.killTweensOf = function (e, t, n) {
            for (var i = this.getTweensOf(e, n), r = i.length; r--; )
              Ht !== i[r] && i[r].kill(e, t);
            return this;
          }),
          (n.getTweensOf = function (e, t) {
            for (var n, i = [], r = nt(e), s = this._first, a = D(t); s; )
              s instanceof Zt
                ? ve(s._targets, r) &&
                  (a
                    ? (!Ht || (s._initted && s._ts)) &&
                      s.globalTime(0) <= t &&
                      s.globalTime(s.totalDuration()) > t
                    : !t || s.isActive()) &&
                  i.push(s)
                : (n = s.getTweensOf(r, t)).length && i.push.apply(i, n),
                (s = s._next);
            return i;
          }),
          (n.tweenTo = function (e, t) {
            t = t || {};
            var n,
              i = this,
              r = Ye(i, e),
              s = t,
              a = s.startAt,
              o = s.onStart,
              l = s.onStartParams,
              c = s.immediateRender,
              u = Zt.to(
                i,
                Ee(
                  {
                    ease: t.ease || "none",
                    lazy: !1,
                    immediateRender: !1,
                    time: r,
                    overwrite: "auto",
                    duration:
                      t.duration ||
                      Math.abs(
                        (r - (a && "time" in a ? a.time : i._time)) /
                          i.timeScale()
                      ) ||
                      E,
                    onStart: function () {
                      if ((i.pause(), !n)) {
                        var e =
                          t.duration ||
                          Math.abs(
                            (r - (a && "time" in a ? a.time : i._time)) /
                              i.timeScale()
                          );
                        u._dur !== e && We(u, e, 0, 1).render(u._time, !0, !0),
                          (n = 1);
                      }
                      o && o.apply(u, l || []);
                    },
                  },
                  t
                )
              );
            return c ? u.render(0) : u;
          }),
          (n.tweenFromTo = function (e, t, n) {
            return this.tweenTo(t, Ee({ startAt: { time: Ye(this, e) } }, n));
          }),
          (n.recent = function () {
            return this._recent;
          }),
          (n.nextLabel = function (e) {
            return void 0 === e && (e = this._time), dt(this, Ye(this, e));
          }),
          (n.previousLabel = function (e) {
            return void 0 === e && (e = this._time), dt(this, Ye(this, e), 1);
          }),
          (n.currentLabel = function (e) {
            return arguments.length
              ? this.seek(e, !0)
              : this.previousLabel(this._time + E);
          }),
          (n.shiftChildren = function (e, t, n) {
            void 0 === n && (n = 0);
            for (var i, r = this._first, s = this.labels; r; )
              r._start >= n && ((r._start += e), (r._end += e)), (r = r._next);
            if (t) for (i in s) s[i] >= n && (s[i] += e);
            return Re(this);
          }),
          (n.invalidate = function (t) {
            var n = this._first;
            for (this._lock = 0; n; ) n.invalidate(t), (n = n._next);
            return e.prototype.invalidate.call(this, t);
          }),
          (n.clear = function (e) {
            void 0 === e && (e = !0);
            for (var t, n = this._first; n; )
              (t = n._next), this.remove(n), (n = t);
            return (
              this._dp && (this._time = this._tTime = this._pTime = 0),
              e && (this.labels = {}),
              Re(this)
            );
          }),
          (n.totalDuration = function (e) {
            var t,
              n,
              i,
              r = 0,
              s = this,
              a = s._last,
              o = b;
            if (arguments.length)
              return s.timeScale(
                (s._repeat < 0 ? s.duration() : s.totalDuration()) /
                  (s.reversed() ? -e : e)
              );
            if (s._dirty) {
              for (i = s.parent; a; )
                (t = a._prev),
                  a._dirty && a.totalDuration(),
                  (n = a._start) > o && s._sort && a._ts && !s._lock
                    ? ((s._lock = 1), (ke(s, a, n - a._delay, 1)._lock = 0))
                    : (o = n),
                  n < 0 &&
                    a._ts &&
                    ((r -= n),
                    ((!i && !s._dp) || (i && i.smoothChildTiming)) &&
                      ((s._start += n / s._ts),
                      (s._time -= n),
                      (s._tTime -= n)),
                    s.shiftChildren(-n, !1, -Infinity),
                    (o = 0)),
                  a._end > r && a._ts && (r = a._end),
                  (a = t);
              We(s, s === l && s._time > r ? s._time : r, 1, 1), (s._dirty = 0);
            }
            return s._tDur;
          }),
          (t.updateRoot = function (e) {
            if ((l._ts && (xe(l, Fe(e, l)), (p = It.frame)), It.frame >= le)) {
              le += x.autoSleep || 120;
              var t = l._first;
              if ((!t || !t._ts) && x.autoSleep && It._listeners.length < 2) {
                for (; t && !t._ts; ) t = t._next;
                t || It.sleep();
              }
            }
          }),
          t
        );
      })(kt);
      Ee(Gt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 });
      var Ht,
        zt,
        Vt = function (e, t, n, i, r, s, a) {
          var o,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            A = new pn(this._pt, e, t, 0, 1, on, null, r),
            g = 0,
            m = 0;
          for (
            A.b = n,
              A.e = i,
              n += "",
              (p = ~(i += "").indexOf("random(")) && (i = ut(i)),
              s && (s((f = [n, i]), e, t), (n = f[0]), (i = f[1])),
              l = n.match(z) || [];
            (o = z.exec(i));

          )
            (u = o[0]),
              (h = i.substring(g, o.index)),
              c ? (c = (c + 1) % 5) : "rgba(" === h.substr(-5) && (c = 1),
              u !== l[m++] &&
                ((d = parseFloat(l[m - 1]) || 0),
                (A._pt = {
                  _next: A._pt,
                  p: h || 1 === m ? h : ",",
                  s: d,
                  c: "=" === u.charAt(1) ? me(d, u) - d : parseFloat(u) - d,
                  m: c && c < 4 ? Math.round : 0,
                }),
                (g = z.lastIndex));
          return (
            (A.c = g < i.length ? i.substring(g, i.length) : ""),
            (A.fp = a),
            (V.test(i) || p) && (A.e = 0),
            (this._pt = A),
            A
          );
        },
        Wt = function (e, t, n, i, r, s, a, o, l, c) {
          R(i) && (i = i(r || 0, e, s));
          var u,
            h = e[t],
            d =
              "get" !== n
                ? n
                : R(h)
                ? l
                  ? e[
                      t.indexOf("set") || !R(e["get" + t.substr(3)])
                        ? t
                        : "get" + t.substr(3)
                    ](l)
                  : e[t]()
                : h,
            p = R(h) ? (l ? tn : en) : $t;
          if (
            (B(i) &&
              (~i.indexOf("random(") && (i = ut(i)),
              "=" === i.charAt(1) &&
                ((u = me(d, i) + (Ze(d) || 0)) || 0 === u) &&
                (i = u)),
            !c || d !== i || zt)
          )
            return isNaN(d * i) || "" === i
              ? (!h && !(t in e) && K(t, i),
                Vt.call(this, e, t, d, i, p, o || x.stringFilter, l))
              : ((u = new pn(
                  this._pt,
                  e,
                  t,
                  +d || 0,
                  i - (d || 0),
                  "boolean" == typeof h ? an : sn,
                  0,
                  p
                )),
                l && (u.fp = l),
                a && u.modifier(a, this, e),
                (this._pt = u));
        },
        jt = function (e, t, n, i, r, s) {
          var a, o, l, c;
          if (
            ae[e] &&
            !1 !==
              (a = new ae[e]()).init(
                r,
                a.rawVars
                  ? t[e]
                  : (function (e, t, n, i, r) {
                      if (
                        (R(e) && (e = Xt(e, r, t, n, i)),
                        !L(e) || (e.style && e.nodeType) || Q(e) || O(e))
                      )
                        return B(e) ? Xt(e, r, t, n, i) : e;
                      var s,
                        a = {};
                      for (s in e) a[s] = Xt(e[s], r, t, n, i);
                      return a;
                    })(t[e], i, r, s, n),
                n,
                i,
                s
              ) &&
            ((n._pt = o =
              new pn(n._pt, r, e, 0, 1, a.render, a, 0, a.priority)),
            n !== f)
          )
            for (
              l = n._ptLookup[n._targets.indexOf(r)], c = a._props.length;
              c--;

            )
              l[a._props[c]] = o;
          return a;
        },
        qt = function e(t, n, i) {
          var r,
            o,
            c,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m,
            v,
            y,
            x = t.vars,
            w = x.ease,
            C = x.startAt,
            I = x.immediateRender,
            S = x.lazy,
            M = x.onUpdate,
            T = x.runBackwards,
            B = x.yoyoEase,
            R = x.keyframes,
            D = x.autoRevert,
            P = t._dur,
            L = t._startAt,
            F = t._targets,
            N = t.parent,
            O = N && "nested" === N.data ? N.vars.targets : F,
            Q = "auto" === t._overwrite && !s,
            k = t.timeline;
          if (
            (k && (!R || !w) && (w = "none"),
            (t._ease = Lt(w, _.ease)),
            (t._yEase = B ? Dt(Lt(!0 === B ? w : B, _.ease)) : 0),
            B &&
              t._yoyo &&
              !t._repeat &&
              ((B = t._yEase), (t._yEase = t._ease), (t._ease = B)),
            (t._from = !k && !!x.runBackwards),
            !k || (R && !x.stagger))
          ) {
            if (
              ((v = (f = F[0] ? de(F[0]).harness : 0) && x[f.prop]),
              (r = Ie(x, ie)),
              L &&
                (L._zTime < 0 && L.progress(1),
                n < 0 && T && I && !D
                  ? L.render(-1, !0)
                  : L.revert(T && P ? te : ee),
                (L._lazy = 0)),
              C)
            ) {
              if (
                (Be(
                  (t._startAt = Zt.set(
                    F,
                    Ee(
                      {
                        data: "isStart",
                        overwrite: !1,
                        parent: N,
                        immediateRender: !0,
                        lazy: !L && U(S),
                        startAt: null,
                        delay: 0,
                        onUpdate:
                          M &&
                          function () {
                            return pt(t, "onUpdate");
                          },
                        stagger: 0,
                      },
                      C
                    )
                  ))
                ),
                (t._startAt._dp = 0),
                (t._startAt._sat = t),
                n < 0 && (a || (!I && !D)) && t._startAt.revert(te),
                I && P && n <= 0 && i <= 0)
              )
                return void (n && (t._zTime = n));
            } else if (T && P && !L)
              if (
                (n && (I = !1),
                (c = Ee(
                  {
                    overwrite: !1,
                    data: "isFromStart",
                    lazy: I && !L && U(S),
                    immediateRender: I,
                    stagger: 0,
                    parent: N,
                  },
                  r
                )),
                v && (c[f.prop] = v),
                Be((t._startAt = Zt.set(F, c))),
                (t._startAt._dp = 0),
                (t._startAt._sat = t),
                n < 0 &&
                  (a ? t._startAt.revert(te) : t._startAt.render(-1, !0)),
                (t._zTime = n),
                I)
              ) {
                if (!n) return;
              } else e(t._startAt, E, E);
            for (
              t._pt = t._ptCache = 0, S = (P && U(S)) || (S && !P), o = 0;
              o < F.length;
              o++
            ) {
              if (
                ((p = (h = F[o])._gsap || he(F)[o]._gsap),
                (t._ptLookup[o] = g = {}),
                se[p.id] && re.length && ye(),
                (m = O === F ? o : O.indexOf(h)),
                f &&
                  !1 !== (A = new f()).init(h, v || r, t, m, O) &&
                  ((t._pt = u =
                    new pn(t._pt, h, A.name, 0, 1, A.render, A, 0, A.priority)),
                  A._props.forEach(function (e) {
                    g[e] = u;
                  }),
                  A.priority && (d = 1)),
                !f || v)
              )
                for (c in r)
                  ae[c] && (A = jt(c, r, t, m, h, O))
                    ? A.priority && (d = 1)
                    : (g[c] = u =
                        Wt.call(t, h, c, "get", r[c], m, O, 0, x.stringFilter));
              t._op && t._op[o] && t.kill(h, t._op[o]),
                Q &&
                  t._pt &&
                  ((Ht = t),
                  l.killTweensOf(h, g, t.globalTime(n)),
                  (y = !t.parent),
                  (Ht = 0)),
                t._pt && S && (se[p.id] = 1);
            }
            d && dn(t), t._onInit && t._onInit(t);
          }
          (t._onUpdate = M),
            (t._initted = (!t._op || t._pt) && !y),
            R && n <= 0 && k.render(b, !0, !0);
        },
        Yt = function (e, t, n, i) {
          var r,
            s,
            a = t.ease || i || "power1.inOut";
          if (Q(t))
            (s = n[e] || (n[e] = [])),
              t.forEach(function (e, n) {
                return s.push({ t: (n / (t.length - 1)) * 100, v: e, e: a });
              });
          else
            for (r in t)
              (s = n[r] || (n[r] = [])),
                "ease" === r || s.push({ t: parseFloat(e), v: t[r], e: a });
        },
        Xt = function (e, t, n, i, r) {
          return R(e)
            ? e.call(t, n, i, r)
            : B(e) && ~e.indexOf("random(")
            ? ut(e)
            : e;
        },
        Kt = ue + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
        Jt = {};
      fe(Kt + ",id,stagger,delay,duration,paused,scrollTrigger", function (e) {
        return (Jt[e] = 1);
      });
      var Zt = (function (e) {
        function t(t, n, r, a) {
          var o;
          "number" == typeof n && ((r.duration = n), (n = r), (r = null));
          var c,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m = (o = e.call(this, a ? n : Se(n)) || this).vars,
            v = m.duration,
            y = m.delay,
            _ = m.immediateRender,
            b = m.stagger,
            E = m.overwrite,
            w = m.keyframes,
            C = m.defaults,
            I = m.scrollTrigger,
            S = m.yoyoEase,
            M = n.parent || l,
            T = (Q(t) || O(t) ? D(t[0]) : "length" in n) ? [t] : nt(t);
          if (
            ((o._targets = T.length
              ? he(T)
              : J(
                  "GSAP target " + t + " not found. https://gsap.com",
                  !x.nullTargetWarn
                ) || []),
            (o._ptLookup = []),
            (o._overwrite = E),
            w || b || N(v) || N(y))
          ) {
            if (
              ((n = o.vars),
              (c = o.timeline =
                new Gt({
                  data: "nested",
                  defaults: C || {},
                  targets: M && "nested" === M.data ? M.vars.targets : T,
                })).kill(),
              (c.parent = c._dp = i(o)),
              (c._start = 0),
              b || N(v) || N(y))
            ) {
              if (((d = T.length), (A = b && st(b)), L(b)))
                for (p in b) ~Kt.indexOf(p) && (g || (g = {}), (g[p] = b[p]));
              for (u = 0; u < d; u++)
                ((h = Ie(n, Jt)).stagger = 0),
                  S && (h.yoyoEase = S),
                  g && we(h, g),
                  (f = T[u]),
                  (h.duration = +Xt(v, i(o), u, f, T)),
                  (h.delay = (+Xt(y, i(o), u, f, T) || 0) - o._delay),
                  !b &&
                    1 === d &&
                    h.delay &&
                    ((o._delay = y = h.delay), (o._start += y), (h.delay = 0)),
                  c.to(f, h, A ? A(u, f, T) : 0),
                  (c._ease = Mt.none);
              c.duration() ? (v = y = 0) : (o.timeline = 0);
            } else if (w) {
              Se(Ee(c.vars.defaults, { ease: "none" })),
                (c._ease = Lt(w.ease || n.ease || "none"));
              var B,
                R,
                P,
                F = 0;
              if (Q(w))
                w.forEach(function (e) {
                  return c.to(T, e, ">");
                }),
                  c.duration();
              else {
                for (p in ((h = {}), w))
                  "ease" === p ||
                    "easeEach" === p ||
                    Yt(p, w[p], h, w.easeEach);
                for (p in h)
                  for (
                    B = h[p].sort(function (e, t) {
                      return e.t - t.t;
                    }),
                      F = 0,
                      u = 0;
                    u < B.length;
                    u++
                  )
                    ((P = {
                      ease: (R = B[u]).e,
                      duration: ((R.t - (u ? B[u - 1].t : 0)) / 100) * v,
                    })[p] = R.v),
                      c.to(T, P, F),
                      (F += P.duration);
                c.duration() < v && c.to({}, { duration: v - c.duration() });
              }
            }
            v || o.duration((v = c.duration()));
          } else o.timeline = 0;
          return (
            !0 !== E || s || ((Ht = i(o)), l.killTweensOf(T), (Ht = 0)),
            ke(M, i(o), r),
            n.reversed && o.reverse(),
            n.paused && o.paused(!0),
            (_ ||
              (!v &&
                !w &&
                o._start === ge(M._time) &&
                U(_) &&
                Pe(i(o)) &&
                "nested" !== M.data)) &&
              ((o._tTime = -1e-8), o.render(Math.max(0, -y) || 0)),
            I && Ge(i(o), I),
            o
          );
        }
        r(t, e);
        var n = t.prototype;
        return (
          (n.render = function (e, t, n) {
            var i,
              r,
              s,
              o,
              l,
              c,
              u,
              h,
              d,
              p = this._time,
              f = this._tDur,
              A = this._dur,
              g = e < 0,
              m = e > f - E && !g ? f : e < E ? 0 : e;
            if (A) {
              if (
                m !== this._tTime ||
                !e ||
                n ||
                (!this._initted && this._tTime) ||
                (this._startAt && this._zTime < 0 !== g)
              ) {
                if (((i = m), (h = this.timeline), this._repeat)) {
                  if (((o = A + this._rDelay), this._repeat < -1 && g))
                    return this.totalTime(100 * o + e, t, n);
                  if (
                    ((i = ge(m % o)),
                    m === f
                      ? ((s = this._repeat), (i = A))
                      : ((s = ~~(m / o)) && s === ge(m / o) && ((i = A), s--),
                        i > A && (i = A)),
                    (c = this._yoyo && 1 & s) &&
                      ((d = this._yEase), (i = A - i)),
                    (l = Ue(this._tTime, o)),
                    i === p && !n && this._initted && s === l)
                  )
                    return (this._tTime = m), this;
                  s !== l &&
                    (h && this._yEase && Pt(h, c),
                    this.vars.repeatRefresh &&
                      !c &&
                      !this._lock &&
                      this._time !== o &&
                      this._initted &&
                      ((this._lock = n = 1),
                      (this.render(ge(o * s), !0).invalidate()._lock = 0)));
                }
                if (!this._initted) {
                  if (He(this, g ? e : i, n, t, m))
                    return (this._tTime = 0), this;
                  if (
                    !(
                      p === this._time ||
                      (n && this.vars.repeatRefresh && s !== l)
                    )
                  )
                    return this;
                  if (A !== this._dur) return this.render(e, t, n);
                }
                if (
                  ((this._tTime = m),
                  (this._time = i),
                  !this._act && this._ts && ((this._act = 1), (this._lazy = 0)),
                  (this.ratio = u = (d || this._ease)(i / A)),
                  this._from && (this.ratio = u = 1 - u),
                  i &&
                    !p &&
                    !t &&
                    !s &&
                    (pt(this, "onStart"), this._tTime !== m))
                )
                  return this;
                for (r = this._pt; r; ) r.r(u, r.d), (r = r._next);
                (h &&
                  h.render(
                    e < 0 ? e : h._dur * h._ease(i / this._dur),
                    t,
                    n
                  )) ||
                  (this._startAt && (this._zTime = e)),
                  this._onUpdate &&
                    !t &&
                    (g && De(this, e, 0, n), pt(this, "onUpdate")),
                  this._repeat &&
                    s !== l &&
                    this.vars.onRepeat &&
                    !t &&
                    this.parent &&
                    pt(this, "onRepeat"),
                  (m !== this._tDur && m) ||
                    this._tTime !== m ||
                    (g && !this._onUpdate && De(this, e, 0, !0),
                    (e || !A) &&
                      ((m === this._tDur && this._ts > 0) ||
                        (!m && this._ts < 0)) &&
                      Be(this, 1),
                    t ||
                      (g && !p) ||
                      !(m || p || c) ||
                      (pt(
                        this,
                        m === f ? "onComplete" : "onReverseComplete",
                        !0
                      ),
                      this._prom &&
                        !(m < f && this.timeScale() > 0) &&
                        this._prom()));
              }
            } else
              !(function (e, t, n, i) {
                var r,
                  s,
                  o,
                  l = e.ratio,
                  c =
                    t < 0 ||
                    (!t &&
                      ((!e._start && ze(e) && (e._initted || !Ve(e))) ||
                        ((e._ts < 0 || e._dp._ts < 0) && !Ve(e))))
                      ? 0
                      : 1,
                  u = e._rDelay,
                  h = 0;
                if (
                  (u &&
                    e._repeat &&
                    ((h = Je(0, e._tDur, t)),
                    (s = Ue(h, u)),
                    e._yoyo && 1 & s && (c = 1 - c),
                    s !== Ue(e._tTime, u) &&
                      ((l = 1 - c),
                      e.vars.repeatRefresh && e._initted && e.invalidate())),
                  c !== l || a || i || e._zTime === E || (!t && e._zTime))
                ) {
                  if (!e._initted && He(e, t, i, n, h)) return;
                  for (
                    o = e._zTime,
                      e._zTime = t || (n ? E : 0),
                      n || (n = t && !o),
                      e.ratio = c,
                      e._from && (c = 1 - c),
                      e._time = 0,
                      e._tTime = h,
                      r = e._pt;
                    r;

                  )
                    r.r(c, r.d), (r = r._next);
                  t < 0 && De(e, t, 0, !0),
                    e._onUpdate && !n && pt(e, "onUpdate"),
                    h && e._repeat && !n && e.parent && pt(e, "onRepeat"),
                    (t >= e._tDur || t < 0) &&
                      e.ratio === c &&
                      (c && Be(e, 1),
                      n ||
                        a ||
                        (pt(e, c ? "onComplete" : "onReverseComplete", !0),
                        e._prom && e._prom()));
                } else e._zTime || (e._zTime = t);
              })(this, e, t, n);
            return this;
          }),
          (n.targets = function () {
            return this._targets;
          }),
          (n.invalidate = function (t) {
            return (
              (!t || !this.vars.runBackwards) && (this._startAt = 0),
              (this._pt =
                this._op =
                this._onUpdate =
                this._lazy =
                this.ratio =
                  0),
              (this._ptLookup = []),
              this.timeline && this.timeline.invalidate(t),
              e.prototype.invalidate.call(this, t)
            );
          }),
          (n.resetTo = function (e, t, n, i, r) {
            A || It.wake(), this._ts || this.play();
            var s = Math.min(
              this._dur,
              (this._dp._time - this._start) * this._ts
            );
            return (
              this._initted || qt(this, s),
              (function (e, t, n, i, r, s, a, o) {
                var l,
                  c,
                  u,
                  h,
                  d = ((e._pt && e._ptCache) || (e._ptCache = {}))[t];
                if (!d)
                  for (
                    d = e._ptCache[t] = [],
                      u = e._ptLookup,
                      h = e._targets.length;
                    h--;

                  ) {
                    if ((l = u[h][t]) && l.d && l.d._pt)
                      for (l = l.d._pt; l && l.p !== t && l.fp !== t; )
                        l = l._next;
                    if (!l)
                      return (
                        (zt = 1),
                        (e.vars[t] = "+=0"),
                        qt(e, a),
                        (zt = 0),
                        o ? J(t + " not eligible for reset") : 1
                      );
                    d.push(l);
                  }
                for (h = d.length; h--; )
                  ((l = (c = d[h])._pt || c).s =
                    (!i && 0 !== i) || r ? l.s + (i || 0) + s * l.c : i),
                    (l.c = n - l.s),
                    c.e && (c.e = Ae(n) + Ze(c.e)),
                    c.b && (c.b = l.s + Ze(c.b));
              })(this, e, t, n, i, this._ease(s / this._dur), s, r)
                ? this.resetTo(e, t, n, i, 1)
                : (Oe(this, 0),
                  this.parent ||
                    Me(
                      this._dp,
                      this,
                      "_first",
                      "_last",
                      this._dp._sort ? "_start" : 0
                    ),
                  this.render(0))
            );
          }),
          (n.kill = function (e, t) {
            if ((void 0 === t && (t = "all"), !(e || (t && "all" !== t))))
              return (this._lazy = this._pt = 0), this.parent ? ft(this) : this;
            if (this.timeline) {
              var n = this.timeline.totalDuration();
              return (
                this.timeline.killTweensOf(e, t, Ht && !0 !== Ht.vars.overwrite)
                  ._first || ft(this),
                this.parent &&
                  n !== this.timeline.totalDuration() &&
                  We(this, (this._dur * this.timeline._tDur) / n, 0, 1),
                this
              );
            }
            var i,
              r,
              s,
              a,
              o,
              l,
              c,
              u = this._targets,
              h = e ? nt(e) : u,
              d = this._ptLookup,
              p = this._pt;
            if (
              (!t || "all" === t) &&
              (function (e, t) {
                for (
                  var n = e.length, i = n === t.length;
                  i && n-- && e[n] === t[n];

                );
                return n < 0;
              })(u, h)
            )
              return "all" === t && (this._pt = 0), ft(this);
            for (
              i = this._op = this._op || [],
                "all" !== t &&
                  (B(t) &&
                    ((o = {}),
                    fe(t, function (e) {
                      return (o[e] = 1);
                    }),
                    (t = o)),
                  (t = (function (e, t) {
                    var n,
                      i,
                      r,
                      s,
                      a = e[0] ? de(e[0]).harness : 0,
                      o = a && a.aliases;
                    if (!o) return t;
                    for (i in ((n = we({}, t)), o))
                      if ((i in n))
                        for (r = (s = o[i].split(",")).length; r--; )
                          n[s[r]] = n[i];
                    return n;
                  })(u, t))),
                c = u.length;
              c--;

            )
              if (~h.indexOf(u[c]))
                for (o in ((r = d[c]),
                "all" === t
                  ? ((i[c] = t), (a = r), (s = {}))
                  : ((s = i[c] = i[c] || {}), (a = t)),
                a))
                  (l = r && r[o]) &&
                    (("kill" in l.d && !0 !== l.d.kill(o)) ||
                      Te(this, l, "_pt"),
                    delete r[o]),
                    "all" !== s && (s[o] = 1);
            return this._initted && !this._pt && p && ft(this), this;
          }),
          (t.to = function (e, n) {
            return new t(e, n, arguments[2]);
          }),
          (t.from = function (e, t) {
            return Xe(1, arguments);
          }),
          (t.delayedCall = function (e, n, i, r) {
            return new t(n, 0, {
              immediateRender: !1,
              lazy: !1,
              overwrite: !1,
              delay: e,
              onComplete: n,
              onReverseComplete: n,
              onCompleteParams: i,
              onReverseCompleteParams: i,
              callbackScope: r,
            });
          }),
          (t.fromTo = function (e, t, n) {
            return Xe(2, arguments);
          }),
          (t.set = function (e, n) {
            return (
              (n.duration = 0), n.repeatDelay || (n.repeat = 0), new t(e, n)
            );
          }),
          (t.killTweensOf = function (e, t, n) {
            return l.killTweensOf(e, t, n);
          }),
          t
        );
      })(kt);
      Ee(Zt.prototype, {
        _targets: [],
        _lazy: 0,
        _startAt: 0,
        _op: 0,
        _onInit: 0,
      }),
        fe("staggerTo,staggerFrom,staggerFromTo", function (e) {
          Zt[e] = function () {
            var t = new Gt(),
              n = $e.call(arguments, 0);
            return (
              n.splice("staggerFromTo" === e ? 5 : 4, 0, 0), t[e].apply(t, n)
            );
          };
        });
      var $t = function (e, t, n) {
          return (e[t] = n);
        },
        en = function (e, t, n) {
          return e[t](n);
        },
        tn = function (e, t, n, i) {
          return e[t](i.fp, n);
        },
        nn = function (e, t, n) {
          return e.setAttribute(t, n);
        },
        rn = function (e, t) {
          return R(e[t]) ? en : P(e[t]) && e.setAttribute ? nn : $t;
        },
        sn = function (e, t) {
          return t.set(t.t, t.p, Math.round(1e6 * (t.s + t.c * e)) / 1e6, t);
        },
        an = function (e, t) {
          return t.set(t.t, t.p, !!(t.s + t.c * e), t);
        },
        on = function (e, t) {
          var n = t._pt,
            i = "";
          if (!e && t.b) i = t.b;
          else if (1 === e && t.e) i = t.e;
          else {
            for (; n; )
              (i =
                n.p +
                (n.m
                  ? n.m(n.s + n.c * e)
                  : Math.round(1e4 * (n.s + n.c * e)) / 1e4) +
                i),
                (n = n._next);
            i += t.c;
          }
          t.set(t.t, t.p, i, t);
        },
        ln = function (e, t) {
          for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
        },
        cn = function (e, t, n, i) {
          for (var r, s = this._pt; s; )
            (r = s._next), s.p === i && s.modifier(e, t, n), (s = r);
        },
        un = function (e) {
          for (var t, n, i = this._pt; i; )
            (n = i._next),
              (i.p === e && !i.op) || i.op === e
                ? Te(this, i, "_pt")
                : i.dep || (t = 1),
              (i = n);
          return !t;
        },
        hn = function (e, t, n, i) {
          i.mSet(e, t, i.m.call(i.tween, n, i.mt), i);
        },
        dn = function (e) {
          for (var t, n, i, r, s = e._pt; s; ) {
            for (t = s._next, n = i; n && n.pr > s.pr; ) n = n._next;
            (s._prev = n ? n._prev : r) ? (s._prev._next = s) : (i = s),
              (s._next = n) ? (n._prev = s) : (r = s),
              (s = t);
          }
          e._pt = i;
        },
        pn = (function () {
          function e(e, t, n, i, r, s, a, o, l) {
            (this.t = t),
              (this.s = i),
              (this.c = r),
              (this.p = n),
              (this.r = s || sn),
              (this.d = a || this),
              (this.set = o || $t),
              (this.pr = l || 0),
              (this._next = e),
              e && (e._prev = this);
          }
          return (
            (e.prototype.modifier = function (e, t, n) {
              (this.mSet = this.mSet || this.set),
                (this.set = hn),
                (this.m = e),
                (this.mt = n),
                (this.tween = t);
            }),
            e
          );
        })();
      fe(
        ue +
          "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger",
        function (e) {
          return (ie[e] = 1);
        }
      ),
        (q.TweenMax = q.TweenLite = Zt),
        (q.TimelineLite = q.TimelineMax = Gt),
        (l = new Gt({
          sortChildren: !1,
          defaults: _,
          autoRemoveChildren: !0,
          id: "root",
          smoothChildTiming: !0,
        })),
        (x.stringFilter = Ct);
      var fn = [],
        An = {},
        gn = [],
        mn = 0,
        vn = 0,
        yn = function (e) {
          return (An[e] || gn).map(function (e) {
            return e();
          });
        },
        xn = function () {
          var e = Date.now(),
            t = [];
          e - mn > 2 &&
            (yn("matchMediaInit"),
            fn.forEach(function (e) {
              var n,
                i,
                r,
                s,
                a = e.queries,
                o = e.conditions;
              for (i in a)
                (n = c.matchMedia(a[i]).matches) && (r = 1),
                  n !== o[i] && ((o[i] = n), (s = 1));
              s && (e.revert(), r && t.push(e));
            }),
            yn("matchMediaRevert"),
            t.forEach(function (e) {
              return e.onMatch(e, function (t) {
                return e.add(null, t);
              });
            }),
            (mn = e),
            yn("matchMedia"));
        },
        _n = (function () {
          function e(e, t) {
            (this.selector = t && it(t)),
              (this.data = []),
              (this._r = []),
              (this.isReverted = !1),
              (this.id = vn++),
              e && this.add(e);
          }
          var t = e.prototype;
          return (
            (t.add = function (e, t, n) {
              R(e) && ((n = t), (t = e), (e = R));
              var i = this,
                r = function () {
                  var e,
                    r = o,
                    s = i.selector;
                  return (
                    r && r !== i && r.data.push(i),
                    n && (i.selector = it(n)),
                    (o = i),
                    (e = t.apply(i, arguments)),
                    R(e) && i._r.push(e),
                    (o = r),
                    (i.selector = s),
                    (i.isReverted = !1),
                    e
                  );
                };
              return (
                (i.last = r),
                e === R
                  ? r(i, function (e) {
                      return i.add(null, e);
                    })
                  : e
                  ? (i[e] = r)
                  : r
              );
            }),
            (t.ignore = function (e) {
              var t = o;
              (o = null), e(this), (o = t);
            }),
            (t.getTweens = function () {
              var t = [];
              return (
                this.data.forEach(function (n) {
                  return n instanceof e
                    ? t.push.apply(t, n.getTweens())
                    : n instanceof Zt &&
                        !(n.parent && "nested" === n.parent.data) &&
                        t.push(n);
                }),
                t
              );
            }),
            (t.clear = function () {
              this._r.length = this.data.length = 0;
            }),
            (t.kill = function (e, t) {
              var n = this;
              if (
                (e
                  ? (function () {
                      for (var t, i = n.getTweens(), r = n.data.length; r--; )
                        "isFlip" === (t = n.data[r]).data &&
                          (t.revert(),
                          t.getChildren(!0, !0, !1).forEach(function (e) {
                            return i.splice(i.indexOf(e), 1);
                          }));
                      for (
                        i
                          .map(function (e) {
                            return {
                              g:
                                e._dur ||
                                e._delay ||
                                (e._sat && !e._sat.vars.immediateRender)
                                  ? e.globalTime(0)
                                  : -1 / 0,
                              t: e,
                            };
                          })
                          .sort(function (e, t) {
                            return t.g - e.g || -1 / 0;
                          })
                          .forEach(function (t) {
                            return t.t.revert(e);
                          }),
                          r = n.data.length;
                        r--;

                      )
                        (t = n.data[r]) instanceof Gt
                          ? "nested" !== t.data &&
                            (t.scrollTrigger && t.scrollTrigger.revert(),
                            t.kill())
                          : !(t instanceof Zt) && t.revert && t.revert(e);
                      n._r.forEach(function (t) {
                        return t(e, n);
                      }),
                        (n.isReverted = !0);
                    })()
                  : this.data.forEach(function (e) {
                      return e.kill && e.kill();
                    }),
                this.clear(),
                t)
              )
                for (var i = fn.length; i--; )
                  fn[i].id === this.id && fn.splice(i, 1);
            }),
            (t.revert = function (e) {
              this.kill(e || {});
            }),
            e
          );
        })(),
        bn = (function () {
          function e(e) {
            (this.contexts = []), (this.scope = e), o && o.data.push(this);
          }
          var t = e.prototype;
          return (
            (t.add = function (e, t, n) {
              L(e) || (e = { matches: e });
              var i,
                r,
                s,
                a = new _n(0, n || this.scope),
                l = (a.conditions = {});
              for (r in (o && !a.selector && (a.selector = o.selector),
              this.contexts.push(a),
              (t = a.add("onMatch", t)),
              (a.queries = e),
              e))
                "all" === r
                  ? (s = 1)
                  : (i = c.matchMedia(e[r])) &&
                    (fn.indexOf(a) < 0 && fn.push(a),
                    (l[r] = i.matches) && (s = 1),
                    i.addListener
                      ? i.addListener(xn)
                      : i.addEventListener("change", xn));
              return (
                s &&
                  t(a, function (e) {
                    return a.add(null, e);
                  }),
                this
              );
            }),
            (t.revert = function (e) {
              this.kill(e || {});
            }),
            (t.kill = function (e) {
              this.contexts.forEach(function (t) {
                return t.kill(e, !0);
              });
            }),
            e
          );
        })(),
        En = {
          registerPlugin: function () {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
              t[n] = arguments[n];
            t.forEach(function (e) {
              return gt(e);
            });
          },
          timeline: function (e) {
            return new Gt(e);
          },
          getTweensOf: function (e, t) {
            return l.getTweensOf(e, t);
          },
          getProperty: function (e, t, n, i) {
            B(e) && (e = nt(e)[0]);
            var r = de(e || {}).get,
              s = n ? be : _e;
            return (
              "native" === n && (n = ""),
              e
                ? t
                  ? s(((ae[t] && ae[t].get) || r)(e, t, n, i))
                  : function (t, n, i) {
                      return s(((ae[t] && ae[t].get) || r)(e, t, n, i));
                    }
                : e
            );
          },
          quickSetter: function (e, t, n) {
            if ((e = nt(e)).length > 1) {
              var i = e.map(function (e) {
                  return In.quickSetter(e, t, n);
                }),
                r = i.length;
              return function (e) {
                for (var t = r; t--; ) i[t](e);
              };
            }
            e = e[0] || {};
            var s = ae[t],
              a = de(e),
              o = (a.harness && (a.harness.aliases || {})[t]) || t,
              l = s
                ? function (t) {
                    var i = new s();
                    (f._pt = 0),
                      i.init(e, n ? t + n : t, f, 0, [e]),
                      i.render(1, i),
                      f._pt && ln(1, f);
                  }
                : a.set(e, o);
            return s
              ? l
              : function (t) {
                  return l(e, o, n ? t + n : t, a, 1);
                };
          },
          quickTo: function (e, t, n) {
            var i,
              r = In.to(
                e,
                we((((i = {})[t] = "+=0.1"), (i.paused = !0), i), n || {})
              ),
              s = function (e, n, i) {
                return r.resetTo(t, e, n, i);
              };
            return (s.tween = r), s;
          },
          isTweening: function (e) {
            return l.getTweensOf(e, !0).length > 0;
          },
          defaults: function (e) {
            return e && e.ease && (e.ease = Lt(e.ease, _.ease)), Ce(_, e || {});
          },
          config: function (e) {
            return Ce(x, e || {});
          },
          registerEffect: function (e) {
            var t = e.name,
              n = e.effect,
              i = e.plugins,
              r = e.defaults,
              s = e.extendTimeline;
            (i || "").split(",").forEach(function (e) {
              return (
                e &&
                !ae[e] &&
                !q[e] &&
                J(t + " effect requires " + e + " plugin.")
              );
            }),
              (oe[t] = function (e, t, i) {
                return n(nt(e), Ee(t || {}, r), i);
              }),
              s &&
                (Gt.prototype[t] = function (e, n, i) {
                  return this.add(oe[t](e, L(n) ? n : (i = n) && {}, this), i);
                });
          },
          registerEase: function (e, t) {
            Mt[e] = Lt(t);
          },
          parseEase: function (e, t) {
            return arguments.length ? Lt(e, t) : Mt;
          },
          getById: function (e) {
            return l.getById(e);
          },
          exportRoot: function (e, t) {
            void 0 === e && (e = {});
            var n,
              i,
              r = new Gt(e);
            for (
              r.smoothChildTiming = U(e.smoothChildTiming),
                l.remove(r),
                r._dp = 0,
                r._time = r._tTime = l._time,
                n = l._first;
              n;

            )
              (i = n._next),
                (!t &&
                  !n._dur &&
                  n instanceof Zt &&
                  n.vars.onComplete === n._targets[0]) ||
                  ke(r, n, n._start - n._delay),
                (n = i);
            return ke(l, r, 0), r;
          },
          context: function (e, t) {
            return e ? new _n(e, t) : o;
          },
          matchMedia: function (e) {
            return new bn(e);
          },
          matchMediaRefresh: function () {
            return (
              fn.forEach(function (e) {
                var t,
                  n,
                  i = e.conditions;
                for (n in i) i[n] && ((i[n] = !1), (t = 1));
                t && e.revert();
              }) || xn()
            );
          },
          addEventListener: function (e, t) {
            var n = An[e] || (An[e] = []);
            ~n.indexOf(t) || n.push(t);
          },
          removeEventListener: function (e, t) {
            var n = An[e],
              i = n && n.indexOf(t);
            i >= 0 && n.splice(i, 1);
          },
          utils: {
            wrap: function e(t, n, i) {
              var r = n - t;
              return Q(t)
                ? ct(t, e(0, t.length), n)
                : Ke(i, function (e) {
                    return ((r + ((e - t) % r)) % r) + t;
                  });
            },
            wrapYoyo: function e(t, n, i) {
              var r = n - t,
                s = 2 * r;
              return Q(t)
                ? ct(t, e(0, t.length - 1), n)
                : Ke(i, function (e) {
                    return (
                      t + ((e = (s + ((e - t) % s)) % s || 0) > r ? s - e : e)
                    );
                  });
            },
            distribute: st,
            random: lt,
            snap: ot,
            normalize: function (e, t, n) {
              return ht(e, t, 0, 1, n);
            },
            getUnit: Ze,
            clamp: function (e, t, n) {
              return Ke(n, function (n) {
                return Je(e, t, n);
              });
            },
            splitColor: xt,
            toArray: nt,
            selector: it,
            mapRange: ht,
            pipe: function () {
              for (
                var e = arguments.length, t = new Array(e), n = 0;
                n < e;
                n++
              )
                t[n] = arguments[n];
              return function (e) {
                return t.reduce(function (e, t) {
                  return t(e);
                }, e);
              };
            },
            unitize: function (e, t) {
              return function (n) {
                return e(parseFloat(n)) + (t || Ze(n));
              };
            },
            interpolate: function e(t, n, i, r) {
              var s = isNaN(t + n)
                ? 0
                : function (e) {
                    return (1 - e) * t + e * n;
                  };
              if (!s) {
                var a,
                  o,
                  l,
                  c,
                  u,
                  h = B(t),
                  d = {};
                if ((!0 === i && (r = 1) && (i = null), h))
                  (t = { p: t }), (n = { p: n });
                else if (Q(t) && !Q(n)) {
                  for (l = [], c = t.length, u = c - 2, o = 1; o < c; o++)
                    l.push(e(t[o - 1], t[o]));
                  c--,
                    (s = function (e) {
                      e *= c;
                      var t = Math.min(u, ~~e);
                      return l[t](e - t);
                    }),
                    (i = n);
                } else r || (t = we(Q(t) ? [] : {}, t));
                if (!l) {
                  for (a in n) Wt.call(d, t, a, "get", n[a]);
                  s = function (e) {
                    return ln(e, d) || (h ? t.p : t);
                  };
                }
              }
              return Ke(i, s);
            },
            shuffle: rt,
          },
          install: X,
          effects: oe,
          ticker: It,
          updateRoot: Gt.updateRoot,
          plugins: ae,
          globalTimeline: l,
          core: {
            PropTween: pn,
            globals: Z,
            Tween: Zt,
            Timeline: Gt,
            Animation: kt,
            getCache: de,
            _removeLinkedListItem: Te,
            reverting: function () {
              return a;
            },
            context: function (e) {
              return e && o && (o.data.push(e), (e._ctx = o)), o;
            },
            suppressOverwrites: function (e) {
              return (s = e);
            },
          },
        };
      fe("to,from,fromTo,delayedCall,set,killTweensOf", function (e) {
        return (En[e] = Zt[e]);
      }),
        It.add(Gt.updateRoot),
        (f = En.to({}, { duration: 0 }));
      var wn = function (e, t) {
          for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t; )
            n = n._next;
          return n;
        },
        Cn = function (e, t) {
          return {
            name: e,
            rawVars: 1,
            init: function (e, n, i) {
              i._onInit = function (e) {
                var i, r;
                if (
                  (B(n) &&
                    ((i = {}),
                    fe(n, function (e) {
                      return (i[e] = 1);
                    }),
                    (n = i)),
                  t)
                ) {
                  for (r in ((i = {}), n)) i[r] = t(n[r]);
                  n = i;
                }
                !(function (e, t) {
                  var n,
                    i,
                    r,
                    s = e._targets;
                  for (n in t)
                    for (i = s.length; i--; )
                      (r = e._ptLookup[i][n]) &&
                        (r = r.d) &&
                        (r._pt && (r = wn(r, n)),
                        r && r.modifier && r.modifier(t[n], e, s[i], n));
                })(e, n);
              };
            },
          };
        },
        In =
          En.registerPlugin(
            {
              name: "attr",
              init: function (e, t, n, i, r) {
                var s, a, o;
                for (s in ((this.tween = n), t))
                  (o = e.getAttribute(s) || ""),
                    ((a = this.add(
                      e,
                      "setAttribute",
                      (o || 0) + "",
                      t[s],
                      i,
                      r,
                      0,
                      0,
                      s
                    )).op = s),
                    (a.b = o),
                    this._props.push(s);
              },
              render: function (e, t) {
                for (var n = t._pt; n; )
                  a ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), (n = n._next);
              },
            },
            {
              name: "endArray",
              init: function (e, t) {
                for (var n = t.length; n--; )
                  this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1);
              },
            },
            Cn("roundProps", at),
            Cn("modifiers"),
            Cn("snap", ot)
          ) || En;
      (Zt.version = Gt.version = In.version = "3.12.5"), (d = 1), F() && St();
      Mt.Power0,
        Mt.Power1,
        Mt.Power2,
        Mt.Power3,
        Mt.Power4,
        Mt.Linear,
        Mt.Quad,
        Mt.Cubic,
        Mt.Quart,
        Mt.Quint,
        Mt.Strong,
        Mt.Elastic,
        Mt.Back,
        Mt.SteppedEase,
        Mt.Bounce,
        Mt.Sine,
        Mt.Expo,
        Mt.Circ;
      var Sn,
        Mn,
        Tn,
        Bn,
        Rn,
        Dn,
        Pn,
        Ln,
        Un = {},
        Fn = 180 / Math.PI,
        Nn = Math.PI / 180,
        On = Math.atan2,
        Qn = /([A-Z])/g,
        kn = /(left|right|width|margin|padding|x)/i,
        Gn = /[\s,\(]\S/,
        Hn = {
          autoAlpha: "opacity,visibility",
          scale: "scaleX,scaleY",
          alpha: "opacity",
        },
        zn = function (e, t) {
          return t.set(
            t.t,
            t.p,
            Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        Vn = function (e, t) {
          return t.set(
            t.t,
            t.p,
            1 === e ? t.e : Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u,
            t
          );
        },
        Wn = function (e, t) {
          return t.set(
            t.t,
            t.p,
            e ? Math.round(1e4 * (t.s + t.c * e)) / 1e4 + t.u : t.b,
            t
          );
        },
        jn = function (e, t) {
          var n = t.s + t.c * e;
          t.set(t.t, t.p, ~~(n + (n < 0 ? -0.5 : 0.5)) + t.u, t);
        },
        qn = function (e, t) {
          return t.set(t.t, t.p, e ? t.e : t.b, t);
        },
        Yn = function (e, t) {
          return t.set(t.t, t.p, 1 !== e ? t.b : t.e, t);
        },
        Xn = function (e, t, n) {
          return (e.style[t] = n);
        },
        Kn = function (e, t, n) {
          return e.style.setProperty(t, n);
        },
        Jn = function (e, t, n) {
          return (e._gsap[t] = n);
        },
        Zn = function (e, t, n) {
          return (e._gsap.scaleX = e._gsap.scaleY = n);
        },
        $n = function (e, t, n, i, r) {
          var s = e._gsap;
          (s.scaleX = s.scaleY = n), s.renderTransform(r, s);
        },
        ei = function (e, t, n, i, r) {
          var s = e._gsap;
          (s[t] = n), s.renderTransform(r, s);
        },
        ti = "transform",
        ni = ti + "Origin",
        ii = function e(t, n) {
          var i = this,
            r = this.target,
            s = r.style,
            a = r._gsap;
          if (t in Un && s) {
            if (((this.tfm = this.tfm || {}), "transform" === t))
              return Hn.transform.split(",").forEach(function (t) {
                return e.call(i, t, n);
              });
            if (
              (~(t = Hn[t] || t).indexOf(",")
                ? t.split(",").forEach(function (e) {
                    return (i.tfm[e] = _i(r, e));
                  })
                : (this.tfm[t] = a.x ? a[t] : _i(r, t)),
              t === ni && (this.tfm.zOrigin = a.zOrigin),
              this.props.indexOf(ti) >= 0)
            )
              return;
            a.svg &&
              ((this.svgo = r.getAttribute("data-svg-origin")),
              this.props.push(ni, n, "")),
              (t = ti);
          }
          (s || n) && this.props.push(t, n, s[t]);
        },
        ri = function (e) {
          e.translate &&
            (e.removeProperty("translate"),
            e.removeProperty("scale"),
            e.removeProperty("rotate"));
        },
        si = function () {
          var e,
            t,
            n = this.props,
            i = this.target,
            r = i.style,
            s = i._gsap;
          for (e = 0; e < n.length; e += 3)
            n[e + 1]
              ? (i[n[e]] = n[e + 2])
              : n[e + 2]
              ? (r[n[e]] = n[e + 2])
              : r.removeProperty(
                  "--" === n[e].substr(0, 2)
                    ? n[e]
                    : n[e].replace(Qn, "-$1").toLowerCase()
                );
          if (this.tfm) {
            for (t in this.tfm) s[t] = this.tfm[t];
            s.svg &&
              (s.renderTransform(),
              i.setAttribute("data-svg-origin", this.svgo || "")),
              ((e = Pn()) && e.isStart) ||
                r[ti] ||
                (ri(r),
                s.zOrigin &&
                  r[ni] &&
                  ((r[ni] += " " + s.zOrigin + "px"),
                  (s.zOrigin = 0),
                  s.renderTransform()),
                (s.uncache = 1));
          }
        },
        ai = function (e, t) {
          var n = { target: e, props: [], revert: si, save: ii };
          return (
            e._gsap || In.core.getCache(e),
            t &&
              t.split(",").forEach(function (e) {
                return n.save(e);
              }),
            n
          );
        },
        oi = function (e, t) {
          var n = Mn.createElementNS
            ? Mn.createElementNS(
                (t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"),
                e
              )
            : Mn.createElement(e);
          return n && n.style ? n : Mn.createElement(e);
        },
        li = function e(t, n, i) {
          var r = getComputedStyle(t);
          return (
            r[n] ||
            r.getPropertyValue(n.replace(Qn, "-$1").toLowerCase()) ||
            r.getPropertyValue(n) ||
            (!i && e(t, ui(n) || n, 1)) ||
            ""
          );
        },
        ci = "O,Moz,ms,Ms,Webkit".split(","),
        ui = function (e, t, n) {
          var i = (t || Rn).style,
            r = 5;
          if (e in i && !n) return e;
          for (
            e = e.charAt(0).toUpperCase() + e.substr(1);
            r-- && !(ci[r] + e in i);

          );
          return r < 0 ? null : (3 === r ? "ms" : r >= 0 ? ci[r] : "") + e;
        },
        hi = function () {
          "undefined" != typeof window &&
            window.document &&
            ((Sn = window),
            (Mn = Sn.document),
            (Tn = Mn.documentElement),
            (Rn = oi("div") || { style: {} }),
            oi("div"),
            (ti = ui(ti)),
            (ni = ti + "Origin"),
            (Rn.style.cssText =
              "border-width:0;line-height:0;position:absolute;padding:0"),
            (Ln = !!ui("perspective")),
            (Pn = In.core.reverting),
            (Bn = 1));
        },
        di = function e(t) {
          var n,
            i = oi(
              "svg",
              (this.ownerSVGElement &&
                this.ownerSVGElement.getAttribute("xmlns")) ||
                "http://www.w3.org/2000/svg"
            ),
            r = this.parentNode,
            s = this.nextSibling,
            a = this.style.cssText;
          if (
            (Tn.appendChild(i),
            i.appendChild(this),
            (this.style.display = "block"),
            t)
          )
            try {
              (n = this.getBBox()),
                (this._gsapBBox = this.getBBox),
                (this.getBBox = e);
            } catch (e) {}
          else this._gsapBBox && (n = this._gsapBBox());
          return (
            r && (s ? r.insertBefore(this, s) : r.appendChild(this)),
            Tn.removeChild(i),
            (this.style.cssText = a),
            n
          );
        },
        pi = function (e, t) {
          for (var n = t.length; n--; )
            if (e.hasAttribute(t[n])) return e.getAttribute(t[n]);
        },
        fi = function (e) {
          var t;
          try {
            t = e.getBBox();
          } catch (n) {
            t = di.call(e, !0);
          }
          return (
            (t && (t.width || t.height)) ||
              e.getBBox === di ||
              (t = di.call(e, !0)),
            !t || t.width || t.x || t.y
              ? t
              : {
                  x: +pi(e, ["x", "cx", "x1"]) || 0,
                  y: +pi(e, ["y", "cy", "y1"]) || 0,
                  width: 0,
                  height: 0,
                }
          );
        },
        Ai = function (e) {
          return !(!e.getCTM || (e.parentNode && !e.ownerSVGElement) || !fi(e));
        },
        gi = function (e, t) {
          if (t) {
            var n,
              i = e.style;
            t in Un && t !== ni && (t = ti),
              i.removeProperty
                ? (("ms" !== (n = t.substr(0, 2)) &&
                    "webkit" !== t.substr(0, 6)) ||
                    (t = "-" + t),
                  i.removeProperty(
                    "--" === n ? t : t.replace(Qn, "-$1").toLowerCase()
                  ))
                : i.removeAttribute(t);
          }
        },
        mi = function (e, t, n, i, r, s) {
          var a = new pn(e._pt, t, n, 0, 1, s ? Yn : qn);
          return (e._pt = a), (a.b = i), (a.e = r), e._props.push(n), a;
        },
        vi = { deg: 1, rad: 1, turn: 1 },
        yi = { grid: 1, flex: 1 },
        xi = function e(t, n, i, r) {
          var s,
            a,
            o,
            l,
            c = parseFloat(i) || 0,
            u = (i + "").trim().substr((c + "").length) || "px",
            h = Rn.style,
            d = kn.test(n),
            p = "svg" === t.tagName.toLowerCase(),
            f = (p ? "client" : "offset") + (d ? "Width" : "Height"),
            A = 100,
            g = "px" === r,
            m = "%" === r;
          if (r === u || !c || vi[r] || vi[u]) return c;
          if (
            ("px" !== u && !g && (c = e(t, n, i, "px")),
            (l = t.getCTM && Ai(t)),
            (m || "%" === u) && (Un[n] || ~n.indexOf("adius")))
          )
            return (
              (s = l ? t.getBBox()[d ? "width" : "height"] : t[f]),
              Ae(m ? (c / s) * A : (c / 100) * s)
            );
          if (
            ((h[d ? "width" : "height"] = A + (g ? u : r)),
            (a =
              ~n.indexOf("adius") || ("em" === r && t.appendChild && !p)
                ? t
                : t.parentNode),
            l && (a = (t.ownerSVGElement || {}).parentNode),
            (a && a !== Mn && a.appendChild) || (a = Mn.body),
            (o = a._gsap) &&
              m &&
              o.width &&
              d &&
              o.time === It.time &&
              !o.uncache)
          )
            return Ae((c / o.width) * A);
          if (!m || ("height" !== n && "width" !== n))
            (m || "%" === u) &&
              !yi[li(a, "display")] &&
              (h.position = li(t, "position")),
              a === t && (h.position = "static"),
              a.appendChild(Rn),
              (s = Rn[f]),
              a.removeChild(Rn),
              (h.position = "absolute");
          else {
            var v = t.style[n];
            (t.style[n] = A + r), (s = t[f]), v ? (t.style[n] = v) : gi(t, n);
          }
          return (
            d && m && (((o = de(a)).time = It.time), (o.width = a[f])),
            Ae(g ? (s * c) / A : s && c ? (A / s) * c : 0)
          );
        },
        _i = function (e, t, n, i) {
          var r;
          return (
            Bn || hi(),
            t in Hn &&
              "transform" !== t &&
              ~(t = Hn[t]).indexOf(",") &&
              (t = t.split(",")[0]),
            Un[t] && "transform" !== t
              ? ((r = Di(e, i)),
                (r =
                  "transformOrigin" !== t
                    ? r[t]
                    : r.svg
                    ? r.origin
                    : Pi(li(e, ni)) + " " + r.zOrigin + "px"))
              : (!(r = e.style[t]) ||
                  "auto" === r ||
                  i ||
                  ~(r + "").indexOf("calc(")) &&
                (r =
                  (Ci[t] && Ci[t](e, t, n)) ||
                  li(e, t) ||
                  pe(e, t) ||
                  ("opacity" === t ? 1 : 0)),
            n && !~(r + "").trim().indexOf(" ") ? xi(e, t, r, n) + n : r
          );
        },
        bi = function (e, t, n, i) {
          if (!n || "none" === n) {
            var r = ui(t, e, 1),
              s = r && li(e, r, 1);
            s && s !== n
              ? ((t = r), (n = s))
              : "borderColor" === t && (n = li(e, "borderTopColor"));
          }
          var a,
            o,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m = new pn(this._pt, e.style, t, 0, 1, on),
            v = 0,
            y = 0;
          if (
            ((m.b = n),
            (m.e = i),
            (n += ""),
            "auto" === (i += "") &&
              ((h = e.style[t]),
              (e.style[t] = i),
              (i = li(e, t) || i),
              h ? (e.style[t] = h) : gi(e, t)),
            Ct((a = [n, i])),
            (i = a[1]),
            (l = (n = a[0]).match(H) || []),
            (i.match(H) || []).length)
          ) {
            for (; (o = H.exec(i)); )
              (d = o[0]),
                (f = i.substring(v, o.index)),
                u
                  ? (u = (u + 1) % 5)
                  : ("rgba(" !== f.substr(-5) && "hsla(" !== f.substr(-5)) ||
                    (u = 1),
                d !== (h = l[y++] || "") &&
                  ((c = parseFloat(h) || 0),
                  (g = h.substr((c + "").length)),
                  "=" === d.charAt(1) && (d = me(c, d) + g),
                  (p = parseFloat(d)),
                  (A = d.substr((p + "").length)),
                  (v = H.lastIndex - A.length),
                  A ||
                    ((A = A || x.units[t] || g),
                    v === i.length && ((i += A), (m.e += A))),
                  g !== A && (c = xi(e, t, h, A) || 0),
                  (m._pt = {
                    _next: m._pt,
                    p: f || 1 === y ? f : ",",
                    s: c,
                    c: p - c,
                    m: (u && u < 4) || "zIndex" === t ? Math.round : 0,
                  }));
            m.c = v < i.length ? i.substring(v, i.length) : "";
          } else m.r = "display" === t && "none" === i ? Yn : qn;
          return V.test(i) && (m.e = 0), (this._pt = m), m;
        },
        Ei = {
          top: "0%",
          bottom: "100%",
          left: "0%",
          right: "100%",
          center: "50%",
        },
        wi = function (e, t) {
          if (t.tween && t.tween._time === t.tween._dur) {
            var n,
              i,
              r,
              s = t.t,
              a = s.style,
              o = t.u,
              l = s._gsap;
            if ("all" === o || !0 === o) (a.cssText = ""), (i = 1);
            else
              for (r = (o = o.split(",")).length; --r > -1; )
                (n = o[r]),
                  Un[n] && ((i = 1), (n = "transformOrigin" === n ? ni : ti)),
                  gi(s, n);
            i &&
              (gi(s, ti),
              l &&
                (l.svg && s.removeAttribute("transform"),
                Di(s, 1),
                (l.uncache = 1),
                ri(a)));
          }
        },
        Ci = {
          clearProps: function (e, t, n, i, r) {
            if ("isFromStart" !== r.data) {
              var s = (e._pt = new pn(e._pt, t, n, 0, 0, wi));
              return (
                (s.u = i), (s.pr = -10), (s.tween = r), e._props.push(n), 1
              );
            }
          },
        },
        Ii = [1, 0, 0, 1, 0, 0],
        Si = {},
        Mi = function (e) {
          return "matrix(1, 0, 0, 1, 0, 0)" === e || "none" === e || !e;
        },
        Ti = function (e) {
          var t = li(e, ti);
          return Mi(t) ? Ii : t.substr(7).match(G).map(Ae);
        },
        Bi = function (e, t) {
          var n,
            i,
            r,
            s,
            a = e._gsap || de(e),
            o = e.style,
            l = Ti(e);
          return a.svg && e.getAttribute("transform")
            ? "1,0,0,1,0,0" ===
              (l = [
                (r = e.transform.baseVal.consolidate().matrix).a,
                r.b,
                r.c,
                r.d,
                r.e,
                r.f,
              ]).join(",")
              ? Ii
              : l
            : (l !== Ii ||
                e.offsetParent ||
                e === Tn ||
                a.svg ||
                ((r = o.display),
                (o.display = "block"),
                ((n = e.parentNode) && e.offsetParent) ||
                  ((s = 1), (i = e.nextElementSibling), Tn.appendChild(e)),
                (l = Ti(e)),
                r ? (o.display = r) : gi(e, "display"),
                s &&
                  (i
                    ? n.insertBefore(e, i)
                    : n
                    ? n.appendChild(e)
                    : Tn.removeChild(e))),
              t && l.length > 6 ? [l[0], l[1], l[4], l[5], l[12], l[13]] : l);
        },
        Ri = function (e, t, n, i, r, s) {
          var a,
            o,
            l,
            c = e._gsap,
            u = r || Bi(e, !0),
            h = c.xOrigin || 0,
            d = c.yOrigin || 0,
            p = c.xOffset || 0,
            f = c.yOffset || 0,
            A = u[0],
            g = u[1],
            m = u[2],
            v = u[3],
            y = u[4],
            x = u[5],
            _ = t.split(" "),
            b = parseFloat(_[0]) || 0,
            E = parseFloat(_[1]) || 0;
          n
            ? u !== Ii &&
              (o = A * v - g * m) &&
              ((l = b * (-g / o) + E * (A / o) - (A * x - g * y) / o),
              (b = b * (v / o) + E * (-m / o) + (m * x - v * y) / o),
              (E = l))
            : ((b =
                (a = fi(e)).x + (~_[0].indexOf("%") ? (b / 100) * a.width : b)),
              (E =
                a.y +
                (~(_[1] || _[0]).indexOf("%") ? (E / 100) * a.height : E))),
            i || (!1 !== i && c.smooth)
              ? ((y = b - h),
                (x = E - d),
                (c.xOffset = p + (y * A + x * m) - y),
                (c.yOffset = f + (y * g + x * v) - x))
              : (c.xOffset = c.yOffset = 0),
            (c.xOrigin = b),
            (c.yOrigin = E),
            (c.smooth = !!i),
            (c.origin = t),
            (c.originIsAbsolute = !!n),
            (e.style[ni] = "0px 0px"),
            s &&
              (mi(s, c, "xOrigin", h, b),
              mi(s, c, "yOrigin", d, E),
              mi(s, c, "xOffset", p, c.xOffset),
              mi(s, c, "yOffset", f, c.yOffset)),
            e.setAttribute("data-svg-origin", b + " " + E);
        },
        Di = function (e, t) {
          var n = e._gsap || new Qt(e);
          if ("x" in n && !t && !n.uncache) return n;
          var i,
            r,
            s,
            a,
            o,
            l,
            c,
            u,
            h,
            d,
            p,
            f,
            A,
            g,
            m,
            v,
            y,
            _,
            b,
            E,
            w,
            C,
            I,
            S,
            M,
            T,
            B,
            R,
            D,
            P,
            L,
            U,
            F = e.style,
            N = n.scaleX < 0,
            O = "px",
            Q = "deg",
            k = getComputedStyle(e),
            G = li(e, ni) || "0";
          return (
            (i = r = s = l = c = u = h = d = p = 0),
            (a = o = 1),
            (n.svg = !(!e.getCTM || !Ai(e))),
            k.translate &&
              (("none" === k.translate &&
                "none" === k.scale &&
                "none" === k.rotate) ||
                (F[ti] =
                  ("none" !== k.translate
                    ? "translate3d(" +
                      (k.translate + " 0 0").split(" ").slice(0, 3).join(", ") +
                      ") "
                    : "") +
                  ("none" !== k.rotate ? "rotate(" + k.rotate + ") " : "") +
                  ("none" !== k.scale
                    ? "scale(" + k.scale.split(" ").join(",") + ") "
                    : "") +
                  ("none" !== k[ti] ? k[ti] : "")),
              (F.scale = F.rotate = F.translate = "none")),
            (g = Bi(e, n.svg)),
            n.svg &&
              (n.uncache
                ? ((M = e.getBBox()),
                  (G = n.xOrigin - M.x + "px " + (n.yOrigin - M.y) + "px"),
                  (S = ""))
                : (S = !t && e.getAttribute("data-svg-origin")),
              Ri(e, S || G, !!S || n.originIsAbsolute, !1 !== n.smooth, g)),
            (f = n.xOrigin || 0),
            (A = n.yOrigin || 0),
            g !== Ii &&
              ((_ = g[0]),
              (b = g[1]),
              (E = g[2]),
              (w = g[3]),
              (i = C = g[4]),
              (r = I = g[5]),
              6 === g.length
                ? ((a = Math.sqrt(_ * _ + b * b)),
                  (o = Math.sqrt(w * w + E * E)),
                  (l = _ || b ? On(b, _) * Fn : 0),
                  (h = E || w ? On(E, w) * Fn + l : 0) &&
                    (o *= Math.abs(Math.cos(h * Nn))),
                  n.svg &&
                    ((i -= f - (f * _ + A * E)), (r -= A - (f * b + A * w))))
                : ((U = g[6]),
                  (P = g[7]),
                  (B = g[8]),
                  (R = g[9]),
                  (D = g[10]),
                  (L = g[11]),
                  (i = g[12]),
                  (r = g[13]),
                  (s = g[14]),
                  (c = (m = On(U, D)) * Fn),
                  m &&
                    ((S = C * (v = Math.cos(-m)) + B * (y = Math.sin(-m))),
                    (M = I * v + R * y),
                    (T = U * v + D * y),
                    (B = C * -y + B * v),
                    (R = I * -y + R * v),
                    (D = U * -y + D * v),
                    (L = P * -y + L * v),
                    (C = S),
                    (I = M),
                    (U = T)),
                  (u = (m = On(-E, D)) * Fn),
                  m &&
                    ((v = Math.cos(-m)),
                    (L = w * (y = Math.sin(-m)) + L * v),
                    (_ = S = _ * v - B * y),
                    (b = M = b * v - R * y),
                    (E = T = E * v - D * y)),
                  (l = (m = On(b, _)) * Fn),
                  m &&
                    ((S = _ * (v = Math.cos(m)) + b * (y = Math.sin(m))),
                    (M = C * v + I * y),
                    (b = b * v - _ * y),
                    (I = I * v - C * y),
                    (_ = S),
                    (C = M)),
                  c &&
                    Math.abs(c) + Math.abs(l) > 359.9 &&
                    ((c = l = 0), (u = 180 - u)),
                  (a = Ae(Math.sqrt(_ * _ + b * b + E * E))),
                  (o = Ae(Math.sqrt(I * I + U * U))),
                  (m = On(C, I)),
                  (h = Math.abs(m) > 2e-4 ? m * Fn : 0),
                  (p = L ? 1 / (L < 0 ? -L : L) : 0)),
              n.svg &&
                ((S = e.getAttribute("transform")),
                (n.forceCSS =
                  e.setAttribute("transform", "") || !Mi(li(e, ti))),
                S && e.setAttribute("transform", S))),
            Math.abs(h) > 90 &&
              Math.abs(h) < 270 &&
              (N
                ? ((a *= -1),
                  (h += l <= 0 ? 180 : -180),
                  (l += l <= 0 ? 180 : -180))
                : ((o *= -1), (h += h <= 0 ? 180 : -180))),
            (t = t || n.uncache),
            (n.x =
              i -
              ((n.xPercent =
                i &&
                ((!t && n.xPercent) ||
                  (Math.round(e.offsetWidth / 2) === Math.round(-i) ? -50 : 0)))
                ? (e.offsetWidth * n.xPercent) / 100
                : 0) +
              O),
            (n.y =
              r -
              ((n.yPercent =
                r &&
                ((!t && n.yPercent) ||
                  (Math.round(e.offsetHeight / 2) === Math.round(-r)
                    ? -50
                    : 0)))
                ? (e.offsetHeight * n.yPercent) / 100
                : 0) +
              O),
            (n.z = s + O),
            (n.scaleX = Ae(a)),
            (n.scaleY = Ae(o)),
            (n.rotation = Ae(l) + Q),
            (n.rotationX = Ae(c) + Q),
            (n.rotationY = Ae(u) + Q),
            (n.skewX = h + Q),
            (n.skewY = d + Q),
            (n.transformPerspective = p + O),
            (n.zOrigin =
              parseFloat(G.split(" ")[2]) || (!t && n.zOrigin) || 0) &&
              (F[ni] = Pi(G)),
            (n.xOffset = n.yOffset = 0),
            (n.force3D = x.force3D),
            (n.renderTransform = n.svg ? ki : Ln ? Qi : Ui),
            (n.uncache = 0),
            n
          );
        },
        Pi = function (e) {
          return (e = e.split(" "))[0] + " " + e[1];
        },
        Li = function (e, t, n) {
          var i = Ze(t);
          return Ae(parseFloat(t) + parseFloat(xi(e, "x", n + "px", i))) + i;
        },
        Ui = function (e, t) {
          (t.z = "0px"),
            (t.rotationY = t.rotationX = "0deg"),
            (t.force3D = 0),
            Qi(e, t);
        },
        Fi = "0deg",
        Ni = "0px",
        Oi = ") ",
        Qi = function (e, t) {
          var n = t || this,
            i = n.xPercent,
            r = n.yPercent,
            s = n.x,
            a = n.y,
            o = n.z,
            l = n.rotation,
            c = n.rotationY,
            u = n.rotationX,
            h = n.skewX,
            d = n.skewY,
            p = n.scaleX,
            f = n.scaleY,
            A = n.transformPerspective,
            g = n.force3D,
            m = n.target,
            v = n.zOrigin,
            y = "",
            x = ("auto" === g && e && 1 !== e) || !0 === g;
          if (v && (u !== Fi || c !== Fi)) {
            var _,
              b = parseFloat(c) * Nn,
              E = Math.sin(b),
              w = Math.cos(b);
            (b = parseFloat(u) * Nn),
              (_ = Math.cos(b)),
              (s = Li(m, s, E * _ * -v)),
              (a = Li(m, a, -Math.sin(b) * -v)),
              (o = Li(m, o, w * _ * -v + v));
          }
          A !== Ni && (y += "perspective(" + A + Oi),
            (i || r) && (y += "translate(" + i + "%, " + r + "%) "),
            (x || s !== Ni || a !== Ni || o !== Ni) &&
              (y +=
                o !== Ni || x
                  ? "translate3d(" + s + ", " + a + ", " + o + ") "
                  : "translate(" + s + ", " + a + Oi),
            l !== Fi && (y += "rotate(" + l + Oi),
            c !== Fi && (y += "rotateY(" + c + Oi),
            u !== Fi && (y += "rotateX(" + u + Oi),
            (h === Fi && d === Fi) || (y += "skew(" + h + ", " + d + Oi),
            (1 === p && 1 === f) || (y += "scale(" + p + ", " + f + Oi),
            (m.style[ti] = y || "translate(0, 0)");
        },
        ki = function (e, t) {
          var n,
            i,
            r,
            s,
            a,
            o = t || this,
            l = o.xPercent,
            c = o.yPercent,
            u = o.x,
            h = o.y,
            d = o.rotation,
            p = o.skewX,
            f = o.skewY,
            A = o.scaleX,
            g = o.scaleY,
            m = o.target,
            v = o.xOrigin,
            y = o.yOrigin,
            x = o.xOffset,
            _ = o.yOffset,
            b = o.forceCSS,
            E = parseFloat(u),
            w = parseFloat(h);
          (d = parseFloat(d)),
            (p = parseFloat(p)),
            (f = parseFloat(f)) && ((p += f = parseFloat(f)), (d += f)),
            d || p
              ? ((d *= Nn),
                (p *= Nn),
                (n = Math.cos(d) * A),
                (i = Math.sin(d) * A),
                (r = Math.sin(d - p) * -g),
                (s = Math.cos(d - p) * g),
                p &&
                  ((f *= Nn),
                  (a = Math.tan(p - f)),
                  (r *= a = Math.sqrt(1 + a * a)),
                  (s *= a),
                  f &&
                    ((a = Math.tan(f)),
                    (n *= a = Math.sqrt(1 + a * a)),
                    (i *= a))),
                (n = Ae(n)),
                (i = Ae(i)),
                (r = Ae(r)),
                (s = Ae(s)))
              : ((n = A), (s = g), (i = r = 0)),
            ((E && !~(u + "").indexOf("px")) ||
              (w && !~(h + "").indexOf("px"))) &&
              ((E = xi(m, "x", u, "px")), (w = xi(m, "y", h, "px"))),
            (v || y || x || _) &&
              ((E = Ae(E + v - (v * n + y * r) + x)),
              (w = Ae(w + y - (v * i + y * s) + _))),
            (l || c) &&
              ((a = m.getBBox()),
              (E = Ae(E + (l / 100) * a.width)),
              (w = Ae(w + (c / 100) * a.height))),
            (a =
              "matrix(" +
              n +
              "," +
              i +
              "," +
              r +
              "," +
              s +
              "," +
              E +
              "," +
              w +
              ")"),
            m.setAttribute("transform", a),
            b && (m.style[ti] = a);
        },
        Gi = function (e, t, n, i, r) {
          var s,
            a,
            o = 360,
            l = B(r),
            c = parseFloat(r) * (l && ~r.indexOf("rad") ? Fn : 1) - i,
            u = i + c + "deg";
          return (
            l &&
              ("short" === (s = r.split("_")[1]) &&
                (c %= o) !== c % 180 &&
                (c += c < 0 ? o : -360),
              "cw" === s && c < 0
                ? (c = ((c + 36e9) % o) - ~~(c / o) * o)
                : "ccw" === s &&
                  c > 0 &&
                  (c = ((c - 36e9) % o) - ~~(c / o) * o)),
            (e._pt = a = new pn(e._pt, t, n, i, c, Vn)),
            (a.e = u),
            (a.u = "deg"),
            e._props.push(n),
            a
          );
        },
        Hi = function (e, t) {
          for (var n in t) e[n] = t[n];
          return e;
        },
        zi = function (e, t, n) {
          var i,
            r,
            s,
            a,
            o,
            l,
            c,
            u = Hi({}, n._gsap),
            h = n.style;
          for (r in (u.svg
            ? ((s = n.getAttribute("transform")),
              n.setAttribute("transform", ""),
              (h[ti] = t),
              (i = Di(n, 1)),
              gi(n, ti),
              n.setAttribute("transform", s))
            : ((s = getComputedStyle(n)[ti]),
              (h[ti] = t),
              (i = Di(n, 1)),
              (h[ti] = s)),
          Un))
            (s = u[r]) !== (a = i[r]) &&
              "perspective,force3D,transformOrigin,svgOrigin".indexOf(r) < 0 &&
              ((o = Ze(s) !== (c = Ze(a)) ? xi(n, r, s, c) : parseFloat(s)),
              (l = parseFloat(a)),
              (e._pt = new pn(e._pt, i, r, o, l - o, zn)),
              (e._pt.u = c || 0),
              e._props.push(r));
          Hi(i, u);
        };
      fe("padding,margin,Width,Radius", function (e, t) {
        var n = "Top",
          i = "Right",
          r = "Bottom",
          s = "Left",
          a = (t < 3 ? [n, i, r, s] : [n + s, n + i, r + i, r + s]).map(
            function (n) {
              return t < 2 ? e + n : "border" + n + e;
            }
          );
        Ci[t > 1 ? "border" + e : e] = function (e, t, n, i, r) {
          var s, o;
          if (arguments.length < 4)
            return (
              (s = a.map(function (t) {
                return _i(e, t, n);
              })),
              5 === (o = s.join(" ")).split(s[0]).length ? s[0] : o
            );
          (s = (i + "").split(" ")),
            (o = {}),
            a.forEach(function (e, t) {
              return (o[e] = s[t] = s[t] || s[((t - 1) / 2) | 0]);
            }),
            e.init(t, o, r);
        };
      });
      var Vi,
        Wi,
        ji,
        qi = {
          name: "css",
          register: hi,
          targetTest: function (e) {
            return e.style && e.nodeType;
          },
          init: function (e, t, n, i, r) {
            var s,
              a,
              o,
              l,
              c,
              u,
              h,
              d,
              p,
              f,
              A,
              g,
              m,
              v,
              y,
              _,
              b,
              E,
              w,
              C,
              I = this._props,
              S = e.style,
              M = n.vars.startAt;
            for (h in (Bn || hi(),
            (this.styles = this.styles || ai(e)),
            (_ = this.styles.props),
            (this.tween = n),
            t))
              if (
                "autoRound" !== h &&
                ((a = t[h]), !ae[h] || !jt(h, t, n, i, e, r))
              )
                if (
                  ((c = typeof a),
                  (u = Ci[h]),
                  "function" === c && (c = typeof (a = a.call(n, i, e, r))),
                  "string" === c && ~a.indexOf("random(") && (a = ut(a)),
                  u)
                )
                  u(this, e, h, a, n) && (y = 1);
                else if ("--" === h.substr(0, 2))
                  (s = (getComputedStyle(e).getPropertyValue(h) + "").trim()),
                    (a += ""),
                    (Et.lastIndex = 0),
                    Et.test(s) || ((d = Ze(s)), (p = Ze(a))),
                    p ? d !== p && (s = xi(e, h, s, p) + p) : d && (a += d),
                    this.add(S, "setProperty", s, a, i, r, 0, 0, h),
                    I.push(h),
                    _.push(h, 0, S[h]);
                else if ("undefined" !== c) {
                  if (
                    (M && h in M
                      ? ((s =
                          "function" == typeof M[h]
                            ? M[h].call(n, i, e, r)
                            : M[h]),
                        B(s) && ~s.indexOf("random(") && (s = ut(s)),
                        Ze(s + "") ||
                          "auto" === s ||
                          (s += x.units[h] || Ze(_i(e, h)) || ""),
                        "=" === (s + "").charAt(1) && (s = _i(e, h)))
                      : (s = _i(e, h)),
                    (l = parseFloat(s)),
                    (f =
                      "string" === c &&
                      "=" === a.charAt(1) &&
                      a.substr(0, 2)) && (a = a.substr(2)),
                    (o = parseFloat(a)),
                    h in Hn &&
                      ("autoAlpha" === h &&
                        (1 === l &&
                          "hidden" === _i(e, "visibility") &&
                          o &&
                          (l = 0),
                        _.push("visibility", 0, S.visibility),
                        mi(
                          this,
                          S,
                          "visibility",
                          l ? "inherit" : "hidden",
                          o ? "inherit" : "hidden",
                          !o
                        )),
                      "scale" !== h &&
                        "transform" !== h &&
                        ~(h = Hn[h]).indexOf(",") &&
                        (h = h.split(",")[0])),
                    (A = h in Un))
                  )
                    if (
                      (this.styles.save(h),
                      g ||
                        (((m = e._gsap).renderTransform && !t.parseTransform) ||
                          Di(e, t.parseTransform),
                        (v = !1 !== t.smoothOrigin && m.smooth),
                        ((g = this._pt =
                          new pn(
                            this._pt,
                            S,
                            ti,
                            0,
                            1,
                            m.renderTransform,
                            m,
                            0,
                            -1
                          )).dep = 1)),
                      "scale" === h)
                    )
                      (this._pt = new pn(
                        this._pt,
                        m,
                        "scaleY",
                        m.scaleY,
                        (f ? me(m.scaleY, f + o) : o) - m.scaleY || 0,
                        zn
                      )),
                        (this._pt.u = 0),
                        I.push("scaleY", h),
                        (h += "X");
                    else {
                      if ("transformOrigin" === h) {
                        _.push(ni, 0, S[ni]),
                          (E = void 0),
                          (w = void 0),
                          (C = void 0),
                          (E = (b = a).split(" ")),
                          (w = E[0]),
                          (C = E[1] || "50%"),
                          ("top" !== w &&
                            "bottom" !== w &&
                            "left" !== C &&
                            "right" !== C) ||
                            ((b = w), (w = C), (C = b)),
                          (E[0] = Ei[w] || w),
                          (E[1] = Ei[C] || C),
                          (a = E.join(" ")),
                          m.svg
                            ? Ri(e, a, 0, v, 0, this)
                            : ((p = parseFloat(a.split(" ")[2]) || 0) !==
                                m.zOrigin &&
                                mi(this, m, "zOrigin", m.zOrigin, p),
                              mi(this, S, h, Pi(s), Pi(a)));
                        continue;
                      }
                      if ("svgOrigin" === h) {
                        Ri(e, a, 1, v, 0, this);
                        continue;
                      }
                      if (h in Si) {
                        Gi(this, m, h, l, f ? me(l, f + a) : a);
                        continue;
                      }
                      if ("smoothOrigin" === h) {
                        mi(this, m, "smooth", m.smooth, a);
                        continue;
                      }
                      if ("force3D" === h) {
                        m[h] = a;
                        continue;
                      }
                      if ("transform" === h) {
                        zi(this, a, e);
                        continue;
                      }
                    }
                  else h in S || (h = ui(h) || h);
                  if (
                    A ||
                    ((o || 0 === o) && (l || 0 === l) && !Gn.test(a) && h in S)
                  )
                    o || (o = 0),
                      (d = (s + "").substr((l + "").length)) !==
                        (p = Ze(a) || (h in x.units ? x.units[h] : d)) &&
                        (l = xi(e, h, s, p)),
                      (this._pt = new pn(
                        this._pt,
                        A ? m : S,
                        h,
                        l,
                        (f ? me(l, f + o) : o) - l,
                        A ||
                        ("px" !== p && "zIndex" !== h) ||
                        !1 === t.autoRound
                          ? zn
                          : jn
                      )),
                      (this._pt.u = p || 0),
                      d !== p &&
                        "%" !== p &&
                        ((this._pt.b = s), (this._pt.r = Wn));
                  else if (h in S) bi.call(this, e, h, s, f ? f + a : a);
                  else if (h in e)
                    this.add(e, h, s || e[h], f ? f + a : a, i, r);
                  else if ("parseTransform" !== h) {
                    K(h, a);
                    continue;
                  }
                  A || (h in S ? _.push(h, 0, S[h]) : _.push(h, 1, s || e[h])),
                    I.push(h);
                }
            y && dn(this);
          },
          render: function (e, t) {
            if (t.tween._time || !Pn())
              for (var n = t._pt; n; ) n.r(e, n.d), (n = n._next);
            else t.styles.revert();
          },
          get: _i,
          aliases: Hn,
          getSetter: function (e, t, n) {
            var i = Hn[t];
            return (
              i && i.indexOf(",") < 0 && (t = i),
              t in Un && t !== ni && (e._gsap.x || _i(e, "x"))
                ? n && Dn === n
                  ? "scale" === t
                    ? Zn
                    : Jn
                  : (Dn = n || {}) && ("scale" === t ? $n : ei)
                : e.style && !P(e.style[t])
                ? Xn
                : ~t.indexOf("-")
                ? Kn
                : rn(e, t)
            );
          },
          core: { _removeProperty: gi, _getMatrix: Bi },
        };
      (In.utils.checkPrefix = ui),
        (In.core.getStyleSaver = ai),
        (ji = fe(
          (Vi = "x,y,z,scale,scaleX,scaleY,xPercent,yPercent") +
            "," +
            (Wi = "rotation,rotationX,rotationY,skewX,skewY") +
            ",transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective",
          function (e) {
            Un[e] = 1;
          }
        )),
        fe(Wi, function (e) {
          (x.units[e] = "deg"), (Si[e] = 1);
        }),
        (Hn[ji[13]] = Vi + "," + Wi),
        fe(
          "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY",
          function (e) {
            var t = e.split(":");
            Hn[t[1]] = ji[t[0]];
          }
        ),
        fe(
          "x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective",
          function (e) {
            x.units[e] = "px";
          }
        ),
        In.registerPlugin(qi);
      var Yi = In.registerPlugin(qi) || In;
      Yi.core.Tween;
    },
    8683: (e, t, n) => {
      var i;
      !(function () {
        "use strict";
        var r = function () {
          this.init();
        };
        r.prototype = {
          init: function () {
            var e = this || s;
            return (
              (e._counter = 1e3),
              (e._html5AudioPool = []),
              (e.html5PoolSize = 10),
              (e._codecs = {}),
              (e._howls = []),
              (e._muted = !1),
              (e._volume = 1),
              (e._canPlayEvent = "canplaythrough"),
              (e._navigator =
                "undefined" != typeof window && window.navigator
                  ? window.navigator
                  : null),
              (e.masterGain = null),
              (e.noAudio = !1),
              (e.usingWebAudio = !0),
              (e.autoSuspend = !0),
              (e.ctx = null),
              (e.autoUnlock = !0),
              e._setup(),
              e
            );
          },
          volume: function (e) {
            var t = this || s;
            if (
              ((e = parseFloat(e)),
              t.ctx || p(),
              void 0 !== e && e >= 0 && e <= 1)
            ) {
              if (((t._volume = e), t._muted)) return t;
              t.usingWebAudio &&
                t.masterGain.gain.setValueAtTime(e, s.ctx.currentTime);
              for (var n = 0; n < t._howls.length; n++)
                if (!t._howls[n]._webAudio)
                  for (
                    var i = t._howls[n]._getSoundIds(), r = 0;
                    r < i.length;
                    r++
                  ) {
                    var a = t._howls[n]._soundById(i[r]);
                    a && a._node && (a._node.volume = a._volume * e);
                  }
              return t;
            }
            return t._volume;
          },
          mute: function (e) {
            var t = this || s;
            t.ctx || p(),
              (t._muted = e),
              t.usingWebAudio &&
                t.masterGain.gain.setValueAtTime(
                  e ? 0 : t._volume,
                  s.ctx.currentTime
                );
            for (var n = 0; n < t._howls.length; n++)
              if (!t._howls[n]._webAudio)
                for (
                  var i = t._howls[n]._getSoundIds(), r = 0;
                  r < i.length;
                  r++
                ) {
                  var a = t._howls[n]._soundById(i[r]);
                  a && a._node && (a._node.muted = !!e || a._muted);
                }
            return t;
          },
          stop: function () {
            for (var e = this || s, t = 0; t < e._howls.length; t++)
              e._howls[t].stop();
            return e;
          },
          unload: function () {
            for (var e = this || s, t = e._howls.length - 1; t >= 0; t--)
              e._howls[t].unload();
            return (
              e.usingWebAudio &&
                e.ctx &&
                void 0 !== e.ctx.close &&
                (e.ctx.close(), (e.ctx = null), p()),
              e
            );
          },
          codecs: function (e) {
            return (this || s)._codecs[e.replace(/^x-/, "")];
          },
          _setup: function () {
            var e = this || s;
            if (
              ((e.state = (e.ctx && e.ctx.state) || "suspended"),
              e._autoSuspend(),
              !e.usingWebAudio)
            )
              if ("undefined" != typeof Audio)
                try {
                  void 0 === new Audio().oncanplaythrough &&
                    (e._canPlayEvent = "canplay");
                } catch (t) {
                  e.noAudio = !0;
                }
              else e.noAudio = !0;
            try {
              new Audio().muted && (e.noAudio = !0);
            } catch (e) {}
            return e.noAudio || e._setupCodecs(), e;
          },
          _setupCodecs: function () {
            var e = this || s,
              t = null;
            try {
              t = "undefined" != typeof Audio ? new Audio() : null;
            } catch (t) {
              return e;
            }
            if (!t || "function" != typeof t.canPlayType) return e;
            var n = t.canPlayType("audio/mpeg;").replace(/^no$/, ""),
              i = e._navigator ? e._navigator.userAgent : "",
              r = i.match(/OPR\/(\d+)/g),
              a = r && parseInt(r[0].split("/")[1], 10) < 33,
              o = -1 !== i.indexOf("Safari") && -1 === i.indexOf("Chrome"),
              l = i.match(/Version\/(.*?) /),
              c = o && l && parseInt(l[1], 10) < 15;
            return (
              (e._codecs = {
                mp3: !(
                  a ||
                  (!n && !t.canPlayType("audio/mp3;").replace(/^no$/, ""))
                ),
                mpeg: !!n,
                opus: !!t
                  .canPlayType('audio/ogg; codecs="opus"')
                  .replace(/^no$/, ""),
                ogg: !!t
                  .canPlayType('audio/ogg; codecs="vorbis"')
                  .replace(/^no$/, ""),
                oga: !!t
                  .canPlayType('audio/ogg; codecs="vorbis"')
                  .replace(/^no$/, ""),
                wav: !!(
                  t.canPlayType('audio/wav; codecs="1"') ||
                  t.canPlayType("audio/wav")
                ).replace(/^no$/, ""),
                aac: !!t.canPlayType("audio/aac;").replace(/^no$/, ""),
                caf: !!t.canPlayType("audio/x-caf;").replace(/^no$/, ""),
                m4a: !!(
                  t.canPlayType("audio/x-m4a;") ||
                  t.canPlayType("audio/m4a;") ||
                  t.canPlayType("audio/aac;")
                ).replace(/^no$/, ""),
                m4b: !!(
                  t.canPlayType("audio/x-m4b;") ||
                  t.canPlayType("audio/m4b;") ||
                  t.canPlayType("audio/aac;")
                ).replace(/^no$/, ""),
                mp4: !!(
                  t.canPlayType("audio/x-mp4;") ||
                  t.canPlayType("audio/mp4;") ||
                  t.canPlayType("audio/aac;")
                ).replace(/^no$/, ""),
                weba: !(
                  c ||
                  !t
                    .canPlayType('audio/webm; codecs="vorbis"')
                    .replace(/^no$/, "")
                ),
                webm: !(
                  c ||
                  !t
                    .canPlayType('audio/webm; codecs="vorbis"')
                    .replace(/^no$/, "")
                ),
                dolby: !!t
                  .canPlayType('audio/mp4; codecs="ec-3"')
                  .replace(/^no$/, ""),
                flac: !!(
                  t.canPlayType("audio/x-flac;") || t.canPlayType("audio/flac;")
                ).replace(/^no$/, ""),
              }),
              e
            );
          },
          _unlockAudio: function () {
            var e = this || s;
            if (!e._audioUnlocked && e.ctx) {
              (e._audioUnlocked = !1),
                (e.autoUnlock = !1),
                e._mobileUnloaded ||
                  44100 === e.ctx.sampleRate ||
                  ((e._mobileUnloaded = !0), e.unload()),
                (e._scratchBuffer = e.ctx.createBuffer(1, 1, 22050));
              var t = function (n) {
                for (; e._html5AudioPool.length < e.html5PoolSize; )
                  try {
                    var i = new Audio();
                    (i._unlocked = !0), e._releaseHtml5Audio(i);
                  } catch (n) {
                    e.noAudio = !0;
                    break;
                  }
                for (var r = 0; r < e._howls.length; r++)
                  if (!e._howls[r]._webAudio)
                    for (
                      var s = e._howls[r]._getSoundIds(), a = 0;
                      a < s.length;
                      a++
                    ) {
                      var o = e._howls[r]._soundById(s[a]);
                      o &&
                        o._node &&
                        !o._node._unlocked &&
                        ((o._node._unlocked = !0), o._node.load());
                    }
                e._autoResume();
                var l = e.ctx.createBufferSource();
                (l.buffer = e._scratchBuffer),
                  l.connect(e.ctx.destination),
                  void 0 === l.start ? l.noteOn(0) : l.start(0),
                  "function" == typeof e.ctx.resume && e.ctx.resume(),
                  (l.onended = function () {
                    l.disconnect(0),
                      (e._audioUnlocked = !0),
                      document.removeEventListener("touchstart", t, !0),
                      document.removeEventListener("touchend", t, !0),
                      document.removeEventListener("click", t, !0),
                      document.removeEventListener("keydown", t, !0);
                    for (var n = 0; n < e._howls.length; n++)
                      e._howls[n]._emit("unlock");
                  });
              };
              return (
                document.addEventListener("touchstart", t, !0),
                document.addEventListener("touchend", t, !0),
                document.addEventListener("click", t, !0),
                document.addEventListener("keydown", t, !0),
                e
              );
            }
          },
          _obtainHtml5Audio: function () {
            var e = this || s;
            if (e._html5AudioPool.length) return e._html5AudioPool.pop();
            var t = new Audio().play();
            return (
              t &&
                "undefined" != typeof Promise &&
                (t instanceof Promise || "function" == typeof t.then) &&
                t.catch(function () {
                  console.warn(
                    "HTML5 Audio pool exhausted, returning potentially locked audio object."
                  );
                }),
              new Audio()
            );
          },
          _releaseHtml5Audio: function (e) {
            var t = this || s;
            return e._unlocked && t._html5AudioPool.push(e), t;
          },
          _autoSuspend: function () {
            var e = this;
            if (
              e.autoSuspend &&
              e.ctx &&
              void 0 !== e.ctx.suspend &&
              s.usingWebAudio
            ) {
              for (var t = 0; t < e._howls.length; t++)
                if (e._howls[t]._webAudio)
                  for (var n = 0; n < e._howls[t]._sounds.length; n++)
                    if (!e._howls[t]._sounds[n]._paused) return e;
              return (
                e._suspendTimer && clearTimeout(e._suspendTimer),
                (e._suspendTimer = setTimeout(function () {
                  if (e.autoSuspend) {
                    (e._suspendTimer = null), (e.state = "suspending");
                    var t = function () {
                      (e.state = "suspended"),
                        e._resumeAfterSuspend &&
                          (delete e._resumeAfterSuspend, e._autoResume());
                    };
                    e.ctx.suspend().then(t, t);
                  }
                }, 3e4)),
                e
              );
            }
          },
          _autoResume: function () {
            var e = this;
            if (e.ctx && void 0 !== e.ctx.resume && s.usingWebAudio)
              return (
                "running" === e.state &&
                "interrupted" !== e.ctx.state &&
                e._suspendTimer
                  ? (clearTimeout(e._suspendTimer), (e._suspendTimer = null))
                  : "suspended" === e.state ||
                    ("running" === e.state && "interrupted" === e.ctx.state)
                  ? (e.ctx.resume().then(function () {
                      e.state = "running";
                      for (var t = 0; t < e._howls.length; t++)
                        e._howls[t]._emit("resume");
                    }),
                    e._suspendTimer &&
                      (clearTimeout(e._suspendTimer), (e._suspendTimer = null)))
                  : "suspending" === e.state && (e._resumeAfterSuspend = !0),
                e
              );
          },
        };
        var s = new r(),
          a = function (e) {
            e.src && 0 !== e.src.length
              ? this.init(e)
              : console.error(
                  "An array of source files must be passed with any new Howl."
                );
          };
        a.prototype = {
          init: function (e) {
            var t = this;
            return (
              s.ctx || p(),
              (t._autoplay = e.autoplay || !1),
              (t._format = "string" != typeof e.format ? e.format : [e.format]),
              (t._html5 = e.html5 || !1),
              (t._muted = e.mute || !1),
              (t._loop = e.loop || !1),
              (t._pool = e.pool || 5),
              (t._preload =
                ("boolean" != typeof e.preload && "metadata" !== e.preload) ||
                e.preload),
              (t._rate = e.rate || 1),
              (t._sprite = e.sprite || {}),
              (t._src = "string" != typeof e.src ? e.src : [e.src]),
              (t._volume = void 0 !== e.volume ? e.volume : 1),
              (t._xhr = {
                method: e.xhr && e.xhr.method ? e.xhr.method : "GET",
                headers: e.xhr && e.xhr.headers ? e.xhr.headers : null,
                withCredentials:
                  !(!e.xhr || !e.xhr.withCredentials) && e.xhr.withCredentials,
              }),
              (t._duration = 0),
              (t._state = "unloaded"),
              (t._sounds = []),
              (t._endTimers = {}),
              (t._queue = []),
              (t._playLock = !1),
              (t._onend = e.onend ? [{ fn: e.onend }] : []),
              (t._onfade = e.onfade ? [{ fn: e.onfade }] : []),
              (t._onload = e.onload ? [{ fn: e.onload }] : []),
              (t._onloaderror = e.onloaderror ? [{ fn: e.onloaderror }] : []),
              (t._onplayerror = e.onplayerror ? [{ fn: e.onplayerror }] : []),
              (t._onpause = e.onpause ? [{ fn: e.onpause }] : []),
              (t._onplay = e.onplay ? [{ fn: e.onplay }] : []),
              (t._onstop = e.onstop ? [{ fn: e.onstop }] : []),
              (t._onmute = e.onmute ? [{ fn: e.onmute }] : []),
              (t._onvolume = e.onvolume ? [{ fn: e.onvolume }] : []),
              (t._onrate = e.onrate ? [{ fn: e.onrate }] : []),
              (t._onseek = e.onseek ? [{ fn: e.onseek }] : []),
              (t._onunlock = e.onunlock ? [{ fn: e.onunlock }] : []),
              (t._onresume = []),
              (t._webAudio = s.usingWebAudio && !t._html5),
              void 0 !== s.ctx && s.ctx && s.autoUnlock && s._unlockAudio(),
              s._howls.push(t),
              t._autoplay &&
                t._queue.push({
                  event: "play",
                  action: function () {
                    t.play();
                  },
                }),
              t._preload && "none" !== t._preload && t.load(),
              t
            );
          },
          load: function () {
            var e = this,
              t = null;
            if (s.noAudio) e._emit("loaderror", null, "No audio support.");
            else {
              "string" == typeof e._src && (e._src = [e._src]);
              for (var n = 0; n < e._src.length; n++) {
                var i, r;
                if (e._format && e._format[n]) i = e._format[n];
                else {
                  if ("string" != typeof (r = e._src[n])) {
                    e._emit(
                      "loaderror",
                      null,
                      "Non-string found in selected audio sources - ignoring."
                    );
                    continue;
                  }
                  (i = /^data:audio\/([^;,]+);/i.exec(r)) ||
                    (i = /\.([^.]+)$/.exec(r.split("?", 1)[0])),
                    i && (i = i[1].toLowerCase());
                }
                if (
                  (i ||
                    console.warn(
                      'No file extension was found. Consider using the "format" property or specify an extension.'
                    ),
                  i && s.codecs(i))
                ) {
                  t = e._src[n];
                  break;
                }
              }
              if (t)
                return (
                  (e._src = t),
                  (e._state = "loading"),
                  "https:" === window.location.protocol &&
                    "http:" === t.slice(0, 5) &&
                    ((e._html5 = !0), (e._webAudio = !1)),
                  new o(e),
                  e._webAudio && c(e),
                  e
                );
              e._emit(
                "loaderror",
                null,
                "No codec support for selected audio sources."
              );
            }
          },
          play: function (e, t) {
            var n = this,
              i = null;
            if ("number" == typeof e) (i = e), (e = null);
            else {
              if (
                "string" == typeof e &&
                "loaded" === n._state &&
                !n._sprite[e]
              )
                return null;
              if (void 0 === e && ((e = "__default"), !n._playLock)) {
                for (var r = 0, a = 0; a < n._sounds.length; a++)
                  n._sounds[a]._paused &&
                    !n._sounds[a]._ended &&
                    (r++, (i = n._sounds[a]._id));
                1 === r ? (e = null) : (i = null);
              }
            }
            var o = i ? n._soundById(i) : n._inactiveSound();
            if (!o) return null;
            if (
              (i && !e && (e = o._sprite || "__default"), "loaded" !== n._state)
            ) {
              (o._sprite = e), (o._ended = !1);
              var l = o._id;
              return (
                n._queue.push({
                  event: "play",
                  action: function () {
                    n.play(l);
                  },
                }),
                l
              );
            }
            if (i && !o._paused) return t || n._loadQueue("play"), o._id;
            n._webAudio && s._autoResume();
            var c = Math.max(0, o._seek > 0 ? o._seek : n._sprite[e][0] / 1e3),
              u = Math.max(0, (n._sprite[e][0] + n._sprite[e][1]) / 1e3 - c),
              h = (1e3 * u) / Math.abs(o._rate),
              d = n._sprite[e][0] / 1e3,
              p = (n._sprite[e][0] + n._sprite[e][1]) / 1e3;
            (o._sprite = e), (o._ended = !1);
            var f = function () {
              (o._paused = !1),
                (o._seek = c),
                (o._start = d),
                (o._stop = p),
                (o._loop = !(!o._loop && !n._sprite[e][2]));
            };
            if (!(c >= p)) {
              var A = o._node;
              if (n._webAudio) {
                var g = function () {
                  (n._playLock = !1), f(), n._refreshBuffer(o);
                  var e = o._muted || n._muted ? 0 : o._volume;
                  A.gain.setValueAtTime(e, s.ctx.currentTime),
                    (o._playStart = s.ctx.currentTime),
                    void 0 === A.bufferSource.start
                      ? o._loop
                        ? A.bufferSource.noteGrainOn(0, c, 86400)
                        : A.bufferSource.noteGrainOn(0, c, u)
                      : o._loop
                      ? A.bufferSource.start(0, c, 86400)
                      : A.bufferSource.start(0, c, u),
                    h !== 1 / 0 &&
                      (n._endTimers[o._id] = setTimeout(
                        n._ended.bind(n, o),
                        h
                      )),
                    t ||
                      setTimeout(function () {
                        n._emit("play", o._id), n._loadQueue();
                      }, 0);
                };
                "running" === s.state && "interrupted" !== s.ctx.state
                  ? g()
                  : ((n._playLock = !0),
                    n.once("resume", g),
                    n._clearTimer(o._id));
              } else {
                var m = function () {
                  (A.currentTime = c),
                    (A.muted = o._muted || n._muted || s._muted || A.muted),
                    (A.volume = o._volume * s.volume()),
                    (A.playbackRate = o._rate);
                  try {
                    var i = A.play();
                    if (
                      (i &&
                      "undefined" != typeof Promise &&
                      (i instanceof Promise || "function" == typeof i.then)
                        ? ((n._playLock = !0),
                          f(),
                          i
                            .then(function () {
                              (n._playLock = !1),
                                (A._unlocked = !0),
                                t ? n._loadQueue() : n._emit("play", o._id);
                            })
                            .catch(function () {
                              (n._playLock = !1),
                                n._emit(
                                  "playerror",
                                  o._id,
                                  "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                                ),
                                (o._ended = !0),
                                (o._paused = !0);
                            }))
                        : t ||
                          ((n._playLock = !1), f(), n._emit("play", o._id)),
                      (A.playbackRate = o._rate),
                      A.paused)
                    )
                      return void n._emit(
                        "playerror",
                        o._id,
                        "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction."
                      );
                    "__default" !== e || o._loop
                      ? (n._endTimers[o._id] = setTimeout(
                          n._ended.bind(n, o),
                          h
                        ))
                      : ((n._endTimers[o._id] = function () {
                          n._ended(o),
                            A.removeEventListener(
                              "ended",
                              n._endTimers[o._id],
                              !1
                            );
                        }),
                        A.addEventListener("ended", n._endTimers[o._id], !1));
                  } catch (e) {
                    n._emit("playerror", o._id, e);
                  }
                };
                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA" ===
                  A.src && ((A.src = n._src), A.load());
                var v =
                  (window && window.ejecta) ||
                  (!A.readyState && s._navigator.isCocoonJS);
                if (A.readyState >= 3 || v) m();
                else {
                  (n._playLock = !0), (n._state = "loading");
                  var y = function () {
                    (n._state = "loaded"),
                      m(),
                      A.removeEventListener(s._canPlayEvent, y, !1);
                  };
                  A.addEventListener(s._canPlayEvent, y, !1),
                    n._clearTimer(o._id);
                }
              }
              return o._id;
            }
            n._ended(o);
          },
          pause: function (e) {
            var t = this;
            if ("loaded" !== t._state || t._playLock)
              return (
                t._queue.push({
                  event: "pause",
                  action: function () {
                    t.pause(e);
                  },
                }),
                t
              );
            for (var n = t._getSoundIds(e), i = 0; i < n.length; i++) {
              t._clearTimer(n[i]);
              var r = t._soundById(n[i]);
              if (
                r &&
                !r._paused &&
                ((r._seek = t.seek(n[i])),
                (r._rateSeek = 0),
                (r._paused = !0),
                t._stopFade(n[i]),
                r._node)
              )
                if (t._webAudio) {
                  if (!r._node.bufferSource) continue;
                  void 0 === r._node.bufferSource.stop
                    ? r._node.bufferSource.noteOff(0)
                    : r._node.bufferSource.stop(0),
                    t._cleanBuffer(r._node);
                } else
                  (isNaN(r._node.duration) && r._node.duration !== 1 / 0) ||
                    r._node.pause();
              arguments[1] || t._emit("pause", r ? r._id : null);
            }
            return t;
          },
          stop: function (e, t) {
            var n = this;
            if ("loaded" !== n._state || n._playLock)
              return (
                n._queue.push({
                  event: "stop",
                  action: function () {
                    n.stop(e);
                  },
                }),
                n
              );
            for (var i = n._getSoundIds(e), r = 0; r < i.length; r++) {
              n._clearTimer(i[r]);
              var s = n._soundById(i[r]);
              s &&
                ((s._seek = s._start || 0),
                (s._rateSeek = 0),
                (s._paused = !0),
                (s._ended = !0),
                n._stopFade(i[r]),
                s._node &&
                  (n._webAudio
                    ? s._node.bufferSource &&
                      (void 0 === s._node.bufferSource.stop
                        ? s._node.bufferSource.noteOff(0)
                        : s._node.bufferSource.stop(0),
                      n._cleanBuffer(s._node))
                    : (isNaN(s._node.duration) && s._node.duration !== 1 / 0) ||
                      ((s._node.currentTime = s._start || 0),
                      s._node.pause(),
                      s._node.duration === 1 / 0 && n._clearSound(s._node))),
                t || n._emit("stop", s._id));
            }
            return n;
          },
          mute: function (e, t) {
            var n = this;
            if ("loaded" !== n._state || n._playLock)
              return (
                n._queue.push({
                  event: "mute",
                  action: function () {
                    n.mute(e, t);
                  },
                }),
                n
              );
            if (void 0 === t) {
              if ("boolean" != typeof e) return n._muted;
              n._muted = e;
            }
            for (var i = n._getSoundIds(t), r = 0; r < i.length; r++) {
              var a = n._soundById(i[r]);
              a &&
                ((a._muted = e),
                a._interval && n._stopFade(a._id),
                n._webAudio && a._node
                  ? a._node.gain.setValueAtTime(
                      e ? 0 : a._volume,
                      s.ctx.currentTime
                    )
                  : a._node && (a._node.muted = !!s._muted || e),
                n._emit("mute", a._id));
            }
            return n;
          },
          volume: function () {
            var e,
              t,
              n,
              i = this,
              r = arguments;
            if (0 === r.length) return i._volume;
            if (
              (1 === r.length || (2 === r.length && void 0 === r[1])
                ? i._getSoundIds().indexOf(r[0]) >= 0
                  ? (t = parseInt(r[0], 10))
                  : (e = parseFloat(r[0]))
                : r.length >= 2 &&
                  ((e = parseFloat(r[0])), (t = parseInt(r[1], 10))),
              !(void 0 !== e && e >= 0 && e <= 1))
            )
              return (n = t ? i._soundById(t) : i._sounds[0]) ? n._volume : 0;
            if ("loaded" !== i._state || i._playLock)
              return (
                i._queue.push({
                  event: "volume",
                  action: function () {
                    i.volume.apply(i, r);
                  },
                }),
                i
              );
            void 0 === t && (i._volume = e), (t = i._getSoundIds(t));
            for (var a = 0; a < t.length; a++)
              (n = i._soundById(t[a])) &&
                ((n._volume = e),
                r[2] || i._stopFade(t[a]),
                i._webAudio && n._node && !n._muted
                  ? n._node.gain.setValueAtTime(e, s.ctx.currentTime)
                  : n._node && !n._muted && (n._node.volume = e * s.volume()),
                i._emit("volume", n._id));
            return i;
          },
          fade: function (e, t, n, i) {
            var r = this;
            if ("loaded" !== r._state || r._playLock)
              return (
                r._queue.push({
                  event: "fade",
                  action: function () {
                    r.fade(e, t, n, i);
                  },
                }),
                r
              );
            (e = Math.min(Math.max(0, parseFloat(e)), 1)),
              (t = Math.min(Math.max(0, parseFloat(t)), 1)),
              (n = parseFloat(n)),
              r.volume(e, i);
            for (var a = r._getSoundIds(i), o = 0; o < a.length; o++) {
              var l = r._soundById(a[o]);
              if (l) {
                if ((i || r._stopFade(a[o]), r._webAudio && !l._muted)) {
                  var c = s.ctx.currentTime,
                    u = c + n / 1e3;
                  (l._volume = e),
                    l._node.gain.setValueAtTime(e, c),
                    l._node.gain.linearRampToValueAtTime(t, u);
                }
                r._startFadeInterval(l, e, t, n, a[o], void 0 === i);
              }
            }
            return r;
          },
          _startFadeInterval: function (e, t, n, i, r, s) {
            var a = this,
              o = t,
              l = n - t,
              c = Math.abs(l / 0.01),
              u = Math.max(4, c > 0 ? i / c : i),
              h = Date.now();
            (e._fadeTo = n),
              (e._interval = setInterval(function () {
                var r = (Date.now() - h) / i;
                (h = Date.now()),
                  (o += l * r),
                  (o = Math.round(100 * o) / 100),
                  (o = l < 0 ? Math.max(n, o) : Math.min(n, o)),
                  a._webAudio ? (e._volume = o) : a.volume(o, e._id, !0),
                  s && (a._volume = o),
                  ((n < t && o <= n) || (n > t && o >= n)) &&
                    (clearInterval(e._interval),
                    (e._interval = null),
                    (e._fadeTo = null),
                    a.volume(n, e._id),
                    a._emit("fade", e._id));
              }, u));
          },
          _stopFade: function (e) {
            var t = this,
              n = t._soundById(e);
            return (
              n &&
                n._interval &&
                (t._webAudio &&
                  n._node.gain.cancelScheduledValues(s.ctx.currentTime),
                clearInterval(n._interval),
                (n._interval = null),
                t.volume(n._fadeTo, e),
                (n._fadeTo = null),
                t._emit("fade", e)),
              t
            );
          },
          loop: function () {
            var e,
              t,
              n,
              i = this,
              r = arguments;
            if (0 === r.length) return i._loop;
            if (1 === r.length) {
              if ("boolean" != typeof r[0])
                return !!(n = i._soundById(parseInt(r[0], 10))) && n._loop;
              (e = r[0]), (i._loop = e);
            } else 2 === r.length && ((e = r[0]), (t = parseInt(r[1], 10)));
            for (var s = i._getSoundIds(t), a = 0; a < s.length; a++)
              (n = i._soundById(s[a])) &&
                ((n._loop = e),
                i._webAudio &&
                  n._node &&
                  n._node.bufferSource &&
                  ((n._node.bufferSource.loop = e),
                  e &&
                    ((n._node.bufferSource.loopStart = n._start || 0),
                    (n._node.bufferSource.loopEnd = n._stop),
                    i.playing(s[a]) && (i.pause(s[a], !0), i.play(s[a], !0)))));
            return i;
          },
          rate: function () {
            var e,
              t,
              n,
              i = this,
              r = arguments;
            if (0 === r.length) t = i._sounds[0]._id;
            else if (1 === r.length) {
              i._getSoundIds().indexOf(r[0]) >= 0
                ? (t = parseInt(r[0], 10))
                : (e = parseFloat(r[0]));
            } else
              2 === r.length &&
                ((e = parseFloat(r[0])), (t = parseInt(r[1], 10)));
            if ("number" != typeof e)
              return (n = i._soundById(t)) ? n._rate : i._rate;
            if ("loaded" !== i._state || i._playLock)
              return (
                i._queue.push({
                  event: "rate",
                  action: function () {
                    i.rate.apply(i, r);
                  },
                }),
                i
              );
            void 0 === t && (i._rate = e), (t = i._getSoundIds(t));
            for (var a = 0; a < t.length; a++)
              if ((n = i._soundById(t[a]))) {
                i.playing(t[a]) &&
                  ((n._rateSeek = i.seek(t[a])),
                  (n._playStart = i._webAudio
                    ? s.ctx.currentTime
                    : n._playStart)),
                  (n._rate = e),
                  i._webAudio && n._node && n._node.bufferSource
                    ? n._node.bufferSource.playbackRate.setValueAtTime(
                        e,
                        s.ctx.currentTime
                      )
                    : n._node && (n._node.playbackRate = e);
                var o = i.seek(t[a]),
                  l =
                    (1e3 *
                      ((i._sprite[n._sprite][0] + i._sprite[n._sprite][1]) /
                        1e3 -
                        o)) /
                    Math.abs(n._rate);
                (!i._endTimers[t[a]] && n._paused) ||
                  (i._clearTimer(t[a]),
                  (i._endTimers[t[a]] = setTimeout(i._ended.bind(i, n), l))),
                  i._emit("rate", n._id);
              }
            return i;
          },
          seek: function () {
            var e,
              t,
              n = this,
              i = arguments;
            if (0 === i.length) n._sounds.length && (t = n._sounds[0]._id);
            else if (1 === i.length) {
              n._getSoundIds().indexOf(i[0]) >= 0
                ? (t = parseInt(i[0], 10))
                : n._sounds.length &&
                  ((t = n._sounds[0]._id), (e = parseFloat(i[0])));
            } else
              2 === i.length &&
                ((e = parseFloat(i[0])), (t = parseInt(i[1], 10)));
            if (void 0 === t) return 0;
            if ("number" == typeof e && ("loaded" !== n._state || n._playLock))
              return (
                n._queue.push({
                  event: "seek",
                  action: function () {
                    n.seek.apply(n, i);
                  },
                }),
                n
              );
            var r = n._soundById(t);
            if (r) {
              if (!("number" == typeof e && e >= 0)) {
                if (n._webAudio) {
                  var a = n.playing(t) ? s.ctx.currentTime - r._playStart : 0,
                    o = r._rateSeek ? r._rateSeek - r._seek : 0;
                  return r._seek + (o + a * Math.abs(r._rate));
                }
                return r._node.currentTime;
              }
              var l = n.playing(t);
              l && n.pause(t, !0),
                (r._seek = e),
                (r._ended = !1),
                n._clearTimer(t),
                n._webAudio ||
                  !r._node ||
                  isNaN(r._node.duration) ||
                  (r._node.currentTime = e);
              var c = function () {
                l && n.play(t, !0), n._emit("seek", t);
              };
              if (l && !n._webAudio) {
                var u = function () {
                  n._playLock ? setTimeout(u, 0) : c();
                };
                setTimeout(u, 0);
              } else c();
            }
            return n;
          },
          playing: function (e) {
            var t = this;
            if ("number" == typeof e) {
              var n = t._soundById(e);
              return !!n && !n._paused;
            }
            for (var i = 0; i < t._sounds.length; i++)
              if (!t._sounds[i]._paused) return !0;
            return !1;
          },
          duration: function (e) {
            var t = this,
              n = t._duration,
              i = t._soundById(e);
            return i && (n = t._sprite[i._sprite][1] / 1e3), n;
          },
          state: function () {
            return this._state;
          },
          unload: function () {
            for (var e = this, t = e._sounds, n = 0; n < t.length; n++)
              t[n]._paused || e.stop(t[n]._id),
                e._webAudio ||
                  (e._clearSound(t[n]._node),
                  t[n]._node.removeEventListener("error", t[n]._errorFn, !1),
                  t[n]._node.removeEventListener(
                    s._canPlayEvent,
                    t[n]._loadFn,
                    !1
                  ),
                  t[n]._node.removeEventListener("ended", t[n]._endFn, !1),
                  s._releaseHtml5Audio(t[n]._node)),
                delete t[n]._node,
                e._clearTimer(t[n]._id);
            var i = s._howls.indexOf(e);
            i >= 0 && s._howls.splice(i, 1);
            var r = !0;
            for (n = 0; n < s._howls.length; n++)
              if (
                s._howls[n]._src === e._src ||
                e._src.indexOf(s._howls[n]._src) >= 0
              ) {
                r = !1;
                break;
              }
            return (
              l && r && delete l[e._src],
              (s.noAudio = !1),
              (e._state = "unloaded"),
              (e._sounds = []),
              (e = null),
              null
            );
          },
          on: function (e, t, n, i) {
            var r = this["_on" + e];
            return (
              "function" == typeof t &&
                r.push(i ? { id: n, fn: t, once: i } : { id: n, fn: t }),
              this
            );
          },
          off: function (e, t, n) {
            var i = this,
              r = i["_on" + e],
              s = 0;
            if (("number" == typeof t && ((n = t), (t = null)), t || n))
              for (s = 0; s < r.length; s++) {
                var a = n === r[s].id;
                if ((t === r[s].fn && a) || (!t && a)) {
                  r.splice(s, 1);
                  break;
                }
              }
            else if (e) i["_on" + e] = [];
            else {
              var o = Object.keys(i);
              for (s = 0; s < o.length; s++)
                0 === o[s].indexOf("_on") &&
                  Array.isArray(i[o[s]]) &&
                  (i[o[s]] = []);
            }
            return i;
          },
          once: function (e, t, n) {
            return this.on(e, t, n, 1), this;
          },
          _emit: function (e, t, n) {
            for (var i = this, r = i["_on" + e], s = r.length - 1; s >= 0; s--)
              (r[s].id && r[s].id !== t && "load" !== e) ||
                (setTimeout(
                  function (e) {
                    e.call(this, t, n);
                  }.bind(i, r[s].fn),
                  0
                ),
                r[s].once && i.off(e, r[s].fn, r[s].id));
            return i._loadQueue(e), i;
          },
          _loadQueue: function (e) {
            var t = this;
            if (t._queue.length > 0) {
              var n = t._queue[0];
              n.event === e && (t._queue.shift(), t._loadQueue()),
                e || n.action();
            }
            return t;
          },
          _ended: function (e) {
            var t = this,
              n = e._sprite;
            if (
              !t._webAudio &&
              e._node &&
              !e._node.paused &&
              !e._node.ended &&
              e._node.currentTime < e._stop
            )
              return setTimeout(t._ended.bind(t, e), 100), t;
            var i = !(!e._loop && !t._sprite[n][2]);
            if (
              (t._emit("end", e._id),
              !t._webAudio && i && t.stop(e._id, !0).play(e._id),
              t._webAudio && i)
            ) {
              t._emit("play", e._id),
                (e._seek = e._start || 0),
                (e._rateSeek = 0),
                (e._playStart = s.ctx.currentTime);
              var r = (1e3 * (e._stop - e._start)) / Math.abs(e._rate);
              t._endTimers[e._id] = setTimeout(t._ended.bind(t, e), r);
            }
            return (
              t._webAudio &&
                !i &&
                ((e._paused = !0),
                (e._ended = !0),
                (e._seek = e._start || 0),
                (e._rateSeek = 0),
                t._clearTimer(e._id),
                t._cleanBuffer(e._node),
                s._autoSuspend()),
              t._webAudio || i || t.stop(e._id, !0),
              t
            );
          },
          _clearTimer: function (e) {
            var t = this;
            if (t._endTimers[e]) {
              if ("function" != typeof t._endTimers[e])
                clearTimeout(t._endTimers[e]);
              else {
                var n = t._soundById(e);
                n &&
                  n._node &&
                  n._node.removeEventListener("ended", t._endTimers[e], !1);
              }
              delete t._endTimers[e];
            }
            return t;
          },
          _soundById: function (e) {
            for (var t = this, n = 0; n < t._sounds.length; n++)
              if (e === t._sounds[n]._id) return t._sounds[n];
            return null;
          },
          _inactiveSound: function () {
            var e = this;
            e._drain();
            for (var t = 0; t < e._sounds.length; t++)
              if (e._sounds[t]._ended) return e._sounds[t].reset();
            return new o(e);
          },
          _drain: function () {
            var e = this,
              t = e._pool,
              n = 0,
              i = 0;
            if (!(e._sounds.length < t)) {
              for (i = 0; i < e._sounds.length; i++) e._sounds[i]._ended && n++;
              for (i = e._sounds.length - 1; i >= 0; i--) {
                if (n <= t) return;
                e._sounds[i]._ended &&
                  (e._webAudio &&
                    e._sounds[i]._node &&
                    e._sounds[i]._node.disconnect(0),
                  e._sounds.splice(i, 1),
                  n--);
              }
            }
          },
          _getSoundIds: function (e) {
            if (void 0 === e) {
              for (var t = [], n = 0; n < this._sounds.length; n++)
                t.push(this._sounds[n]._id);
              return t;
            }
            return [e];
          },
          _refreshBuffer: function (e) {
            return (
              (e._node.bufferSource = s.ctx.createBufferSource()),
              (e._node.bufferSource.buffer = l[this._src]),
              e._panner
                ? e._node.bufferSource.connect(e._panner)
                : e._node.bufferSource.connect(e._node),
              (e._node.bufferSource.loop = e._loop),
              e._loop &&
                ((e._node.bufferSource.loopStart = e._start || 0),
                (e._node.bufferSource.loopEnd = e._stop || 0)),
              e._node.bufferSource.playbackRate.setValueAtTime(
                e._rate,
                s.ctx.currentTime
              ),
              this
            );
          },
          _cleanBuffer: function (e) {
            var t = s._navigator && s._navigator.vendor.indexOf("Apple") >= 0;
            if (!e.bufferSource) return this;
            if (
              s._scratchBuffer &&
              e.bufferSource &&
              ((e.bufferSource.onended = null), e.bufferSource.disconnect(0), t)
            )
              try {
                e.bufferSource.buffer = s._scratchBuffer;
              } catch (e) {}
            return (e.bufferSource = null), this;
          },
          _clearSound: function (e) {
            /MSIE |Trident\//.test(s._navigator && s._navigator.userAgent) ||
              (e.src =
                "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA");
          },
        };
        var o = function (e) {
          (this._parent = e), this.init();
        };
        o.prototype = {
          init: function () {
            var e = this,
              t = e._parent;
            return (
              (e._muted = t._muted),
              (e._loop = t._loop),
              (e._volume = t._volume),
              (e._rate = t._rate),
              (e._seek = 0),
              (e._paused = !0),
              (e._ended = !0),
              (e._sprite = "__default"),
              (e._id = ++s._counter),
              t._sounds.push(e),
              e.create(),
              e
            );
          },
          create: function () {
            var e = this,
              t = e._parent,
              n = s._muted || e._muted || e._parent._muted ? 0 : e._volume;
            return (
              t._webAudio
                ? ((e._node =
                    void 0 === s.ctx.createGain
                      ? s.ctx.createGainNode()
                      : s.ctx.createGain()),
                  e._node.gain.setValueAtTime(n, s.ctx.currentTime),
                  (e._node.paused = !0),
                  e._node.connect(s.masterGain))
                : s.noAudio ||
                  ((e._node = s._obtainHtml5Audio()),
                  (e._errorFn = e._errorListener.bind(e)),
                  e._node.addEventListener("error", e._errorFn, !1),
                  (e._loadFn = e._loadListener.bind(e)),
                  e._node.addEventListener(s._canPlayEvent, e._loadFn, !1),
                  (e._endFn = e._endListener.bind(e)),
                  e._node.addEventListener("ended", e._endFn, !1),
                  (e._node.src = t._src),
                  (e._node.preload = !0 === t._preload ? "auto" : t._preload),
                  (e._node.volume = n * s.volume()),
                  e._node.load()),
              e
            );
          },
          reset: function () {
            var e = this,
              t = e._parent;
            return (
              (e._muted = t._muted),
              (e._loop = t._loop),
              (e._volume = t._volume),
              (e._rate = t._rate),
              (e._seek = 0),
              (e._rateSeek = 0),
              (e._paused = !0),
              (e._ended = !0),
              (e._sprite = "__default"),
              (e._id = ++s._counter),
              e
            );
          },
          _errorListener: function () {
            var e = this;
            e._parent._emit(
              "loaderror",
              e._id,
              e._node.error ? e._node.error.code : 0
            ),
              e._node.removeEventListener("error", e._errorFn, !1);
          },
          _loadListener: function () {
            var e = this,
              t = e._parent;
            (t._duration = Math.ceil(10 * e._node.duration) / 10),
              0 === Object.keys(t._sprite).length &&
                (t._sprite = { __default: [0, 1e3 * t._duration] }),
              "loaded" !== t._state &&
                ((t._state = "loaded"), t._emit("load"), t._loadQueue()),
              e._node.removeEventListener(s._canPlayEvent, e._loadFn, !1);
          },
          _endListener: function () {
            var e = this,
              t = e._parent;
            t._duration === 1 / 0 &&
              ((t._duration = Math.ceil(10 * e._node.duration) / 10),
              t._sprite.__default[1] === 1 / 0 &&
                (t._sprite.__default[1] = 1e3 * t._duration),
              t._ended(e)),
              e._node.removeEventListener("ended", e._endFn, !1);
          },
        };
        var l = {},
          c = function (e) {
            var t = e._src;
            if (l[t]) return (e._duration = l[t].duration), void d(e);
            if (/^data:[^;]+;base64,/.test(t)) {
              for (
                var n = atob(t.split(",")[1]),
                  i = new Uint8Array(n.length),
                  r = 0;
                r < n.length;
                ++r
              )
                i[r] = n.charCodeAt(r);
              h(i.buffer, e);
            } else {
              var s = new XMLHttpRequest();
              s.open(e._xhr.method, t, !0),
                (s.withCredentials = e._xhr.withCredentials),
                (s.responseType = "arraybuffer"),
                e._xhr.headers &&
                  Object.keys(e._xhr.headers).forEach(function (t) {
                    s.setRequestHeader(t, e._xhr.headers[t]);
                  }),
                (s.onload = function () {
                  var t = (s.status + "")[0];
                  "0" === t || "2" === t || "3" === t
                    ? h(s.response, e)
                    : e._emit(
                        "loaderror",
                        null,
                        "Failed loading audio file with status: " +
                          s.status +
                          "."
                      );
                }),
                (s.onerror = function () {
                  e._webAudio &&
                    ((e._html5 = !0),
                    (e._webAudio = !1),
                    (e._sounds = []),
                    delete l[t],
                    e.load());
                }),
                u(s);
            }
          },
          u = function (e) {
            try {
              e.send();
            } catch (t) {
              e.onerror();
            }
          },
          h = function (e, t) {
            var n = function () {
                t._emit("loaderror", null, "Decoding audio data failed.");
              },
              i = function (e) {
                e && t._sounds.length > 0 ? ((l[t._src] = e), d(t, e)) : n();
              };
            "undefined" != typeof Promise && 1 === s.ctx.decodeAudioData.length
              ? s.ctx.decodeAudioData(e).then(i).catch(n)
              : s.ctx.decodeAudioData(e, i, n);
          },
          d = function (e, t) {
            t && !e._duration && (e._duration = t.duration),
              0 === Object.keys(e._sprite).length &&
                (e._sprite = { __default: [0, 1e3 * e._duration] }),
              "loaded" !== e._state &&
                ((e._state = "loaded"), e._emit("load"), e._loadQueue());
          },
          p = function () {
            if (s.usingWebAudio) {
              try {
                "undefined" != typeof AudioContext
                  ? (s.ctx = new AudioContext())
                  : "undefined" != typeof webkitAudioContext
                  ? (s.ctx = new webkitAudioContext())
                  : (s.usingWebAudio = !1);
              } catch (e) {
                s.usingWebAudio = !1;
              }
              s.ctx || (s.usingWebAudio = !1);
              var e = /iP(hone|od|ad)/.test(
                  s._navigator && s._navigator.platform
                ),
                t =
                  s._navigator &&
                  s._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/),
                n = t ? parseInt(t[1], 10) : null;
              if (e && n && n < 9) {
                var i = /safari/.test(
                  s._navigator && s._navigator.userAgent.toLowerCase()
                );
                s._navigator && !i && (s.usingWebAudio = !1);
              }
              s.usingWebAudio &&
                ((s.masterGain =
                  void 0 === s.ctx.createGain
                    ? s.ctx.createGainNode()
                    : s.ctx.createGain()),
                s.masterGain.gain.setValueAtTime(
                  s._muted ? 0 : s._volume,
                  s.ctx.currentTime
                ),
                s.masterGain.connect(s.ctx.destination)),
                s._setup();
            }
          };
        void 0 ===
          (i = function () {
            return { Howler: s, Howl: a };
          }.apply(t, [])) || (e.exports = i),
          (t.Howler = s),
          (t.Howl = a),
          void 0 !== n.g
            ? ((n.g.HowlerGlobal = r),
              (n.g.Howler = s),
              (n.g.Howl = a),
              (n.g.Sound = o))
            : "undefined" != typeof window &&
              ((window.HowlerGlobal = r),
              (window.Howler = s),
              (window.Howl = a),
              (window.Sound = o));
      })(),
        (function () {
          "use strict";
          var e;
          (HowlerGlobal.prototype._pos = [0, 0, 0]),
            (HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0]),
            (HowlerGlobal.prototype.stereo = function (e) {
              var t = this;
              if (!t.ctx || !t.ctx.listener) return t;
              for (var n = t._howls.length - 1; n >= 0; n--)
                t._howls[n].stereo(e);
              return t;
            }),
            (HowlerGlobal.prototype.pos = function (e, t, n) {
              var i = this;
              return i.ctx && i.ctx.listener
                ? ((t = "number" != typeof t ? i._pos[1] : t),
                  (n = "number" != typeof n ? i._pos[2] : n),
                  "number" != typeof e
                    ? i._pos
                    : ((i._pos = [e, t, n]),
                      void 0 !== i.ctx.listener.positionX
                        ? (i.ctx.listener.positionX.setTargetAtTime(
                            i._pos[0],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          i.ctx.listener.positionY.setTargetAtTime(
                            i._pos[1],
                            Howler.ctx.currentTime,
                            0.1
                          ),
                          i.ctx.listener.positionZ.setTargetAtTime(
                            i._pos[2],
                            Howler.ctx.currentTime,
                            0.1
                          ))
                        : i.ctx.listener.setPosition(
                            i._pos[0],
                            i._pos[1],
                            i._pos[2]
                          ),
                      i))
                : i;
            }),
            (HowlerGlobal.prototype.orientation = function (e, t, n, i, r, s) {
              var a = this;
              if (!a.ctx || !a.ctx.listener) return a;
              var o = a._orientation;
              return (
                (t = "number" != typeof t ? o[1] : t),
                (n = "number" != typeof n ? o[2] : n),
                (i = "number" != typeof i ? o[3] : i),
                (r = "number" != typeof r ? o[4] : r),
                (s = "number" != typeof s ? o[5] : s),
                "number" != typeof e
                  ? o
                  : ((a._orientation = [e, t, n, i, r, s]),
                    void 0 !== a.ctx.listener.forwardX
                      ? (a.ctx.listener.forwardX.setTargetAtTime(
                          e,
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        a.ctx.listener.forwardY.setTargetAtTime(
                          t,
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        a.ctx.listener.forwardZ.setTargetAtTime(
                          n,
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        a.ctx.listener.upX.setTargetAtTime(
                          i,
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        a.ctx.listener.upY.setTargetAtTime(
                          r,
                          Howler.ctx.currentTime,
                          0.1
                        ),
                        a.ctx.listener.upZ.setTargetAtTime(
                          s,
                          Howler.ctx.currentTime,
                          0.1
                        ))
                      : a.ctx.listener.setOrientation(e, t, n, i, r, s),
                    a)
              );
            }),
            (Howl.prototype.init =
              ((e = Howl.prototype.init),
              function (t) {
                var n = this;
                return (
                  (n._orientation = t.orientation || [1, 0, 0]),
                  (n._stereo = t.stereo || null),
                  (n._pos = t.pos || null),
                  (n._pannerAttr = {
                    coneInnerAngle:
                      void 0 !== t.coneInnerAngle ? t.coneInnerAngle : 360,
                    coneOuterAngle:
                      void 0 !== t.coneOuterAngle ? t.coneOuterAngle : 360,
                    coneOuterGain:
                      void 0 !== t.coneOuterGain ? t.coneOuterGain : 0,
                    distanceModel:
                      void 0 !== t.distanceModel ? t.distanceModel : "inverse",
                    maxDistance: void 0 !== t.maxDistance ? t.maxDistance : 1e4,
                    panningModel:
                      void 0 !== t.panningModel ? t.panningModel : "HRTF",
                    refDistance: void 0 !== t.refDistance ? t.refDistance : 1,
                    rolloffFactor:
                      void 0 !== t.rolloffFactor ? t.rolloffFactor : 1,
                  }),
                  (n._onstereo = t.onstereo ? [{ fn: t.onstereo }] : []),
                  (n._onpos = t.onpos ? [{ fn: t.onpos }] : []),
                  (n._onorientation = t.onorientation
                    ? [{ fn: t.onorientation }]
                    : []),
                  e.call(this, t)
                );
              })),
            (Howl.prototype.stereo = function (e, n) {
              var i = this;
              if (!i._webAudio) return i;
              if ("loaded" !== i._state)
                return (
                  i._queue.push({
                    event: "stereo",
                    action: function () {
                      i.stereo(e, n);
                    },
                  }),
                  i
                );
              var r =
                void 0 === Howler.ctx.createStereoPanner ? "spatial" : "stereo";
              if (void 0 === n) {
                if ("number" != typeof e) return i._stereo;
                (i._stereo = e), (i._pos = [e, 0, 0]);
              }
              for (var s = i._getSoundIds(n), a = 0; a < s.length; a++) {
                var o = i._soundById(s[a]);
                if (o) {
                  if ("number" != typeof e) return o._stereo;
                  (o._stereo = e),
                    (o._pos = [e, 0, 0]),
                    o._node &&
                      ((o._pannerAttr.panningModel = "equalpower"),
                      (o._panner && o._panner.pan) || t(o, r),
                      "spatial" === r
                        ? void 0 !== o._panner.positionX
                          ? (o._panner.positionX.setValueAtTime(
                              e,
                              Howler.ctx.currentTime
                            ),
                            o._panner.positionY.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ),
                            o._panner.positionZ.setValueAtTime(
                              0,
                              Howler.ctx.currentTime
                            ))
                          : o._panner.setPosition(e, 0, 0)
                        : o._panner.pan.setValueAtTime(
                            e,
                            Howler.ctx.currentTime
                          )),
                    i._emit("stereo", o._id);
                }
              }
              return i;
            }),
            (Howl.prototype.pos = function (e, n, i, r) {
              var s = this;
              if (!s._webAudio) return s;
              if ("loaded" !== s._state)
                return (
                  s._queue.push({
                    event: "pos",
                    action: function () {
                      s.pos(e, n, i, r);
                    },
                  }),
                  s
                );
              if (
                ((n = "number" != typeof n ? 0 : n),
                (i = "number" != typeof i ? -0.5 : i),
                void 0 === r)
              ) {
                if ("number" != typeof e) return s._pos;
                s._pos = [e, n, i];
              }
              for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                var l = s._soundById(a[o]);
                if (l) {
                  if ("number" != typeof e) return l._pos;
                  (l._pos = [e, n, i]),
                    l._node &&
                      ((l._panner && !l._panner.pan) || t(l, "spatial"),
                      void 0 !== l._panner.positionX
                        ? (l._panner.positionX.setValueAtTime(
                            e,
                            Howler.ctx.currentTime
                          ),
                          l._panner.positionY.setValueAtTime(
                            n,
                            Howler.ctx.currentTime
                          ),
                          l._panner.positionZ.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ))
                        : l._panner.setPosition(e, n, i)),
                    s._emit("pos", l._id);
                }
              }
              return s;
            }),
            (Howl.prototype.orientation = function (e, n, i, r) {
              var s = this;
              if (!s._webAudio) return s;
              if ("loaded" !== s._state)
                return (
                  s._queue.push({
                    event: "orientation",
                    action: function () {
                      s.orientation(e, n, i, r);
                    },
                  }),
                  s
                );
              if (
                ((n = "number" != typeof n ? s._orientation[1] : n),
                (i = "number" != typeof i ? s._orientation[2] : i),
                void 0 === r)
              ) {
                if ("number" != typeof e) return s._orientation;
                s._orientation = [e, n, i];
              }
              for (var a = s._getSoundIds(r), o = 0; o < a.length; o++) {
                var l = s._soundById(a[o]);
                if (l) {
                  if ("number" != typeof e) return l._orientation;
                  (l._orientation = [e, n, i]),
                    l._node &&
                      (l._panner ||
                        (l._pos || (l._pos = s._pos || [0, 0, -0.5]),
                        t(l, "spatial")),
                      void 0 !== l._panner.orientationX
                        ? (l._panner.orientationX.setValueAtTime(
                            e,
                            Howler.ctx.currentTime
                          ),
                          l._panner.orientationY.setValueAtTime(
                            n,
                            Howler.ctx.currentTime
                          ),
                          l._panner.orientationZ.setValueAtTime(
                            i,
                            Howler.ctx.currentTime
                          ))
                        : l._panner.setOrientation(e, n, i)),
                    s._emit("orientation", l._id);
                }
              }
              return s;
            }),
            (Howl.prototype.pannerAttr = function () {
              var e,
                n,
                i,
                r = this,
                s = arguments;
              if (!r._webAudio) return r;
              if (0 === s.length) return r._pannerAttr;
              if (1 === s.length) {
                if ("object" != typeof s[0])
                  return (i = r._soundById(parseInt(s[0], 10)))
                    ? i._pannerAttr
                    : r._pannerAttr;
                (e = s[0]),
                  void 0 === n &&
                    (e.pannerAttr ||
                      (e.pannerAttr = {
                        coneInnerAngle: e.coneInnerAngle,
                        coneOuterAngle: e.coneOuterAngle,
                        coneOuterGain: e.coneOuterGain,
                        distanceModel: e.distanceModel,
                        maxDistance: e.maxDistance,
                        refDistance: e.refDistance,
                        rolloffFactor: e.rolloffFactor,
                        panningModel: e.panningModel,
                      }),
                    (r._pannerAttr = {
                      coneInnerAngle:
                        void 0 !== e.pannerAttr.coneInnerAngle
                          ? e.pannerAttr.coneInnerAngle
                          : r._coneInnerAngle,
                      coneOuterAngle:
                        void 0 !== e.pannerAttr.coneOuterAngle
                          ? e.pannerAttr.coneOuterAngle
                          : r._coneOuterAngle,
                      coneOuterGain:
                        void 0 !== e.pannerAttr.coneOuterGain
                          ? e.pannerAttr.coneOuterGain
                          : r._coneOuterGain,
                      distanceModel:
                        void 0 !== e.pannerAttr.distanceModel
                          ? e.pannerAttr.distanceModel
                          : r._distanceModel,
                      maxDistance:
                        void 0 !== e.pannerAttr.maxDistance
                          ? e.pannerAttr.maxDistance
                          : r._maxDistance,
                      refDistance:
                        void 0 !== e.pannerAttr.refDistance
                          ? e.pannerAttr.refDistance
                          : r._refDistance,
                      rolloffFactor:
                        void 0 !== e.pannerAttr.rolloffFactor
                          ? e.pannerAttr.rolloffFactor
                          : r._rolloffFactor,
                      panningModel:
                        void 0 !== e.pannerAttr.panningModel
                          ? e.pannerAttr.panningModel
                          : r._panningModel,
                    }));
              } else 2 === s.length && ((e = s[0]), (n = parseInt(s[1], 10)));
              for (var a = r._getSoundIds(n), o = 0; o < a.length; o++)
                if ((i = r._soundById(a[o]))) {
                  var l = i._pannerAttr;
                  l = {
                    coneInnerAngle:
                      void 0 !== e.coneInnerAngle
                        ? e.coneInnerAngle
                        : l.coneInnerAngle,
                    coneOuterAngle:
                      void 0 !== e.coneOuterAngle
                        ? e.coneOuterAngle
                        : l.coneOuterAngle,
                    coneOuterGain:
                      void 0 !== e.coneOuterGain
                        ? e.coneOuterGain
                        : l.coneOuterGain,
                    distanceModel:
                      void 0 !== e.distanceModel
                        ? e.distanceModel
                        : l.distanceModel,
                    maxDistance:
                      void 0 !== e.maxDistance ? e.maxDistance : l.maxDistance,
                    refDistance:
                      void 0 !== e.refDistance ? e.refDistance : l.refDistance,
                    rolloffFactor:
                      void 0 !== e.rolloffFactor
                        ? e.rolloffFactor
                        : l.rolloffFactor,
                    panningModel:
                      void 0 !== e.panningModel
                        ? e.panningModel
                        : l.panningModel,
                  };
                  var c = i._panner;
                  c ||
                    (i._pos || (i._pos = r._pos || [0, 0, -0.5]),
                    t(i, "spatial"),
                    (c = i._panner)),
                    (c.coneInnerAngle = l.coneInnerAngle),
                    (c.coneOuterAngle = l.coneOuterAngle),
                    (c.coneOuterGain = l.coneOuterGain),
                    (c.distanceModel = l.distanceModel),
                    (c.maxDistance = l.maxDistance),
                    (c.refDistance = l.refDistance),
                    (c.rolloffFactor = l.rolloffFactor),
                    (c.panningModel = l.panningModel);
                }
              return r;
            }),
            (Sound.prototype.init = (function (e) {
              return function () {
                var t = this,
                  n = t._parent;
                (t._orientation = n._orientation),
                  (t._stereo = n._stereo),
                  (t._pos = n._pos),
                  (t._pannerAttr = n._pannerAttr),
                  e.call(this),
                  t._stereo
                    ? n.stereo(t._stereo)
                    : t._pos && n.pos(t._pos[0], t._pos[1], t._pos[2], t._id);
              };
            })(Sound.prototype.init)),
            (Sound.prototype.reset = (function (e) {
              return function () {
                var t = this,
                  n = t._parent;
                return (
                  (t._orientation = n._orientation),
                  (t._stereo = n._stereo),
                  (t._pos = n._pos),
                  (t._pannerAttr = n._pannerAttr),
                  t._stereo
                    ? n.stereo(t._stereo)
                    : t._pos
                    ? n.pos(t._pos[0], t._pos[1], t._pos[2], t._id)
                    : t._panner &&
                      (t._panner.disconnect(0),
                      (t._panner = void 0),
                      n._refreshBuffer(t)),
                  e.call(this)
                );
              };
            })(Sound.prototype.reset));
          var t = function (e, t) {
            "spatial" === (t = t || "spatial")
              ? ((e._panner = Howler.ctx.createPanner()),
                (e._panner.coneInnerAngle = e._pannerAttr.coneInnerAngle),
                (e._panner.coneOuterAngle = e._pannerAttr.coneOuterAngle),
                (e._panner.coneOuterGain = e._pannerAttr.coneOuterGain),
                (e._panner.distanceModel = e._pannerAttr.distanceModel),
                (e._panner.maxDistance = e._pannerAttr.maxDistance),
                (e._panner.refDistance = e._pannerAttr.refDistance),
                (e._panner.rolloffFactor = e._pannerAttr.rolloffFactor),
                (e._panner.panningModel = e._pannerAttr.panningModel),
                void 0 !== e._panner.positionX
                  ? (e._panner.positionX.setValueAtTime(
                      e._pos[0],
                      Howler.ctx.currentTime
                    ),
                    e._panner.positionY.setValueAtTime(
                      e._pos[1],
                      Howler.ctx.currentTime
                    ),
                    e._panner.positionZ.setValueAtTime(
                      e._pos[2],
                      Howler.ctx.currentTime
                    ))
                  : e._panner.setPosition(e._pos[0], e._pos[1], e._pos[2]),
                void 0 !== e._panner.orientationX
                  ? (e._panner.orientationX.setValueAtTime(
                      e._orientation[0],
                      Howler.ctx.currentTime
                    ),
                    e._panner.orientationY.setValueAtTime(
                      e._orientation[1],
                      Howler.ctx.currentTime
                    ),
                    e._panner.orientationZ.setValueAtTime(
                      e._orientation[2],
                      Howler.ctx.currentTime
                    ))
                  : e._panner.setOrientation(
                      e._orientation[0],
                      e._orientation[1],
                      e._orientation[2]
                    ))
              : ((e._panner = Howler.ctx.createStereoPanner()),
                e._panner.pan.setValueAtTime(
                  e._stereo,
                  Howler.ctx.currentTime
                )),
              e._panner.connect(e._node),
              e._paused || e._parent.pause(e._id, !0).play(e._id, !0);
          };
        })();
    },
    8336: (e) => {
      var t, n;
      (t = []),
        (n = []),
        (e.exports = function (e, i, r) {
          var s, a, o, l, c, u, h, d;
          if (e === i) return 0;
          if (((s = e.length), (a = i.length), 0 === s)) return a;
          if (0 === a) return s;
          for (
            r && ((e = e.toLowerCase()), (i = i.toLowerCase())), h = 0;
            h < s;

          )
            (n[h] = e.charCodeAt(h)), (t[h] = ++h);
          for (d = 0; d < a; )
            for (o = i.charCodeAt(d), l = c = d++, h = -1; ++h < s; )
              (u = o === n[h] ? c : c + 1),
                (c = t[h]),
                (t[h] = l = c > l ? (u > l ? l + 1 : u) : u > c ? c + 1 : u);
          return l;
        });
    },
    2722: (e, t, n) => {
      var i = n(8336);
      e.exports = function () {
        var e,
          t,
          n,
          r,
          s,
          a = 0,
          o = arguments[0],
          l = arguments[1],
          c = l.length,
          u = arguments[2];
        u && ((r = u.threshold), (s = u.ignoreCase)), void 0 === r && (r = 0);
        for (var h = 0; h < c; ++h)
          (e =
            (t = s ? i(o, l[h], !0) : i(o, l[h])) > o.length
              ? 1 - t / l[h].length
              : 1 - t / o.length) > a && ((a = e), (n = l[h]));
        return a >= r ? n : null;
      };
    },
    2052: function (e) {
      var t;
      e.exports =
        (((t = function () {
          function e(e) {
            return r.appendChild(e.dom), e;
          }
          function n(e) {
            for (var t = 0; t < r.children.length; t++)
              r.children[t].style.display = t === e ? "block" : "none";
            i = e;
          }
          var i = 0,
            r = document.createElement("div");
          (r.style.cssText =
            "position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000"),
            r.addEventListener(
              "click",
              function (e) {
                e.preventDefault(), n(++i % r.children.length);
              },
              !1
            );
          var s = (performance || Date).now(),
            a = s,
            o = 0,
            l = e(new t.Panel("FPS", "#0ff", "#002")),
            c = e(new t.Panel("MS", "#0f0", "#020"));
          if (self.performance && self.performance.memory)
            var u = e(new t.Panel("MB", "#f08", "#201"));
          return (
            n(0),
            {
              REVISION: 16,
              dom: r,
              addPanel: e,
              showPanel: n,
              begin: function () {
                s = (performance || Date).now();
              },
              end: function () {
                o++;
                var e = (performance || Date).now();
                if (
                  (c.update(e - s, 200),
                  e > a + 1e3 &&
                    (l.update((1e3 * o) / (e - a), 100), (a = e), (o = 0), u))
                ) {
                  var t = performance.memory;
                  u.update(
                    t.usedJSHeapSize / 1048576,
                    t.jsHeapSizeLimit / 1048576
                  );
                }
                return e;
              },
              update: function () {
                s = this.end();
              },
              domElement: r,
              setMode: n,
            }
          );
        }).Panel = function (e, t, n) {
          var i = 1 / 0,
            r = 0,
            s = Math.round,
            a = s(window.devicePixelRatio || 1),
            o = 80 * a,
            l = 48 * a,
            c = 3 * a,
            u = 2 * a,
            h = 3 * a,
            d = 15 * a,
            p = 74 * a,
            f = 30 * a,
            A = document.createElement("canvas");
          (A.width = o),
            (A.height = l),
            (A.style.cssText = "width:80px;height:48px");
          var g = A.getContext("2d");
          return (
            (g.font = "bold " + 9 * a + "px Helvetica,Arial,sans-serif"),
            (g.textBaseline = "top"),
            (g.fillStyle = n),
            g.fillRect(0, 0, o, l),
            (g.fillStyle = t),
            g.fillText(e, c, u),
            g.fillRect(h, d, p, f),
            (g.fillStyle = n),
            (g.globalAlpha = 0.9),
            g.fillRect(h, d, p, f),
            {
              dom: A,
              update: function (l, m) {
                (i = Math.min(i, l)),
                  (r = Math.max(r, l)),
                  (g.fillStyle = n),
                  (g.globalAlpha = 1),
                  g.fillRect(0, 0, o, d),
                  (g.fillStyle = t),
                  g.fillText(
                    s(l) + " " + e + " (" + s(i) + "-" + s(r) + ")",
                    c,
                    u
                  ),
                  g.drawImage(A, h + a, d, p - a, f, h, d, p - a, f),
                  g.fillRect(h + p - a, d, a, f),
                  (g.fillStyle = n),
                  (g.globalAlpha = 0.9),
                  g.fillRect(h + p - a, d, a, s((1 - l / m) * f));
              },
            }
          );
        }),
        t);
    },
    5314: (e) => {
      e.exports = (function () {
        function e(e, t, n, i) {
          this.set(e, t, n, i);
        }
        return (
          (e.prototype.set = function (e, t, n, i) {
            (this._cx = 3 * e),
              (this._bx = 3 * (n - e) - this._cx),
              (this._ax = 1 - this._cx - this._bx),
              (this._cy = 3 * t),
              (this._by = 3 * (i - t) - this._cy),
              (this._ay = 1 - this._cy - this._by);
          }),
          (e.epsilon = 1e-6),
          (e.prototype._sampleCurveX = function (e) {
            return ((this._ax * e + this._bx) * e + this._cx) * e;
          }),
          (e.prototype._sampleCurveY = function (e) {
            return ((this._ay * e + this._by) * e + this._cy) * e;
          }),
          (e.prototype._sampleCurveDerivativeX = function (e) {
            return (3 * this._ax * e + 2 * this._bx) * e + this._cx;
          }),
          (e.prototype._solveCurveX = function (e, t) {
            var n, i, r, s, a, o;
            for (
              r = void 0,
                s = void 0,
                a = void 0,
                o = void 0,
                n = void 0,
                i = void 0,
                a = e,
                i = 0;
              i < 8;

            ) {
              if (((o = this._sampleCurveX(a) - e), Math.abs(o) < t)) return a;
              if (((n = this._sampleCurveDerivativeX(a)), Math.abs(n) < t))
                break;
              (a -= o / n), i++;
            }
            if ((a = e) < (r = 0)) return r;
            if (a > (s = 1)) return s;
            for (; r < s; ) {
              if (((o = this._sampleCurveX(a)), Math.abs(o - e) < t)) return a;
              e > o ? (r = a) : (s = a), (a = 0.5 * (s - r) + r);
            }
            return a;
          }),
          (e.prototype.solve = function (e, t) {
            return this._sampleCurveY(this._solveCurveX(e, t));
          }),
          (e.prototype.solveSimple = function (e) {
            return this._sampleCurveY(this._solveCurveX(e, 1e-6));
          }),
          e
        );
      })();
    },
    9314: (e, t, n) => {
      "use strict";
      n.d(t, { i: () => In });
      var i = n(1773);
      const r = new WeakMap();
      var s = n(9791),
        a = n(2378),
        o = n(154);
      class l {
        constructor(e) {
          this.animations = e.filter(Boolean);
        }
        then(e, t) {
          return Promise.all(this.animations).then(e).catch(t);
        }
        getAll(e) {
          return this.animations[0][e];
        }
        setAll(e, t) {
          for (let n = 0; n < this.animations.length; n++)
            this.animations[n][e] = t;
        }
        attachTimeline(e) {
          const t = this.animations.map((t) => {
            if (!(0, o.J)() || !t.attachTimeline)
              return (
                t.pause(),
                (0, a.y)((e) => {
                  t.time = t.duration * e;
                }, e)
              );
            t.attachTimeline(e);
          });
          return () => {
            t.forEach((e, t) => {
              e && e(), this.animations[t].stop();
            });
          };
        }
        get time() {
          return this.getAll("time");
        }
        set time(e) {
          this.setAll("time", e);
        }
        get speed() {
          return this.getAll("speed");
        }
        set speed(e) {
          this.setAll("speed", e);
        }
        get duration() {
          let e = 0;
          for (let t = 0; t < this.animations.length; t++)
            e = Math.max(e, this.animations[t].duration);
          return e;
        }
        runAll(e) {
          this.animations.forEach((t) => t[e]());
        }
        play() {
          this.runAll("play");
        }
        pause() {
          this.runAll("pause");
        }
        stop() {
          this.runAll("stop");
        }
        cancel() {
          this.runAll("cancel");
        }
        complete() {
          this.runAll("complete");
        }
      }
      const c = [
          "transformPerspective",
          "x",
          "y",
          "z",
          "translateX",
          "translateY",
          "translateZ",
          "scale",
          "scaleX",
          "scaleY",
          "rotate",
          "rotateX",
          "rotateY",
          "rotateZ",
          "skew",
          "skewX",
          "skewY",
        ],
        u = new Set(c),
        h = (e) => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
        d = "data-" + h("framerAppearId"),
        p = (e) => 1e3 * e,
        f = (e) => e / 1e3,
        A = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 },
        g = { type: "keyframes", duration: 0.8 },
        m = { type: "keyframes", ease: [0.25, 0.1, 0.35, 1], duration: 0.3 },
        v = (e, { keyframes: t }) =>
          t.length > 2
            ? g
            : u.has(e)
            ? e.startsWith("scale")
              ? {
                  type: "spring",
                  stiffness: 550,
                  damping: 0 === t[1] ? 2 * Math.sqrt(550) : 30,
                  restSpeed: 10,
                }
              : A
            : m;
      function y(e, t) {
        return e[t] || e.default || e;
      }
      var x = n(6021);
      const _ = !1,
        b = (e) => null !== e;
      function E(e, { repeat: t, repeatType: n = "loop" }) {
        const i = e.filter(b);
        return i[t && "loop" !== n && t % 2 == 1 ? 0 : i.length - 1];
      }
      var w = n(4124);
      let C;
      function I() {
        C = void 0;
      }
      const S = {
          now: () => (
            void 0 === C &&
              S.set(
                w.uv.isProcessing || x.W.useManualTiming
                  ? w.uv.timestamp
                  : performance.now()
              ),
            C
          ),
          set: (e) => {
            (C = e), queueMicrotask(I);
          },
        },
        M = (e) => /^0[^.\s]+$/u.test(e);
      const T = (e) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e);
      var B = n(5813);
      const R = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
      function D(e, t, n = 1) {
        (0, s.V)(
          n <= 4,
          `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`
        );
        const [i, r] = (function (e) {
          const t = R.exec(e);
          if (!t) return [,];
          const [, n, i, r] = t;
          return [`--${null != n ? n : i}`, r];
        })(e);
        if (!i) return;
        const a = window.getComputedStyle(t).getPropertyValue(i);
        if (a) {
          const e = a.trim();
          return T(e) ? parseFloat(e) : e;
        }
        return (0, B.p)(r) ? D(r, t, n + 1) : r;
      }
      var P = n(8411),
        L = n(4238);
      const U = new Set([
          "width",
          "height",
          "top",
          "left",
          "right",
          "bottom",
          "x",
          "y",
          "translateX",
          "translateY",
        ]),
        F = (e) => e === P.ai || e === L.px,
        N = (e, t) => parseFloat(e.split(", ")[t]),
        O =
          (e, t) =>
          (n, { transform: i }) => {
            if ("none" === i || !i) return 0;
            const r = i.match(/^matrix3d\((.+)\)$/u);
            if (r) return N(r[1], t);
            {
              const t = i.match(/^matrix\((.+)\)$/u);
              return t ? N(t[1], e) : 0;
            }
          },
        Q = new Set(["x", "y", "z"]),
        k = c.filter((e) => !Q.has(e));
      const G = {
        width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) =>
          e.max - e.min - parseFloat(t) - parseFloat(n),
        height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) =>
          e.max - e.min - parseFloat(t) - parseFloat(n),
        top: (e, { top: t }) => parseFloat(t),
        left: (e, { left: t }) => parseFloat(t),
        bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min),
        right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min),
        x: O(4, 13),
        y: O(5, 14),
      };
      (G.translateX = G.x), (G.translateY = G.y);
      const H = (e) => (t) => t.test(e),
        z = [
          P.ai,
          L.px,
          L.KN,
          L.uj,
          L.vw,
          L.vh,
          { test: (e) => "auto" === e, parse: (e) => e },
        ],
        V = (e) => z.find(H(e)),
        W = new Set();
      let j = !1,
        q = !1;
      function Y() {
        q &&
          (W.forEach((e) => {
            e.needsMeasurement && e.unsetTransforms();
          }),
          W.forEach((e) => {
            e.needsMeasurement && e.measureInitialState();
          }),
          W.forEach((e) => {
            e.needsMeasurement && e.renderEndStyles();
          }),
          W.forEach((e) => {
            e.needsMeasurement && e.measureEndState();
          })),
          (q = !1),
          (j = !1),
          W.forEach((e) => e.complete()),
          W.clear();
      }
      function X() {
        W.forEach((e) => {
          e.readKeyframes(), e.needsMeasurement && (q = !0);
        }),
          w.Gt.resolveKeyframes(Y);
      }
      class K {
        constructor(e, t, n, i, r, s = !1) {
          (this.isComplete = !1),
            (this.isAsync = !1),
            (this.needsMeasurement = !1),
            (this.isScheduled = !1),
            (this.unresolvedKeyframes = [...e]),
            (this.onComplete = t),
            (this.name = n),
            (this.motionValue = i),
            (this.element = r),
            (this.isAsync = s);
        }
        scheduleResolve() {
          (this.isScheduled = !0),
            this.isAsync
              ? (W.add(this), j || ((j = !0), w.Gt.read(X)))
              : (this.readKeyframes(), this.complete());
        }
        readKeyframes() {
          const {
            unresolvedKeyframes: e,
            name: t,
            element: n,
            motionValue: i,
          } = this;
          for (let r = 0; r < e.length; r++)
            if (null === e[r])
              if (0 === r) {
                const r = null == i ? void 0 : i.get(),
                  s = e[e.length - 1];
                if (void 0 !== r) e[0] = r;
                else if (n && t) {
                  const i = n.readValue(t, s);
                  null != i && (e[0] = i);
                }
                void 0 === e[0] && (e[0] = s), i && void 0 === r && i.set(e[0]);
              } else e[r] = e[r - 1];
        }
        unsetTransforms() {}
        measureInitialState() {}
        renderEndStyles() {}
        measureEndState() {}
        complete() {
          (this.isComplete = !0),
            this.onComplete(this.unresolvedKeyframes),
            W.delete(this);
        }
        cancel() {
          this.isComplete || ((this.isScheduled = !1), W.delete(this));
        }
        resume() {
          this.isComplete || this.scheduleResolve();
        }
      }
      var J = n(7865),
        Z = n(211);
      const $ = new Set(["brightness", "contrast", "saturate", "opacity"]);
      function ee(e) {
        const [t, n] = e.slice(0, -1).split("(");
        if ("drop-shadow" === t) return e;
        const [i] = n.match(Z.SY) || [];
        if (!i) return e;
        const r = n.replace(i, "");
        let s = $.has(t) ? 1 : 0;
        return i !== n && (s *= 100), t + "(" + s + r + ")";
      }
      const te = /\b([a-z-]*)\(.*?\)/gu,
        ne = {
          ...J.f,
          getAnimatableNone: (e) => {
            const t = e.match(te);
            return t ? t.map(ee).join(" ") : e;
          },
        };
      var ie = n(4984);
      const re = { ...P.ai, transform: Math.round },
        se = {
          borderWidth: L.px,
          borderTopWidth: L.px,
          borderRightWidth: L.px,
          borderBottomWidth: L.px,
          borderLeftWidth: L.px,
          borderRadius: L.px,
          radius: L.px,
          borderTopLeftRadius: L.px,
          borderTopRightRadius: L.px,
          borderBottomRightRadius: L.px,
          borderBottomLeftRadius: L.px,
          width: L.px,
          maxWidth: L.px,
          height: L.px,
          maxHeight: L.px,
          size: L.px,
          top: L.px,
          right: L.px,
          bottom: L.px,
          left: L.px,
          padding: L.px,
          paddingTop: L.px,
          paddingRight: L.px,
          paddingBottom: L.px,
          paddingLeft: L.px,
          margin: L.px,
          marginTop: L.px,
          marginRight: L.px,
          marginBottom: L.px,
          marginLeft: L.px,
          rotate: L.uj,
          rotateX: L.uj,
          rotateY: L.uj,
          rotateZ: L.uj,
          scale: P.hs,
          scaleX: P.hs,
          scaleY: P.hs,
          scaleZ: P.hs,
          skew: L.uj,
          skewX: L.uj,
          skewY: L.uj,
          distance: L.px,
          translateX: L.px,
          translateY: L.px,
          translateZ: L.px,
          x: L.px,
          y: L.px,
          z: L.px,
          perspective: L.px,
          transformPerspective: L.px,
          opacity: P.X4,
          originX: L.gQ,
          originY: L.gQ,
          originZ: L.px,
          zIndex: re,
          fillOpacity: P.X4,
          strokeOpacity: P.X4,
          numOctaves: re,
        },
        ae = {
          ...se,
          color: ie.y,
          backgroundColor: ie.y,
          outlineColor: ie.y,
          fill: ie.y,
          stroke: ie.y,
          borderColor: ie.y,
          borderTopColor: ie.y,
          borderRightColor: ie.y,
          borderBottomColor: ie.y,
          borderLeftColor: ie.y,
          filter: ne,
          WebkitFilter: ne,
        },
        oe = (e) => ae[e];
      function le(e, t) {
        let n = oe(e);
        return (
          n !== ne && (n = J.f),
          n.getAnimatableNone ? n.getAnimatableNone(t) : void 0
        );
      }
      class ce extends K {
        constructor(e, t, n, i) {
          super(e, t, n, i, null == i ? void 0 : i.owner, !0);
        }
        readKeyframes() {
          const { unresolvedKeyframes: e, element: t, name: n } = this;
          if (!t.current) return;
          const i = [];
          super.readKeyframes();
          for (let n = 0; n < e.length; n++) {
            const s = e[n];
            if ("string" == typeof s && (0, B.p)(s)) {
              const i = D(s, t.current);
              void 0 !== i && (e[n] = i);
            }
            ("number" == typeof (r = e[n])
              ? 0 === r
              : null === r || "none" === r || "0" === r || M(r)) && i.push(n);
          }
          var r;
          if (
            (i.length &&
              (function (e, t, n) {
                let i,
                  r = 0;
                for (; r < e.length && !i; )
                  "string" == typeof e[r] &&
                    "none" !== e[r] &&
                    "0" !== e[r] &&
                    (i = e[r]),
                    r++;
                if (i && n) for (const r of t) e[r] = le(n, i);
              })(e, i, n),
            !U.has(n) || 2 !== e.length)
          )
            return;
          const [s, a] = e,
            o = V(s),
            l = V(a);
          if (o && l && o !== l)
            if (F(o) && F(l))
              for (let t = 0; t < e.length; t++) {
                const n = e[t];
                "string" == typeof n && (e[t] = parseFloat(n));
              }
            else this.needsMeasurement = !0;
        }
        unsetTransforms() {
          const { element: e, name: t, unresolvedKeyframes: n } = this;
          if (!e.current) return;
          this.removedTransforms = (function (e) {
            const t = [];
            return (
              k.forEach((n) => {
                const i = e.getValue(n);
                void 0 !== i &&
                  (t.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0));
              }),
              t.length && e.render(),
              t
            );
          })(e);
          const i = n[n.length - 1];
          e.getValue(t, i).jump(i, !1);
        }
        measureInitialState() {
          const { element: e, unresolvedKeyframes: t, name: n } = this;
          e.current &&
            ("height" === n && (this.suspendedScrollY = window.pageYOffset),
            (this.measuredOrigin = G[n](
              e.measureViewportBox(),
              window.getComputedStyle(e.current)
            )),
            (t[0] = this.measuredOrigin));
        }
        renderEndStyles() {
          this.element.render();
        }
        measureEndState() {
          var e;
          const { element: t, name: n, unresolvedKeyframes: i } = this;
          if (!t.current) return;
          const r = t.getValue(n);
          r && r.jump(this.measuredOrigin, !1),
            (i[i.length - 1] = G[n](
              t.measureViewportBox(),
              window.getComputedStyle(t.current)
            )),
            "height" === n &&
              void 0 !== this.suspendedScrollY &&
              window.scrollTo(0, this.suspendedScrollY),
            (null === (e = this.removedTransforms) || void 0 === e
              ? void 0
              : e.length) &&
              this.removedTransforms.forEach(([e, n]) => {
                t.getValue(e).set(n);
              });
        }
      }
      var ue = n(3628),
        he = n(3146);
      const de = (e, t) =>
        "zIndex" !== t &&
        (!("number" != typeof e && !Array.isArray(e)) ||
          !(
            "string" != typeof e ||
            (!J.f.test(e) && "0" !== e) ||
            e.startsWith("url(")
          ));
      class pe {
        constructor({
          autoplay: e = !0,
          delay: t = 0,
          type: n = "keyframes",
          repeat: i = 0,
          repeatDelay: r = 0,
          repeatType: s = "loop",
          ...a
        }) {
          (this.isStopped = !1),
            (this.options = {
              autoplay: e,
              delay: t,
              type: n,
              repeat: i,
              repeatDelay: r,
              repeatType: s,
              ...a,
            }),
            this.updateFinishedPromise();
        }
        get resolved() {
          return (
            this._resolved || (X(), Y(), (0, w.WG)(X), (0, w.WG)(Y)),
            this._resolved
          );
        }
        onKeyframesResolved(e) {
          const {
            name: t,
            type: n,
            velocity: i,
            delay: r,
            onComplete: a,
            onUpdate: o,
          } = this.options;
          if (
            !(function (e, t, n, i) {
              const r = e[0];
              if (null === r) return !1;
              const a = e[e.length - 1],
                o = de(r, t),
                l = de(a, t);
              return (
                (0, s.$)(
                  o === l,
                  `You are trying to animate ${t} from "${r}" to "${a}". ${r} is not an animatable value - to enable this animation set ${r} to a value animatable to ${a} via the \`style\` property.`
                ),
                !(!o || !l) &&
                  ((function (e) {
                    const t = e[0];
                    if (1 === e.length) return !0;
                    for (let n = 0; n < e.length; n++)
                      if (e[n] !== t) return !0;
                  })(e) ||
                    ("spring" === n && i))
              );
            })(e, t, n, i)
          ) {
            if (_ || !r) {
              const t = E(e, this.options);
              return (
                null == o || o(t),
                null == a || a(),
                this.resolveFinishedPromise(),
                void this.updateFinishedPromise()
              );
            }
            this.options.duration = 0;
          }
          (this._resolved = { keyframes: e, ...this.initPlayback(e) }),
            this.onPostResolved();
        }
        onPostResolved() {}
        then(e, t) {
          return this.currentFinishedPromise.then(e, t);
        }
        updateFinishedPromise() {
          this.currentFinishedPromise = new Promise((e) => {
            this.resolveFinishedPromise = () => {
              e(), this.updateFinishedPromise();
            };
          });
        }
      }
      var fe = n(6898);
      const Ae = 5;
      function ge(e, t, n) {
        const i = Math.max(t - Ae, 0);
        return (0, fe.f)(n - e(i), t - i);
      }
      var me = n(9239);
      const ve = 0.001,
        ye = 0.01,
        xe = 10,
        _e = 0.05,
        be = 1;
      function Ee({
        duration: e = 800,
        bounce: t = 0.25,
        velocity: n = 0,
        mass: i = 1,
      }) {
        let r, a;
        (0, s.$)(e <= p(xe), "Spring duration must be 10 seconds or less");
        let o = 1 - t;
        (o = (0, me.q)(_e, be, o)),
          (e = (0, me.q)(ye, xe, f(e))),
          o < 1
            ? ((r = (t) => {
                const i = t * o,
                  r = i * e,
                  s = i - n,
                  a = Ce(t, o),
                  l = Math.exp(-r);
                return ve - (s / a) * l;
              }),
              (a = (t) => {
                const i = t * o * e,
                  s = i * n + n,
                  a = Math.pow(o, 2) * Math.pow(t, 2) * e,
                  l = Math.exp(-i),
                  c = Ce(Math.pow(t, 2), o);
                return ((-r(t) + ve > 0 ? -1 : 1) * ((s - a) * l)) / c;
              }))
            : ((r = (t) => Math.exp(-t * e) * ((t - n) * e + 1) - ve),
              (a = (t) => Math.exp(-t * e) * (e * e * (n - t))));
        const l = (function (e, t, n) {
          let i = n;
          for (let n = 1; n < we; n++) i -= e(i) / t(i);
          return i;
        })(r, a, 5 / e);
        if (((e = p(e)), isNaN(l)))
          return { stiffness: 100, damping: 10, duration: e };
        {
          const t = Math.pow(l, 2) * i;
          return {
            stiffness: t,
            damping: 2 * o * Math.sqrt(i * t),
            duration: e,
          };
        }
      }
      const we = 12;
      function Ce(e, t) {
        return e * Math.sqrt(1 - t * t);
      }
      const Ie = ["duration", "bounce"],
        Se = ["stiffness", "damping", "mass"];
      function Me(e, t) {
        return t.some((t) => void 0 !== e[t]);
      }
      function Te({ keyframes: e, restDelta: t, restSpeed: n, ...i }) {
        const r = e[0],
          s = e[e.length - 1],
          a = { done: !1, value: r },
          {
            stiffness: o,
            damping: l,
            mass: c,
            duration: u,
            velocity: h,
            isResolvedFromDuration: d,
          } = (function (e) {
            let t = {
              velocity: 0,
              stiffness: 100,
              damping: 10,
              mass: 1,
              isResolvedFromDuration: !1,
              ...e,
            };
            if (!Me(e, Se) && Me(e, Ie)) {
              const n = Ee(e);
              (t = { ...t, ...n, mass: 1 }), (t.isResolvedFromDuration = !0);
            }
            return t;
          })({ ...i, velocity: -f(i.velocity || 0) }),
          p = h || 0,
          A = l / (2 * Math.sqrt(o * c)),
          g = s - r,
          m = f(Math.sqrt(o / c)),
          v = Math.abs(g) < 5;
        let y;
        if ((n || (n = v ? 0.01 : 2), t || (t = v ? 0.005 : 0.5), A < 1)) {
          const e = Ce(m, A);
          y = (t) => {
            const n = Math.exp(-A * m * t);
            return (
              s -
              n *
                (((p + A * m * g) / e) * Math.sin(e * t) + g * Math.cos(e * t))
            );
          };
        } else if (1 === A)
          y = (e) => s - Math.exp(-m * e) * (g + (p + m * g) * e);
        else {
          const e = m * Math.sqrt(A * A - 1);
          y = (t) => {
            const n = Math.exp(-A * m * t),
              i = Math.min(e * t, 300);
            return (
              s -
              (n * ((p + A * m * g) * Math.sinh(i) + e * g * Math.cosh(i))) / e
            );
          };
        }
        return {
          calculatedDuration: (d && u) || null,
          next: (e) => {
            const i = y(e);
            if (d) a.done = e >= u;
            else {
              let r = p;
              0 !== e && (r = A < 1 ? ge(y, e, i) : 0);
              const o = Math.abs(r) <= n,
                l = Math.abs(s - i) <= t;
              a.done = o && l;
            }
            return (a.value = a.done ? s : i), a;
          },
        };
      }
      function Be({
        keyframes: e,
        velocity: t = 0,
        power: n = 0.8,
        timeConstant: i = 325,
        bounceDamping: r = 10,
        bounceStiffness: s = 500,
        modifyTarget: a,
        min: o,
        max: l,
        restDelta: c = 0.5,
        restSpeed: u,
      }) {
        const h = e[0],
          d = { done: !1, value: h },
          p = (e) =>
            void 0 === o
              ? l
              : void 0 === l || Math.abs(o - e) < Math.abs(l - e)
              ? o
              : l;
        let f = n * t;
        const A = h + f,
          g = void 0 === a ? A : a(A);
        g !== A && (f = g - h);
        const m = (e) => -f * Math.exp(-e / i),
          v = (e) => g + m(e),
          y = (e) => {
            const t = m(e),
              n = v(e);
            (d.done = Math.abs(t) <= c), (d.value = d.done ? g : n);
          };
        let x, _;
        const b = (e) => {
          var t;
          ((t = d.value), (void 0 !== o && t < o) || (void 0 !== l && t > l)) &&
            ((x = e),
            (_ = Te({
              keyframes: [d.value, p(d.value)],
              velocity: ge(v, e, d.value),
              damping: r,
              stiffness: s,
              restDelta: c,
              restSpeed: u,
            })));
        };
        return (
          b(0),
          {
            calculatedDuration: null,
            next: (e) => {
              let t = !1;
              return (
                _ || void 0 !== x || ((t = !0), y(e), b(e)),
                void 0 !== x && e >= x ? _.next(e - x) : (!t && y(e), d)
              );
            },
          }
        );
      }
      const Re = (e, t, n) =>
          (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e,
        De = 1e-7,
        Pe = 12;
      function Le(e, t, n, i) {
        if (e === t && n === i) return he.l;
        const r = (t) =>
          (function (e, t, n, i, r) {
            let s,
              a,
              o = 0;
            do {
              (a = t + (n - t) / 2),
                (s = Re(a, i, r) - e),
                s > 0 ? (n = a) : (t = a);
            } while (Math.abs(s) > De && ++o < Pe);
            return a;
          })(t, 0, 1, e, n);
        return (e) => (0 === e || 1 === e ? e : Re(r(e), t, i));
      }
      const Ue = Le(0.42, 0, 1, 1),
        Fe = Le(0, 0, 0.58, 1),
        Ne = Le(0.42, 0, 0.58, 1),
        Oe = (e) => Array.isArray(e) && "number" != typeof e[0],
        Qe = (e) => (t) => t <= 0.5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2,
        ke = (e) => (t) => 1 - e(1 - t),
        Ge = (e) => 1 - Math.sin(Math.acos(e)),
        He = ke(Ge),
        ze = Qe(Ge),
        Ve = Le(0.33, 1.53, 0.69, 0.99),
        We = ke(Ve),
        je = Qe(We),
        qe = {
          linear: he.l,
          easeIn: Ue,
          easeInOut: Ne,
          easeOut: Fe,
          circIn: Ge,
          circInOut: ze,
          circOut: He,
          backIn: We,
          backInOut: je,
          backOut: Ve,
          anticipate: (e) =>
            (e *= 2) < 1 ? 0.5 * We(e) : 0.5 * (2 - Math.pow(2, -10 * (e - 1))),
        },
        Ye = (e) => {
          if (Array.isArray(e)) {
            (0, s.V)(
              4 === e.length,
              "Cubic bezier arrays must contain four numerical values."
            );
            const [t, n, i, r] = e;
            return Le(t, n, i, r);
          }
          return "string" == typeof e
            ? ((0, s.V)(void 0 !== qe[e], `Invalid easing type '${e}'`), qe[e])
            : e;
        };
      var Xe = n(3167),
        Ke = n(8952);
      function Je({
        duration: e = 300,
        keyframes: t,
        times: n,
        ease: i = "easeInOut",
      }) {
        const r = Oe(i) ? i.map(Ye) : Ye(i),
          s = { done: !1, value: t[0] },
          a = (function (e, t) {
            return e.map((e) => e * t);
          })(n && n.length === t.length ? n : (0, Ke.Z)(t), e),
          o = (0, Xe.G)(a, t, {
            ease: Array.isArray(r)
              ? r
              : ((l = t),
                (c = r),
                l.map(() => c || Ne).splice(0, l.length - 1)),
          });
        var l, c;
        return {
          calculatedDuration: e,
          next: (t) => ((s.value = o(t)), (s.done = t >= e), s),
        };
      }
      var Ze = n(2302),
        $e = n(1105);
      const et = 2e4;
      function tt(e) {
        let t = 0;
        let n = e.next(t);
        for (; !n.done && t < et; ) (t += 50), (n = e.next(t));
        return t >= et ? 1 / 0 : t;
      }
      const nt = (e) => {
          const t = ({ timestamp: t }) => e(t);
          return {
            start: () => w.Gt.update(t, !0),
            stop: () => (0, w.WG)(t),
            now: () => (w.uv.isProcessing ? w.uv.timestamp : S.now()),
          };
        },
        it = { decay: Be, inertia: Be, tween: Je, keyframes: Je, spring: Te },
        rt = (e) => e / 100;
      class st extends pe {
        constructor({ KeyframeResolver: e = K, ...t }) {
          super(t),
            (this.holdTime = null),
            (this.startTime = null),
            (this.cancelTime = null),
            (this.currentTime = 0),
            (this.playbackSpeed = 1),
            (this.pendingPlayState = "running"),
            (this.state = "idle");
          const { name: n, motionValue: i, keyframes: r } = this.options,
            s = (e) => this.onKeyframesResolved(e);
          n && i && i.owner
            ? (this.resolver = i.owner.resolveKeyframes(r, s, n, i))
            : (this.resolver = new e(r, s, n, i)),
            this.resolver.scheduleResolve();
        }
        initPlayback(e) {
          const {
              type: t = "keyframes",
              repeat: n = 0,
              repeatDelay: i = 0,
              repeatType: r,
              velocity: s = 0,
            } = this.options,
            a = it[t] || Je;
          let o, l;
          a !== Je &&
            "number" != typeof e[0] &&
            ((o = (0, Ze.F)(rt, (0, $e.j)(e[0], e[1]))), (e = [0, 100]));
          const c = a({ ...this.options, keyframes: e });
          "mirror" === r &&
            (l = a({
              ...this.options,
              keyframes: [...e].reverse(),
              velocity: -s,
            })),
            null === c.calculatedDuration && (c.calculatedDuration = tt(c));
          const { calculatedDuration: u } = c,
            h = u + i;
          return {
            generator: c,
            mirroredGenerator: l,
            mapPercentToKeyframes: o,
            calculatedDuration: u,
            resolvedDuration: h,
            totalDuration: h * (n + 1) - i,
          };
        }
        onPostResolved() {
          const { autoplay: e = !0 } = this.options;
          this.play(),
            "paused" !== this.pendingPlayState && e
              ? (this.state = this.pendingPlayState)
              : this.pause();
        }
        tick(e, t = !1) {
          const {
            generator: n,
            mirroredGenerator: i,
            mapPercentToKeyframes: r,
            keyframes: s,
            calculatedDuration: a,
            totalDuration: o,
            resolvedDuration: l,
          } = this.resolved;
          if (null === this.startTime) return n.next(0);
          const {
            delay: c,
            repeat: u,
            repeatType: h,
            repeatDelay: d,
            onUpdate: p,
          } = this.options;
          this.speed > 0
            ? (this.startTime = Math.min(this.startTime, e))
            : this.speed < 0 &&
              (this.startTime = Math.min(e - o / this.speed, this.startTime)),
            t
              ? (this.currentTime = e)
              : null !== this.holdTime
              ? (this.currentTime = this.holdTime)
              : (this.currentTime =
                  Math.round(e - this.startTime) * this.speed);
          const f = this.currentTime - c * (this.speed >= 0 ? 1 : -1),
            A = this.speed >= 0 ? f < 0 : f > o;
          (this.currentTime = Math.max(f, 0)),
            "finished" === this.state &&
              null === this.holdTime &&
              (this.currentTime = o);
          let g = this.currentTime,
            m = n;
          if (u) {
            const e = Math.min(this.currentTime, o) / l;
            let t = Math.floor(e),
              n = e % 1;
            !n && e >= 1 && (n = 1), 1 === n && t--, (t = Math.min(t, u + 1));
            Boolean(t % 2) &&
              ("reverse" === h
                ? ((n = 1 - n), d && (n -= d / l))
                : "mirror" === h && (m = i)),
              (g = (0, me.q)(0, 1, n) * l);
          }
          const v = A ? { done: !1, value: s[0] } : m.next(g);
          r && (v.value = r(v.value));
          let { done: y } = v;
          A ||
            null === a ||
            (y =
              this.speed >= 0 ? this.currentTime >= o : this.currentTime <= 0);
          const x =
            null === this.holdTime &&
            ("finished" === this.state || ("running" === this.state && y));
          return p && p(v.value), x && this.finish(), v;
        }
        get duration() {
          return f(this.resolved.calculatedDuration);
        }
        get time() {
          return f(this.currentTime);
        }
        set time(e) {
          (e = p(e)),
            (this.currentTime = e),
            null !== this.holdTime || 0 === this.speed
              ? (this.holdTime = e)
              : this.driver &&
                (this.startTime = this.driver.now() - e / this.speed);
        }
        get speed() {
          return this.playbackSpeed;
        }
        set speed(e) {
          const t = this.playbackSpeed !== e;
          (this.playbackSpeed = e), t && (this.time = f(this.currentTime));
        }
        play() {
          if (
            (this.resolver.isScheduled || this.resolver.resume(),
            !this._resolved)
          )
            return void (this.pendingPlayState = "running");
          if (this.isStopped) return;
          const { driver: e = nt, onPlay: t } = this.options;
          this.driver || (this.driver = e((e) => this.tick(e))), t && t();
          const n = this.driver.now();
          null !== this.holdTime
            ? (this.startTime = n - this.holdTime)
            : (this.startTime && "finished" !== this.state) ||
              (this.startTime = n),
            "finished" === this.state && this.updateFinishedPromise(),
            (this.cancelTime = this.startTime),
            (this.holdTime = null),
            (this.state = "running"),
            this.driver.start();
        }
        pause() {
          var e;
          this._resolved
            ? ((this.state = "paused"),
              (this.holdTime =
                null !== (e = this.currentTime) && void 0 !== e ? e : 0))
            : (this.pendingPlayState = "paused");
        }
        stop() {
          if (((this.isStopped = !0), "idle" === this.state)) return;
          this.state = "idle";
          const { onStop: e } = this.options;
          e && e(), this.teardown();
        }
        complete() {
          "running" !== this.state && this.play(),
            (this.pendingPlayState = this.state = "finished"),
            (this.holdTime = null);
        }
        finish() {
          this.teardown(), (this.state = "finished");
          const { onComplete: e } = this.options;
          e && e();
        }
        cancel() {
          null !== this.cancelTime && this.tick(this.cancelTime),
            this.teardown();
        }
        teardown() {
          (this.state = "idle"),
            this.stopDriver(),
            this.resolveFinishedPromise(),
            this.updateFinishedPromise(),
            (this.startTime = this.cancelTime = null),
            this.resolver.cancel();
        }
        stopDriver() {
          this.driver && (this.driver.stop(), (this.driver = void 0));
        }
        sample(e) {
          return (this.startTime = 0), this.tick(e, !0);
        }
      }
      const at = (e) => Array.isArray(e) && "number" == typeof e[0];
      function ot(e) {
        return Boolean(
          !e ||
            ("string" == typeof e && ct[e]) ||
            at(e) ||
            (Array.isArray(e) && e.every(ot))
        );
      }
      const lt = ([e, t, n, i]) => `cubic-bezier(${e}, ${t}, ${n}, ${i})`,
        ct = {
          linear: "linear",
          ease: "ease",
          easeIn: "ease-in",
          easeOut: "ease-out",
          easeInOut: "ease-in-out",
          circIn: lt([0, 0.65, 0.55, 1]),
          circOut: lt([0.55, 0, 1, 0.45]),
          backIn: lt([0.31, 0.01, 0.66, -0.59]),
          backOut: lt([0.33, 1.53, 0.69, 0.99]),
        };
      function ut(e) {
        if (e) return at(e) ? lt(e) : Array.isArray(e) ? e.map(ut) : ct[e];
      }
      const ht = (0, ue.p)(() =>
          Object.hasOwnProperty.call(Element.prototype, "animate")
        ),
        dt = new Set(["opacity", "clipPath", "filter", "transform"]);
      class pt extends pe {
        constructor(e) {
          super(e);
          const { name: t, motionValue: n, keyframes: i } = this.options;
          (this.resolver = new ce(i, (e) => this.onKeyframesResolved(e), t, n)),
            this.resolver.scheduleResolve();
        }
        initPlayback(e) {
          let t = this.options.duration || 300;
          if (
            "spring" === (n = this.options).type ||
            "backgroundColor" === n.name ||
            !ot(n.ease)
          ) {
            const {
                onComplete: n,
                onUpdate: i,
                motionValue: r,
                ...s
              } = this.options,
              a = (function (e, t) {
                const n = new st({ ...t, keyframes: e, repeat: 0, delay: 0 });
                let i = { done: !1, value: e[0] };
                const r = [];
                let s = 0;
                for (; !i.done && s < 2e4; )
                  (i = n.sample(s)), r.push(i.value), (s += 10);
                return {
                  times: void 0,
                  keyframes: r,
                  duration: s - 10,
                  ease: "linear",
                };
              })(e, s);
            (e = a.keyframes),
              (t = a.duration),
              (this.options.times = a.times),
              (this.options.ease = a.ease);
          }
          var n;
          const { motionValue: i, name: r } = this.options,
            s = (function (
              e,
              t,
              n,
              {
                delay: i = 0,
                duration: r = 300,
                repeat: s = 0,
                repeatType: a = "loop",
                ease: o,
                times: l,
              } = {}
            ) {
              const c = { [t]: n };
              l && (c.offset = l);
              const u = ut(o);
              return (
                Array.isArray(u) && (c.easing = u),
                e.animate(c, {
                  delay: i,
                  duration: r,
                  easing: Array.isArray(u) ? "linear" : u,
                  fill: "both",
                  iterations: s + 1,
                  direction: "reverse" === a ? "alternate" : "normal",
                })
              );
            })(i.owner.current, r, e, { ...this.options, duration: t });
          return (
            (s.startTime = S.now()),
            this.pendingTimeline
              ? ((s.timeline = this.pendingTimeline),
                (this.pendingTimeline = void 0))
              : (s.onfinish = () => {
                  const { onComplete: t } = this.options;
                  i.set(E(e, this.options)),
                    t && t(),
                    this.cancel(),
                    this.resolveFinishedPromise(),
                    this.updateFinishedPromise();
                }),
            { animation: s, duration: t, keyframes: e }
          );
        }
        get duration() {
          const { duration: e } = this.resolved;
          return f(e);
        }
        get time() {
          const { animation: e } = this.resolved;
          return f(e.currentTime || 0);
        }
        set time(e) {
          const { animation: t } = this.resolved;
          t.currentTime = p(e);
        }
        get speed() {
          const { animation: e } = this.resolved;
          return e.playbackRate;
        }
        set speed(e) {
          const { animation: t } = this.resolved;
          t.playbackRate = e;
        }
        get state() {
          const { animation: e } = this.resolved;
          return e.playState;
        }
        attachTimeline(e) {
          if (this._resolved) {
            const { animation: t } = this.resolved;
            (t.timeline = e), (t.onfinish = null);
          } else this.pendingTimeline = e;
          return he.l;
        }
        play() {
          if (this.isStopped) return;
          const { animation: e } = this.resolved;
          e.play();
        }
        pause() {
          const { animation: e } = this.resolved;
          e.pause();
        }
        stop() {
          this.isStopped = !0;
          const { animation: e, keyframes: t } = this.resolved;
          if ("idle" !== e.playState && "finished" !== e.playState) {
            if (this.time) {
              const {
                  motionValue: e,
                  onUpdate: n,
                  onComplete: i,
                  ...r
                } = this.options,
                s = new st({ ...r, keyframes: t });
              e.setWithVelocity(
                s.sample(this.time - 10).value,
                s.sample(this.time).value,
                10
              );
            }
            this.cancel();
          }
        }
        complete() {
          this.resolved.animation.finish();
        }
        cancel() {
          this.resolved.animation.cancel();
        }
        static supports(e) {
          const {
            motionValue: t,
            name: n,
            repeatDelay: i,
            repeatType: r,
            damping: s,
            type: a,
          } = e;
          return (
            ht() &&
            n &&
            dt.has(n) &&
            t &&
            t.owner &&
            t.owner.current instanceof HTMLElement &&
            !t.owner.getProps().onUpdate &&
            !i &&
            "mirror" !== r &&
            0 !== s &&
            "inertia" !== a
          );
        }
      }
      const ft =
          (e, t, n, i = {}, r, s) =>
          (a) => {
            const o = y(i, e) || {},
              l = o.delay || i.delay || 0;
            let { elapsed: c = 0 } = i;
            c -= p(l);
            let u = {
              keyframes: Array.isArray(n) ? n : [null, n],
              ease: "easeOut",
              velocity: t.getVelocity(),
              ...o,
              delay: -c,
              onUpdate: (e) => {
                t.set(e), o.onUpdate && o.onUpdate(e);
              },
              onComplete: () => {
                a(), o.onComplete && o.onComplete();
              },
              name: e,
              motionValue: t,
              element: s ? void 0 : r,
            };
            (function ({
              when: e,
              delay: t,
              delayChildren: n,
              staggerChildren: i,
              staggerDirection: r,
              repeat: s,
              repeatType: a,
              repeatDelay: o,
              from: l,
              elapsed: c,
              ...u
            }) {
              return !!Object.keys(u).length;
            })(o) || (u = { ...u, ...v(e, u) }),
              u.duration && (u.duration = p(u.duration)),
              u.repeatDelay && (u.repeatDelay = p(u.repeatDelay)),
              void 0 !== u.from && (u.keyframes[0] = u.from);
            let h = !1;
            if (
              (!1 === u.type && ((u.duration = 0), 0 === u.delay && (h = !0)),
              (_ || x.W.skipAnimations) &&
                ((h = !0), (u.duration = 0), (u.delay = 0)),
              h && !s && void 0 !== t.get())
            ) {
              const e = E(u.keyframes, o);
              if (void 0 !== e)
                return void w.Gt.update(() => {
                  u.onUpdate(e), u.onComplete();
                });
            }
            return !s && pt.supports(u) ? new pt(u) : new st(u);
          },
        At = (e) => Boolean(e && e.getVelocity);
      function gt(e) {
        return Boolean(At(e) && e.add);
      }
      const mt = (e) =>
        ((e) => Array.isArray(e))(e) ? e[e.length - 1] || 0 : e;
      function vt(e, t) {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1);
      }
      class yt {
        constructor() {
          this.subscriptions = [];
        }
        add(e) {
          var t, n;
          return (
            (t = this.subscriptions),
            (n = e),
            -1 === t.indexOf(n) && t.push(n),
            () => vt(this.subscriptions, e)
          );
        }
        notify(e, t, n) {
          const i = this.subscriptions.length;
          if (i)
            if (1 === i) this.subscriptions[0](e, t, n);
            else
              for (let r = 0; r < i; r++) {
                const i = this.subscriptions[r];
                i && i(e, t, n);
              }
        }
        getSize() {
          return this.subscriptions.length;
        }
        clear() {
          this.subscriptions.length = 0;
        }
      }
      const xt = { current: void 0 };
      class _t {
        constructor(e, t = {}) {
          var n;
          (this.version = "11.0.12"),
            (this.canTrackVelocity = !1),
            (this.events = {}),
            (this.updateAndNotify = (e, t = !0) => {
              const n = S.now();
              this.updatedAt !== n && this.setPrevFrameValue(),
                (this.prev = this.current),
                this.setCurrent(e),
                this.current !== this.prev &&
                  this.events.change &&
                  this.events.change.notify(this.current),
                t &&
                  this.events.renderRequest &&
                  this.events.renderRequest.notify(this.current);
            }),
            (this.hasAnimated = !1),
            this.setCurrent(e),
            (this.canTrackVelocity =
              ((n = this.current), !isNaN(parseFloat(n)))),
            (this.owner = t.owner);
        }
        setCurrent(e) {
          (this.current = e), (this.updatedAt = S.now());
        }
        setPrevFrameValue(e = this.current) {
          (this.prevFrameValue = e), (this.prevUpdatedAt = this.updatedAt);
        }
        onChange(e) {
          return this.on("change", e);
        }
        on(e, t) {
          this.events[e] || (this.events[e] = new yt());
          const n = this.events[e].add(t);
          return "change" === e
            ? () => {
                n(),
                  w.Gt.read(() => {
                    this.events.change.getSize() || this.stop();
                  });
              }
            : n;
        }
        clearListeners() {
          for (const e in this.events) this.events[e].clear();
        }
        attach(e, t) {
          (this.passiveEffect = e), (this.stopPassiveEffect = t);
        }
        set(e, t = !0) {
          t && this.passiveEffect
            ? this.passiveEffect(e, this.updateAndNotify)
            : this.updateAndNotify(e, t);
        }
        setWithVelocity(e, t, n) {
          this.set(t),
            (this.prev = void 0),
            (this.prevFrameValue = e),
            (this.prevUpdatedAt = this.updatedAt - n);
        }
        jump(e, t = !0) {
          this.updateAndNotify(e),
            (this.prev = e),
            (this.prevUpdatedAt = this.prevFrameValue = void 0),
            t && this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
        get() {
          return xt.current && xt.current.push(this), this.current;
        }
        getPrevious() {
          return this.prev;
        }
        getVelocity() {
          const e = S.now();
          if (
            !this.canTrackVelocity ||
            void 0 === this.prevFrameValue ||
            e - this.updatedAt > 30
          )
            return 0;
          const t = Math.min(this.updatedAt - this.prevUpdatedAt, 30);
          return (0, fe.f)(
            parseFloat(this.current) - parseFloat(this.prevFrameValue),
            t
          );
        }
        start(e) {
          return (
            this.stop(),
            new Promise((t) => {
              (this.hasAnimated = !0),
                (this.animation = e(t)),
                this.events.animationStart &&
                  this.events.animationStart.notify();
            }).then(() => {
              this.events.animationComplete &&
                this.events.animationComplete.notify(),
                this.clearAnimation();
            })
          );
        }
        stop() {
          this.animation &&
            (this.animation.stop(),
            this.events.animationCancel &&
              this.events.animationCancel.notify()),
            this.clearAnimation();
        }
        isAnimating() {
          return !!this.animation;
        }
        clearAnimation() {
          delete this.animation;
        }
        destroy() {
          this.clearListeners(),
            this.stop(),
            this.stopPassiveEffect && this.stopPassiveEffect();
        }
      }
      function bt(e, t) {
        return new _t(e, t);
      }
      function Et(e, t, n, i = {}, r = {}) {
        return (
          "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
          "string" == typeof t && (t = e.variants && e.variants[t]),
          "function" == typeof t && (t = t(void 0 !== n ? n : e.custom, i, r)),
          t
        );
      }
      function wt(e, t, n) {
        e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, bt(n));
      }
      function Ct(e, t) {
        const n = (function (e, t, n) {
          const i = e.getProps();
          return Et(
            i,
            t,
            void 0 !== n ? n : i.custom,
            (function (e) {
              const t = {};
              return e.values.forEach((e, n) => (t[n] = e.get())), t;
            })(e),
            (function (e) {
              const t = {};
              return e.values.forEach((e, n) => (t[n] = e.getVelocity())), t;
            })(e)
          );
        })(e, t);
        let { transitionEnd: i = {}, transition: r = {}, ...s } = n || {};
        s = { ...s, ...i };
        for (const t in s) {
          wt(e, t, mt(s[t]));
        }
      }
      function It({ protectedKeys: e, needsAnimating: t }, n) {
        const i = e.hasOwnProperty(n) && !0 !== t[n];
        return (t[n] = !1), i;
      }
      function St(e, t, { delay: n = 0, transitionOverride: i, type: r } = {}) {
        var s;
        let {
          transition: a = e.getDefaultTransition(),
          transitionEnd: o,
          ...l
        } = t;
        const c = e.getValue("willChange");
        i && (a = i);
        const h = [],
          p = r && e.animationState && e.animationState.getState()[r];
        for (const t in l) {
          const i = e.getValue(
              t,
              null !== (s = e.latestValues[t]) && void 0 !== s ? s : null
            ),
            r = l[t];
          if (void 0 === r || (p && It(p, t))) continue;
          const o = { delay: n, elapsed: 0, ...y(a || {}, t) };
          let f = !1;
          if (window.HandoffAppearAnimations) {
            const n = e.getProps()[d];
            if (n) {
              const e = window.HandoffAppearAnimations(n, t);
              null !== e && ((o.elapsed = e), (f = !0));
            }
          }
          i.start(
            ft(
              t,
              i,
              r,
              e.shouldReduceMotion && u.has(t) ? { type: !1 } : o,
              e,
              f
            )
          );
          const A = i.animation;
          A && (gt(c) && (c.add(t), A.then(() => c.remove(t))), h.push(A));
        }
        return (
          o &&
            Promise.all(h).then(() => {
              w.Gt.update(() => {
                o && Ct(e, o);
              });
            }),
          h
        );
      }
      const Mt = {};
      function Tt(e, { layout: t, layoutId: n }) {
        return (
          u.has(e) ||
          e.startsWith("origin") ||
          ((t || void 0 !== n) && (!!Mt[e] || "opacity" === e))
        );
      }
      function Bt(e, t) {
        const { style: n } = e,
          i = {};
        for (const r in n)
          (At(n[r]) || (t.style && At(t.style[r])) || Tt(r, e)) &&
            (i[r] = n[r]);
        return i;
      }
      const Rt = "undefined" != typeof document,
        Dt = { current: null },
        Pt = { current: !1 };
      function Lt(e) {
        return "string" == typeof e || Array.isArray(e);
      }
      const Ut = [
        "initial",
        "animate",
        "whileInView",
        "whileFocus",
        "whileHover",
        "whileTap",
        "whileDrag",
        "exit",
      ];
      function Ft(e) {
        return (
          (null !== (t = e.animate) &&
            "object" == typeof t &&
            "function" == typeof t.start) ||
          Ut.some((t) => Lt(e[t]))
        );
        var t;
      }
      const Nt = {
          animation: [
            "animate",
            "variants",
            "whileHover",
            "whileTap",
            "exit",
            "whileInView",
            "whileFocus",
            "whileDrag",
          ],
          exit: ["exit"],
          drag: ["drag", "dragControls"],
          focus: ["whileFocus"],
          hover: ["whileHover", "onHoverStart", "onHoverEnd"],
          tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
          pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
          inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
          layout: ["layout", "layoutId"],
        },
        Ot = {};
      for (const e in Nt)
        Ot[e] = { isEnabled: (t) => Nt[e].some((e) => !!t[e]) };
      const Qt = [...z, ie.y, J.f],
        kt = Object.keys(Ot),
        Gt = kt.length,
        Ht = [
          "AnimationStart",
          "AnimationComplete",
          "Update",
          "BeforeLayoutMeasure",
          "LayoutMeasure",
          "LayoutAnimationStart",
          "LayoutAnimationComplete",
        ],
        zt = Ut.length;
      class Vt {
        constructor(
          {
            parent: e,
            props: t,
            presenceContext: n,
            reducedMotionConfig: i,
            blockInitialAnimation: r,
            visualState: s,
          },
          a = {}
        ) {
          (this.resolveKeyframes = (e, t, n, i) =>
            new this.KeyframeResolver(e, t, n, i, this)),
            (this.current = null),
            (this.children = new Set()),
            (this.isVariantNode = !1),
            (this.isControllingVariants = !1),
            (this.shouldReduceMotion = null),
            (this.values = new Map()),
            (this.KeyframeResolver = K),
            (this.features = {}),
            (this.valueSubscriptions = new Map()),
            (this.prevMotionValues = {}),
            (this.events = {}),
            (this.propEventSubscriptions = {}),
            (this.notifyUpdate = () =>
              this.notify("Update", this.latestValues)),
            (this.render = () => {
              this.current &&
                (this.triggerBuild(),
                this.renderInstance(
                  this.current,
                  this.renderState,
                  this.props.style,
                  this.projection
                ));
            }),
            (this.scheduleRender = () => w.Gt.render(this.render, !1, !0));
          const { latestValues: o, renderState: l } = s;
          (this.latestValues = o),
            (this.baseTarget = { ...o }),
            (this.initialValues = t.initial ? { ...o } : {}),
            (this.renderState = l),
            (this.parent = e),
            (this.props = t),
            (this.presenceContext = n),
            (this.depth = e ? e.depth + 1 : 0),
            (this.reducedMotionConfig = i),
            (this.options = a),
            (this.blockInitialAnimation = Boolean(r)),
            (this.isControllingVariants = Ft(t)),
            (this.isVariantNode = (function (e) {
              return Boolean(Ft(e) || e.variants);
            })(t)),
            this.isVariantNode && (this.variantChildren = new Set()),
            (this.manuallyAnimateOnMount = Boolean(e && e.current));
          const { willChange: c, ...u } = this.scrapeMotionValuesFromProps(
            t,
            {}
          );
          for (const e in u) {
            const t = u[e];
            void 0 !== o[e] && At(t) && (t.set(o[e], !1), gt(c) && c.add(e));
          }
        }
        scrapeMotionValuesFromProps(e, t) {
          return {};
        }
        mount(e) {
          (this.current = e),
            r.set(e, this),
            this.projection &&
              !this.projection.instance &&
              this.projection.mount(e),
            this.parent &&
              this.isVariantNode &&
              !this.isControllingVariants &&
              (this.removeFromVariantTree = this.parent.addVariantChild(this)),
            this.values.forEach((e, t) => this.bindToMotionValue(t, e)),
            Pt.current ||
              (function () {
                if (((Pt.current = !0), Rt))
                  if (window.matchMedia) {
                    const e = window.matchMedia("(prefers-reduced-motion)"),
                      t = () => (Dt.current = e.matches);
                    e.addListener(t), t();
                  } else Dt.current = !1;
              })(),
            (this.shouldReduceMotion =
              "never" !== this.reducedMotionConfig &&
              ("always" === this.reducedMotionConfig || Dt.current)),
            this.parent && this.parent.children.add(this),
            this.update(this.props, this.presenceContext);
        }
        unmount() {
          r.delete(this.current),
            this.projection && this.projection.unmount(),
            (0, w.WG)(this.notifyUpdate),
            (0, w.WG)(this.render),
            this.valueSubscriptions.forEach((e) => e()),
            this.removeFromVariantTree && this.removeFromVariantTree(),
            this.parent && this.parent.children.delete(this);
          for (const e in this.events) this.events[e].clear();
          for (const e in this.features) this.features[e].unmount();
          this.current = null;
        }
        bindToMotionValue(e, t) {
          const n = u.has(e),
            i = t.on("change", (t) => {
              (this.latestValues[e] = t),
                this.props.onUpdate && w.Gt.preRender(this.notifyUpdate),
                n && this.projection && (this.projection.isTransformDirty = !0);
            }),
            r = t.on("renderRequest", this.scheduleRender);
          this.valueSubscriptions.set(e, () => {
            i(), r();
          });
        }
        sortNodePosition(e) {
          return this.current &&
            this.sortInstanceNodePosition &&
            this.type === e.type
            ? this.sortInstanceNodePosition(this.current, e.current)
            : 0;
        }
        loadFeatures({ children: e, ...t }, n, i, r) {
          let s, a;
          for (let e = 0; e < Gt; e++) {
            const n = kt[e],
              {
                isEnabled: i,
                Feature: r,
                ProjectionNode: o,
                MeasureLayout: l,
              } = Ot[n];
            o && (s = o),
              i(t) &&
                (!this.features[n] && r && (this.features[n] = new r(this)),
                l && (a = l));
          }
          if (
            ("html" === this.type || "svg" === this.type) &&
            !this.projection &&
            s
          ) {
            this.projection = new s(
              this.latestValues,
              this.parent && this.parent.projection
            );
            const {
              layoutId: e,
              layout: n,
              drag: i,
              dragConstraints: a,
              layoutScroll: l,
              layoutRoot: c,
            } = t;
            this.projection.setOptions({
              layoutId: e,
              layout: n,
              alwaysMeasureLayout:
                Boolean(i) ||
                (a &&
                  ((o = a),
                  o &&
                    "object" == typeof o &&
                    Object.prototype.hasOwnProperty.call(o, "current"))),
              visualElement: this,
              scheduleRender: () => this.scheduleRender(),
              animationType: "string" == typeof n ? n : "both",
              initialPromotionConfig: r,
              layoutScroll: l,
              layoutRoot: c,
            });
          }
          var o;
          return a;
        }
        updateFeatures() {
          for (const e in this.features) {
            const t = this.features[e];
            t.isMounted ? t.update() : (t.mount(), (t.isMounted = !0));
          }
        }
        triggerBuild() {
          this.build(
            this.renderState,
            this.latestValues,
            this.options,
            this.props
          );
        }
        measureViewportBox() {
          return this.current
            ? this.measureInstanceViewportBox(this.current, this.props)
            : { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
        }
        getStaticValue(e) {
          return this.latestValues[e];
        }
        setStaticValue(e, t) {
          this.latestValues[e] = t;
        }
        update(e, t) {
          (e.transformTemplate || this.props.transformTemplate) &&
            this.scheduleRender(),
            (this.prevProps = this.props),
            (this.props = e),
            (this.prevPresenceContext = this.presenceContext),
            (this.presenceContext = t);
          for (let t = 0; t < Ht.length; t++) {
            const n = Ht[t];
            this.propEventSubscriptions[n] &&
              (this.propEventSubscriptions[n](),
              delete this.propEventSubscriptions[n]);
            const i = e["on" + n];
            i && (this.propEventSubscriptions[n] = this.on(n, i));
          }
          (this.prevMotionValues = (function (e, t, n) {
            const { willChange: i } = t;
            for (const r in t) {
              const s = t[r],
                a = n[r];
              if (At(s)) e.addValue(r, s), gt(i) && i.add(r);
              else if (At(a))
                e.addValue(r, bt(s, { owner: e })), gt(i) && i.remove(r);
              else if (a !== s)
                if (e.hasValue(r)) {
                  const t = e.getValue(r);
                  !t.hasAnimated && t.set(s);
                } else {
                  const t = e.getStaticValue(r);
                  e.addValue(r, bt(void 0 !== t ? t : s, { owner: e }));
                }
            }
            for (const i in n) void 0 === t[i] && e.removeValue(i);
            return t;
          })(
            this,
            this.scrapeMotionValuesFromProps(e, this.prevProps),
            this.prevMotionValues
          )),
            this.handleChildMotionValue && this.handleChildMotionValue();
        }
        getProps() {
          return this.props;
        }
        getVariant(e) {
          return this.props.variants ? this.props.variants[e] : void 0;
        }
        getDefaultTransition() {
          return this.props.transition;
        }
        getTransformPagePoint() {
          return this.props.transformPagePoint;
        }
        getClosestVariantNode() {
          return this.isVariantNode
            ? this
            : this.parent
            ? this.parent.getClosestVariantNode()
            : void 0;
        }
        getVariantContext(e = !1) {
          if (e) return this.parent ? this.parent.getVariantContext() : void 0;
          if (!this.isControllingVariants) {
            const e = (this.parent && this.parent.getVariantContext()) || {};
            return (
              void 0 !== this.props.initial && (e.initial = this.props.initial),
              e
            );
          }
          const t = {};
          for (let e = 0; e < zt; e++) {
            const n = Ut[e],
              i = this.props[n];
            (Lt(i) || !1 === i) && (t[n] = i);
          }
          return t;
        }
        addVariantChild(e) {
          const t = this.getClosestVariantNode();
          if (t)
            return (
              t.variantChildren && t.variantChildren.add(e),
              () => t.variantChildren.delete(e)
            );
        }
        addValue(e, t) {
          t !== this.values.get(e) &&
            (this.removeValue(e), this.bindToMotionValue(e, t)),
            this.values.set(e, t),
            (this.latestValues[e] = t.get());
        }
        removeValue(e) {
          this.values.delete(e);
          const t = this.valueSubscriptions.get(e);
          t && (t(), this.valueSubscriptions.delete(e)),
            delete this.latestValues[e],
            this.removeValueFromRenderState(e, this.renderState);
        }
        hasValue(e) {
          return this.values.has(e);
        }
        getValue(e, t) {
          if (this.props.values && this.props.values[e])
            return this.props.values[e];
          let n = this.values.get(e);
          return (
            void 0 === n &&
              void 0 !== t &&
              ((n = bt(null === t ? void 0 : t, { owner: this })),
              this.addValue(e, n)),
            n
          );
        }
        readValue(e, t) {
          var n;
          let i =
            void 0 === this.latestValues[e] && this.current
              ? null !== (n = this.getBaseTargetFromProps(this.props, e)) &&
                void 0 !== n
                ? n
                : this.readValueFromInstance(this.current, e, this.options)
              : this.latestValues[e];
          var r;
          return (
            null != i &&
              ("string" == typeof i && (T(i) || M(i))
                ? (i = parseFloat(i))
                : ((r = i), !Qt.find(H(r)) && J.f.test(t) && (i = le(e, t))),
              this.setBaseTarget(e, At(i) ? i.get() : i)),
            At(i) ? i.get() : i
          );
        }
        setBaseTarget(e, t) {
          this.baseTarget[e] = t;
        }
        getBaseTarget(e) {
          var t, n;
          const { initial: i } = this.props,
            r =
              "string" == typeof i || "object" == typeof i
                ? null ===
                    (n = Et(
                      this.props,
                      i,
                      null === (t = this.presenceContext) || void 0 === t
                        ? void 0
                        : t.custom
                    )) || void 0 === n
                  ? void 0
                  : n[e]
                : void 0;
          if (i && void 0 !== r) return r;
          const s = this.getBaseTargetFromProps(this.props, e);
          return void 0 === s || At(s)
            ? void 0 !== this.initialValues[e] && void 0 === r
              ? void 0
              : this.baseTarget[e]
            : s;
        }
        on(e, t) {
          return (
            this.events[e] || (this.events[e] = new yt()), this.events[e].add(t)
          );
        }
        notify(e, ...t) {
          this.events[e] && this.events[e].notify(...t);
        }
      }
      class Wt extends Vt {
        constructor() {
          super(...arguments), (this.KeyframeResolver = ce);
        }
        sortInstanceNodePosition(e, t) {
          return 2 & e.compareDocumentPosition(t) ? 1 : -1;
        }
        getBaseTargetFromProps(e, t) {
          return e.style ? e.style[t] : void 0;
        }
        removeValueFromRenderState(e, { vars: t, style: n }) {
          delete t[e], delete n[e];
        }
      }
      const jt = {
          x: "translateX",
          y: "translateY",
          z: "translateZ",
          transformPerspective: "perspective",
        },
        qt = c.length;
      const Yt = (e, t) => (t && "number" == typeof e ? t.transform(e) : e);
      function Xt(e, t, n, i) {
        const { style: r, vars: s, transform: a, transformOrigin: o } = e;
        let l = !1,
          h = !1,
          d = !0;
        for (const e in t) {
          const n = t[e];
          if ((0, B.j)(e)) {
            s[e] = n;
            continue;
          }
          const i = se[e],
            c = Yt(n, i);
          if (u.has(e)) {
            if (((l = !0), (a[e] = c), !d)) continue;
            n !== (i.default || 0) && (d = !1);
          } else e.startsWith("origin") ? ((h = !0), (o[e] = c)) : (r[e] = c);
        }
        if (
          (t.transform ||
            (l || i
              ? (r.transform = (function (
                  e,
                  {
                    enableHardwareAcceleration: t = !0,
                    allowTransformNone: n = !0,
                  },
                  i,
                  r
                ) {
                  let s = "";
                  for (let t = 0; t < qt; t++) {
                    const n = c[t];
                    void 0 !== e[n] && (s += `${jt[n] || n}(${e[n]}) `);
                  }
                  return (
                    t && !e.z && (s += "translateZ(0)"),
                    (s = s.trim()),
                    r ? (s = r(e, i ? "" : s)) : n && i && (s = "none"),
                    s
                  );
                })(e.transform, n, d, i))
              : r.transform && (r.transform = "none")),
          h)
        ) {
          const { originX: e = "50%", originY: t = "50%", originZ: n = 0 } = o;
          r.transformOrigin = `${e} ${t} ${n}`;
        }
      }
      function Kt(e, t, n) {
        return "string" == typeof e ? e : L.px.transform(t + n * e);
      }
      const Jt = { offset: "stroke-dashoffset", array: "stroke-dasharray" },
        Zt = { offset: "strokeDashoffset", array: "strokeDasharray" };
      function $t(
        e,
        {
          attrX: t,
          attrY: n,
          attrScale: i,
          originX: r,
          originY: s,
          pathLength: a,
          pathSpacing: o = 1,
          pathOffset: l = 0,
          ...c
        },
        u,
        h,
        d
      ) {
        if ((Xt(e, c, u, d), h))
          return void (e.style.viewBox && (e.attrs.viewBox = e.style.viewBox));
        (e.attrs = e.style), (e.style = {});
        const { attrs: p, style: f, dimensions: A } = e;
        p.transform && (A && (f.transform = p.transform), delete p.transform),
          A &&
            (void 0 !== r || void 0 !== s || f.transform) &&
            (f.transformOrigin = (function (e, t, n) {
              return `${Kt(t, e.x, e.width)} ${Kt(n, e.y, e.height)}`;
            })(A, void 0 !== r ? r : 0.5, void 0 !== s ? s : 0.5)),
          void 0 !== t && (p.x = t),
          void 0 !== n && (p.y = n),
          void 0 !== i && (p.scale = i),
          void 0 !== a &&
            (function (e, t, n = 1, i = 0, r = !0) {
              e.pathLength = 1;
              const s = r ? Jt : Zt;
              e[s.offset] = L.px.transform(-i);
              const a = L.px.transform(t),
                o = L.px.transform(n);
              e[s.array] = `${a} ${o}`;
            })(p, a, o, l, !1);
      }
      const en = new Set([
        "baseFrequency",
        "diffuseConstant",
        "kernelMatrix",
        "kernelUnitLength",
        "keySplines",
        "keyTimes",
        "limitingConeAngle",
        "markerHeight",
        "markerWidth",
        "numOctaves",
        "targetX",
        "targetY",
        "surfaceScale",
        "specularConstant",
        "specularExponent",
        "stdDeviation",
        "tableValues",
        "viewBox",
        "gradientTransform",
        "pathLength",
        "startOffset",
        "textLength",
        "lengthAdjust",
      ]);
      function tn(e, { style: t, vars: n }, i, r) {
        Object.assign(e.style, t, r && r.getProjectionStyles(i));
        for (const t in n) e.style.setProperty(t, n[t]);
      }
      class nn extends Wt {
        constructor() {
          super(...arguments), (this.type = "svg"), (this.isSVGTag = !1);
        }
        getBaseTargetFromProps(e, t) {
          return e[t];
        }
        readValueFromInstance(e, t) {
          if (u.has(t)) {
            const e = oe(t);
            return (e && e.default) || 0;
          }
          return (t = en.has(t) ? t : h(t)), e.getAttribute(t);
        }
        measureInstanceViewportBox() {
          return { x: { min: 0, max: 0 }, y: { min: 0, max: 0 } };
        }
        scrapeMotionValuesFromProps(e, t) {
          return (function (e, t) {
            const n = Bt(e, t);
            for (const i in e)
              (At(e[i]) || At(t[i])) &&
                (n[
                  -1 !== c.indexOf(i)
                    ? "attr" + i.charAt(0).toUpperCase() + i.substring(1)
                    : i
                ] = e[i]);
            return n;
          })(e, t);
        }
        build(e, t, n, i) {
          $t(e, t, n, this.isSVGTag, i.transformTemplate);
        }
        renderInstance(e, t, n, i) {
          !(function (e, t, n, i) {
            tn(e, t, void 0, i);
            for (const n in t.attrs)
              e.setAttribute(en.has(n) ? n : h(n), t.attrs[n]);
          })(e, t, 0, i);
        }
        mount(e) {
          var t;
          (this.isSVGTag =
            "string" == typeof (t = e.tagName) && "svg" === t.toLowerCase()),
            super.mount(e);
        }
      }
      function rn(e, t) {
        return (function ({ top: e, left: t, right: n, bottom: i }) {
          return { x: { min: t, max: n }, y: { min: e, max: i } };
        })(
          (function (e, t) {
            if (!t) return e;
            const n = t({ x: e.left, y: e.top }),
              i = t({ x: e.right, y: e.bottom });
            return { top: n.y, left: n.x, bottom: i.y, right: i.x };
          })(e.getBoundingClientRect(), t)
        );
      }
      class sn extends Wt {
        constructor() {
          super(...arguments), (this.type = "html");
        }
        readValueFromInstance(e, t) {
          if (u.has(t)) {
            const e = oe(t);
            return (e && e.default) || 0;
          }
          {
            const i = ((n = e), window.getComputedStyle(n)),
              r = ((0, B.j)(t) ? i.getPropertyValue(t) : i[t]) || 0;
            return "string" == typeof r ? r.trim() : r;
          }
          var n;
        }
        measureInstanceViewportBox(e, { transformPagePoint: t }) {
          return rn(e, t);
        }
        build(e, t, n, i) {
          Xt(e, t, n, i.transformTemplate);
        }
        scrapeMotionValuesFromProps(e, t) {
          return Bt(e, t);
        }
        handleChildMotionValue() {
          this.childSubscription &&
            (this.childSubscription(), delete this.childSubscription);
          const { children: e } = this.props;
          At(e) &&
            (this.childSubscription = e.on("change", (e) => {
              this.current && (this.current.textContent = `${e}`);
            }));
        }
        renderInstance(e, t, n, i) {
          tn(e, t, n, i);
        }
      }
      function an(e) {
        const t = {
            presenceContext: null,
            props: {},
            visualState: {
              renderState: {
                transform: {},
                transformOrigin: {},
                style: {},
                vars: {},
                attrs: {},
              },
              latestValues: {},
            },
          },
          n = (function (e) {
            return e instanceof SVGElement && "svg" !== e.tagName;
          })(e)
            ? new nn(t, { enableHardwareAcceleration: !1 })
            : new sn(t, { enableHardwareAcceleration: !0 });
        n.mount(e), r.set(e, n);
      }
      function on(e, t, n) {
        const i = At(e) ? e : bt(e);
        return i.start(ft("", i, t, n)), i.animation;
      }
      function ln(e, t = 100) {
        const n = Te({ keyframes: [0, t], ...e }),
          i = Math.min(tt(n), et);
        return {
          type: "keyframes",
          ease: (e) => n.next(i * e).value / t,
          duration: f(i),
        };
      }
      var cn = n(842),
        un = n(7699);
      function hn(e, t, n, i) {
        var r;
        return "number" == typeof t
          ? t
          : t.startsWith("-") || t.startsWith("+")
          ? Math.max(0, e + parseFloat(t))
          : "<" === t
          ? n
          : null !== (r = i.get(t)) && void 0 !== r
          ? r
          : e;
      }
      const dn = (e, t, n) => {
        const i = t - e;
        return ((((n - e) % i) + i) % i) + e;
      };
      function pn(e, t) {
        return Oe(e) ? e[dn(0, e.length, t)] : e;
      }
      var fn = n(5244);
      function An(e, t, n, i, r, s) {
        !(function (e, t, n) {
          for (let i = 0; i < e.length; i++) {
            const r = e[i];
            r.at > t && r.at < n && (vt(e, r), i--);
          }
        })(e, r, s);
        for (let a = 0; a < t.length; a++)
          e.push({ value: t[a], at: (0, fn.k)(r, s, i[a]), easing: pn(n, a) });
      }
      function gn(e, t) {
        return e.at === t.at
          ? null === e.value
            ? 1
            : null === t.value
            ? -1
            : 0
          : e.at - t.at;
      }
      const mn = "easeInOut";
      function vn(e, t) {
        return !t.has(e) && t.set(e, {}), t.get(e);
      }
      function yn(e, t) {
        return t[e] || (t[e] = []), t[e];
      }
      function xn(e) {
        return Array.isArray(e) ? e : [e];
      }
      function _n(e, t) {
        return e[t] ? { ...e, ...e[t] } : { ...e };
      }
      const bn = (e) => "number" == typeof e,
        En = (e) => e.every(bn);
      function wn(e, t, n, a) {
        const o = (0, i.K)(e, a),
          c = o.length;
        (0, s.V)(Boolean(c), "No valid element provided.");
        const u = [];
        for (let e = 0; e < c; e++) {
          const i = o[e];
          r.has(i) || an(i);
          const s = r.get(i),
            a = { ...n };
          "function" == typeof a.delay && (a.delay = a.delay(e, c)),
            u.push(...St(s, { ...t, transition: a }, {}));
        }
        return new l(u);
      }
      function Cn(e, t, n) {
        const r = [],
          s = (function (e, { defaultTransition: t = {}, ...n } = {}, r) {
            const s = t.duration || 0.3,
              a = new Map(),
              o = new Map(),
              l = {},
              c = new Map();
            let u = 0,
              h = 0,
              d = 0;
            for (let n = 0; n < e.length; n++) {
              const a = e[n];
              if ("string" == typeof a) {
                c.set(a, h);
                continue;
              }
              if (!Array.isArray(a)) {
                c.set(a.name, hn(h, a.at, u, c));
                continue;
              }
              let [f, A, g = {}] = a;
              void 0 !== g.at && (h = hn(h, g.at, u, c));
              let m = 0;
              const v = (e, n, i, r = 0, a = 0) => {
                const o = xn(e),
                  {
                    delay: l = 0,
                    times: c = (0, Ke.Z)(o),
                    type: u = "keyframes",
                    ...f
                  } = n;
                let { ease: A = t.ease || "easeOut", duration: g } = n;
                const v = "function" == typeof l ? l(r, a) : l,
                  y = o.length;
                if (y <= 2 && "spring" === u) {
                  let e = 100;
                  if (2 === y && En(o)) {
                    const t = o[1] - o[0];
                    e = Math.abs(t);
                  }
                  const t = { ...f };
                  void 0 !== g && (t.duration = p(g));
                  const n = ln(t, e);
                  (A = n.ease), (g = n.duration);
                }
                null != g || (g = s);
                const x = h + v,
                  _ = x + g;
                1 === c.length && 0 === c[0] && (c[1] = 1);
                const b = c.length - o.length;
                b > 0 && (0, cn.f)(c, b),
                  1 === o.length && o.unshift(null),
                  An(i, o, A, c, x, _),
                  (m = Math.max(v + g, m)),
                  (d = Math.max(_, d));
              };
              if (At(f)) v(A, g, yn("default", vn(f, o)));
              else {
                const e = (0, i.K)(f, r, l),
                  t = e.length;
                for (let n = 0; n < t; n++) {
                  const i = vn(e[n], o);
                  for (const e in A) v(A[e], _n(g, e), yn(e, i), n, t);
                }
              }
              (u = h), (h += m);
            }
            return (
              o.forEach((e, i) => {
                for (const r in e) {
                  const s = e[r];
                  s.sort(gn);
                  const o = [],
                    l = [],
                    c = [];
                  for (let e = 0; e < s.length; e++) {
                    const { at: t, value: n, easing: i } = s[e];
                    o.push(n),
                      l.push((0, un.q)(0, d, t)),
                      c.push(i || "easeOut");
                  }
                  0 !== l[0] && (l.unshift(0), o.unshift(o[0]), c.unshift(mn)),
                    1 !== l[l.length - 1] && (l.push(1), o.push(null)),
                    a.has(i) || a.set(i, { keyframes: {}, transition: {} });
                  const u = a.get(i);
                  (u.keyframes[r] = o),
                    (u.transition[r] = {
                      ...t,
                      duration: d,
                      ease: c,
                      times: l,
                      ...n,
                    });
                }
              }),
              a
            );
          })(e, t, n);
        return (
          s.forEach(({ keyframes: e, transition: t }, n) => {
            let i;
            (i = At(n) ? on(n, e.default, t.default) : wn(n, e, t)), r.push(i);
          }),
          new l(r)
        );
      }
      const In = function (e, t, n) {
        let i;
        var r;
        return (
          (r = e),
          (i =
            Array.isArray(r) && Array.isArray(r[0])
              ? Cn(e, t, Sn)
              : (function (e) {
                  return "object" == typeof e && !Array.isArray(e);
                })(t)
              ? wn(e, t, n, Sn)
              : on(e, t, n)),
          Sn && Sn.animations.push(i),
          i
        );
      };
      var Sn;
    },
    4124: (e, t, n) => {
      "use strict";
      n.d(t, { WG: () => l, Gt: () => o, uv: () => c });
      var i = n(3146),
        r = n(6021);
      class s {
        constructor() {
          (this.order = []), (this.scheduled = new Set());
        }
        add(e) {
          if (!this.scheduled.has(e))
            return this.scheduled.add(e), this.order.push(e), !0;
        }
        remove(e) {
          const t = this.order.indexOf(e);
          -1 !== t && (this.order.splice(t, 1), this.scheduled.delete(e));
        }
        clear() {
          (this.order.length = 0), this.scheduled.clear();
        }
      }
      const a = [
        "read",
        "resolveKeyframes",
        "update",
        "preRender",
        "render",
        "postRender",
      ];
      const {
        schedule: o,
        cancel: l,
        state: c,
        steps: u,
      } = (function (e, t) {
        let n = !1,
          i = !0;
        const o = { delta: 0, timestamp: 0, isProcessing: !1 },
          l = a.reduce(
            (e, t) => (
              (e[t] = (function (e) {
                let t = new s(),
                  n = new s(),
                  i = 0,
                  r = !1,
                  a = !1;
                const o = new WeakSet(),
                  l = {
                    schedule: (e, s = !1, a = !1) => {
                      const l = a && r,
                        c = l ? t : n;
                      return (
                        s && o.add(e),
                        c.add(e) && l && r && (i = t.order.length),
                        e
                      );
                    },
                    cancel: (e) => {
                      n.remove(e), o.delete(e);
                    },
                    process: (s) => {
                      if (r) a = !0;
                      else {
                        if (
                          ((r = !0),
                          ([t, n] = [n, t]),
                          n.clear(),
                          (i = t.order.length),
                          i)
                        )
                          for (let n = 0; n < i; n++) {
                            const i = t.order[n];
                            o.has(i) && (l.schedule(i), e()), i(s);
                          }
                        (r = !1), a && ((a = !1), l.process(s));
                      }
                    },
                  };
                return l;
              })(() => (n = !0))),
              e
            ),
            {}
          ),
          c = (e) => {
            l[e].process(o);
          },
          u = () => {
            const s = r.W.useManualTiming ? o.timestamp : performance.now();
            (n = !1),
              (o.delta = i
                ? 1e3 / 60
                : Math.max(Math.min(s - o.timestamp, 40), 1)),
              (o.timestamp = s),
              (o.isProcessing = !0),
              a.forEach(c),
              (o.isProcessing = !1),
              n && t && ((i = !1), e(u));
          };
        return {
          schedule: a.reduce((t, r) => {
            const s = l[r];
            return (
              (t[r] = (t, r = !1, a = !1) => (
                n || ((n = !0), (i = !0), o.isProcessing || e(u)),
                s.schedule(t, r, a)
              )),
              t
            );
          }, {}),
          cancel: (e) => a.forEach((t) => l[t].cancel(e)),
          state: o,
          steps: l,
        };
      })(
        "undefined" != typeof requestAnimationFrame
          ? requestAnimationFrame
          : i.l,
        !0
      );
    },
    5450: (e, t, n) => {
      "use strict";
      n.d(t, { W: () => O });
      var i = n(1773);
      const r = new WeakMap();
      let s;
      function a({ target: e, contentRect: t, borderBoxSize: n }) {
        var i;
        null === (i = r.get(e)) ||
          void 0 === i ||
          i.forEach((i) => {
            i({
              target: e,
              contentSize: t,
              get size() {
                return (function (e, t) {
                  if (t) {
                    const { inlineSize: e, blockSize: n } = t[0];
                    return { width: e, height: n };
                  }
                  return e instanceof SVGElement && "getBBox" in e
                    ? e.getBBox()
                    : { width: e.offsetWidth, height: e.offsetHeight };
                })(e, n);
              },
            });
          });
      }
      function o(e) {
        e.forEach(a);
      }
      function l(e, t) {
        s ||
          ("undefined" != typeof ResizeObserver && (s = new ResizeObserver(o)));
        const n = (0, i.K)(e);
        return (
          n.forEach((e) => {
            let n = r.get(e);
            n || ((n = new Set()), r.set(e, n)),
              n.add(t),
              null == s || s.observe(e);
          }),
          () => {
            n.forEach((e) => {
              const n = r.get(e);
              null == n || n.delete(t),
                (null == n ? void 0 : n.size) || null == s || s.unobserve(e);
            });
          }
        );
      }
      const c = new Set();
      let u;
      function h(e) {
        return (
          c.add(e),
          u ||
            ((u = () => {
              const e = {
                  width: window.innerWidth,
                  height: window.innerHeight,
                },
                t = { target: window, size: e, contentSize: e };
              c.forEach((e) => e(t));
            }),
            window.addEventListener("resize", u)),
          () => {
            c.delete(e), !c.size && u && (u = void 0);
          }
        );
      }
      var d = n(7699),
        p = n(6898);
      const f = 50,
        A = () => ({
          time: 0,
          x: {
            current: 0,
            offset: [],
            progress: 0,
            scrollLength: 0,
            targetOffset: 0,
            targetLength: 0,
            containerLength: 0,
            velocity: 0,
          },
          y: {
            current: 0,
            offset: [],
            progress: 0,
            scrollLength: 0,
            targetOffset: 0,
            targetLength: 0,
            containerLength: 0,
            velocity: 0,
          },
        }),
        g = {
          x: { length: "Width", position: "Left" },
          y: { length: "Height", position: "Top" },
        };
      function m(e, t, n, i) {
        const r = n[t],
          { length: s, position: a } = g[t],
          o = r.current,
          l = n.time;
        (r.current = e["scroll" + a]),
          (r.scrollLength = e["scroll" + s] - e["client" + s]),
          (r.offset.length = 0),
          (r.offset[0] = 0),
          (r.offset[1] = r.scrollLength),
          (r.progress = (0, d.q)(0, r.scrollLength, r.current));
        const c = i - l;
        r.velocity = c > f ? 0 : (0, p.f)(r.current - o, c);
      }
      const v = {
          Enter: [
            [0, 1],
            [1, 1],
          ],
          Exit: [
            [0, 0],
            [1, 0],
          ],
          Any: [
            [1, 0],
            [0, 1],
          ],
          All: [
            [0, 0],
            [1, 1],
          ],
        },
        y = { start: 0, center: 0.5, end: 1 };
      function x(e, t, n = 0) {
        let i = 0;
        if ((void 0 !== y[e] && (e = y[e]), "string" == typeof e)) {
          const t = parseFloat(e);
          e.endsWith("px")
            ? (i = t)
            : e.endsWith("%")
            ? (e = t / 100)
            : e.endsWith("vw")
            ? (i = (t / 100) * document.documentElement.clientWidth)
            : e.endsWith("vh")
            ? (i = (t / 100) * document.documentElement.clientHeight)
            : (e = t);
        }
        return "number" == typeof e && (i = t * e), n + i;
      }
      const _ = [0, 0];
      function b(e, t, n, i) {
        let r = Array.isArray(e) ? e : _,
          s = 0,
          a = 0;
        return (
          "number" == typeof e
            ? (r = [e, e])
            : "string" == typeof e &&
              (r = (e = e.trim()).includes(" ")
                ? e.split(" ")
                : [e, y[e] ? e : "0"]),
          (s = x(r[0], n, i)),
          (a = x(r[1], t)),
          s - a
        );
      }
      var E = n(3167),
        w = n(8952);
      const C = { x: 0, y: 0 };
      function I(e, t, n) {
        const { offset: i = v.All } = n,
          { target: r = e, axis: s = "y" } = n,
          a = "y" === s ? "height" : "width",
          o =
            r !== e
              ? (function (e, t) {
                  const n = { x: 0, y: 0 };
                  let i = e;
                  for (; i && i !== t; )
                    if (i instanceof HTMLElement)
                      (n.x += i.offsetLeft),
                        (n.y += i.offsetTop),
                        (i = i.offsetParent);
                    else if ("svg" === i.tagName) {
                      const e = i.getBoundingClientRect();
                      i = i.parentElement;
                      const t = i.getBoundingClientRect();
                      (n.x += e.left - t.left), (n.y += e.top - t.top);
                    } else {
                      if (!(i instanceof SVGGraphicsElement)) break;
                      {
                        const { x: e, y: t } = i.getBBox();
                        (n.x += e), (n.y += t);
                        let r = null,
                          s = i.parentNode;
                        for (; !r; )
                          "svg" === s.tagName && (r = s), (s = i.parentNode);
                        i = r;
                      }
                    }
                  return n;
                })(r, e)
              : C,
          l =
            r === e
              ? { width: e.scrollWidth, height: e.scrollHeight }
              : (function (e) {
                  return "getBBox" in e && "svg" !== e.tagName
                    ? e.getBBox()
                    : { width: e.clientWidth, height: e.clientHeight };
                })(r),
          c = { width: e.clientWidth, height: e.clientHeight };
        t[s].offset.length = 0;
        let u = !t[s].interpolate;
        const h = i.length;
        for (let e = 0; e < h; e++) {
          const n = b(i[e], c[a], l[a], o[s]);
          u || n === t[s].interpolatorOffsets[e] || (u = !0),
            (t[s].offset[e] = n);
        }
        u &&
          ((t[s].interpolate = (0, E.G)(t[s].offset, (0, w.Z)(i))),
          (t[s].interpolatorOffsets = [...t[s].offset])),
          (t[s].progress = t[s].interpolate(t[s].current));
      }
      function S(e, t, n, i = {}) {
        return {
          measure: () =>
            (function (e, t = e, n) {
              if (((n.x.targetOffset = 0), (n.y.targetOffset = 0), t !== e)) {
                let i = t;
                for (; i && i !== e; )
                  (n.x.targetOffset += i.offsetLeft),
                    (n.y.targetOffset += i.offsetTop),
                    (i = i.offsetParent);
              }
              (n.x.targetLength = t === e ? t.scrollWidth : t.clientWidth),
                (n.y.targetLength = t === e ? t.scrollHeight : t.clientHeight),
                (n.x.containerLength = e.clientWidth),
                (n.y.containerLength = e.clientHeight);
            })(e, i.target, n),
          update: (t) => {
            !(function (e, t, n) {
              m(e, "x", t, n), m(e, "y", t, n), (t.time = n);
            })(e, n, t),
              (i.offset || i.target) && I(e, n, i);
          },
          notify: () => t(n),
        };
      }
      var M = n(4124);
      const T = new WeakMap(),
        B = new WeakMap(),
        R = new WeakMap(),
        D = (e) => (e === document.documentElement ? window : e);
      function P(e, { container: t = document.documentElement, ...n } = {}) {
        let i = R.get(t);
        i || ((i = new Set()), R.set(t, i));
        const r = A(),
          s = S(t, e, r, n);
        if ((i.add(s), !T.has(t))) {
          const e = () => {
              for (const e of i) e.measure();
            },
            n = () => {
              for (const e of i) e.update(M.uv.timestamp);
            },
            r = () => {
              for (const e of i) e.notify();
            },
            s = () => {
              M.Gt.read(e, !1, !0),
                M.Gt.read(n, !1, !0),
                M.Gt.update(r, !1, !0);
            };
          T.set(t, s);
          const c = D(t);
          window.addEventListener("resize", s, { passive: !0 }),
            t !== document.documentElement &&
              B.set(
                t,
                ((o = s), "function" == typeof (a = t) ? h(a) : l(a, o))
              ),
            c.addEventListener("scroll", s, { passive: !0 });
        }
        var a, o;
        const c = T.get(t);
        return (
          M.Gt.read(c, !1, !0),
          () => {
            var e;
            (0, M.WG)(c);
            const n = R.get(t);
            if (!n) return;
            if ((n.delete(s), n.size)) return;
            const i = T.get(t);
            T.delete(t),
              i &&
                (D(t).removeEventListener("scroll", i),
                null === (e = B.get(t)) || void 0 === e || e(),
                window.removeEventListener("resize", i));
          }
        );
      }
      var L = n(2378),
        U = n(154);
      const F = new Map();
      function N({ source: e = document.documentElement, axis: t = "y" } = {}) {
        F.has(e) || F.set(e, {});
        const n = F.get(e);
        return (
          n[t] ||
            (n[t] = (0, U.J)()
              ? new ScrollTimeline({ source: e, axis: t })
              : (function ({ source: e, axis: t = "y" }) {
                  const n = { value: 0 },
                    i = P(
                      (e) => {
                        n.value = 100 * e[t].progress;
                      },
                      { container: e, axis: t }
                    );
                  return { currentTime: n, cancel: i };
                })({ source: e, axis: t })),
          n[t]
        );
      }
      function O(e, t) {
        const n = N(t);
        return "function" == typeof e ? (0, L.y)(e, n) : e.attachTimeline(n);
      }
    },
    2378: (e, t, n) => {
      "use strict";
      n.d(t, { y: () => r });
      var i = n(4124);
      function r(e, t) {
        let n;
        const r = () => {
          const { currentTime: i } = t,
            r = (null === i ? 0 : i.value) / 100;
          n !== r && e(r), (n = r);
        };
        return i.Gt.update(r, !0), () => (0, i.WG)(r);
      }
    },
    154: (e, t, n) => {
      "use strict";
      n.d(t, { J: () => i });
      const i = (0, n(3628).p)(() => void 0 !== window.ScrollTimeline);
    },
    5813: (e, t, n) => {
      "use strict";
      n.d(t, { j: () => r, p: () => a });
      const i = (e) => (t) => "string" == typeof t && t.startsWith(e),
        r = i("--"),
        s = i("var(--"),
        a = (e) => !!s(e) && o.test(e.split("/*")[0].trim()),
        o =
          /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
    },
    1773: (e, t, n) => {
      "use strict";
      n.d(t, { K: () => r });
      var i = n(9791);
      function r(e, t, n) {
        var r;
        if ("string" == typeof e) {
          let s = document;
          t &&
            ((0, i.V)(
              Boolean(t.current),
              "Scope provided, but no element detected."
            ),
            (s = t.current)),
            n
              ? ((null !== (r = n[e]) && void 0 !== r) ||
                  (n[e] = s.querySelectorAll(e)),
                (e = n[e]))
              : (e = s.querySelectorAll(e));
        } else e instanceof Element && (e = [e]);
        return Array.from(e || []);
      }
    },
    2407: (e, t, n) => {
      "use strict";
      n.d(t, { l: () => s });
      var i = n(1773);
      const r = { some: 0, all: 1 };
      function s(e, t, { root: n, margin: s, amount: a = "some" } = {}) {
        const o = (0, i.K)(e),
          l = new WeakMap(),
          c = new IntersectionObserver(
            (e) => {
              e.forEach((e) => {
                const n = l.get(e.target);
                if (e.isIntersecting !== Boolean(n))
                  if (e.isIntersecting) {
                    const n = t(e);
                    "function" == typeof n
                      ? l.set(e.target, n)
                      : c.unobserve(e.target);
                  } else n && (n(e), l.delete(e.target));
              });
            },
            {
              root: n,
              rootMargin: s,
              threshold: "number" == typeof a ? a : r[a],
            }
          );
        return o.forEach((e) => c.observe(e)), () => c.disconnect();
      }
    },
    6021: (e, t, n) => {
      "use strict";
      n.d(t, { W: () => i });
      const i = { skipAnimations: !1, useManualTiming: !1 };
    },
    9239: (e, t, n) => {
      "use strict";
      n.d(t, { q: () => i });
      const i = (e, t, n) => (n > t ? t : n < e ? e : n);
    },
    9791: (e, t, n) => {
      "use strict";
      n.d(t, { $: () => r, V: () => s });
      var i = n(3146);
      let r = i.l,
        s = i.l;
    },
    3167: (e, t, n) => {
      "use strict";
      n.d(t, { G: () => c });
      var i = n(9791),
        r = n(9239),
        s = n(2302),
        a = n(7699),
        o = n(3146),
        l = n(1105);
      function c(e, t, { clamp: n = !0, ease: c, mixer: u } = {}) {
        const h = e.length;
        if (
          ((0, i.V)(
            h === t.length,
            "Both input and output ranges must be the same length"
          ),
          1 === h)
        )
          return () => t[0];
        if (2 === h && e[0] === e[1]) return () => t[1];
        e[0] > e[h - 1] && ((e = [...e].reverse()), (t = [...t].reverse()));
        const d = (function (e, t, n) {
            const i = [],
              r = n || l.j,
              a = e.length - 1;
            for (let n = 0; n < a; n++) {
              let a = r(e[n], e[n + 1]);
              if (t) {
                const e = Array.isArray(t) ? t[n] || o.l : t;
                a = (0, s.F)(e, a);
              }
              i.push(a);
            }
            return i;
          })(t, c, u),
          p = d.length,
          f = (t) => {
            let n = 0;
            if (p > 1) for (; n < e.length - 2 && !(t < e[n + 1]); n++);
            const i = (0, a.q)(e[n], e[n + 1], t);
            return d[n](i);
          };
        return n ? (t) => f((0, r.q)(e[0], e[h - 1], t)) : f;
      }
    },
    3628: (e, t, n) => {
      "use strict";
      function i(e) {
        let t;
        return () => (void 0 === t && (t = e()), t);
      }
      n.d(t, { p: () => i });
    },
    1105: (e, t, n) => {
      "use strict";
      n.d(t, { j: () => E });
      var i = n(5244),
        r = n(9791);
      function s(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + (t - e) * (2 / 3 - n) * 6
            : e
        );
      }
      var a = n(9131),
        o = n(8678),
        l = n(2946);
      const c = (e, t, n) => {
          const i = e * e,
            r = n * (t * t - i) + i;
          return r < 0 ? 0 : Math.sqrt(r);
        },
        u = [a.u, o.B, l.V];
      function h(e) {
        const t = ((n = e), u.find((e) => e.test(n)));
        var n;
        (0, r.V)(
          Boolean(t),
          `'${e}' is not an animatable color. Use the equivalent color code instead.`
        );
        let i = t.parse(e);
        return (
          t === l.V &&
            (i = (function ({ hue: e, saturation: t, lightness: n, alpha: i }) {
              (e /= 360), (n /= 100);
              let r = 0,
                a = 0,
                o = 0;
              if ((t /= 100)) {
                const i = n < 0.5 ? n * (1 + t) : n + t - n * t,
                  l = 2 * n - i;
                (r = s(l, i, e + 1 / 3)),
                  (a = s(l, i, e)),
                  (o = s(l, i, e - 1 / 3));
              } else r = a = o = n;
              return {
                red: Math.round(255 * r),
                green: Math.round(255 * a),
                blue: Math.round(255 * o),
                alpha: i,
              };
            })(i)),
          i
        );
      }
      const d = (e, t) => {
        const n = h(e),
          r = h(t),
          s = { ...n };
        return (e) => (
          (s.red = c(n.red, r.red, e)),
          (s.green = c(n.green, r.green, e)),
          (s.blue = c(n.blue, r.blue, e)),
          (s.alpha = (0, i.k)(n.alpha, r.alpha, e)),
          o.B.transform(s)
        );
      };
      var p = n(2302),
        f = n(4984),
        A = n(7865),
        g = n(5813);
      function m(e, t) {
        return (n) => (n > 0 ? t : e);
      }
      function v(e, t) {
        return (n) => (0, i.k)(e, t, n);
      }
      function y(e) {
        return "number" == typeof e
          ? v
          : "string" == typeof e
          ? (0, g.p)(e)
            ? m
            : f.y.test(e)
            ? d
            : b
          : Array.isArray(e)
          ? x
          : "object" == typeof e
          ? f.y.test(e)
            ? d
            : _
          : m;
      }
      function x(e, t) {
        const n = [...e],
          i = n.length,
          r = e.map((e, n) => y(e)(e, t[n]));
        return (e) => {
          for (let t = 0; t < i; t++) n[t] = r[t](e);
          return n;
        };
      }
      function _(e, t) {
        const n = { ...e, ...t },
          i = {};
        for (const r in n)
          void 0 !== e[r] && void 0 !== t[r] && (i[r] = y(e[r])(e[r], t[r]));
        return (e) => {
          for (const t in i) n[t] = i[t](e);
          return n;
        };
      }
      const b = (e, t) => {
        const n = A.f.createTransformer(t),
          i = (0, A.V)(e),
          s = (0, A.V)(t);
        return i.indexes.var.length === s.indexes.var.length &&
          i.indexes.color.length === s.indexes.color.length &&
          i.indexes.number.length >= s.indexes.number.length
          ? (0, p.F)(
              x(
                (function (e, t) {
                  var n;
                  const i = [],
                    r = { color: 0, var: 0, number: 0 };
                  for (let s = 0; s < t.values.length; s++) {
                    const a = t.types[s],
                      o = e.indexes[a][r[a]],
                      l = null !== (n = e.values[o]) && void 0 !== n ? n : 0;
                    (i[s] = l), r[a]++;
                  }
                  return i;
                })(i, s),
                s.values
              ),
              n
            )
          : ((0, r.$)(
              !0,
              `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`
            ),
            m(e, t));
      };
      function E(e, t, n) {
        if (
          "number" == typeof e &&
          "number" == typeof t &&
          "number" == typeof n
        )
          return (0, i.k)(e, t, n);
        return y(e)(e, t);
      }
    },
    5244: (e, t, n) => {
      "use strict";
      n.d(t, { k: () => i });
      const i = (e, t, n) => e + (t - e) * n;
    },
    3146: (e, t, n) => {
      "use strict";
      n.d(t, { l: () => i });
      const i = (e) => e;
    },
    8952: (e, t, n) => {
      "use strict";
      n.d(t, { Z: () => r });
      var i = n(842);
      function r(e) {
        const t = [0];
        return (0, i.f)(t, e.length - 1), t;
      }
    },
    842: (e, t, n) => {
      "use strict";
      n.d(t, { f: () => s });
      var i = n(5244),
        r = n(7699);
      function s(e, t) {
        const n = e[e.length - 1];
        for (let s = 1; s <= t; s++) {
          const a = (0, r.q)(0, t, s);
          e.push((0, i.k)(n, 1, a));
        }
      }
    },
    2302: (e, t, n) => {
      "use strict";
      n.d(t, { F: () => r });
      const i = (e, t) => (n) => t(e(n)),
        r = (...e) => e.reduce(i);
    },
    7699: (e, t, n) => {
      "use strict";
      n.d(t, { q: () => i });
      const i = (e, t, n) => {
        const i = t - e;
        return 0 === i ? 1 : (n - e) / i;
      };
    },
    6898: (e, t, n) => {
      "use strict";
      function i(e, t) {
        return t ? e * (1e3 / t) : 0;
      }
      n.d(t, { f: () => i });
    },
    9131: (e, t, n) => {
      "use strict";
      n.d(t, { u: () => r });
      var i = n(8678);
      const r = {
        test: (0, n(8711).$)("#"),
        parse: function (e) {
          let t = "",
            n = "",
            i = "",
            r = "";
          return (
            e.length > 5
              ? ((t = e.substring(1, 3)),
                (n = e.substring(3, 5)),
                (i = e.substring(5, 7)),
                (r = e.substring(7, 9)))
              : ((t = e.substring(1, 2)),
                (n = e.substring(2, 3)),
                (i = e.substring(3, 4)),
                (r = e.substring(4, 5)),
                (t += t),
                (n += n),
                (i += i),
                (r += r)),
            {
              red: parseInt(t, 16),
              green: parseInt(n, 16),
              blue: parseInt(i, 16),
              alpha: r ? parseInt(r, 16) / 255 : 1,
            }
          );
        },
        transform: i.B.transform,
      };
    },
    2946: (e, t, n) => {
      "use strict";
      n.d(t, { V: () => o });
      var i = n(8411),
        r = n(4238),
        s = n(211),
        a = n(8711);
      const o = {
        test: (0, a.$)("hsl", "hue"),
        parse: (0, a.q)("hue", "saturation", "lightness"),
        transform: ({ hue: e, saturation: t, lightness: n, alpha: a = 1 }) =>
          "hsla(" +
          Math.round(e) +
          ", " +
          r.KN.transform((0, s.aj)(t)) +
          ", " +
          r.KN.transform((0, s.aj)(n)) +
          ", " +
          (0, s.aj)(i.X4.transform(a)) +
          ")",
      };
    },
    4984: (e, t, n) => {
      "use strict";
      n.d(t, { y: () => o });
      var i = n(211),
        r = n(9131),
        s = n(2946),
        a = n(8678);
      const o = {
        test: (e) => a.B.test(e) || r.u.test(e) || s.V.test(e),
        parse: (e) =>
          a.B.test(e)
            ? a.B.parse(e)
            : s.V.test(e)
            ? s.V.parse(e)
            : r.u.parse(e),
        transform: (e) =>
          (0, i.Kg)(e)
            ? e
            : e.hasOwnProperty("red")
            ? a.B.transform(e)
            : s.V.transform(e),
      };
    },
    8678: (e, t, n) => {
      "use strict";
      n.d(t, { B: () => l });
      var i = n(9239),
        r = n(8411),
        s = n(211),
        a = n(8711);
      const o = {
          ...r.ai,
          transform: (e) => Math.round(((e) => (0, i.q)(0, 255, e))(e)),
        },
        l = {
          test: (0, a.$)("rgb", "red"),
          parse: (0, a.q)("red", "green", "blue"),
          transform: ({ red: e, green: t, blue: n, alpha: i = 1 }) =>
            "rgba(" +
            o.transform(e) +
            ", " +
            o.transform(t) +
            ", " +
            o.transform(n) +
            ", " +
            (0, s.aj)(r.X4.transform(i)) +
            ")",
        };
    },
    8711: (e, t, n) => {
      "use strict";
      n.d(t, { $: () => r, q: () => s });
      var i = n(211);
      const r = (e, t) => (n) =>
          Boolean(
            ((0, i.Kg)(n) && i.Fl.test(n) && n.startsWith(e)) ||
              (t && Object.prototype.hasOwnProperty.call(n, t))
          ),
        s = (e, t, n) => (r) => {
          if (!(0, i.Kg)(r)) return r;
          const [s, a, o, l] = r.match(i.SY);
          return {
            [e]: parseFloat(s),
            [t]: parseFloat(a),
            [n]: parseFloat(o),
            alpha: void 0 !== l ? parseFloat(l) : 1,
          };
        };
    },
    7865: (e, t, n) => {
      "use strict";
      n.d(t, { V: () => h, f: () => A });
      var i = n(4984),
        r = n(211);
      const s = "number",
        a = "color",
        o = "var",
        l = "var(",
        c = "${}",
        u =
          /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
      function h(e) {
        const t = e.toString(),
          n = [],
          r = { color: [], number: [], var: [] },
          h = [];
        let d = 0;
        const p = t
          .replace(
            u,
            (e) => (
              i.y.test(e)
                ? (r.color.push(d), h.push(a), n.push(i.y.parse(e)))
                : e.startsWith(l)
                ? (r.var.push(d), h.push(o), n.push(e))
                : (r.number.push(d), h.push(s), n.push(parseFloat(e))),
              ++d,
              c
            )
          )
          .split(c);
        return { values: n, split: p, indexes: r, types: h };
      }
      function d(e) {
        return h(e).values;
      }
      function p(e) {
        const { split: t, types: n } = h(e),
          o = t.length;
        return (e) => {
          let l = "";
          for (let c = 0; c < o; c++)
            if (((l += t[c]), void 0 !== e[c])) {
              const t = n[c];
              l +=
                t === s
                  ? (0, r.aj)(e[c])
                  : t === a
                  ? i.y.transform(e[c])
                  : e[c];
            }
          return l;
        };
      }
      const f = (e) => ("number" == typeof e ? 0 : e);
      const A = {
        test: function (e) {
          var t, n;
          return (
            isNaN(e) &&
            (0, r.Kg)(e) &&
            ((null === (t = e.match(r.SY)) || void 0 === t
              ? void 0
              : t.length) || 0) +
              ((null === (n = e.match(r.ne)) || void 0 === n
                ? void 0
                : n.length) || 0) >
              0
          );
        },
        parse: d,
        createTransformer: p,
        getAnimatableNone: function (e) {
          const t = d(e);
          return p(e)(t.map(f));
        },
      };
    },
    8411: (e, t, n) => {
      "use strict";
      n.d(t, { X4: () => s, ai: () => r, hs: () => a });
      var i = n(9239);
      const r = {
          test: (e) => "number" == typeof e,
          parse: parseFloat,
          transform: (e) => e,
        },
        s = { ...r, transform: (e) => (0, i.q)(0, 1, e) },
        a = { ...r, default: 1 };
    },
    4238: (e, t, n) => {
      "use strict";
      n.d(t, {
        KN: () => a,
        gQ: () => u,
        px: () => o,
        uj: () => s,
        vh: () => l,
        vw: () => c,
      });
      var i = n(211);
      const r = (e) => ({
          test: (t) =>
            (0, i.Kg)(t) && t.endsWith(e) && 1 === t.split(" ").length,
          parse: parseFloat,
          transform: (t) => `${t}${e}`,
        }),
        s = r("deg"),
        a = r("%"),
        o = r("px"),
        l = r("vh"),
        c = r("vw"),
        u = {
          ...a,
          parse: (e) => a.parse(e) / 100,
          transform: (e) => a.transform(100 * e),
        };
    },
    211: (e, t, n) => {
      "use strict";
      n.d(t, {
        Fl: () => a,
        Kg: () => o,
        SY: () => r,
        aj: () => i,
        ne: () => s,
      });
      const i = (e) => Math.round(1e5 * e) / 1e5,
        r = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu,
        s =
          /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu,
        a =
          /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;
      function o(e) {
        return "string" == typeof e;
      }
    },
    5803: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => u });
      function i(e, t, n) {
        return Math.max(e, Math.min(t, n));
      }
      var r = class {
        isRunning = !1;
        value = 0;
        from = 0;
        to = 0;
        currentTime = 0;
        lerp;
        duration;
        easing;
        onUpdate;
        advance(e) {
          if (!this.isRunning) return;
          let t = !1;
          if (this.duration && this.easing) {
            this.currentTime += e;
            const n = i(0, this.currentTime / this.duration, 1);
            t = n >= 1;
            const r = t ? 1 : this.easing(n);
            this.value = this.from + (this.to - this.from) * r;
          } else
            this.lerp
              ? ((this.value = (function (e, t, n, i) {
                  return (function (e, t, n) {
                    return (1 - n) * e + n * t;
                  })(e, t, 1 - Math.exp(-n * i));
                })(this.value, this.to, 60 * this.lerp, e)),
                Math.round(this.value) === this.to &&
                  ((this.value = this.to), (t = !0)))
              : ((this.value = this.to), (t = !0));
          t && this.stop(), this.onUpdate?.(this.value, t);
        }
        stop() {
          this.isRunning = !1;
        }
        fromTo(
          e,
          t,
          { lerp: n, duration: i, easing: r, onStart: s, onUpdate: a }
        ) {
          (this.from = this.value = e),
            (this.to = t),
            (this.lerp = n),
            (this.duration = i),
            (this.easing = r),
            (this.currentTime = 0),
            (this.isRunning = !0),
            s?.(),
            (this.onUpdate = a);
        }
      };
      var s = class {
          constructor(e, t, { autoResize: n = !0, debounce: i = 250 } = {}) {
            (this.wrapper = e),
              (this.content = t),
              n &&
                ((this.debouncedResize = (function (e, t) {
                  let n;
                  return function (...i) {
                    let r = this;
                    clearTimeout(n),
                      (n = setTimeout(() => {
                        (n = void 0), e.apply(r, i);
                      }, t));
                  };
                })(this.resize, i)),
                this.wrapper instanceof Window
                  ? window.addEventListener("resize", this.debouncedResize, !1)
                  : ((this.wrapperResizeObserver = new ResizeObserver(
                      this.debouncedResize
                    )),
                    this.wrapperResizeObserver.observe(this.wrapper)),
                (this.contentResizeObserver = new ResizeObserver(
                  this.debouncedResize
                )),
                this.contentResizeObserver.observe(this.content)),
              this.resize();
          }
          width = 0;
          height = 0;
          scrollHeight = 0;
          scrollWidth = 0;
          debouncedResize;
          wrapperResizeObserver;
          contentResizeObserver;
          destroy() {
            this.wrapperResizeObserver?.disconnect(),
              this.contentResizeObserver?.disconnect(),
              this.wrapper === window &&
                this.debouncedResize &&
                window.removeEventListener("resize", this.debouncedResize, !1);
          }
          resize = () => {
            this.onWrapperResize(), this.onContentResize();
          };
          onWrapperResize = () => {
            this.wrapper instanceof Window
              ? ((this.width = window.innerWidth),
                (this.height = window.innerHeight))
              : ((this.width = this.wrapper.clientWidth),
                (this.height = this.wrapper.clientHeight));
          };
          onContentResize = () => {
            this.wrapper instanceof Window
              ? ((this.scrollHeight = this.content.scrollHeight),
                (this.scrollWidth = this.content.scrollWidth))
              : ((this.scrollHeight = this.wrapper.scrollHeight),
                (this.scrollWidth = this.wrapper.scrollWidth));
          };
          get limit() {
            return {
              x: this.scrollWidth - this.width,
              y: this.scrollHeight - this.height,
            };
          }
        },
        a = class {
          events = {};
          emit(e, ...t) {
            let n = this.events[e] || [];
            for (let e = 0, i = n.length; e < i; e++) n[e]?.(...t);
          }
          on(e, t) {
            return (
              this.events[e]?.push(t) || (this.events[e] = [t]),
              () => {
                this.events[e] = this.events[e]?.filter((e) => t !== e);
              }
            );
          }
          off(e, t) {
            this.events[e] = this.events[e]?.filter((e) => t !== e);
          }
          destroy() {
            this.events = {};
          }
        },
        o = 100 / 6,
        l = { passive: !1 },
        c = class {
          constructor(e, t = { wheelMultiplier: 1, touchMultiplier: 1 }) {
            (this.element = e),
              (this.options = t),
              window.addEventListener("resize", this.onWindowResize, !1),
              this.onWindowResize(),
              this.element.addEventListener("wheel", this.onWheel, l),
              this.element.addEventListener("touchstart", this.onTouchStart, l),
              this.element.addEventListener("touchmove", this.onTouchMove, l),
              this.element.addEventListener("touchend", this.onTouchEnd, l);
          }
          touchStart = { x: 0, y: 0 };
          lastDelta = { x: 0, y: 0 };
          window = { width: 0, height: 0 };
          emitter = new a();
          on(e, t) {
            return this.emitter.on(e, t);
          }
          destroy() {
            this.emitter.destroy(),
              window.removeEventListener("resize", this.onWindowResize, !1),
              this.element.removeEventListener("wheel", this.onWheel, l),
              this.element.removeEventListener(
                "touchstart",
                this.onTouchStart,
                l
              ),
              this.element.removeEventListener(
                "touchmove",
                this.onTouchMove,
                l
              ),
              this.element.removeEventListener("touchend", this.onTouchEnd, l);
          }
          onTouchStart = (e) => {
            const { clientX: t, clientY: n } = e.targetTouches
              ? e.targetTouches[0]
              : e;
            (this.touchStart.x = t),
              (this.touchStart.y = n),
              (this.lastDelta = { x: 0, y: 0 }),
              this.emitter.emit("scroll", { deltaX: 0, deltaY: 0, event: e });
          };
          onTouchMove = (e) => {
            const { clientX: t, clientY: n } = e.targetTouches
                ? e.targetTouches[0]
                : e,
              i = -(t - this.touchStart.x) * this.options.touchMultiplier,
              r = -(n - this.touchStart.y) * this.options.touchMultiplier;
            (this.touchStart.x = t),
              (this.touchStart.y = n),
              (this.lastDelta = { x: i, y: r }),
              this.emitter.emit("scroll", { deltaX: i, deltaY: r, event: e });
          };
          onTouchEnd = (e) => {
            this.emitter.emit("scroll", {
              deltaX: this.lastDelta.x,
              deltaY: this.lastDelta.y,
              event: e,
            });
          };
          onWheel = (e) => {
            let { deltaX: t, deltaY: n, deltaMode: i } = e;
            (t *= 1 === i ? o : 2 === i ? this.window.width : 1),
              (n *= 1 === i ? o : 2 === i ? this.window.height : 1),
              (t *= this.options.wheelMultiplier),
              (n *= this.options.wheelMultiplier),
              this.emitter.emit("scroll", { deltaX: t, deltaY: n, event: e });
          };
          onWindowResize = () => {
            this.window = {
              width: window.innerWidth,
              height: window.innerHeight,
            };
          };
        },
        u = class {
          _isScrolling = !1;
          _isStopped = !1;
          _isLocked = !1;
          _preventNextNativeScrollEvent = !1;
          _resetVelocityTimeout = null;
          __rafID = null;
          isTouching;
          time = 0;
          userData = {};
          lastVelocity = 0;
          velocity = 0;
          direction = 0;
          options;
          targetScroll;
          animatedScroll;
          animate = new r();
          emitter = new a();
          dimensions;
          virtualScroll;
          constructor({
            wrapper: e = window,
            content: t = document.documentElement,
            eventsTarget: n = e,
            smoothWheel: i = !0,
            syncTouch: r = !1,
            syncTouchLerp: a = 0.075,
            touchInertiaMultiplier: o = 35,
            duration: l,
            easing: u = (e) => Math.min(1, 1.001 - Math.pow(2, -10 * e)),
            lerp: h = 0.1,
            infinite: d = !1,
            orientation: p = "vertical",
            gestureOrientation: f = "vertical",
            touchMultiplier: A = 1,
            wheelMultiplier: g = 1,
            autoResize: m = !0,
            prevent: v,
            virtualScroll: y,
            overscroll: x = !0,
            autoRaf: _ = !1,
            __experimental__naiveDimensions: b = !1,
          } = {}) {
            (window.lenisVersion = "1.1.16"),
              (e && e !== document.documentElement && e !== document.body) ||
                (e = window),
              (this.options = {
                wrapper: e,
                content: t,
                eventsTarget: n,
                smoothWheel: i,
                syncTouch: r,
                syncTouchLerp: a,
                touchInertiaMultiplier: o,
                duration: l,
                easing: u,
                lerp: h,
                infinite: d,
                gestureOrientation: f,
                orientation: p,
                touchMultiplier: A,
                wheelMultiplier: g,
                autoResize: m,
                prevent: v,
                virtualScroll: y,
                overscroll: x,
                autoRaf: _,
                __experimental__naiveDimensions: b,
              }),
              (this.dimensions = new s(e, t, { autoResize: m })),
              this.updateClassName(),
              (this.targetScroll = this.animatedScroll = this.actualScroll),
              this.options.wrapper.addEventListener(
                "scroll",
                this.onNativeScroll,
                !1
              ),
              this.options.wrapper.addEventListener(
                "pointerdown",
                this.onPointerDown,
                !1
              ),
              (this.virtualScroll = new c(n, {
                touchMultiplier: A,
                wheelMultiplier: g,
              })),
              this.virtualScroll.on("scroll", this.onVirtualScroll),
              this.options.autoRaf &&
                (this.__rafID = requestAnimationFrame(this.raf));
          }
          destroy() {
            this.emitter.destroy(),
              this.options.wrapper.removeEventListener(
                "scroll",
                this.onNativeScroll,
                !1
              ),
              this.options.wrapper.removeEventListener(
                "pointerdown",
                this.onPointerDown,
                !1
              ),
              this.virtualScroll.destroy(),
              this.dimensions.destroy(),
              this.cleanUpClassName(),
              this.__rafID && cancelAnimationFrame(this.__rafID);
          }
          on(e, t) {
            return this.emitter.on(e, t);
          }
          off(e, t) {
            return this.emitter.off(e, t);
          }
          setScroll(e) {
            this.isHorizontal
              ? (this.rootElement.scrollLeft = e)
              : (this.rootElement.scrollTop = e);
          }
          onPointerDown = (e) => {
            1 === e.button && this.reset();
          };
          onVirtualScroll = (e) => {
            if (
              "function" == typeof this.options.virtualScroll &&
              !1 === this.options.virtualScroll(e)
            )
              return;
            const { deltaX: t, deltaY: n, event: i } = e;
            if (
              (this.emitter.emit("virtual-scroll", {
                deltaX: t,
                deltaY: n,
                event: i,
              }),
              i.ctrlKey)
            )
              return;
            if (i.lenisStopPropagation) return;
            const r = i.type.includes("touch"),
              s = i.type.includes("wheel");
            this.isTouching = "touchstart" === i.type || "touchmove" === i.type;
            if (
              this.options.syncTouch &&
              r &&
              "touchstart" === i.type &&
              !this.isStopped &&
              !this.isLocked
            )
              return void this.reset();
            const a = 0 === t && 0 === n,
              o =
                ("vertical" === this.options.gestureOrientation && 0 === n) ||
                ("horizontal" === this.options.gestureOrientation && 0 === t);
            if (a || o) return;
            let l = i.composedPath();
            l = l.slice(0, l.indexOf(this.rootElement));
            const c = this.options.prevent;
            if (
              l.find(
                (e) =>
                  e instanceof HTMLElement &&
                  (("function" == typeof c && c?.(e)) ||
                    e.hasAttribute?.("data-lenis-prevent") ||
                    (r && e.hasAttribute?.("data-lenis-prevent-touch")) ||
                    (s && e.hasAttribute?.("data-lenis-prevent-wheel")))
              )
            )
              return;
            if (this.isStopped || this.isLocked) return void i.preventDefault();
            if (
              !(
                (this.options.syncTouch && r) ||
                (this.options.smoothWheel && s)
              )
            )
              return (
                (this.isScrolling = "native"),
                this.animate.stop(),
                void (i.lenisStopPropagation = !0)
              );
            let u = n;
            "both" === this.options.gestureOrientation
              ? (u = Math.abs(n) > Math.abs(t) ? n : t)
              : "horizontal" === this.options.gestureOrientation && (u = t),
              (!this.options.overscroll ||
                this.options.infinite ||
                (this.options.wrapper !== window &&
                  ((this.animatedScroll > 0 &&
                    this.animatedScroll < this.limit) ||
                    (0 === this.animatedScroll && n > 0) ||
                    (this.animatedScroll === this.limit && n < 0)))) &&
                (i.lenisStopPropagation = !0),
              i.preventDefault();
            const h = r && this.options.syncTouch,
              d = r && "touchend" === i.type && Math.abs(u) > 5;
            d && (u = this.velocity * this.options.touchInertiaMultiplier),
              this.scrollTo(this.targetScroll + u, {
                programmatic: !1,
                ...(h
                  ? { lerp: d ? this.options.syncTouchLerp : 1 }
                  : {
                      lerp: this.options.lerp,
                      duration: this.options.duration,
                      easing: this.options.easing,
                    }),
              });
          };
          resize() {
            this.dimensions.resize(),
              (this.animatedScroll = this.targetScroll = this.actualScroll),
              this.emit();
          }
          emit() {
            this.emitter.emit("scroll", this);
          }
          onNativeScroll = () => {
            if (
              (null !== this._resetVelocityTimeout &&
                (clearTimeout(this._resetVelocityTimeout),
                (this._resetVelocityTimeout = null)),
              this._preventNextNativeScrollEvent)
            )
              this._preventNextNativeScrollEvent = !1;
            else if (!1 === this.isScrolling || "native" === this.isScrolling) {
              const e = this.animatedScroll;
              (this.animatedScroll = this.targetScroll = this.actualScroll),
                (this.lastVelocity = this.velocity),
                (this.velocity = this.animatedScroll - e),
                (this.direction = Math.sign(this.animatedScroll - e)),
                (this.isScrolling = "native"),
                this.emit(),
                0 !== this.velocity &&
                  (this._resetVelocityTimeout = setTimeout(() => {
                    (this.lastVelocity = this.velocity),
                      (this.velocity = 0),
                      (this.isScrolling = !1),
                      this.emit();
                  }, 400));
            }
          };
          reset() {
            (this.isLocked = !1),
              (this.isScrolling = !1),
              (this.animatedScroll = this.targetScroll = this.actualScroll),
              (this.lastVelocity = this.velocity = 0),
              this.animate.stop();
          }
          start() {
            this.isStopped && ((this.isStopped = !1), this.reset());
          }
          stop() {
            this.isStopped ||
              ((this.isStopped = !0), this.animate.stop(), this.reset());
          }
          raf = (e) => {
            const t = e - (this.time || e);
            (this.time = e),
              this.animate.advance(0.001 * t),
              this.options.autoRaf &&
                (this.__rafID = requestAnimationFrame(this.raf));
          };
          scrollTo(
            e,
            {
              offset: t = 0,
              immediate: n = !1,
              lock: r = !1,
              duration: s = this.options.duration,
              easing: a = this.options.easing,
              lerp: o = this.options.lerp,
              onStart: l,
              onComplete: c,
              force: u = !1,
              programmatic: h = !0,
              userData: d,
            } = {}
          ) {
            if ((!this.isStopped && !this.isLocked) || u) {
              if ("string" == typeof e && ["top", "left", "start"].includes(e))
                e = 0;
              else if (
                "string" == typeof e &&
                ["bottom", "right", "end"].includes(e)
              )
                e = this.limit;
              else {
                let n;
                if (
                  ("string" == typeof e
                    ? (n = document.querySelector(e))
                    : e instanceof HTMLElement && e?.nodeType && (n = e),
                  n)
                ) {
                  if (this.options.wrapper !== window) {
                    const e = this.rootElement.getBoundingClientRect();
                    t -= this.isHorizontal ? e.left : e.top;
                  }
                  const i = n.getBoundingClientRect();
                  e =
                    (this.isHorizontal ? i.left : i.top) + this.animatedScroll;
                }
              }
              if ("number" == typeof e) {
                if (
                  ((e += t),
                  (e = Math.round(e)),
                  this.options.infinite
                    ? h &&
                      (this.targetScroll = this.animatedScroll = this.scroll)
                    : (e = i(0, e, this.limit)),
                  e === this.targetScroll)
                )
                  return l?.(this), void c?.(this);
                if (((this.userData = d ?? {}), n))
                  return (
                    (this.animatedScroll = this.targetScroll = e),
                    this.setScroll(this.scroll),
                    this.reset(),
                    this.preventNextNativeScrollEvent(),
                    this.emit(),
                    c?.(this),
                    void (this.userData = {})
                  );
                h || (this.targetScroll = e),
                  this.animate.fromTo(this.animatedScroll, e, {
                    duration: s,
                    easing: a,
                    lerp: o,
                    onStart: () => {
                      r && (this.isLocked = !0),
                        (this.isScrolling = "smooth"),
                        l?.(this);
                    },
                    onUpdate: (e, t) => {
                      (this.isScrolling = "smooth"),
                        (this.lastVelocity = this.velocity),
                        (this.velocity = e - this.animatedScroll),
                        (this.direction = Math.sign(this.velocity)),
                        (this.animatedScroll = e),
                        this.setScroll(this.scroll),
                        h && (this.targetScroll = e),
                        t || this.emit(),
                        t &&
                          (this.reset(),
                          this.emit(),
                          c?.(this),
                          (this.userData = {}),
                          this.preventNextNativeScrollEvent());
                    },
                  });
              }
            }
          }
          preventNextNativeScrollEvent() {
            (this._preventNextNativeScrollEvent = !0),
              requestAnimationFrame(() => {
                this._preventNextNativeScrollEvent = !1;
              });
          }
          get rootElement() {
            return this.options.wrapper === window
              ? document.documentElement
              : this.options.wrapper;
          }
          get limit() {
            return this.options.__experimental__naiveDimensions
              ? this.isHorizontal
                ? this.rootElement.scrollWidth - this.rootElement.clientWidth
                : this.rootElement.scrollHeight - this.rootElement.clientHeight
              : this.dimensions.limit[this.isHorizontal ? "x" : "y"];
          }
          get isHorizontal() {
            return "horizontal" === this.options.orientation;
          }
          get actualScroll() {
            return this.isHorizontal
              ? this.rootElement.scrollLeft
              : this.rootElement.scrollTop;
          }
          get scroll() {
            return this.options.infinite
              ? ((e = this.animatedScroll), (t = this.limit), ((e % t) + t) % t)
              : this.animatedScroll;
            var e, t;
          }
          get progress() {
            return 0 === this.limit ? 1 : this.scroll / this.limit;
          }
          get isScrolling() {
            return this._isScrolling;
          }
          set isScrolling(e) {
            this._isScrolling !== e &&
              ((this._isScrolling = e), this.updateClassName());
          }
          get isStopped() {
            return this._isStopped;
          }
          set isStopped(e) {
            this._isStopped !== e &&
              ((this._isStopped = e), this.updateClassName());
          }
          get isLocked() {
            return this._isLocked;
          }
          set isLocked(e) {
            this._isLocked !== e &&
              ((this._isLocked = e), this.updateClassName());
          }
          get isSmooth() {
            return "smooth" === this.isScrolling;
          }
          get className() {
            let e = "lenis";
            return (
              this.isStopped && (e += " lenis-stopped"),
              this.isLocked && (e += " lenis-locked"),
              this.isScrolling && (e += " lenis-scrolling"),
              "smooth" === this.isScrolling && (e += " lenis-smooth"),
              e
            );
          }
          updateClassName() {
            this.cleanUpClassName(),
              (this.rootElement.className =
                `${this.rootElement.className} ${this.className}`.trim());
          }
          cleanUpClassName() {
            this.rootElement.className = this.rootElement.className
              .replace(/lenis(-\w+)?/g, "")
              .trim();
          }
        };
    },
    6781: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => d });
      var i = n(6096);
      const r = function () {
        (this.__data__ = new i.A()), (this.size = 0);
      };
      const s = function (e) {
        var t = this.__data__,
          n = t.delete(e);
        return (this.size = t.size), n;
      };
      const a = function (e) {
        return this.__data__.get(e);
      };
      const o = function (e) {
        return this.__data__.has(e);
      };
      var l = n(5436),
        c = n(3269);
      const u = function (e, t) {
        var n = this.__data__;
        if (n instanceof i.A) {
          var r = n.__data__;
          if (!l.A || r.length < 199)
            return r.push([e, t]), (this.size = ++n.size), this;
          n = this.__data__ = new c.A(r);
        }
        return n.set(e, t), (this.size = n.size), this;
      };
      function h(e) {
        var t = (this.__data__ = new i.A(e));
        this.size = t.size;
      }
      (h.prototype.clear = r),
        (h.prototype.delete = s),
        (h.prototype.get = a),
        (h.prototype.has = o),
        (h.prototype.set = u);
      const d = h;
    },
    7913: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = n(9600).A.Uint8Array;
    },
    7252: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => u });
      const i = function (e, t) {
        for (var n = -1, i = Array(e); ++n < e; ) i[n] = t(n);
        return i;
      };
      var r = n(8748),
        s = n(6956),
        a = n(4517),
        o = n(5378),
        l = n(2888),
        c = Object.prototype.hasOwnProperty;
      const u = function (e, t) {
        var n = (0, s.A)(e),
          u = !n && (0, r.A)(e),
          h = !n && !u && (0, a.A)(e),
          d = !n && !u && !h && (0, l.A)(e),
          p = n || u || h || d,
          f = p ? i(e.length, String) : [],
          A = f.length;
        for (var g in e)
          (!t && !c.call(e, g)) ||
            (p &&
              ("length" == g ||
                (h && ("offset" == g || "parent" == g)) ||
                (d &&
                  ("buffer" == g || "byteLength" == g || "byteOffset" == g)) ||
                (0, o.A)(g, A))) ||
            f.push(g);
        return f;
      };
    },
    3271: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e, t) {
        for (var n = -1, i = t.length, r = e.length; ++n < i; ) e[r + n] = t[n];
        return e;
      };
    },
    6124: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => a });
      var i = n(9465),
        r = n(6979),
        s = Object.prototype.hasOwnProperty;
      const a = function (e, t, n) {
        var a = e[t];
        (s.call(e, t) && (0, r.A)(a, n) && (void 0 !== n || t in e)) ||
          (0, i.A)(e, t, n);
      };
    },
    9465: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => s });
      var i = n(123);
      const r = (function () {
        try {
          var e = (0, i.A)(Object, "defineProperty");
          return e({}, "", {}), e;
        } catch (e) {}
      })();
      const s = function (e, t, n) {
        "__proto__" == t && r
          ? r(e, t, {
              configurable: !0,
              enumerable: !0,
              value: n,
              writable: !0,
            })
          : (e[t] = n);
      };
    },
    4494: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => s });
      var i = n(3271),
        r = n(6956);
      const s = function (e, t, n) {
        var s = t(e);
        return (0, r.A)(e) ? s : (0, i.A)(s, n(e));
      };
    },
    1730: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => P });
      var i = n(6781),
        r = n(3269);
      const s = function (e) {
        return this.__data__.set(e, "__lodash_hash_undefined__"), this;
      };
      const a = function (e) {
        return this.__data__.has(e);
      };
      function o(e) {
        var t = -1,
          n = null == e ? 0 : e.length;
        for (this.__data__ = new r.A(); ++t < n; ) this.add(e[t]);
      }
      (o.prototype.add = o.prototype.push = s), (o.prototype.has = a);
      const l = o;
      const c = function (e, t) {
        for (var n = -1, i = null == e ? 0 : e.length; ++n < i; )
          if (t(e[n], n, e)) return !0;
        return !1;
      };
      const u = function (e, t) {
        return e.has(t);
      };
      const h = function (e, t, n, i, r, s) {
        var a = 1 & n,
          o = e.length,
          h = t.length;
        if (o != h && !(a && h > o)) return !1;
        var d = s.get(e),
          p = s.get(t);
        if (d && p) return d == t && p == e;
        var f = -1,
          A = !0,
          g = 2 & n ? new l() : void 0;
        for (s.set(e, t), s.set(t, e); ++f < o; ) {
          var m = e[f],
            v = t[f];
          if (i) var y = a ? i(v, m, f, t, e, s) : i(m, v, f, e, t, s);
          if (void 0 !== y) {
            if (y) continue;
            A = !1;
            break;
          }
          if (g) {
            if (
              !c(t, function (e, t) {
                if (!u(g, t) && (m === e || r(m, e, n, i, s))) return g.push(t);
              })
            ) {
              A = !1;
              break;
            }
          } else if (m !== v && !r(m, v, n, i, s)) {
            A = !1;
            break;
          }
        }
        return s.delete(e), s.delete(t), A;
      };
      var d = n(3516),
        p = n(7913),
        f = n(6979);
      const A = function (e) {
        var t = -1,
          n = Array(e.size);
        return (
          e.forEach(function (e, i) {
            n[++t] = [i, e];
          }),
          n
        );
      };
      const g = function (e) {
        var t = -1,
          n = Array(e.size);
        return (
          e.forEach(function (e) {
            n[++t] = e;
          }),
          n
        );
      };
      var m = d.A ? d.A.prototype : void 0,
        v = m ? m.valueOf : void 0;
      const y = function (e, t, n, i, r, s, a) {
        switch (n) {
          case "[object DataView]":
            if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
              return !1;
            (e = e.buffer), (t = t.buffer);
          case "[object ArrayBuffer]":
            return !(
              e.byteLength != t.byteLength || !s(new p.A(e), new p.A(t))
            );
          case "[object Boolean]":
          case "[object Date]":
          case "[object Number]":
            return (0, f.A)(+e, +t);
          case "[object Error]":
            return e.name == t.name && e.message == t.message;
          case "[object RegExp]":
          case "[object String]":
            return e == t + "";
          case "[object Map]":
            var o = A;
          case "[object Set]":
            var l = 1 & i;
            if ((o || (o = g), e.size != t.size && !l)) return !1;
            var c = a.get(e);
            if (c) return c == t;
            (i |= 2), a.set(e, t);
            var u = h(o(e), o(t), i, r, s, a);
            return a.delete(e), u;
          case "[object Symbol]":
            if (v) return v.call(e) == v.call(t);
        }
        return !1;
      };
      var x = n(2475),
        _ = Object.prototype.hasOwnProperty;
      const b = function (e, t, n, i, r, s) {
        var a = 1 & n,
          o = (0, x.A)(e),
          l = o.length;
        if (l != (0, x.A)(t).length && !a) return !1;
        for (var c = l; c--; ) {
          var u = o[c];
          if (!(a ? u in t : _.call(t, u))) return !1;
        }
        var h = s.get(e),
          d = s.get(t);
        if (h && d) return h == t && d == e;
        var p = !0;
        s.set(e, t), s.set(t, e);
        for (var f = a; ++c < l; ) {
          var A = e[(u = o[c])],
            g = t[u];
          if (i) var m = a ? i(g, A, u, t, e, s) : i(A, g, u, e, t, s);
          if (!(void 0 === m ? A === g || r(A, g, n, i, s) : m)) {
            p = !1;
            break;
          }
          f || (f = "constructor" == u);
        }
        if (p && !f) {
          var v = e.constructor,
            y = t.constructor;
          v == y ||
            !("constructor" in e) ||
            !("constructor" in t) ||
            ("function" == typeof v &&
              v instanceof v &&
              "function" == typeof y &&
              y instanceof y) ||
            (p = !1);
        }
        return s.delete(e), s.delete(t), p;
      };
      var E = n(6881),
        w = n(6956),
        C = n(4517),
        I = n(2888),
        S = "[object Arguments]",
        M = "[object Array]",
        T = "[object Object]",
        B = Object.prototype.hasOwnProperty;
      const R = function (e, t, n, r, s, a) {
        var o = (0, w.A)(e),
          l = (0, w.A)(t),
          c = o ? M : (0, E.A)(e),
          u = l ? M : (0, E.A)(t),
          d = (c = c == S ? T : c) == T,
          p = (u = u == S ? T : u) == T,
          f = c == u;
        if (f && (0, C.A)(e)) {
          if (!(0, C.A)(t)) return !1;
          (o = !0), (d = !1);
        }
        if (f && !d)
          return (
            a || (a = new i.A()),
            o || (0, I.A)(e) ? h(e, t, n, r, s, a) : y(e, t, c, n, r, s, a)
          );
        if (!(1 & n)) {
          var A = d && B.call(e, "__wrapped__"),
            g = p && B.call(t, "__wrapped__");
          if (A || g) {
            var m = A ? e.value() : e,
              v = g ? t.value() : t;
            return a || (a = new i.A()), s(m, v, n, r, a);
          }
        }
        return !!f && (a || (a = new i.A()), b(e, t, n, r, s, a));
      };
      var D = n(7313);
      const P = function e(t, n, i, r, s) {
        return (
          t === n ||
          (null == t || null == n || (!(0, D.A)(t) && !(0, D.A)(n))
            ? t != t && n != n
            : R(t, n, i, r, e, s))
        );
      };
    },
    6132: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e) {
        return function (t) {
          return null == t ? void 0 : t[e];
        };
      };
    },
    8007: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e, t, n) {
        var i = -1,
          r = e.length;
        t < 0 && (t = -t > r ? 0 : r + t),
          (n = n > r ? r : n) < 0 && (n += r),
          (r = t > n ? 0 : (n - t) >>> 0),
          (t >>>= 0);
        for (var s = Array(r); ++i < r; ) s[i] = e[i + t];
        return s;
      };
    },
    8126: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e) {
        return function (t) {
          return e(t);
        };
      };
    },
    2475: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => a });
      var i = n(4494),
        r = n(4402),
        s = n(8964);
      const a = function (e) {
        return (0, i.A)(e, s.A, r.A);
      };
    },
    4878: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = (0, n(7244).A)(Object.getPrototypeOf, Object);
    },
    4402: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => o });
      const i = function (e, t) {
        for (
          var n = -1, i = null == e ? 0 : e.length, r = 0, s = [];
          ++n < i;

        ) {
          var a = e[n];
          t(a, n, e) && (s[r++] = a);
        }
        return s;
      };
      var r = n(1276),
        s = Object.prototype.propertyIsEnumerable,
        a = Object.getOwnPropertySymbols;
      const o = a
        ? function (e) {
            return null == e
              ? []
              : ((e = Object(e)),
                i(a(e), function (t) {
                  return s.call(e, t);
                }));
          }
        : r.A;
    },
    6881: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => E });
      var i = n(123),
        r = n(9600);
      const s = (0, i.A)(r.A, "DataView");
      var a = n(5436);
      const o = (0, i.A)(r.A, "Promise");
      const l = (0, i.A)(r.A, "Set");
      const c = (0, i.A)(r.A, "WeakMap");
      var u = n(4044),
        h = n(1548),
        d = "[object Map]",
        p = "[object Promise]",
        f = "[object Set]",
        A = "[object WeakMap]",
        g = "[object DataView]",
        m = (0, h.A)(s),
        v = (0, h.A)(a.A),
        y = (0, h.A)(o),
        x = (0, h.A)(l),
        _ = (0, h.A)(c),
        b = u.A;
      ((s && b(new s(new ArrayBuffer(1))) != g) ||
        (a.A && b(new a.A()) != d) ||
        (o && b(o.resolve()) != p) ||
        (l && b(new l()) != f) ||
        (c && b(new c()) != A)) &&
        (b = function (e) {
          var t = (0, u.A)(e),
            n = "[object Object]" == t ? e.constructor : void 0,
            i = n ? (0, h.A)(n) : "";
          if (i)
            switch (i) {
              case m:
                return g;
              case v:
                return d;
              case y:
                return p;
              case x:
                return f;
              case _:
                return A;
            }
          return t;
        });
      const E = b;
    },
    5378: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => r });
      var i = /^(?:0|[1-9]\d*)$/;
      const r = function (e, t) {
        var n = typeof e;
        return (
          !!(t = null == t ? 9007199254740991 : t) &&
          ("number" == n || ("symbol" != n && i.test(e))) &&
          e > -1 &&
          e % 1 == 0 &&
          e < t
        );
      };
    },
    1140: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => r });
      var i = Object.prototype;
      const r = function (e) {
        var t = e && e.constructor;
        return e === (("function" == typeof t && t.prototype) || i);
      };
    },
    248: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => o });
      var i = n(6713),
        r =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        s =
          r &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        a = s && s.exports === r && i.A.process;
      const o = (function () {
        try {
          var e = s && s.require && s.require("util").types;
          return e || (a && a.binding && a.binding("util"));
        } catch (e) {}
      })();
    },
    7244: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e, t) {
        return function (n) {
          return e(t(n));
        };
      };
    },
    5434: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => s });
      const i = function (e, t, n) {
        return (
          e == e &&
            (void 0 !== n && (e = e <= n ? e : n),
            void 0 !== t && (e = e >= t ? e : t)),
          e
        );
      };
      var r = n(3558);
      const s = function (e, t, n) {
        return (
          void 0 === n && ((n = t), (t = void 0)),
          void 0 !== n && (n = (n = (0, r.A)(n)) == n ? n : 0),
          void 0 !== t && (t = (t = (0, r.A)(t)) == t ? t : 0),
          i((0, r.A)(e), t, n)
        );
      };
    },
    7853: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => Ae });
      var i = n(6781);
      const r = function (e, t) {
        for (
          var n = -1, i = null == e ? 0 : e.length;
          ++n < i && !1 !== t(e[n], n, e);

        );
        return e;
      };
      var s = n(6124),
        a = n(9465);
      const o = function (e, t, n, i) {
        var r = !n;
        n || (n = {});
        for (var o = -1, l = t.length; ++o < l; ) {
          var c = t[o],
            u = i ? i(n[c], e[c], c, n, e) : void 0;
          void 0 === u && (u = e[c]), r ? (0, a.A)(n, c, u) : (0, s.A)(n, c, u);
        }
        return n;
      };
      var l = n(8964);
      const c = function (e, t) {
        return e && o(t, (0, l.A)(t), e);
      };
      var u = n(7252),
        h = n(7942),
        d = n(1140);
      const p = function (e) {
        var t = [];
        if (null != e) for (var n in Object(e)) t.push(n);
        return t;
      };
      var f = Object.prototype.hasOwnProperty;
      const A = function (e) {
        if (!(0, h.A)(e)) return p(e);
        var t = (0, d.A)(e),
          n = [];
        for (var i in e)
          ("constructor" != i || (!t && f.call(e, i))) && n.push(i);
        return n;
      };
      var g = n(1475);
      const m = function (e) {
        return (0, g.A)(e) ? (0, u.A)(e, !0) : A(e);
      };
      const v = function (e, t) {
        return e && o(t, m(t), e);
      };
      var y = n(9600),
        x =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        _ =
          x &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        b = _ && _.exports === x ? y.A.Buffer : void 0,
        E = b ? b.allocUnsafe : void 0;
      const w = function (e, t) {
        if (t) return e.slice();
        var n = e.length,
          i = E ? E(n) : new e.constructor(n);
        return e.copy(i), i;
      };
      const C = function (e, t) {
        var n = -1,
          i = e.length;
        for (t || (t = Array(i)); ++n < i; ) t[n] = e[n];
        return t;
      };
      var I = n(4402);
      const S = function (e, t) {
        return o(e, (0, I.A)(e), t);
      };
      var M = n(3271),
        T = n(4878),
        B = n(1276);
      const R = Object.getOwnPropertySymbols
        ? function (e) {
            for (var t = []; e; ) (0, M.A)(t, (0, I.A)(e)), (e = (0, T.A)(e));
            return t;
          }
        : B.A;
      const D = function (e, t) {
        return o(e, R(e), t);
      };
      var P = n(2475),
        L = n(4494);
      const U = function (e) {
        return (0, L.A)(e, m, R);
      };
      var F = n(6881),
        N = Object.prototype.hasOwnProperty;
      const O = function (e) {
        var t = e.length,
          n = new e.constructor(t);
        return (
          t &&
            "string" == typeof e[0] &&
            N.call(e, "index") &&
            ((n.index = e.index), (n.input = e.input)),
          n
        );
      };
      var Q = n(7913);
      const k = function (e) {
        var t = new e.constructor(e.byteLength);
        return new Q.A(t).set(new Q.A(e)), t;
      };
      const G = function (e, t) {
        var n = t ? k(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.byteLength);
      };
      var H = /\w*$/;
      const z = function (e) {
        var t = new e.constructor(e.source, H.exec(e));
        return (t.lastIndex = e.lastIndex), t;
      };
      var V = n(3516),
        W = V.A ? V.A.prototype : void 0,
        j = W ? W.valueOf : void 0;
      const q = function (e) {
        return j ? Object(j.call(e)) : {};
      };
      const Y = function (e, t) {
        var n = t ? k(e.buffer) : e.buffer;
        return new e.constructor(n, e.byteOffset, e.length);
      };
      const X = function (e, t, n) {
        var i = e.constructor;
        switch (t) {
          case "[object ArrayBuffer]":
            return k(e);
          case "[object Boolean]":
          case "[object Date]":
            return new i(+e);
          case "[object DataView]":
            return G(e, n);
          case "[object Float32Array]":
          case "[object Float64Array]":
          case "[object Int8Array]":
          case "[object Int16Array]":
          case "[object Int32Array]":
          case "[object Uint8Array]":
          case "[object Uint8ClampedArray]":
          case "[object Uint16Array]":
          case "[object Uint32Array]":
            return Y(e, n);
          case "[object Map]":
          case "[object Set]":
            return new i();
          case "[object Number]":
          case "[object String]":
            return new i(e);
          case "[object RegExp]":
            return z(e);
          case "[object Symbol]":
            return q(e);
        }
      };
      var K = Object.create;
      const J = (function () {
        function e() {}
        return function (t) {
          if (!(0, h.A)(t)) return {};
          if (K) return K(t);
          e.prototype = t;
          var n = new e();
          return (e.prototype = void 0), n;
        };
      })();
      const Z = function (e) {
        return "function" != typeof e.constructor || (0, d.A)(e)
          ? {}
          : J((0, T.A)(e));
      };
      var $ = n(6956),
        ee = n(4517),
        te = n(7313);
      const ne = function (e) {
        return (0, te.A)(e) && "[object Map]" == (0, F.A)(e);
      };
      var ie = n(8126),
        re = n(248),
        se = re.A && re.A.isMap;
      const ae = se ? (0, ie.A)(se) : ne;
      const oe = function (e) {
        return (0, te.A)(e) && "[object Set]" == (0, F.A)(e);
      };
      var le = re.A && re.A.isSet;
      const ce = le ? (0, ie.A)(le) : oe;
      var ue = "[object Arguments]",
        he = "[object Function]",
        de = "[object Object]",
        pe = {};
      (pe[ue] =
        pe["[object Array]"] =
        pe["[object ArrayBuffer]"] =
        pe["[object DataView]"] =
        pe["[object Boolean]"] =
        pe["[object Date]"] =
        pe["[object Float32Array]"] =
        pe["[object Float64Array]"] =
        pe["[object Int8Array]"] =
        pe["[object Int16Array]"] =
        pe["[object Int32Array]"] =
        pe["[object Map]"] =
        pe["[object Number]"] =
        pe[de] =
        pe["[object RegExp]"] =
        pe["[object Set]"] =
        pe["[object String]"] =
        pe["[object Symbol]"] =
        pe["[object Uint8Array]"] =
        pe["[object Uint8ClampedArray]"] =
        pe["[object Uint16Array]"] =
        pe["[object Uint32Array]"] =
          !0),
        (pe["[object Error]"] = pe[he] = pe["[object WeakMap]"] = !1);
      const fe = function e(t, n, a, o, u, d) {
        var p,
          f = 1 & n,
          A = 2 & n,
          g = 4 & n;
        if ((a && (p = u ? a(t, o, u, d) : a(t)), void 0 !== p)) return p;
        if (!(0, h.A)(t)) return t;
        var y = (0, $.A)(t);
        if (y) {
          if (((p = O(t)), !f)) return C(t, p);
        } else {
          var x = (0, F.A)(t),
            _ = x == he || "[object GeneratorFunction]" == x;
          if ((0, ee.A)(t)) return w(t, f);
          if (x == de || x == ue || (_ && !u)) {
            if (((p = A || _ ? {} : Z(t)), !f))
              return A ? D(t, v(p, t)) : S(t, c(p, t));
          } else {
            if (!pe[x]) return u ? t : {};
            p = X(t, x, f);
          }
        }
        d || (d = new i.A());
        var b = d.get(t);
        if (b) return b;
        d.set(t, p),
          ce(t)
            ? t.forEach(function (i) {
                p.add(e(i, n, a, i, t, d));
              })
            : ae(t) &&
              t.forEach(function (i, r) {
                p.set(r, e(i, n, a, r, t, d));
              });
        var E = g ? (A ? U : P.A) : A ? m : l.A,
          I = y ? void 0 : E(t);
        return (
          r(I || t, function (i, r) {
            I && (i = t[(r = i)]), (0, s.A)(p, r, e(i, n, a, r, t, d));
          }),
          p
        );
      };
      const Ae = function (e) {
        return fe(e, 5);
      };
    },
    7028: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => c });
      var i = n(7942),
        r = n(9600);
      const s = function () {
        return r.A.Date.now();
      };
      var a = n(3558),
        o = Math.max,
        l = Math.min;
      const c = function (e, t, n) {
        var r,
          c,
          u,
          h,
          d,
          p,
          f = 0,
          A = !1,
          g = !1,
          m = !0;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        function v(t) {
          var n = r,
            i = c;
          return (r = c = void 0), (f = t), (h = e.apply(i, n));
        }
        function y(e) {
          var n = e - p;
          return void 0 === p || n >= t || n < 0 || (g && e - f >= u);
        }
        function x() {
          var e = s();
          if (y(e)) return _(e);
          d = setTimeout(
            x,
            (function (e) {
              var n = t - (e - p);
              return g ? l(n, u - (e - f)) : n;
            })(e)
          );
        }
        function _(e) {
          return (d = void 0), m && r ? v(e) : ((r = c = void 0), h);
        }
        function b() {
          var e = s(),
            n = y(e);
          if (((r = arguments), (c = this), (p = e), n)) {
            if (void 0 === d)
              return (function (e) {
                return (f = e), (d = setTimeout(x, t)), A ? v(e) : h;
              })(p);
            if (g) return clearTimeout(d), (d = setTimeout(x, t)), v(p);
          }
          return void 0 === d && (d = setTimeout(x, t)), h;
        }
        return (
          (t = (0, a.A)(t) || 0),
          (0, i.A)(n) &&
            ((A = !!n.leading),
            (u = (g = "maxWait" in n) ? o((0, a.A)(n.maxWait) || 0, t) : u),
            (m = "trailing" in n ? !!n.trailing : m)),
          (b.cancel = function () {
            void 0 !== d && clearTimeout(d), (f = 0), (r = p = c = d = void 0);
          }),
          (b.flush = function () {
            return void 0 === d ? h : _(s());
          }),
          b
        );
      };
    },
    8748: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => c });
      var i = n(4044),
        r = n(7313);
      const s = function (e) {
        return (0, r.A)(e) && "[object Arguments]" == (0, i.A)(e);
      };
      var a = Object.prototype,
        o = a.hasOwnProperty,
        l = a.propertyIsEnumerable;
      const c = s(
        (function () {
          return arguments;
        })()
      )
        ? s
        : function (e) {
            return (0, r.A)(e) && o.call(e, "callee") && !l.call(e, "callee");
          };
    },
    1475: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => s });
      var i = n(405),
        r = n(7893);
      const s = function (e) {
        return null != e && (0, r.A)(e.length) && !(0, i.A)(e);
      };
    },
    4517: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => l });
      var i = n(9600);
      const r = function () {
        return !1;
      };
      var s =
          "object" == typeof exports && exports && !exports.nodeType && exports,
        a =
          s &&
          "object" == typeof module &&
          module &&
          !module.nodeType &&
          module,
        o = a && a.exports === s ? i.A.Buffer : void 0;
      const l = (o ? o.isBuffer : void 0) || r;
    },
    2853: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => r });
      var i = n(1730);
      const r = function (e, t) {
        return (0, i.A)(e, t);
      };
    },
    2727: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => r });
      var i = n(684);
      const r = function (e) {
        return "number" == typeof e && e == (0, i.A)(e);
      };
    },
    7893: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e) {
        return (
          "number" == typeof e && e > -1 && e % 1 == 0 && e <= 9007199254740991
        );
      };
    },
    8938: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => h });
      var i = n(4044),
        r = n(4878),
        s = n(7313),
        a = Function.prototype,
        o = Object.prototype,
        l = a.toString,
        c = o.hasOwnProperty,
        u = l.call(Object);
      const h = function (e) {
        if (!(0, s.A)(e) || "[object Object]" != (0, i.A)(e)) return !1;
        var t = (0, r.A)(e);
        if (null === t) return !0;
        var n = c.call(t, "constructor") && t.constructor;
        return "function" == typeof n && n instanceof n && l.call(n) == u;
      };
    },
    2888: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => h });
      var i = n(4044),
        r = n(7893),
        s = n(7313),
        a = {};
      (a["[object Float32Array]"] =
        a["[object Float64Array]"] =
        a["[object Int8Array]"] =
        a["[object Int16Array]"] =
        a["[object Int32Array]"] =
        a["[object Uint8Array]"] =
        a["[object Uint8ClampedArray]"] =
        a["[object Uint16Array]"] =
        a["[object Uint32Array]"] =
          !0),
        (a["[object Arguments]"] =
          a["[object Array]"] =
          a["[object ArrayBuffer]"] =
          a["[object Boolean]"] =
          a["[object DataView]"] =
          a["[object Date]"] =
          a["[object Error]"] =
          a["[object Function]"] =
          a["[object Map]"] =
          a["[object Number]"] =
          a["[object Object]"] =
          a["[object RegExp]"] =
          a["[object Set]"] =
          a["[object String]"] =
          a["[object WeakMap]"] =
            !1);
      const o = function (e) {
        return (0, s.A)(e) && (0, r.A)(e.length) && !!a[(0, i.A)(e)];
      };
      var l = n(8126),
        c = n(248),
        u = c.A && c.A.isTypedArray;
      const h = u ? (0, l.A)(u) : o;
    },
    8964: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => c });
      var i = n(7252),
        r = n(1140);
      const s = (0, n(7244).A)(Object.keys, Object);
      var a = Object.prototype.hasOwnProperty;
      const o = function (e) {
        if (!(0, r.A)(e)) return s(e);
        var t = [];
        for (var n in Object(e))
          a.call(e, n) && "constructor" != n && t.push(n);
        return t;
      };
      var l = n(1475);
      const c = function (e) {
        return (0, l.A)(e) ? (0, i.A)(e) : o(e);
      };
    },
    4441: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function (e) {
        var t = null == e ? 0 : e.length;
        return t ? e[t - 1] : void 0;
      };
    },
    2854: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => P });
      var i = n(9465);
      const r = (function (e) {
        return function (t, n, i) {
          for (var r = -1, s = Object(t), a = i(t), o = a.length; o--; ) {
            var l = a[e ? o : ++r];
            if (!1 === n(s[l], l, s)) break;
          }
          return t;
        };
      })();
      var s = n(8964);
      const a = function (e, t) {
        return e && r(e, t, s.A);
      };
      var o = n(6781),
        l = n(1730);
      const c = function (e, t, n, i) {
        var r = n.length,
          s = r,
          a = !i;
        if (null == e) return !s;
        for (e = Object(e); r--; ) {
          var c = n[r];
          if (a && c[2] ? c[1] !== e[c[0]] : !(c[0] in e)) return !1;
        }
        for (; ++r < s; ) {
          var u = (c = n[r])[0],
            h = e[u],
            d = c[1];
          if (a && c[2]) {
            if (void 0 === h && !(u in e)) return !1;
          } else {
            var p = new o.A();
            if (i) var f = i(h, d, u, e, t, p);
            if (!(void 0 === f ? (0, l.A)(d, h, 3, i, p) : f)) return !1;
          }
        }
        return !0;
      };
      var u = n(7942);
      const h = function (e) {
        return e == e && !(0, u.A)(e);
      };
      const d = function (e) {
        for (var t = (0, s.A)(e), n = t.length; n--; ) {
          var i = t[n],
            r = e[i];
          t[n] = [i, r, h(r)];
        }
        return t;
      };
      const p = function (e, t) {
        return function (n) {
          return null != n && n[e] === t && (void 0 !== t || e in Object(n));
        };
      };
      const f = function (e) {
        var t = d(e);
        return 1 == t.length && t[0][2]
          ? p(t[0][0], t[0][1])
          : function (n) {
              return n === e || c(n, e, t);
            };
      };
      var A = n(385);
      const g = function (e, t) {
        return null != e && t in Object(e);
      };
      var m = n(9333),
        v = n(8748),
        y = n(6956),
        x = n(5378),
        _ = n(7893),
        b = n(9322);
      const E = function (e, t, n) {
        for (var i = -1, r = (t = (0, m.A)(t, e)).length, s = !1; ++i < r; ) {
          var a = (0, b.A)(t[i]);
          if (!(s = null != e && n(e, a))) break;
          e = e[a];
        }
        return s || ++i != r
          ? s
          : !!(r = null == e ? 0 : e.length) &&
              (0, _.A)(r) &&
              (0, x.A)(a, r) &&
              ((0, y.A)(e) || (0, v.A)(e));
      };
      const w = function (e, t) {
        return null != e && E(e, t, g);
      };
      var C = n(1677);
      const I = function (e, t) {
        return (0, C.A)(e) && h(t)
          ? p((0, b.A)(e), t)
          : function (n) {
              var i = (0, A.A)(n, e);
              return void 0 === i && i === t ? w(n, e) : (0, l.A)(t, i, 3);
            };
      };
      const S = function (e) {
        return e;
      };
      var M = n(6132),
        T = n(5841);
      const B = function (e) {
        return function (t) {
          return (0, T.A)(t, e);
        };
      };
      const R = function (e) {
        return (0, C.A)(e) ? (0, M.A)((0, b.A)(e)) : B(e);
      };
      const D = function (e) {
        return "function" == typeof e
          ? e
          : null == e
          ? S
          : "object" == typeof e
          ? (0, y.A)(e)
            ? I(e[0], e[1])
            : f(e)
          : R(e);
      };
      const P = function (e, t) {
        var n = {};
        return (
          (t = D(t, 3)),
          a(e, function (e, r, s) {
            (0, i.A)(n, r, t(e, r, s));
          }),
          n
        );
      };
    },
    4225: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => V });
      var i = Math.floor;
      const r = function (e, t) {
        var n = "";
        if (!e || t < 1 || t > 9007199254740991) return n;
        do {
          t % 2 && (n += e), (t = i(t / 2)) && (e += e);
        } while (t);
        return n;
      };
      var s = n(817),
        a = n(8007);
      const o = function (e, t, n) {
        var i = e.length;
        return (n = void 0 === n ? i : n), !t && n >= i ? e : (0, a.A)(e, t, n);
      };
      var l = RegExp(
        "[\\u200d\\ud800-\\udfff\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff\\ufe0e\\ufe0f]"
      );
      const c = function (e) {
        return l.test(e);
      };
      const u = (0, n(6132).A)("length");
      var h = "\\ud800-\\udfff",
        d = "[" + h + "]",
        p = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
        f = "\\ud83c[\\udffb-\\udfff]",
        A = "[^" + h + "]",
        g = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        m = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        v = "(?:" + p + "|" + f + ")" + "?",
        y = "[\\ufe0e\\ufe0f]?",
        x =
          y + v + ("(?:\\u200d(?:" + [A, g, m].join("|") + ")" + y + v + ")*"),
        _ = "(?:" + [A + p + "?", p, g, m, d].join("|") + ")",
        b = RegExp(f + "(?=" + f + ")|" + _ + x, "g");
      const E = function (e) {
        for (var t = (b.lastIndex = 0); b.test(e); ) ++t;
        return t;
      };
      const w = function (e) {
        return c(e) ? E(e) : u(e);
      };
      const C = function (e) {
        return e.split("");
      };
      var I = "\\ud800-\\udfff",
        S = "[" + I + "]",
        M = "[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]",
        T = "\\ud83c[\\udffb-\\udfff]",
        B = "[^" + I + "]",
        R = "(?:\\ud83c[\\udde6-\\uddff]){2}",
        D = "[\\ud800-\\udbff][\\udc00-\\udfff]",
        P = "(?:" + M + "|" + T + ")" + "?",
        L = "[\\ufe0e\\ufe0f]?",
        U =
          L + P + ("(?:\\u200d(?:" + [B, R, D].join("|") + ")" + L + P + ")*"),
        F = "(?:" + [B + M + "?", M, R, D, S].join("|") + ")",
        N = RegExp(T + "(?=" + T + ")|" + F + U, "g");
      const O = function (e) {
        return e.match(N) || [];
      };
      const Q = function (e) {
        return c(e) ? O(e) : C(e);
      };
      var k = Math.ceil;
      const G = function (e, t) {
        var n = (t = void 0 === t ? " " : (0, s.A)(t)).length;
        if (n < 2) return n ? r(t, e) : t;
        var i = r(t, k(e / w(t)));
        return c(t) ? o(Q(i), 0, e).join("") : i.slice(0, e);
      };
      var H = n(684),
        z = n(2021);
      const V = function (e, t, n) {
        e = (0, z.A)(e);
        var i = (t = (0, H.A)(t)) ? w(e) : 0;
        return t && i < t ? G(t - i, n) + e : e;
      };
    },
    6822: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => c });
      var i = n(6124),
        r = n(9333),
        s = n(5378),
        a = n(7942),
        o = n(9322);
      const l = function (e, t, n, l) {
        if (!(0, a.A)(e)) return e;
        for (
          var c = -1, u = (t = (0, r.A)(t, e)).length, h = u - 1, d = e;
          null != d && ++c < u;

        ) {
          var p = (0, o.A)(t[c]),
            f = n;
          if ("__proto__" === p || "constructor" === p || "prototype" === p)
            return e;
          if (c != h) {
            var A = d[p];
            void 0 === (f = l ? l(A, p, d) : void 0) &&
              (f = (0, a.A)(A) ? A : (0, s.A)(t[c + 1]) ? [] : {});
          }
          (0, i.A)(d, p, f), (d = d[p]);
        }
        return e;
      };
      const c = function (e, t, n) {
        return null == e ? e : l(e, t, n);
      };
    },
    1276: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => i });
      const i = function () {
        return [];
      };
    },
    2777: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => s });
      var i = n(7028),
        r = n(7942);
      const s = function (e, t, n) {
        var s = !0,
          a = !0;
        if ("function" != typeof e) throw new TypeError("Expected a function");
        return (
          (0, r.A)(n) &&
            ((s = "leading" in n ? !!n.leading : s),
            (a = "trailing" in n ? !!n.trailing : a)),
          (0, i.A)(e, t, { leading: s, maxWait: t, trailing: a })
        );
      };
    },
    684: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => a });
      var i = n(3558),
        r = 1 / 0;
      const s = function (e) {
        return e
          ? (e = (0, i.A)(e)) === r || e === -1 / 0
            ? 17976931348623157e292 * (e < 0 ? -1 : 1)
            : e == e
            ? e
            : 0
          : 0 === e
          ? e
          : 0;
      };
      const a = function (e) {
        var t = s(e),
          n = t % 1;
        return t == t ? (n ? t - n : t) : 0;
      };
    },
    3558: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => p });
      var i = /\s/;
      const r = function (e) {
        for (var t = e.length; t-- && i.test(e.charAt(t)); );
        return t;
      };
      var s = /^\s+/;
      const a = function (e) {
        return e ? e.slice(0, r(e) + 1).replace(s, "") : e;
      };
      var o = n(7942),
        l = n(4089),
        c = /^[-+]0x[0-9a-f]+$/i,
        u = /^0b[01]+$/i,
        h = /^0o[0-7]+$/i,
        d = parseInt;
      const p = function (e) {
        if ("number" == typeof e) return e;
        if ((0, l.A)(e)) return NaN;
        if ((0, o.A)(e)) {
          var t = "function" == typeof e.valueOf ? e.valueOf() : e;
          e = (0, o.A)(t) ? t + "" : t;
        }
        if ("string" != typeof e) return 0 === e ? e : +e;
        e = a(e);
        var n = u.test(e);
        return n || h.test(e) ? d(e.slice(2), n ? 2 : 8) : c.test(e) ? NaN : +e;
      };
    },
    2190: (e, t, n) => {
      "use strict";
      n.d(t, { A: () => u });
      var i = n(9333),
        r = n(4441),
        s = n(5841),
        a = n(8007);
      const o = function (e, t) {
        return t.length < 2 ? e : (0, s.A)(e, (0, a.A)(t, 0, -1));
      };
      var l = n(9322);
      const c = function (e, t) {
        return (
          (t = (0, i.A)(t, e)),
          null == (e = o(e, t)) || delete e[(0, l.A)((0, r.A)(t))]
        );
      };
      const u = function (e, t) {
        return null == e || c(e, t);
      };
    },
    7469: (e, t, n) => {
      "use strict";
      n.d(t, {
        AH: () => ue,
        IF: () => g,
        K1: () => Ye,
        LN: () => I,
        Ql: () => he,
        Vu: () => $e,
        Xe: () => et,
        bv: () => q,
        eF: () => ke,
        ei: () => X,
        i: () => Le,
        i4: () => qe,
        jz: () => Ue,
        kt: () => ae,
        lq: () => Y,
        nV: () => h,
        oF: () => o,
        s0: () => A,
        w2: () => Ve,
      });
      var i = n(5062),
        r = 0.001,
        s = class {
          constructor() {
            (this.startTime = performance.now()),
              (this.previousTime = 0),
              (this.currentTime = 0),
              (this._delta = 0),
              (this._elapsed = 0),
              (this._fixedDelta = 1e3 / 60),
              (this.timescale = 1),
              (this.useFixedDelta = !1),
              (this._autoReset = !1);
          }
          get autoReset() {
            return this._autoReset;
          }
          set autoReset(e) {
            "undefined" != typeof document &&
              void 0 !== document.hidden &&
              (e
                ? document.addEventListener("visibilitychange", this)
                : document.removeEventListener("visibilitychange", this),
              (this._autoReset = e));
          }
          get delta() {
            return this._delta * r;
          }
          get fixedDelta() {
            return this._fixedDelta * r;
          }
          set fixedDelta(e) {
            this._fixedDelta = 1e3 * e;
          }
          get elapsed() {
            return this._elapsed * r;
          }
          update(e) {
            this.useFixedDelta
              ? (this._delta = this.fixedDelta)
              : ((this.previousTime = this.currentTime),
                (this.currentTime =
                  (void 0 !== e ? e : performance.now()) - this.startTime),
                (this._delta = this.currentTime - this.previousTime)),
              (this._delta *= this.timescale),
              (this._elapsed += this._delta);
          }
          reset() {
            (this._delta = 0),
              (this._elapsed = 0),
              (this.currentTime = performance.now() - this.startTime);
          }
          getDelta() {
            return this.delta;
          }
          getElapsed() {
            return this.elapsed;
          }
          handleEvent(e) {
            document.hidden ||
              (this.currentTime = performance.now() - this.startTime);
          }
          dispose() {
            this.autoReset = !1;
          }
        },
        a = (() => {
          const e = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
            t = new Float32Array([0, 0, 2, 0, 0, 2]),
            n = new i.LoY();
          return (
            n.setAttribute("position", new i.THS(e, 3)),
            n.setAttribute("uv", new i.THS(t, 2)),
            n
          );
        })(),
        o = class e {
          static get fullscreenGeometry() {
            return a;
          }
          constructor(e = "Pass", t = new i.Z58(), n = new i.i7d()) {
            (this.name = e),
              (this.renderer = null),
              (this.scene = t),
              (this.camera = n),
              (this.screen = null),
              (this.rtt = !0),
              (this.needsSwap = !0),
              (this.needsDepthTexture = !1),
              (this.enabled = !0);
          }
          get renderToScreen() {
            return !this.rtt;
          }
          set renderToScreen(e) {
            if (this.rtt === e) {
              const t = this.fullscreenMaterial;
              null !== t && (t.needsUpdate = !0), (this.rtt = !e);
            }
          }
          set mainScene(e) {}
          set mainCamera(e) {}
          setRenderer(e) {
            this.renderer = e;
          }
          isEnabled() {
            return this.enabled;
          }
          setEnabled(e) {
            this.enabled = e;
          }
          get fullscreenMaterial() {
            return null !== this.screen ? this.screen.material : null;
          }
          set fullscreenMaterial(t) {
            let n = this.screen;
            null !== n
              ? (n.material = t)
              : ((n = new i.eaF(e.fullscreenGeometry, t)),
                (n.frustumCulled = !1),
                null === this.scene && (this.scene = new i.Z58()),
                this.scene.add(n),
                (this.screen = n));
          }
          getFullscreenMaterial() {
            return this.fullscreenMaterial;
          }
          setFullscreenMaterial(e) {
            this.fullscreenMaterial = e;
          }
          getDepthTexture() {
            return null;
          }
          setDepthTexture(e, t = i.Rkk) {}
          render(e, t, n, i, r) {
            throw new Error("Render method not implemented!");
          }
          setSize(e, t) {}
          initialize(e, t, n) {}
          dispose() {
            for (const t of Object.keys(this)) {
              const n = this[t];
              (n instanceof i.nWS ||
                n instanceof i.imn ||
                n instanceof i.gPd ||
                n instanceof e) &&
                this[t].dispose();
            }
            null !== this.fullscreenMaterial &&
              this.fullscreenMaterial.dispose();
          }
        },
        l = class extends o {
          constructor() {
            super("ClearMaskPass", null, null), (this.needsSwap = !1);
          }
          render(e, t, n, i, r) {
            const s = e.state.buffers.stencil;
            s.setLocked(!1), s.setTest(!1);
          }
        },
        c =
          "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
        u = class extends i.BKk {
          constructor() {
            super({
              name: "CopyMaterial",
              uniforms: { inputBuffer: new i.nc$(null), opacity: new i.nc$(1) },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#include <dithering_pars_fragment>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;\n#include <colorspace_fragment>\n#include <dithering_fragment>\n}",
              vertexShader: c,
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          getOpacity(e) {
            return this.uniforms.opacity.value;
          }
          setOpacity(e) {
            this.uniforms.opacity.value = e;
          }
        },
        h = class extends o {
          constructor(e, t = !0) {
            super("CopyPass"),
              (this.fullscreenMaterial = new u()),
              (this.needsSwap = !1),
              (this.renderTarget = e),
              void 0 === e &&
                ((this.renderTarget = new i.nWS(1, 1, {
                  minFilter: i.k6q,
                  magFilter: i.k6q,
                  stencilBuffer: !1,
                  depthBuffer: !1,
                })),
                (this.renderTarget.texture.name = "CopyPass.Target")),
              (this.autoResize = t);
          }
          get resize() {
            return this.autoResize;
          }
          set resize(e) {
            this.autoResize = e;
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          setAutoResizeEnabled(e) {
            this.autoResize = e;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.inputBuffer = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              e.render(this.scene, this.camera);
          }
          setSize(e, t) {
            this.autoResize && this.renderTarget.setSize(e, t);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              ((this.renderTarget.texture.type = n),
              n !== i.OUM
                ? (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1")
                : null !== e &&
                  e.outputColorSpace === i.er$ &&
                  (this.renderTarget.texture.colorSpace = i.er$));
          }
        },
        d = new i.Q1f(),
        p = class extends o {
          constructor(e = !0, t = !0, n = !1) {
            super("ClearPass", null, null),
              (this.needsSwap = !1),
              (this.color = e),
              (this.depth = t),
              (this.stencil = n),
              (this.overrideClearColor = null),
              (this.overrideClearAlpha = -1);
          }
          setClearFlags(e, t, n) {
            (this.color = e), (this.depth = t), (this.stencil = n);
          }
          getOverrideClearColor() {
            return this.overrideClearColor;
          }
          setOverrideClearColor(e) {
            this.overrideClearColor = e;
          }
          getOverrideClearAlpha() {
            return this.overrideClearAlpha;
          }
          setOverrideClearAlpha(e) {
            this.overrideClearAlpha = e;
          }
          render(e, t, n, i, r) {
            const s = this.overrideClearColor,
              a = this.overrideClearAlpha,
              o = e.getClearAlpha(),
              l = null !== s,
              c = a >= 0;
            l
              ? (e.getClearColor(d), e.setClearColor(s, c ? a : o))
              : c && e.setClearAlpha(a),
              e.setRenderTarget(this.renderToScreen ? null : t),
              e.clear(this.color, this.depth, this.stencil),
              l ? e.setClearColor(d, o) : c && e.setClearAlpha(o);
          }
        },
        f = class extends o {
          constructor(e, t) {
            super("MaskPass", e, t),
              (this.needsSwap = !1),
              (this.clearPass = new p(!1, !1, !0)),
              (this.inverse = !1);
          }
          set mainScene(e) {
            this.scene = e;
          }
          set mainCamera(e) {
            this.camera = e;
          }
          get inverted() {
            return this.inverse;
          }
          set inverted(e) {
            this.inverse = e;
          }
          get clear() {
            return this.clearPass.enabled;
          }
          set clear(e) {
            this.clearPass.enabled = e;
          }
          getClearPass() {
            return this.clearPass;
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(e) {
            this.inverted = e;
          }
          render(e, t, n, i, r) {
            const s = e.getContext(),
              a = e.state.buffers,
              o = this.scene,
              l = this.camera,
              c = this.clearPass,
              u = this.inverted ? 0 : 1,
              h = 1 - u;
            a.color.setMask(!1),
              a.depth.setMask(!1),
              a.color.setLocked(!0),
              a.depth.setLocked(!0),
              a.stencil.setTest(!0),
              a.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE),
              a.stencil.setFunc(s.ALWAYS, u, 4294967295),
              a.stencil.setClear(h),
              a.stencil.setLocked(!0),
              this.clearPass.enabled &&
                (this.renderToScreen
                  ? c.render(e, null)
                  : (c.render(e, t), c.render(e, n))),
              this.renderToScreen
                ? (e.setRenderTarget(null), e.render(o, l))
                : (e.setRenderTarget(t),
                  e.render(o, l),
                  e.setRenderTarget(n),
                  e.render(o, l)),
              a.color.setLocked(!1),
              a.depth.setLocked(!1),
              a.stencil.setLocked(!1),
              a.stencil.setFunc(s.EQUAL, 1, 4294967295),
              a.stencil.setOp(s.KEEP, s.KEEP, s.KEEP),
              a.stencil.setLocked(!0);
          }
        },
        A = class {
          constructor(
            e = null,
            {
              depthBuffer: t = !0,
              stencilBuffer: n = !1,
              multisampling: i = 0,
              frameBufferType: r,
            } = {}
          ) {
            (this.renderer = null),
              (this.inputBuffer = this.createBuffer(t, n, r, i)),
              (this.outputBuffer = this.inputBuffer.clone()),
              (this.copyPass = new h()),
              (this.depthTexture = null),
              (this.passes = []),
              (this.timer = new s()),
              (this.autoRenderToScreen = !0),
              this.setRenderer(e);
          }
          get multisampling() {
            return this.inputBuffer.samples || 0;
          }
          set multisampling(e) {
            const t = this.inputBuffer,
              n = this.multisampling;
            n > 0 && e > 0
              ? ((this.inputBuffer.samples = e),
                (this.outputBuffer.samples = e),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose())
              : n !== e &&
                (this.inputBuffer.dispose(),
                this.outputBuffer.dispose(),
                (this.inputBuffer = this.createBuffer(
                  t.depthBuffer,
                  t.stencilBuffer,
                  t.texture.type,
                  e
                )),
                (this.inputBuffer.depthTexture = this.depthTexture),
                (this.outputBuffer = this.inputBuffer.clone()));
          }
          getTimer() {
            return this.timer;
          }
          getRenderer() {
            return this.renderer;
          }
          setRenderer(e) {
            if (((this.renderer = e), null !== e)) {
              const t = e.getSize(new i.I9Y()),
                n = e.getContext().getContextAttributes().alpha,
                r = this.inputBuffer.texture.type;
              r === i.OUM &&
                e.outputColorSpace === i.er$ &&
                ((this.inputBuffer.texture.colorSpace = i.er$),
                (this.outputBuffer.texture.colorSpace = i.er$),
                this.inputBuffer.dispose(),
                this.outputBuffer.dispose()),
                (e.autoClear = !1),
                this.setSize(t.width, t.height);
              for (const t of this.passes) t.initialize(e, n, r);
            }
          }
          replaceRenderer(e, t = !0) {
            const n = this.renderer,
              i = n.domElement.parentNode;
            return (
              this.setRenderer(e),
              t &&
                null !== i &&
                (i.removeChild(n.domElement), i.appendChild(e.domElement)),
              n
            );
          }
          createDepthTexture() {
            const e = (this.depthTexture = new i.VCu());
            return (
              (this.inputBuffer.depthTexture = e),
              this.inputBuffer.dispose(),
              this.inputBuffer.stencilBuffer
                ? ((e.format = i.dcC), (e.type = i.V3x))
                : (e.type = i.bkx),
              e
            );
          }
          deleteDepthTexture() {
            if (null !== this.depthTexture) {
              this.depthTexture.dispose(),
                (this.depthTexture = null),
                (this.inputBuffer.depthTexture = null),
                this.inputBuffer.dispose();
              for (const e of this.passes) e.setDepthTexture(null);
            }
          }
          createBuffer(e, t, n, r) {
            const s = this.renderer,
              a =
                null === s ? new i.I9Y() : s.getDrawingBufferSize(new i.I9Y()),
              o = {
                minFilter: i.k6q,
                magFilter: i.k6q,
                stencilBuffer: t,
                depthBuffer: e,
                type: n,
              },
              l = new i.nWS(a.width, a.height, o);
            return (
              r > 0 &&
                ((l.ignoreDepthForMultisampleCopy = !1), (l.samples = r)),
              n === i.OUM &&
                null !== s &&
                s.outputColorSpace === i.er$ &&
                (l.texture.colorSpace = i.er$),
              (l.texture.name = "EffectComposer.Buffer"),
              (l.texture.generateMipmaps = !1),
              l
            );
          }
          setMainScene(e) {
            for (const t of this.passes) t.mainScene = e;
          }
          setMainCamera(e) {
            for (const t of this.passes) t.mainCamera = e;
          }
          addPass(e, t) {
            const n = this.passes,
              r = this.renderer,
              s = r.getDrawingBufferSize(new i.I9Y()),
              a = r.getContext().getContextAttributes().alpha,
              o = this.inputBuffer.texture.type;
            if (
              (e.setRenderer(r),
              e.setSize(s.width, s.height),
              e.initialize(r, a, o),
              this.autoRenderToScreen &&
                (n.length > 0 && (n[n.length - 1].renderToScreen = !1),
                e.renderToScreen && (this.autoRenderToScreen = !1)),
              void 0 !== t ? n.splice(t, 0, e) : n.push(e),
              this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0),
              e.needsDepthTexture || null !== this.depthTexture)
            )
              if (null === this.depthTexture) {
                const t = this.createDepthTexture();
                for (e of n) e.setDepthTexture(t);
              } else e.setDepthTexture(this.depthTexture);
          }
          removePass(e) {
            const t = this.passes,
              n = t.indexOf(e);
            if (-1 !== n && t.splice(n, 1).length > 0) {
              if (null !== this.depthTexture) {
                const n = (e, t) => e || t.needsDepthTexture;
                t.reduce(n, !1) ||
                  (e.getDepthTexture() === this.depthTexture &&
                    e.setDepthTexture(null),
                  this.deleteDepthTexture());
              }
              this.autoRenderToScreen &&
                n === t.length &&
                ((e.renderToScreen = !1),
                t.length > 0 && (t[t.length - 1].renderToScreen = !0));
            }
          }
          removeAllPasses() {
            const e = this.passes;
            this.deleteDepthTexture(),
              e.length > 0 &&
                (this.autoRenderToScreen &&
                  (e[e.length - 1].renderToScreen = !1),
                (this.passes = []));
          }
          render(e) {
            const t = this.renderer,
              n = this.copyPass;
            let i,
              r,
              s,
              a = this.inputBuffer,
              o = this.outputBuffer,
              c = !1;
            void 0 === e && (this.timer.update(), (e = this.timer.getDelta()));
            for (const u of this.passes)
              u.enabled &&
                (u.render(t, a, o, e, c),
                u.needsSwap &&
                  (c &&
                    ((n.renderToScreen = u.renderToScreen),
                    (i = t.getContext()),
                    (r = t.state.buffers.stencil),
                    r.setFunc(i.NOTEQUAL, 1, 4294967295),
                    n.render(t, a, o, e, c),
                    r.setFunc(i.EQUAL, 1, 4294967295)),
                  (s = a),
                  (a = o),
                  (o = s)),
                u instanceof f ? (c = !0) : u instanceof l && (c = !1));
          }
          setSize(e, t, n) {
            const r = this.renderer,
              s = r.getSize(new i.I9Y());
            (void 0 !== e && void 0 !== t) || ((e = s.width), (t = s.height)),
              (s.width === e && s.height === t) || r.setSize(e, t, n);
            const a = r.getDrawingBufferSize(new i.I9Y());
            this.inputBuffer.setSize(a.width, a.height),
              this.outputBuffer.setSize(a.width, a.height);
            for (const e of this.passes) e.setSize(a.width, a.height);
          }
          reset() {
            this.dispose(), (this.autoRenderToScreen = !0);
          }
          dispose() {
            for (const e of this.passes) e.dispose();
            (this.passes = []),
              null !== this.inputBuffer && this.inputBuffer.dispose(),
              null !== this.outputBuffer && this.outputBuffer.dispose(),
              this.deleteDepthTexture(),
              this.copyPass.dispose(),
              this.timer.dispose(),
              o.fullscreenGeometry.dispose();
          }
        },
        g = { NONE: 0, DEPTH: 1, CONVOLUTION: 2 },
        m = {
          FRAGMENT_HEAD: "FRAGMENT_HEAD",
          FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
          FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
          VERTEX_HEAD: "VERTEX_HEAD",
          VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT",
        },
        v = class {
          constructor() {
            (this.shaderParts = new Map([
              [m.FRAGMENT_HEAD, null],
              [m.FRAGMENT_MAIN_UV, null],
              [m.FRAGMENT_MAIN_IMAGE, null],
              [m.VERTEX_HEAD, null],
              [m.VERTEX_MAIN_SUPPORT, null],
            ])),
              (this.defines = new Map()),
              (this.uniforms = new Map()),
              (this.blendModes = new Map()),
              (this.extensions = new Set()),
              (this.attributes = g.NONE),
              (this.varyings = new Set()),
              (this.uvTransformation = !1),
              (this.readDepth = !1),
              (this.colorSpace = i.Zr2);
          }
        };
      function y(e) {
        let t;
        if (0 === e) t = new Float64Array(0);
        else if (1 === e) t = new Float64Array([1]);
        else if (e > 1) {
          let n = new Float64Array(e),
            i = new Float64Array(e);
          for (let r = 1; r <= e; ++r) {
            for (let e = 0; e < r; ++e)
              i[e] = 0 === e || e === r - 1 ? 1 : n[e - 1] + n[e];
            (t = i), (i = n), (n = t);
          }
        }
        return t;
      }
      var x = class {
          constructor(e, t = 2) {
            (this.weights = null),
              (this.offsets = null),
              (this.linearWeights = null),
              (this.linearOffsets = null),
              this.generate(e, t);
          }
          get steps() {
            return null === this.offsets ? 0 : this.offsets.length;
          }
          get linearSteps() {
            return null === this.linearOffsets ? 0 : this.linearOffsets.length;
          }
          generate(e, t) {
            if (e < 3 || e > 1020)
              throw new Error("The kernel size must be in the range [3, 1020]");
            const n = e + 2 * t,
              i = t > 0 ? y(n).slice(t, -t) : y(n),
              r = Math.floor((i.length - 1) / 2),
              s = i.reduce((e, t) => e + t, 0),
              a = i.slice(r),
              o = [...Array(r + 1).keys()],
              l = new Float64Array(Math.floor(o.length / 2)),
              c = new Float64Array(l.length);
            l[0] = a[0] / s;
            for (let e = 1, t = 1, n = o.length - 1; e < n; e += 2, ++t) {
              const n = o[e],
                i = o[e + 1],
                r = a[e],
                u = a[e + 1],
                h = r + u,
                d = (n * r + i * u) / h;
              (l[t] = h / s), (c[t] = d);
            }
            for (let e = 0, t = a.length, n = 1 / s; e < t; ++e) a[e] *= n;
            const u = 2 * (l.reduce((e, t) => e + t, 0) - 0.5 * l[0]);
            if (0 !== u)
              for (let e = 0, t = l.length, n = 1 / u; e < t; ++e) l[e] *= n;
            (this.offsets = o),
              (this.weights = a),
              (this.linearOffsets = c),
              (this.linearWeights = l);
          }
        },
        _ = !1,
        b = class {
          constructor(e = null) {
            (this.originalMaterials = new Map()),
              (this.material = null),
              (this.materials = null),
              (this.materialsBackSide = null),
              (this.materialsDoubleSide = null),
              (this.materialsFlatShaded = null),
              (this.materialsFlatShadedBackSide = null),
              (this.materialsFlatShadedDoubleSide = null),
              this.setMaterial(e),
              (this.meshCount = 0),
              (this.replaceMaterial = (e) => {
                if (e.isMesh) {
                  let t;
                  if (e.material.flatShading)
                    switch (e.material.side) {
                      case i.$EB:
                        t = this.materialsFlatShadedDoubleSide;
                        break;
                      case i.hsX:
                        t = this.materialsFlatShadedBackSide;
                        break;
                      default:
                        t = this.materialsFlatShaded;
                    }
                  else
                    switch (e.material.side) {
                      case i.$EB:
                        t = this.materialsDoubleSide;
                        break;
                      case i.hsX:
                        t = this.materialsBackSide;
                        break;
                      default:
                        t = this.materials;
                    }
                  this.originalMaterials.set(e, e.material),
                    e.isSkinnedMesh
                      ? (e.material = t[2])
                      : e.isInstancedMesh
                      ? (e.material = t[1])
                      : (e.material = t[0]),
                    ++this.meshCount;
                }
              });
          }
          cloneMaterial(e) {
            if (!(e instanceof i.BKk)) return e.clone();
            const t = e.uniforms,
              n = new Map();
            for (const e in t) {
              const i = t[e].value;
              i.isRenderTargetTexture && ((t[e].value = null), n.set(e, i));
            }
            const r = e.clone();
            for (const e of n)
              (t[e[0]].value = e[1]), (r.uniforms[e[0]].value = e[1]);
            return r;
          }
          setMaterial(e) {
            if ((this.disposeMaterials(), (this.material = e), null !== e)) {
              const t = (this.materials = [
                this.cloneMaterial(e),
                this.cloneMaterial(e),
                this.cloneMaterial(e),
              ]);
              for (const n of t)
                (n.uniforms = Object.assign({}, e.uniforms)), (n.side = i.hB5);
              (t[2].skinning = !0),
                (this.materialsBackSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.side = i.hsX),
                    n
                  );
                })),
                (this.materialsDoubleSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.side = i.$EB),
                    n
                  );
                })),
                (this.materialsFlatShaded = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    n
                  );
                })),
                (this.materialsFlatShadedBackSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    (n.side = i.hsX),
                    n
                  );
                })),
                (this.materialsFlatShadedDoubleSide = t.map((t) => {
                  const n = this.cloneMaterial(t);
                  return (
                    (n.uniforms = Object.assign({}, e.uniforms)),
                    (n.flatShading = !0),
                    (n.side = i.$EB),
                    n
                  );
                }));
            }
          }
          render(e, t, n) {
            const i = e.shadowMap.enabled;
            if (((e.shadowMap.enabled = !1), _)) {
              const i = this.originalMaterials;
              (this.meshCount = 0),
                t.traverse(this.replaceMaterial),
                e.render(t, n);
              for (const e of i) e[0].material = e[1];
              this.meshCount !== i.size && i.clear();
            } else {
              const i = t.overrideMaterial;
              (t.overrideMaterial = this.material),
                e.render(t, n),
                (t.overrideMaterial = i);
            }
            e.shadowMap.enabled = i;
          }
          disposeMaterials() {
            if (null !== this.material) {
              const e = this.materials
                .concat(this.materialsBackSide)
                .concat(this.materialsDoubleSide)
                .concat(this.materialsFlatShaded)
                .concat(this.materialsFlatShadedBackSide)
                .concat(this.materialsFlatShadedDoubleSide);
              for (const t of e) t.dispose();
            }
          }
          dispose() {
            this.originalMaterials.clear(), this.disposeMaterials();
          }
          static get workaroundEnabled() {
            return _;
          }
          static set workaroundEnabled(e) {
            _ = e;
          }
        },
        E = -1,
        w = class extends i.Qev {
          constructor(e, t = -1, n = -1, r = 1) {
            super(),
              (this.resizable = e),
              (this.baseSize = new i.I9Y(1, 1)),
              (this.preferredSize = new i.I9Y(t, n)),
              (this.target = this.preferredSize),
              (this.s = r),
              (this.effectiveSize = new i.I9Y()),
              this.addEventListener("change", () => this.updateEffectiveSize()),
              this.updateEffectiveSize();
          }
          updateEffectiveSize() {
            const e = this.baseSize,
              t = this.preferredSize,
              n = this.effectiveSize,
              i = this.scale;
            t.width !== E
              ? (n.width = t.width)
              : t.height !== E
              ? (n.width = Math.round(
                  t.height * (e.width / Math.max(e.height, 1))
                ))
              : (n.width = Math.round(e.width * i)),
              t.height !== E
                ? (n.height = t.height)
                : t.width !== E
                ? (n.height = Math.round(
                    t.width / Math.max(e.width / Math.max(e.height, 1), 1)
                  ))
                : (n.height = Math.round(e.height * i));
          }
          get width() {
            return this.effectiveSize.width;
          }
          set width(e) {
            this.preferredWidth = e;
          }
          get height() {
            return this.effectiveSize.height;
          }
          set height(e) {
            this.preferredHeight = e;
          }
          getWidth() {
            return this.width;
          }
          getHeight() {
            return this.height;
          }
          get scale() {
            return this.s;
          }
          set scale(e) {
            this.s !== e &&
              ((this.s = e),
              this.preferredSize.setScalar(E),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getScale() {
            return this.scale;
          }
          setScale(e) {
            this.scale = e;
          }
          get baseWidth() {
            return this.baseSize.width;
          }
          set baseWidth(e) {
            this.baseSize.width !== e &&
              ((this.baseSize.width = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getBaseWidth() {
            return this.baseWidth;
          }
          setBaseWidth(e) {
            this.baseWidth = e;
          }
          get baseHeight() {
            return this.baseSize.height;
          }
          set baseHeight(e) {
            this.baseSize.height !== e &&
              ((this.baseSize.height = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getBaseHeight() {
            return this.baseHeight;
          }
          setBaseHeight(e) {
            this.baseHeight = e;
          }
          setBaseSize(e, t) {
            (this.baseSize.width === e && this.baseSize.height === t) ||
              (this.baseSize.set(e, t),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          get preferredWidth() {
            return this.preferredSize.width;
          }
          set preferredWidth(e) {
            this.preferredSize.width !== e &&
              ((this.preferredSize.width = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getPreferredWidth() {
            return this.preferredWidth;
          }
          setPreferredWidth(e) {
            this.preferredWidth = e;
          }
          get preferredHeight() {
            return this.preferredSize.height;
          }
          set preferredHeight(e) {
            this.preferredSize.height !== e &&
              ((this.preferredSize.height = e),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          getPreferredHeight() {
            return this.preferredHeight;
          }
          setPreferredHeight(e) {
            this.preferredHeight = e;
          }
          setPreferredSize(e, t) {
            (this.preferredSize.width === e &&
              this.preferredSize.height === t) ||
              (this.preferredSize.set(e, t),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(
                this.baseSize.width,
                this.baseSize.height
              ));
          }
          copy(e) {
            (this.s = e.scale),
              this.baseSize.set(e.baseWidth, e.baseHeight),
              this.preferredSize.set(e.preferredWidth, e.preferredHeight),
              this.dispatchEvent({ type: "change" }),
              this.resizable.setSize(this.baseSize.width, this.baseSize.height);
          }
          static get AUTO_SIZE() {
            return E;
          }
        },
        C = new (class {
          constructor(e = 0) {
            this.nextId = e;
          }
          getNextId() {
            return this.nextId++;
          }
          reset(e = 0) {
            return (this.nextId = e), this;
          }
        })(2),
        I = class extends Set {
          constructor(e, t = C.getNextId()) {
            super(),
              (this.exclusive = !1),
              (this._layer = t),
              (this._layer < 1 || this._layer > 31) &&
                (console.warn("Layer out of range, resetting to 2"),
                C.reset(2),
                (this._layer = C.getNextId())),
              void 0 !== e && this.set(e);
          }
          get layer() {
            return this._layer;
          }
          set layer(e) {
            const t = this._layer;
            for (const n of this) n.layers.disable(t), n.layers.enable(e);
            this._layer = e;
          }
          getLayer() {
            return this.layer;
          }
          setLayer(e) {
            this.layer = e;
          }
          isExclusive() {
            return this.exclusive;
          }
          setExclusive(e) {
            this.exclusive = e;
          }
          clear() {
            const e = this.layer;
            for (const t of this) t.layers.disable(e);
            return super.clear();
          }
          set(e) {
            this.clear();
            for (const t of e) this.add(t);
            return this;
          }
          indexOf(e) {
            return this.has(e) ? 0 : -1;
          }
          add(e) {
            return (
              this.exclusive
                ? e.layers.set(this.layer)
                : e.layers.enable(this.layer),
              super.add(e)
            );
          }
          delete(e) {
            return this.has(e) && e.layers.disable(this.layer), super.delete(e);
          }
          toggle(e) {
            let t;
            return (
              this.has(e)
                ? (this.delete(e), (t = !1))
                : (this.add(e), (t = !0)),
              t
            );
          }
          setVisible(e) {
            for (const t of this) e ? t.layers.enable(0) : t.layers.disable(0);
            return this;
          }
        },
        S = 1,
        M = 9,
        T = 21,
        B = 23,
        R = 24,
        D = 28,
        P = 30,
        L = new Map([
          [
            0,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",
          ],
          [
            S,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",
          ],
          [
            2,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",
          ],
          [
            3,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            4,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",
          ],
          [
            5,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",
          ],
          [
            6,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",
          ],
          [
            7,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",
          ],
          [
            8,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",
          ],
          [M, null],
          [
            10,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",
          ],
          [
            11,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",
          ],
          [
            12,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",
          ],
          [
            13,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            14,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",
          ],
          [
            15,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",
          ],
          [
            16,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",
          ],
          [
            17,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",
          ],
          [
            18,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",
          ],
          [
            19,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",
          ],
          [
            20,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            T,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",
          ],
          [
            22,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",
          ],
          [
            B,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
          ],
          [
            R,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",
          ],
          [
            25,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",
          ],
          [
            26,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",
          ],
          [
            27,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
          ],
          [
            D,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",
          ],
          [
            29,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",
          ],
          [
            P,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
          ],
          [
            31,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",
          ],
          [
            32,
            "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",
          ],
        ]),
        U = class extends i.Qev {
          constructor(e, t = 1) {
            super(), (this._blendFunction = e), (this.opacity = new i.nc$(t));
          }
          getOpacity() {
            return this.opacity.value;
          }
          setOpacity(e) {
            this.opacity.value = e;
          }
          get blendFunction() {
            return this._blendFunction;
          }
          set blendFunction(e) {
            (this._blendFunction = e), this.dispatchEvent({ type: "change" });
          }
          getBlendFunction() {
            return this.blendFunction;
          }
          setBlendFunction(e) {
            this.blendFunction = e;
          }
          getShaderCode() {
            return L.get(this.blendFunction);
          }
        },
        F = 2,
        N = 3,
        O = [
          new Float32Array([0, 0]),
          new Float32Array([0, 1, 1]),
          new Float32Array([0, 1, 1, 2]),
          new Float32Array([0, 1, 2, 2, 3]),
          new Float32Array([0, 1, 2, 3, 4, 4, 5]),
          new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10]),
        ],
        Q = class extends i.BKk {
          constructor(e = new i.IUQ()) {
            super({
              name: "KawaseBlurMaterial",
              uniforms: {
                inputBuffer: new i.nc$(null),
                texelSize: new i.nc$(new i.IUQ()),
                scale: new i.nc$(1),
                kernel: new i.nc$(0),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              this.setTexelSize(e.x, e.y),
              (this.kernelSize = F);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.inputBuffer = e;
          }
          get kernelSequence() {
            return O[this.kernelSize];
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(e) {
            this.uniforms.scale.value = e;
          }
          getScale() {
            return this.uniforms.scale.value;
          }
          setScale(e) {
            this.uniforms.scale.value = e;
          }
          getKernel() {
            return null;
          }
          get kernel() {
            return this.uniforms.kernel.value;
          }
          set kernel(e) {
            this.uniforms.kernel.value = e;
          }
          setKernel(e) {
            this.kernel = e;
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t, 0.5 * e, 0.5 * t);
          }
          setSize(e, t) {
            const n = 1 / e,
              i = 1 / t;
            this.uniforms.texelSize.value.set(n, i, 0.5 * n, 0.5 * i);
          }
        },
        k = class extends o {
          constructor({
            kernelSize: e = F,
            resolutionScale: t = 0.5,
            width: n = w.AUTO_SIZE,
            height: r = w.AUTO_SIZE,
            resolutionX: s = n,
            resolutionY: a = r,
          } = {}) {
            super("KawaseBlurPass"),
              (this.renderTargetA = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTargetA.texture.name = "Blur.Target.A"),
              (this.renderTargetB = this.renderTargetA.clone()),
              (this.renderTargetB.texture.name = "Blur.Target.B");
            const o = (this.resolution = new w(this, s, a, t));
            o.addEventListener("change", (e) =>
              this.setSize(o.baseWidth, o.baseHeight)
            ),
              (this._blurMaterial = new Q()),
              (this._blurMaterial.kernelSize = e),
              (this.copyMaterial = new u());
          }
          getResolution() {
            return this.resolution;
          }
          get blurMaterial() {
            return this._blurMaterial;
          }
          set blurMaterial(e) {
            this._blurMaterial = e;
          }
          get dithering() {
            return this.copyMaterial.dithering;
          }
          set dithering(e) {
            this.copyMaterial.dithering = e;
          }
          get kernelSize() {
            return this.blurMaterial.kernelSize;
          }
          set kernelSize(e) {
            this.blurMaterial.kernelSize = e;
          }
          get width() {
            return this.resolution.width;
          }
          set width(e) {
            this.resolution.preferredWidth = e;
          }
          get height() {
            return this.resolution.height;
          }
          set height(e) {
            this.resolution.preferredHeight = e;
          }
          get scale() {
            return this.blurMaterial.scale;
          }
          set scale(e) {
            this.blurMaterial.scale = e;
          }
          getScale() {
            return this.blurMaterial.scale;
          }
          setScale(e) {
            this.blurMaterial.scale = e;
          }
          getKernelSize() {
            return this.kernelSize;
          }
          setKernelSize(e) {
            this.kernelSize = e;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(e) {
            this.resolution.scale = e;
          }
          render(e, t, n, i, r) {
            const s = this.scene,
              a = this.camera,
              o = this.renderTargetA,
              l = this.renderTargetB,
              c = this.blurMaterial,
              u = c.kernelSequence;
            let h = t;
            this.fullscreenMaterial = c;
            for (let t = 0, n = u.length; t < n; ++t) {
              const n = 1 & t ? l : o;
              (c.kernel = u[t]),
                (c.inputBuffer = h.texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
            (this.fullscreenMaterial = this.copyMaterial),
              (this.copyMaterial.inputBuffer = h.texture),
              e.setRenderTarget(this.renderToScreen ? null : n),
              e.render(s, a);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t);
            const i = n.width,
              r = n.height;
            this.renderTargetA.setSize(i, r),
              this.renderTargetB.setSize(i, r),
              this.blurMaterial.setSize(e, t);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              ((this.renderTargetA.texture.type = n),
              (this.renderTargetB.texture.type = n),
              n !== i.OUM
                ? ((this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"),
                  (this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1"))
                : null !== e &&
                  e.outputColorSpace === i.er$ &&
                  ((this.renderTargetA.texture.colorSpace = i.er$),
                  (this.renderTargetB.texture.colorSpace = i.er$)));
          }
          static get AUTO_SIZE() {
            return w.AUTO_SIZE;
          }
        },
        G = class extends i.BKk {
          constructor(e = !1, t = null) {
            super({
              name: "LuminanceMaterial",
              defines: { THREE_REVISION: i.sPf.replace(/\D+/g, "") },
              uniforms: {
                inputBuffer: new i.nc$(null),
                threshold: new i.nc$(0),
                smoothing: new i.nc$(1),
                range: new i.nc$(null),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef RANGE\nuniform vec2 range;\n#elif defined(THRESHOLD)\nuniform float threshold;uniform float smoothing;\n#endif\nvarying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);\n#ifdef RANGE\nfloat low=step(range.x,l);float high=step(l,range.y);l*=low*high;\n#elif defined(THRESHOLD)\nl=smoothstep(threshold,threshold+smoothing,l)*l;\n#endif\n#ifdef COLOR\ngl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);\n#else\ngl_FragColor=vec4(l);\n#endif\n}",
              vertexShader: c,
            }),
              (this.colorOutput = e),
              (this.luminanceRange = t);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          get threshold() {
            return this.uniforms.threshold.value;
          }
          set threshold(e) {
            this.smoothing > 0 || e > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.threshold.value = e);
          }
          getThreshold() {
            return this.threshold;
          }
          setThreshold(e) {
            this.threshold = e;
          }
          get smoothing() {
            return this.uniforms.smoothing.value;
          }
          set smoothing(e) {
            this.threshold > 0 || e > 0
              ? (this.defines.THRESHOLD = "1")
              : delete this.defines.THRESHOLD,
              (this.uniforms.smoothing.value = e);
          }
          getSmoothingFactor() {
            return this.smoothing;
          }
          setSmoothingFactor(e) {
            this.smoothing = e;
          }
          get useThreshold() {
            return this.threshold > 0 || this.smoothing > 0;
          }
          set useThreshold(e) {}
          get colorOutput() {
            return void 0 !== this.defines.COLOR;
          }
          set colorOutput(e) {
            e ? (this.defines.COLOR = "1") : delete this.defines.COLOR,
              (this.needsUpdate = !0);
          }
          isColorOutputEnabled(e) {
            return this.colorOutput;
          }
          setColorOutputEnabled(e) {
            this.colorOutput = e;
          }
          get useRange() {
            return null !== this.luminanceRange;
          }
          set useRange(e) {
            this.luminanceRange = null;
          }
          get luminanceRange() {
            return this.uniforms.range.value;
          }
          set luminanceRange(e) {
            null !== e ? (this.defines.RANGE = "1") : delete this.defines.RANGE,
              (this.uniforms.range.value = e),
              (this.needsUpdate = !0);
          }
          getLuminanceRange() {
            return this.luminanceRange;
          }
          setLuminanceRange(e) {
            this.luminanceRange = e;
          }
        },
        H = class extends o {
          constructor({
            renderTarget: e,
            luminanceRange: t,
            colorOutput: n,
            resolutionScale: r = 1,
            width: s = w.AUTO_SIZE,
            height: a = w.AUTO_SIZE,
            resolutionX: o = s,
            resolutionY: l = a,
          } = {}) {
            super("LuminancePass"),
              (this.fullscreenMaterial = new G(n, t)),
              (this.needsSwap = !1),
              (this.renderTarget = e),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new i.nWS(1, 1, { depthBuffer: !1 })),
                (this.renderTarget.texture.name = "LuminancePass.Target"));
            const c = (this.resolution = new w(this, o, l, r));
            c.addEventListener("change", (e) =>
              this.setSize(c.baseWidth, c.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.inputBuffer = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              e.render(this.scene, this.camera);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              n !== i.OUM &&
              ((this.renderTarget.texture.type = n),
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1"));
          }
        },
        z = class extends i.BKk {
          constructor() {
            super({
              name: "DownsamplingMaterial",
              uniforms: {
                inputBuffer: new i.nc$(null),
                texelSize: new i.nc$(new i.I9Y()),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#define WEIGHT_INNER 0.125\n#define WEIGHT_OUTER 0.0555555\nvarying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        },
        V = class extends i.BKk {
          constructor() {
            super({
              name: "UpsamplingMaterial",
              uniforms: {
                inputBuffer: new i.nc$(null),
                supportBuffer: new i.nc$(null),
                texelSize: new i.nc$(new i.I9Y()),
                radius: new i.nc$(0.85),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;\n#else\nuniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;\n#endif\nuniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);\n#include <colorspace_fragment>\n}",
              vertexShader:
                "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set supportBuffer(e) {
            this.uniforms.supportBuffer.value = e;
          }
          get radius() {
            return this.uniforms.radius.value;
          }
          set radius(e) {
            this.uniforms.radius.value = e;
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        },
        W = class extends o {
          constructor() {
            super("MipmapBlurPass"),
              (this.needsSwap = !1),
              (this.renderTarget = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "Upsampling.Mipmap0"),
              (this.downsamplingMipmaps = []),
              (this.upsamplingMipmaps = []),
              (this.downsamplingMaterial = new z()),
              (this.upsamplingMaterial = new V()),
              (this.resolution = new i.I9Y());
          }
          get texture() {
            return this.renderTarget.texture;
          }
          get levels() {
            return this.downsamplingMipmaps.length;
          }
          set levels(e) {
            if (this.levels !== e) {
              const t = this.renderTarget;
              this.dispose(),
                (this.downsamplingMipmaps = []),
                (this.upsamplingMipmaps = []);
              for (let n = 0; n < e; ++n) {
                const e = t.clone();
                (e.texture.name = "Downsampling.Mipmap" + n),
                  this.downsamplingMipmaps.push(e);
              }
              this.upsamplingMipmaps.push(t);
              for (let n = 1, i = e - 1; n < i; ++n) {
                const e = t.clone();
                (e.texture.name = "Upsampling.Mipmap" + n),
                  this.upsamplingMipmaps.push(e);
              }
              this.setSize(this.resolution.x, this.resolution.y);
            }
          }
          get radius() {
            return this.upsamplingMaterial.radius;
          }
          set radius(e) {
            this.upsamplingMaterial.radius = e;
          }
          render(e, t, n, i, r) {
            const { scene: s, camera: a } = this,
              { downsamplingMaterial: o, upsamplingMaterial: l } = this,
              { downsamplingMipmaps: c, upsamplingMipmaps: u } = this;
            let h = t;
            this.fullscreenMaterial = o;
            for (let t = 0, n = c.length; t < n; ++t) {
              const n = c[t];
              o.setSize(h.width, h.height),
                (o.inputBuffer = h.texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
            this.fullscreenMaterial = l;
            for (let t = u.length - 1; t >= 0; --t) {
              const n = u[t];
              l.setSize(h.width, h.height),
                (l.inputBuffer = h.texture),
                (l.supportBuffer = c[t].texture),
                e.setRenderTarget(n),
                e.render(s, a),
                (h = n);
            }
          }
          setSize(e, t) {
            const n = this.resolution;
            n.set(e, t);
            let i = n.width,
              r = n.height;
            for (let e = 0, t = this.downsamplingMipmaps.length; e < t; ++e)
              (i = Math.round(0.5 * i)),
                (r = Math.round(0.5 * r)),
                this.downsamplingMipmaps[e].setSize(i, r),
                e < this.upsamplingMipmaps.length &&
                  this.upsamplingMipmaps[e].setSize(i, r);
          }
          initialize(e, t, n) {
            if (void 0 !== n) {
              const t = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
              for (const e of t) e.texture.type = n;
              if (n !== i.OUM)
                (this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                  "1"),
                  (this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                    "1");
              else if (null !== e && e.outputColorSpace === i.er$)
                for (const e of t) e.texture.colorSpace = i.er$;
            }
          }
          dispose() {
            super.dispose();
            for (const e of this.downsamplingMipmaps.concat(
              this.upsamplingMipmaps
            ))
              e.dispose();
          }
        },
        j = class extends i.Qev {
          constructor(
            e,
            t,
            {
              attributes: n = g.NONE,
              blendFunction: r = B,
              defines: s = new Map(),
              uniforms: a = new Map(),
              extensions: o = null,
              vertexShader: l = null,
            } = {}
          ) {
            super(),
              (this.name = e),
              (this.renderer = null),
              (this.attributes = n),
              (this.fragmentShader = t),
              (this.vertexShader = l),
              (this.defines = s),
              (this.uniforms = a),
              (this.extensions = o),
              (this.blendMode = new U(r)),
              this.blendMode.addEventListener("change", (e) =>
                this.setChanged()
              ),
              (this._inputColorSpace = i.Zr2),
              (this._outputColorSpace = i.jf0);
          }
          get inputColorSpace() {
            return this._inputColorSpace;
          }
          set inputColorSpace(e) {
            (this._inputColorSpace = e), this.setChanged();
          }
          get outputColorSpace() {
            return this._outputColorSpace;
          }
          set outputColorSpace(e) {
            (this._outputColorSpace = e), this.setChanged();
          }
          set mainScene(e) {}
          set mainCamera(e) {}
          getName() {
            return this.name;
          }
          setRenderer(e) {
            this.renderer = e;
          }
          getDefines() {
            return this.defines;
          }
          getUniforms() {
            return this.uniforms;
          }
          getExtensions() {
            return this.extensions;
          }
          getBlendMode() {
            return this.blendMode;
          }
          getAttributes() {
            return this.attributes;
          }
          setAttributes(e) {
            (this.attributes = e), this.setChanged();
          }
          getFragmentShader() {
            return this.fragmentShader;
          }
          setFragmentShader(e) {
            (this.fragmentShader = e), this.setChanged();
          }
          getVertexShader() {
            return this.vertexShader;
          }
          setVertexShader(e) {
            (this.vertexShader = e), this.setChanged();
          }
          setChanged() {
            this.dispatchEvent({ type: "change" });
          }
          setDepthTexture(e, t = i.Rkk) {}
          update(e, t, n) {}
          setSize(e, t) {}
          initialize(e, t, n) {}
          dispose() {
            for (const e of Object.keys(this)) {
              const t = this[e];
              (t instanceof i.nWS ||
                t instanceof i.imn ||
                t instanceof i.gPd ||
                t instanceof o) &&
                this[e].dispose();
            }
          }
        },
        q = class extends j {
          constructor({
            blendFunction: e = D,
            luminanceThreshold: t = 0.9,
            luminanceSmoothing: n = 0.025,
            mipmapBlur: r = !1,
            intensity: s = 1,
            radius: a = 0.85,
            levels: o = 8,
            kernelSize: l = N,
            resolutionScale: c = 0.5,
            width: u = w.AUTO_SIZE,
            height: h = w.AUTO_SIZE,
            resolutionX: d = u,
            resolutionY: p = h,
          } = {}) {
            super(
              "BloomEffect",
              "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D map;\n#else\nuniform lowp sampler2D map;\n#endif\nuniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,texel.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["map", new i.nc$(null)],
                  ["intensity", new i.nc$(s)],
                ]),
              }
            ),
              (this.renderTarget = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "Bloom.Target"),
              (this.blurPass = new k({ kernelSize: l })),
              (this.luminancePass = new H({ colorOutput: !0 })),
              (this.luminanceMaterial.threshold = t),
              (this.luminanceMaterial.smoothing = n),
              (this.mipmapBlurPass = new W()),
              (this.mipmapBlurPass.enabled = r),
              (this.mipmapBlurPass.radius = a),
              (this.mipmapBlurPass.levels = o),
              (this.uniforms.get("map").value = r
                ? this.mipmapBlurPass.texture
                : this.renderTarget.texture);
            const f = (this.resolution = new w(this, d, p, c));
            f.addEventListener("change", (e) =>
              this.setSize(f.baseWidth, f.baseHeight)
            );
          }
          get texture() {
            return this.mipmapBlurPass.enabled
              ? this.mipmapBlurPass.texture
              : this.renderTarget.texture;
          }
          getTexture() {
            return this.texture;
          }
          getResolution() {
            return this.resolution;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getLuminancePass() {
            return this.luminancePass;
          }
          get luminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          getLuminanceMaterial() {
            return this.luminancePass.fullscreenMaterial;
          }
          get width() {
            return this.resolution.width;
          }
          set width(e) {
            this.resolution.preferredWidth = e;
          }
          get height() {
            return this.resolution.height;
          }
          set height(e) {
            this.resolution.preferredHeight = e;
          }
          get dithering() {
            return this.blurPass.dithering;
          }
          set dithering(e) {
            this.blurPass.dithering = e;
          }
          get kernelSize() {
            return this.blurPass.kernelSize;
          }
          set kernelSize(e) {
            this.blurPass.kernelSize = e;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed"), 1;
          }
          set distinction(e) {
            console.warn(this.name, "distinction was removed");
          }
          get intensity() {
            return this.uniforms.get("intensity").value;
          }
          set intensity(e) {
            this.uniforms.get("intensity").value = e;
          }
          getIntensity() {
            return this.intensity;
          }
          setIntensity(e) {
            this.intensity = e;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(e) {
            this.resolution.scale = e;
          }
          update(e, t, n) {
            const i = this.renderTarget,
              r = this.luminancePass;
            r.enabled
              ? (r.render(e, t),
                this.mipmapBlurPass.enabled
                  ? this.mipmapBlurPass.render(e, r.renderTarget)
                  : this.blurPass.render(e, r.renderTarget, i))
              : this.mipmapBlurPass.enabled
              ? this.mipmapBlurPass.render(e, t)
              : this.blurPass.render(e, t, i);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t),
              this.renderTarget.setSize(n.width, n.height),
              this.blurPass.resolution.copy(n),
              this.luminancePass.setSize(e, t),
              this.mipmapBlurPass.setSize(e, t);
          }
          initialize(e, t, n) {
            this.blurPass.initialize(e, t, n),
              this.luminancePass.initialize(e, t, n),
              this.mipmapBlurPass.initialize(e, t, n),
              void 0 !== n &&
                ((this.renderTarget.texture.type = n),
                null !== e &&
                  e.outputColorSpace === i.er$ &&
                  (this.renderTarget.texture.colorSpace = i.er$));
          }
        },
        Y = class extends j {
          constructor({
            blendFunction: e = P,
            brightness: t = 0,
            contrast: n = 0,
          } = {}) {
            super(
              "BrightnessContrastEffect",
              "uniform float brightness;uniform float contrast;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=inputColor.rgb+vec3(brightness-0.5);if(contrast>0.0){color/=vec3(1.0-contrast);}else{color*=vec3(1.0+contrast);}outputColor=vec4(color+vec3(0.5),inputColor.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["brightness", new i.nc$(t)],
                  ["contrast", new i.nc$(n)],
                ]),
              }
            ),
              (this.inputColorSpace = i.er$);
          }
          get brightness() {
            return this.uniforms.get("brightness").value;
          }
          set brightness(e) {
            this.uniforms.get("brightness").value = e;
          }
          getBrightness() {
            return this.brightness;
          }
          setBrightness(e) {
            this.brightness = e;
          }
          get contrast() {
            return this.uniforms.get("contrast").value;
          }
          set contrast(e) {
            this.uniforms.get("contrast").value = e;
          }
          getContrast() {
            return this.contrast;
          }
          setContrast(e) {
            this.contrast = e;
          }
        },
        X = class extends j {
          constructor({ blendFunction: e, bits: t = 16 } = {}) {
            super(
              "ColorDepthEffect",
              "uniform float factor;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=vec4(floor(inputColor.rgb*factor+0.5)/factor,inputColor.a);}",
              {
                blendFunction: e,
                uniforms: new Map([["factor", new i.nc$(1)]]),
              }
            ),
              (this.bits = 0),
              (this.bitDepth = t);
          }
          get bitDepth() {
            return this.bits;
          }
          set bitDepth(e) {
            (this.bits = e),
              (this.uniforms.get("factor").value = Math.pow(2, e / 3));
          }
          getBitDepth() {
            return this.bitDepth;
          }
          setBitDepth(e) {
            this.bitDepth = e;
          }
        },
        K = 0,
        J = 1,
        Z = 0,
        $ = 3,
        ee = class extends i.BKk {
          constructor(e = !1, t = !1) {
            super({
              name: "BokehMaterial",
              defines: { PASS: e ? "2" : "1" },
              uniforms: {
                inputBuffer: new i.nc$(null),
                cocBuffer: new i.nc$(null),
                texelSize: new i.nc$(new i.I9Y()),
                kernel64: new i.nc$(null),
                kernel16: new i.nc$(null),
                scale: new i.nc$(1),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if PASS == 1\nuniform vec4 kernel64[32];\n#else\nuniform vec4 kernel16[8];\n#endif\nuniform lowp sampler2D cocBuffer;uniform vec2 texelSize;uniform float scale;varying vec2 vUv;void main(){\n#ifdef FOREGROUND\nvec2 cocNearFar=texture2D(cocBuffer,vUv).rg*scale;float coc=cocNearFar.x;\n#else\nfloat coc=texture2D(cocBuffer,vUv).g*scale;\n#endif\nif(coc==0.0){gl_FragColor=texture2D(inputBuffer,vUv);}else{\n#ifdef FOREGROUND\nvec2 step=texelSize*max(cocNearFar.x,cocNearFar.y);\n#else\nvec2 step=texelSize*coc;\n#endif\n#if PASS == 1\nvec4 acc=vec4(0.0);for(int i=0;i<32;++i){vec4 kernel=kernel64[i];vec2 uv=step*kernel.xy+vUv;acc+=texture2D(inputBuffer,uv);uv=step*kernel.zw+vUv;acc+=texture2D(inputBuffer,uv);}gl_FragColor=acc/64.0;\n#else\nvec4 maxValue=texture2D(inputBuffer,vUv);for(int i=0;i<8;++i){vec4 kernel=kernel16[i];vec2 uv=step*kernel.xy+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);uv=step*kernel.zw+vUv;maxValue=max(texture2D(inputBuffer,uv),maxValue);}gl_FragColor=maxValue;\n#endif\n}}",
              vertexShader: c,
            }),
              t && (this.defines.FOREGROUND = "1"),
              this.generateKernel();
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set cocBuffer(e) {
            this.uniforms.cocBuffer.value = e;
          }
          setCoCBuffer(e) {
            this.uniforms.cocBuffer.value = e;
          }
          get scale() {
            return this.uniforms.scale.value;
          }
          set scale(e) {
            this.uniforms.scale.value = e;
          }
          getScale(e) {
            return this.scale;
          }
          setScale(e) {
            this.scale = e;
          }
          generateKernel() {
            const e = new Float64Array(128),
              t = new Float64Array(32);
            let n = 0,
              i = 0;
            for (let r = 0, s = Math.sqrt(80); r < 80; ++r) {
              const a = 2.39996323 * r,
                o = Math.sqrt(r) / s,
                l = o * Math.cos(a),
                c = o * Math.sin(a);
              r % 5 == 0
                ? ((t[i++] = l), (t[i++] = c))
                : ((e[n++] = l), (e[n++] = c));
            }
            (this.uniforms.kernel64.value = e),
              (this.uniforms.kernel16.value = t);
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t);
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        };
      function te(e, t, n) {
        return e * (t - n) - t;
      }
      function ne(e, t, n) {
        return Math.min(Math.max((e + t) / (t - n), 0), 1);
      }
      var ie = class extends i.BKk {
          constructor(e) {
            super({
              name: "CircleOfConfusionMaterial",
              defines: { DEPTH_PACKING: "0" },
              uniforms: {
                depthBuffer: new i.nc$(null),
                focusDistance: new i.nc$(0),
                focusRange: new i.nc$(0),
                cameraNear: new i.nc$(0.3),
                cameraFar: new i.nc$(1e3),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform float focusDistance;uniform float focusRange;uniform float cameraNear;uniform float cameraFar;varying vec2 vUv;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nfloat depth=unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nfloat depth=texture2D(depthBuffer,uv).r;\n#endif\n#ifdef LOG_DEPTH\nfloat d=pow(2.0,depth*log2(cameraFar+1.0))-1.0;float a=cameraFar/(cameraFar-cameraNear);float b=cameraFar*cameraNear/(cameraNear-cameraFar);depth=a+b/d;\n#endif\nreturn depth;}void main(){float depth=readDepth(vUv);\n#ifdef PERSPECTIVE_CAMERA\nfloat viewZ=perspectiveDepthToViewZ(depth,cameraNear,cameraFar);float linearDepth=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);\n#else\nfloat linearDepth=depth;\n#endif\nfloat signedDistance=linearDepth-focusDistance;float magnitude=smoothstep(0.0,focusRange,abs(signedDistance));gl_FragColor.rg=magnitude*vec2(step(signedDistance,0.0),step(0.0,signedDistance));}",
              vertexShader: c,
            }),
              (this.uniforms.focalLength = this.uniforms.focusRange),
              this.copyCameraSettings(e);
          }
          get near() {
            return this.uniforms.cameraNear.value;
          }
          get far() {
            return this.uniforms.cameraFar.value;
          }
          set depthBuffer(e) {
            this.uniforms.depthBuffer.value = e;
          }
          set depthPacking(e) {
            (this.defines.DEPTH_PACKING = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(e, t = i.Rkk) {
            (this.depthBuffer = e), (this.depthPacking = t);
          }
          get focusDistance() {
            return this.uniforms.focusDistance.value;
          }
          set focusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          get worldFocusDistance() {
            return -te(this.focusDistance, this.near, this.far);
          }
          set worldFocusDistance(e) {
            this.focusDistance = ne(-e, this.near, this.far);
          }
          getFocusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          setFocusDistance(e) {
            this.uniforms.focusDistance.value = e;
          }
          get focalLength() {
            return this.focusRange;
          }
          set focalLength(e) {
            this.focusRange = e;
          }
          get focusRange() {
            return this.uniforms.focusRange.value;
          }
          set focusRange(e) {
            this.uniforms.focusRange.value = e;
          }
          get worldFocusRange() {
            return -te(this.focusRange, this.near, this.far);
          }
          set worldFocusRange(e) {
            this.focusRange = ne(-e, this.near, this.far);
          }
          getFocalLength(e) {
            return this.focusRange;
          }
          setFocalLength(e) {
            this.focusRange = e;
          }
          adoptCameraSettings(e) {
            this.copyCameraSettings(e);
          }
          copyCameraSettings(e) {
            e &&
              ((this.uniforms.cameraNear.value = e.near),
              (this.uniforms.cameraFar.value = e.far),
              e instanceof i.ubm
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
        },
        re = class extends i.BKk {
          constructor(e = null) {
            super({
              name: "MaskMaterial",
              uniforms: {
                maskTexture: new i.nc$(e),
                inputBuffer: new i.nc$(null),
                strength: new i.nc$(1),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#ifdef MASK_PRECISION_HIGH\nuniform mediump sampler2D maskTexture;\n#else\nuniform lowp sampler2D maskTexture;\n#endif\n#if MASK_FUNCTION != 0\nuniform float strength;\n#endif\nvarying vec2 vUv;void main(){\n#if COLOR_CHANNEL == 0\nfloat mask=texture2D(maskTexture,vUv).r;\n#elif COLOR_CHANNEL == 1\nfloat mask=texture2D(maskTexture,vUv).g;\n#elif COLOR_CHANNEL == 2\nfloat mask=texture2D(maskTexture,vUv).b;\n#else\nfloat mask=texture2D(maskTexture,vUv).a;\n#endif\n#if MASK_FUNCTION == 0\n#ifdef INVERTED\nmask=step(mask,0.0);\n#else\nmask=1.0-step(mask,0.0);\n#endif\n#else\nmask=clamp(mask*strength,0.0,1.0);\n#ifdef INVERTED\nmask=1.0-mask;\n#endif\n#endif\n#if MASK_FUNCTION == 3\nvec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=vec4(mask*texel.rgb,texel.a);\n#elif MASK_FUNCTION == 2\ngl_FragColor=vec4(mask*texture2D(inputBuffer,vUv).rgb,mask);\n#else\ngl_FragColor=mask*texture2D(inputBuffer,vUv);\n#endif\n}",
              vertexShader: c,
            }),
              (this.colorChannel = K),
              (this.maskFunction = Z);
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          set maskTexture(e) {
            (this.uniforms.maskTexture.value = e),
              delete this.defines.MASK_PRECISION_HIGH,
              e.type !== i.OUM && (this.defines.MASK_PRECISION_HIGH = "1"),
              (this.needsUpdate = !0);
          }
          setMaskTexture(e) {
            this.maskTexture = e;
          }
          set colorChannel(e) {
            (this.defines.COLOR_CHANNEL = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setColorChannel(e) {
            this.colorChannel = e;
          }
          set maskFunction(e) {
            (this.defines.MASK_FUNCTION = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setMaskFunction(e) {
            this.maskFunction = e;
          }
          get inverted() {
            return void 0 !== this.defines.INVERTED;
          }
          set inverted(e) {
            this.inverted && !e
              ? delete this.defines.INVERTED
              : e && (this.defines.INVERTED = "1"),
              (this.needsUpdate = !0);
          }
          isInverted() {
            return this.inverted;
          }
          setInverted(e) {
            this.inverted = e;
          }
          get strength() {
            return this.uniforms.strength.value;
          }
          set strength(e) {
            this.uniforms.strength.value = e;
          }
          getStrength() {
            return this.strength;
          }
          setStrength(e) {
            this.strength = e;
          }
        },
        se = class extends o {
          constructor(e, t = "inputBuffer") {
            super("ShaderPass"),
              (this.fullscreenMaterial = e),
              (this.input = t);
          }
          setInput(e) {
            this.input = e;
          }
          render(e, t, n, i, r) {
            const s = this.fullscreenMaterial.uniforms;
            null !== t &&
              void 0 !== s &&
              void 0 !== s[this.input] &&
              (s[this.input].value = t.texture),
              e.setRenderTarget(this.renderToScreen ? null : n),
              e.render(this.scene, this.camera);
          }
          initialize(e, t, n) {
            void 0 !== n &&
              n !== i.OUM &&
              (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                "1");
          }
        },
        ae = class extends j {
          constructor(
            e,
            {
              blendFunction: t,
              worldFocusDistance: n,
              worldFocusRange: r,
              focusDistance: s = 0,
              focalLength: a = 0.1,
              focusRange: o = a,
              bokehScale: l = 1,
              resolutionScale: c = 1,
              width: u = w.AUTO_SIZE,
              height: h = w.AUTO_SIZE,
              resolutionX: d = u,
              resolutionY: p = h,
            } = {}
          ) {
            super(
              "DepthOfFieldEffect",
              "#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D nearColorBuffer;uniform mediump sampler2D farColorBuffer;\n#else\nuniform lowp sampler2D nearColorBuffer;uniform lowp sampler2D farColorBuffer;\n#endif\nuniform lowp sampler2D nearCoCBuffer;uniform lowp sampler2D farCoCBuffer;uniform float scale;void mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){vec4 colorNear=texture2D(nearColorBuffer,uv);vec4 colorFar=texture2D(farColorBuffer,uv);\n#if MASK_FUNCTION == 1\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,colorFar.a);cocNearFar.x=min(cocNearFar.x*scale,1.0);\n#else\nvec2 cocNearFar=vec2(texture2D(nearCoCBuffer,uv).r,texture2D(farCoCBuffer,uv).g);cocNearFar=min(cocNearFar*scale,1.0);\n#endif\nvec4 result=inputColor*(1.0-cocNearFar.y)+colorFar;result=mix(result,colorNear,cocNearFar.x);outputColor=result;}",
              {
                blendFunction: t,
                attributes: g.DEPTH,
                uniforms: new Map([
                  ["nearColorBuffer", new i.nc$(null)],
                  ["farColorBuffer", new i.nc$(null)],
                  ["nearCoCBuffer", new i.nc$(null)],
                  ["farCoCBuffer", new i.nc$(null)],
                  ["scale", new i.nc$(1)],
                ]),
              }
            ),
              (this.camera = e),
              (this.renderTarget = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "DoF.Intermediate"),
              (this.renderTargetMasked = this.renderTarget.clone()),
              (this.renderTargetMasked.texture.name = "DoF.Masked.Far"),
              (this.renderTargetNear = this.renderTarget.clone()),
              (this.renderTargetNear.texture.name = "DoF.Bokeh.Near"),
              (this.uniforms.get("nearColorBuffer").value =
                this.renderTargetNear.texture),
              (this.renderTargetFar = this.renderTarget.clone()),
              (this.renderTargetFar.texture.name = "DoF.Bokeh.Far"),
              (this.uniforms.get("farColorBuffer").value =
                this.renderTargetFar.texture),
              (this.renderTargetCoC = this.renderTarget.clone()),
              (this.renderTargetCoC.texture.name = "DoF.CoC"),
              (this.uniforms.get("farCoCBuffer").value =
                this.renderTargetCoC.texture),
              (this.renderTargetCoCBlurred = this.renderTargetCoC.clone()),
              (this.renderTargetCoCBlurred.texture.name = "DoF.CoC.Blurred"),
              (this.uniforms.get("nearCoCBuffer").value =
                this.renderTargetCoCBlurred.texture),
              (this.cocPass = new se(new ie(e)));
            const f = this.cocMaterial;
            (f.focusDistance = s),
              (f.focusRange = o),
              void 0 !== n && (f.worldFocusDistance = n),
              void 0 !== r && (f.worldFocusRange = r),
              (this.blurPass = new k({
                resolutionScale: c,
                resolutionX: d,
                resolutionY: p,
                kernelSize: F,
              })),
              (this.maskPass = new se(new re(this.renderTargetCoC.texture)));
            (this.maskPass.fullscreenMaterial.colorChannel = J),
              (this.maskFunction = $),
              (this.bokehNearBasePass = new se(new ee(!1, !0))),
              (this.bokehNearBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehNearFillPass = new se(new ee(!0, !0))),
              (this.bokehNearFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoCBlurred.texture),
              (this.bokehFarBasePass = new se(new ee(!1, !1))),
              (this.bokehFarBasePass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.bokehFarFillPass = new se(new ee(!0, !1))),
              (this.bokehFarFillPass.fullscreenMaterial.cocBuffer =
                this.renderTargetCoC.texture),
              (this.target = null);
            const A = (this.resolution = new w(this, d, p, c));
            A.addEventListener("change", (e) =>
              this.setSize(A.baseWidth, A.baseHeight)
            ),
              (this.bokehScale = l);
          }
          set mainCamera(e) {
            (this.camera = e), this.cocMaterial.copyCameraSettings(e);
          }
          get cocTexture() {
            return this.renderTargetCoC.texture;
          }
          get maskFunction() {
            return this.maskPass.fullscreenMaterial.maskFunction;
          }
          set maskFunction(e) {
            this.maskFunction !== e &&
              (this.defines.set("MASK_FUNCTION", e.toFixed(0)),
              (this.maskPass.fullscreenMaterial.maskFunction = e),
              this.setChanged());
          }
          get cocMaterial() {
            return this.cocPass.fullscreenMaterial;
          }
          get circleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getCircleOfConfusionMaterial() {
            return this.cocMaterial;
          }
          getBlurPass() {
            return this.blurPass;
          }
          getResolution() {
            return this.resolution;
          }
          get bokehScale() {
            return this.uniforms.get("scale").value;
          }
          set bokehScale(e) {
            (this.bokehNearBasePass.fullscreenMaterial.scale = e),
              (this.bokehNearFillPass.fullscreenMaterial.scale = e),
              (this.bokehFarBasePass.fullscreenMaterial.scale = e),
              (this.bokehFarFillPass.fullscreenMaterial.scale = e),
              (this.maskPass.fullscreenMaterial.strength = e),
              (this.uniforms.get("scale").value = e);
          }
          getBokehScale() {
            return this.bokehScale;
          }
          setBokehScale(e) {
            this.bokehScale = e;
          }
          getTarget() {
            return this.target;
          }
          setTarget(e) {
            this.target = e;
          }
          calculateFocusDistance(e) {
            const t = this.camera;
            return ne(-t.position.distanceTo(e), t.near, t.far);
          }
          setDepthTexture(e, t = i.Rkk) {
            (this.cocMaterial.depthBuffer = e),
              (this.cocMaterial.depthPacking = t);
          }
          update(e, t, n) {
            const i = this.renderTarget,
              r = this.renderTargetCoC,
              s = this.renderTargetCoCBlurred,
              a = this.renderTargetMasked;
            if (null !== this.target) {
              const e = this.calculateFocusDistance(this.target);
              this.cocMaterial.focusDistance = e;
            }
            this.cocPass.render(e, null, r),
              this.blurPass.render(e, r, s),
              this.maskPass.render(e, t, a),
              this.bokehFarBasePass.render(e, a, i),
              this.bokehFarFillPass.render(e, i, this.renderTargetFar),
              this.bokehNearBasePass.render(e, t, i),
              this.bokehNearFillPass.render(e, i, this.renderTargetNear);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t);
            const i = n.width,
              r = n.height;
            this.cocPass.setSize(e, t),
              this.blurPass.setSize(e, t),
              this.maskPass.setSize(e, t),
              this.renderTargetFar.setSize(e, t),
              this.renderTargetCoC.setSize(e, t),
              this.renderTargetMasked.setSize(e, t),
              this.renderTarget.setSize(i, r),
              this.renderTargetNear.setSize(i, r),
              this.renderTargetCoCBlurred.setSize(i, r),
              this.bokehNearBasePass.fullscreenMaterial.setSize(e, t),
              this.bokehNearFillPass.fullscreenMaterial.setSize(e, t),
              this.bokehFarBasePass.fullscreenMaterial.setSize(e, t),
              this.bokehFarFillPass.fullscreenMaterial.setSize(e, t);
          }
          initialize(e, t, n) {
            this.cocPass.initialize(e, t, n),
              this.maskPass.initialize(e, t, n),
              this.bokehNearBasePass.initialize(e, t, n),
              this.bokehNearFillPass.initialize(e, t, n),
              this.bokehFarBasePass.initialize(e, t, n),
              this.bokehFarFillPass.initialize(e, t, n),
              this.blurPass.initialize(e, t, i.OUM),
              e.capabilities.logarithmicDepthBuffer &&
                (this.cocPass.fullscreenMaterial.defines.LOG_DEPTH = "1"),
              void 0 !== n &&
                ((this.renderTarget.texture.type = n),
                (this.renderTargetNear.texture.type = n),
                (this.renderTargetFar.texture.type = n),
                (this.renderTargetMasked.texture.type = n),
                null !== e &&
                  e.outputColorSpace === i.er$ &&
                  ((this.renderTarget.texture.colorSpace = i.er$),
                  (this.renderTargetNear.texture.colorSpace = i.er$),
                  (this.renderTargetFar.texture.colorSpace = i.er$),
                  (this.renderTargetMasked.texture.colorSpace = i.er$)));
          }
        };
      var oe = class extends i.GYF {
        constructor(e, t, n = i.Kzv, r = i.OUM) {
          super(
            (function (e, t, n) {
              const r = new Map([
                [i.Kzv, 1],
                [i.VT0, 1],
                [i.paN, 2],
                [i.GWd, 4],
              ]);
              let s;
              if (
                (r.has(t) || console.error("Invalid noise texture format"),
                n === i.OUM)
              ) {
                s = new Uint8Array(e * r.get(t));
                for (let e = 0, t = s.length; e < t; ++e)
                  s[e] = 255 * Math.random() + 0.5;
              } else {
                s = new Float32Array(e * r.get(t));
                for (let e = 0, t = s.length; e < t; ++e) s[e] = Math.random();
              }
              return s;
            })(e * t, n, r),
            e,
            t,
            n,
            r
          ),
            (this.needsUpdate = !0);
        }
      };
      var le = 1,
        ce = 2,
        ue =
          (i.BKk,
          i.BKk,
          class extends o {
            constructor(e, t, n = null) {
              super("RenderPass", e, t),
                (this.needsSwap = !1),
                (this.clearPass = new p()),
                (this.overrideMaterialManager = null === n ? null : new b(n)),
                (this.ignoreBackground = !1),
                (this.skipShadowMapUpdate = !1),
                (this.selection = null);
            }
            set mainScene(e) {
              this.scene = e;
            }
            set mainCamera(e) {
              this.camera = e;
            }
            get renderToScreen() {
              return super.renderToScreen;
            }
            set renderToScreen(e) {
              (super.renderToScreen = e), (this.clearPass.renderToScreen = e);
            }
            get overrideMaterial() {
              const e = this.overrideMaterialManager;
              return null !== e ? e.material : null;
            }
            set overrideMaterial(e) {
              const t = this.overrideMaterialManager;
              null !== e
                ? null !== t
                  ? t.setMaterial(e)
                  : (this.overrideMaterialManager = new b(e))
                : null !== t &&
                  (t.dispose(), (this.overrideMaterialManager = null));
            }
            getOverrideMaterial() {
              return this.overrideMaterial;
            }
            setOverrideMaterial(e) {
              this.overrideMaterial = e;
            }
            get clear() {
              return this.clearPass.enabled;
            }
            set clear(e) {
              this.clearPass.enabled = e;
            }
            getSelection() {
              return this.selection;
            }
            setSelection(e) {
              this.selection = e;
            }
            isBackgroundDisabled() {
              return this.ignoreBackground;
            }
            setBackgroundDisabled(e) {
              this.ignoreBackground = e;
            }
            isShadowMapDisabled() {
              return this.skipShadowMapUpdate;
            }
            setShadowMapDisabled(e) {
              this.skipShadowMapUpdate = e;
            }
            getClearPass() {
              return this.clearPass;
            }
            render(e, t, n, i, r) {
              const s = this.scene,
                a = this.camera,
                o = this.selection,
                l = a.layers.mask,
                c = s.background,
                u = e.shadowMap.autoUpdate,
                h = this.renderToScreen ? null : t;
              null !== o && a.layers.set(o.getLayer()),
                this.skipShadowMapUpdate && (e.shadowMap.autoUpdate = !1),
                (this.ignoreBackground ||
                  null !== this.clearPass.overrideClearColor) &&
                  (s.background = null),
                this.clearPass.enabled && this.clearPass.render(e, t),
                e.setRenderTarget(h),
                null !== this.overrideMaterialManager
                  ? this.overrideMaterialManager.render(e, s, a)
                  : e.render(s, a),
                (a.layers.mask = l),
                (s.background = c),
                (e.shadowMap.autoUpdate = u);
            }
          }),
        he = class extends j {
          constructor({
            blendFunction: e = P,
            hue: t = 0,
            saturation: n = 0,
          } = {}) {
            super(
              "HueSaturationEffect",
              "uniform vec3 hue;uniform float saturation;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 color=vec3(dot(inputColor.rgb,hue.xyz),dot(inputColor.rgb,hue.zxy),dot(inputColor.rgb,hue.yzx));float average=(color.r+color.g+color.b)/3.0;vec3 diff=average-color;if(saturation>0.0){color+=diff*(1.0-1.0/(1.001-saturation));}else{color+=diff*-saturation;}outputColor=vec4(min(color,1.0),inputColor.a);}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["hue", new i.nc$(new i.Pq0())],
                  ["saturation", new i.nc$(n)],
                ]),
              }
            ),
              (this.hue = t);
          }
          get saturation() {
            return this.uniforms.get("saturation").value;
          }
          set saturation(e) {
            this.uniforms.get("saturation").value = e;
          }
          getSaturation() {
            return this.saturation;
          }
          setSaturation(e) {
            this.saturation = e;
          }
          get hue() {
            const e = this.uniforms.get("hue").value;
            return Math.acos((3 * e.x - 1) / 2);
          }
          set hue(e) {
            const t = Math.sin(e),
              n = Math.cos(e);
            this.uniforms
              .get("hue")
              .value.set(
                (2 * n + 1) / 3,
                (-Math.sqrt(3) * t - n + 1) / 3,
                (Math.sqrt(3) * t - n + 1) / 3
              );
          }
          getHue() {
            return this.hue;
          }
          setHue(e) {
            this.hue = e;
          }
        },
        de = "lut.scaleup";
      function pe(e, t, n) {
        const i = document.createElement("canvas"),
          r = i.getContext("2d");
        if (((i.width = e), (i.height = t), n instanceof Image))
          r.drawImage(n, 0, 0);
        else {
          const i = r.createImageData(e, t);
          i.data.set(n), r.putImageData(i, 0, 0);
        }
        return i;
      }
      var fe = class e {
          constructor(e = 0, t = 0, n = null) {
            (this.width = e), (this.height = t), (this.data = n);
          }
          toCanvas() {
            return "undefined" == typeof document
              ? null
              : pe(this.width, this.height, this.data);
          }
          static from(t) {
            const { width: n, height: i } = t;
            let r;
            if (t instanceof Image) {
              const e = pe(n, i, t);
              if (null !== e) {
                r = e.getContext("2d").getImageData(0, 0, n, i).data;
              }
            } else r = t.data;
            return new e(n, i, r);
          }
        },
        Ae = new i.Q1f(),
        ge = (i.dYF, 0),
        me = 2,
        ve = 0,
        ye = 0,
        xe = 1,
        _e = 2,
        be = 3,
        Ee = 0,
        we = 1,
        Ce = 2,
        Ie = 3,
        Se = 5,
        Me = 5,
        Te = 6,
        Be = 7,
        Re = 8,
        De = 0,
        Pe = 1,
        Le = class extends j {
          constructor({ blendFunction: e = D, premultiply: t = !1 } = {}) {
            super(
              "NoiseEffect",
              "void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec3 noise=vec3(rand(uv*(1.0+time)));\n#ifdef PREMULTIPLY\noutputColor=vec4(min(inputColor.rgb*noise,vec3(1.0)),inputColor.a);\n#else\noutputColor=vec4(noise,inputColor.a);\n#endif\n}",
              { blendFunction: e }
            ),
              (this.premultiply = t);
          }
          get premultiply() {
            return this.defines.has("PREMULTIPLY");
          }
          set premultiply(e) {
            this.premultiply !== e &&
              (e
                ? this.defines.set("PREMULTIPLY", "1")
                : this.defines.delete("PREMULTIPLY"),
              this.setChanged());
          }
          isPremultiplied() {
            return this.premultiply;
          }
          setPremultiplied(e) {
            this.premultiply = e;
          }
        },
        Ue =
          (i.BKk,
          i.BKk,
          class extends j {
            constructor(e = 30) {
              super(
                "PixelationEffect",
                "uniform bool active;uniform vec4 d;void mainUv(inout vec2 uv){if(active){uv=d.xy*(floor(uv*d.zw)+0.5);}}",
                {
                  uniforms: new Map([
                    ["active", new i.nc$(!1)],
                    ["d", new i.nc$(new i.IUQ())],
                  ]),
                }
              ),
                (this.resolution = new i.I9Y()),
                (this._granularity = 0),
                (this.granularity = e);
            }
            get granularity() {
              return this._granularity;
            }
            set granularity(e) {
              let t = Math.floor(e);
              t % 2 > 0 && (t += 1),
                (this._granularity = t),
                (this.uniforms.get("active").value = t > 0),
                this.setSize(this.resolution.width, this.resolution.height);
            }
            getGranularity() {
              return this.granularity;
            }
            setGranularity(e) {
              this.granularity = e;
            }
            setSize(e, t) {
              const n = this.resolution;
              n.set(e, t);
              const i = this.granularity,
                r = i / n.x,
                s = i / n.y;
              this.uniforms.get("d").value.set(r, s, 1 / r, 1 / s);
            }
          }),
        Fe =
          (Math.PI,
          class extends i.BKk {
            constructor(e = new i.I9Y(), t = me) {
              super({
                name: "EdgeDetectionMaterial",
                defines: {
                  THREE_REVISION: i.sPf.replace(/\D+/g, ""),
                  LOCAL_CONTRAST_ADAPTATION_FACTOR: "2.0",
                  EDGE_THRESHOLD: "0.1",
                  DEPTH_THRESHOLD: "0.01",
                  PREDICATION_MODE: "0",
                  PREDICATION_THRESHOLD: "0.01",
                  PREDICATION_SCALE: "2.0",
                  PREDICATION_STRENGTH: "1.0",
                  DEPTH_PACKING: "0",
                },
                uniforms: {
                  inputBuffer: new i.nc$(null),
                  depthBuffer: new i.nc$(null),
                  predicationBuffer: new i.nc$(null),
                  texelSize: new i.nc$(e),
                },
                blending: i.XIg,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader:
                  "varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\n#if EDGE_DETECTION_MODE == 1\n#include <common>\n#endif\n#if EDGE_DETECTION_MODE == 0 || PREDICATION_MODE == 1\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}vec3 gatherNeighbors(){float p=readDepth(vUv);float pLeft=readDepth(vUv0);float pTop=readDepth(vUv1);return vec3(p,pLeft,pTop);}\n#elif PREDICATION_MODE == 2\nuniform sampler2D predicationBuffer;vec3 gatherNeighbors(){float p=texture2D(predicationBuffer,vUv).r;float pLeft=texture2D(predicationBuffer,vUv0).r;float pTop=texture2D(predicationBuffer,vUv1).r;return vec3(p,pLeft,pTop);}\n#endif\n#if PREDICATION_MODE != 0\nvec2 calculatePredicatedThreshold(){vec3 neighbours=gatherNeighbors();vec2 delta=abs(neighbours.xx-neighbours.yz);vec2 edges=step(PREDICATION_THRESHOLD,delta);return PREDICATION_SCALE*EDGE_THRESHOLD*(1.0-PREDICATION_STRENGTH*edges);}\n#endif\n#if EDGE_DETECTION_MODE != 0\nuniform sampler2D inputBuffer;\n#endif\nvoid main(){\n#if EDGE_DETECTION_MODE == 0\nconst vec2 threshold=vec2(DEPTH_THRESHOLD);\n#elif PREDICATION_MODE != 0\nvec2 threshold=calculatePredicatedThreshold();\n#else\nconst vec2 threshold=vec2(EDGE_THRESHOLD);\n#endif\n#if EDGE_DETECTION_MODE == 0\nvec3 neighbors=gatherNeighbors();vec2 delta=abs(neighbors.xx-vec2(neighbors.y,neighbors.z));vec2 edges=step(threshold,delta);if(dot(edges,vec2(1.0))==0.0){discard;}gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 1\nfloat l=luminance(texture2D(inputBuffer,vUv).rgb);float lLeft=luminance(texture2D(inputBuffer,vUv0).rgb);float lTop=luminance(texture2D(inputBuffer,vUv1).rgb);vec4 delta;delta.xy=abs(l-vec2(lLeft,lTop));vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}float lRight=luminance(texture2D(inputBuffer,vUv2).rgb);float lBottom=luminance(texture2D(inputBuffer,vUv3).rgb);delta.zw=abs(l-vec2(lRight,lBottom));vec2 maxDelta=max(delta.xy,delta.zw);float lLeftLeft=luminance(texture2D(inputBuffer,vUv4).rgb);float lTopTop=luminance(texture2D(inputBuffer,vUv5).rgb);delta.zw=abs(vec2(lLeft,lTop)-vec2(lLeftLeft,lTopTop));maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges.xy*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#elif EDGE_DETECTION_MODE == 2\nvec4 delta;vec3 c=texture2D(inputBuffer,vUv).rgb;vec3 cLeft=texture2D(inputBuffer,vUv0).rgb;vec3 t=abs(c-cLeft);delta.x=max(max(t.r,t.g),t.b);vec3 cTop=texture2D(inputBuffer,vUv1).rgb;t=abs(c-cTop);delta.y=max(max(t.r,t.g),t.b);vec2 edges=step(threshold,delta.xy);if(dot(edges,vec2(1.0))==0.0){discard;}vec3 cRight=texture2D(inputBuffer,vUv2).rgb;t=abs(c-cRight);delta.z=max(max(t.r,t.g),t.b);vec3 cBottom=texture2D(inputBuffer,vUv3).rgb;t=abs(c-cBottom);delta.w=max(max(t.r,t.g),t.b);vec2 maxDelta=max(delta.xy,delta.zw);vec3 cLeftLeft=texture2D(inputBuffer,vUv4).rgb;t=abs(c-cLeftLeft);delta.z=max(max(t.r,t.g),t.b);vec3 cTopTop=texture2D(inputBuffer,vUv5).rgb;t=abs(c-cTopTop);delta.w=max(max(t.r,t.g),t.b);maxDelta=max(maxDelta.xy,delta.zw);float finalDelta=max(maxDelta.x,maxDelta.y);edges*=step(finalDelta,LOCAL_CONTRAST_ADAPTATION_FACTOR*delta.xy);gl_FragColor=vec4(edges,0.0,1.0);\n#endif\n}",
                vertexShader:
                  "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;\n#if EDGE_DETECTION_MODE != 0\nvarying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;\n#endif\nvoid main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,0.0);vUv1=vUv+texelSize*vec2(0.0,-1.0);\n#if EDGE_DETECTION_MODE != 0\nvUv2=vUv+texelSize*vec2(1.0,0.0);vUv3=vUv+texelSize*vec2(0.0,1.0);vUv4=vUv+texelSize*vec2(-2.0,0.0);vUv5=vUv+texelSize*vec2(0.0,-2.0);\n#endif\ngl_Position=vec4(position.xy,1.0,1.0);}",
              }),
                (this.edgeDetectionMode = t);
            }
            set depthBuffer(e) {
              this.uniforms.depthBuffer.value = e;
            }
            set depthPacking(e) {
              (this.defines.DEPTH_PACKING = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            setDepthBuffer(e, t = i.Rkk) {
              (this.depthBuffer = e), (this.depthPacking = t);
            }
            get edgeDetectionMode() {
              return Number(this.defines.EDGE_DETECTION_MODE);
            }
            set edgeDetectionMode(e) {
              (this.defines.EDGE_DETECTION_MODE = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            getEdgeDetectionMode() {
              return this.edgeDetectionMode;
            }
            setEdgeDetectionMode(e) {
              this.edgeDetectionMode = e;
            }
            get localContrastAdaptationFactor() {
              return Number(this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR);
            }
            set localContrastAdaptationFactor(e) {
              (this.defines.LOCAL_CONTRAST_ADAPTATION_FACTOR = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getLocalContrastAdaptationFactor() {
              return this.localContrastAdaptationFactor;
            }
            setLocalContrastAdaptationFactor(e) {
              this.localContrastAdaptationFactor = e;
            }
            get edgeDetectionThreshold() {
              return Number(this.defines.EDGE_THRESHOLD);
            }
            set edgeDetectionThreshold(e) {
              (this.defines.EDGE_THRESHOLD = e.toFixed("6")),
                (this.defines.DEPTH_THRESHOLD = (0.1 * e).toFixed("6")),
                (this.needsUpdate = !0);
            }
            getEdgeDetectionThreshold() {
              return this.edgeDetectionThreshold;
            }
            setEdgeDetectionThreshold(e) {
              this.edgeDetectionThreshold = e;
            }
            get predicationMode() {
              return Number(this.defines.PREDICATION_MODE);
            }
            set predicationMode(e) {
              (this.defines.PREDICATION_MODE = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            getPredicationMode() {
              return this.predicationMode;
            }
            setPredicationMode(e) {
              this.predicationMode = e;
            }
            set predicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e;
            }
            setPredicationBuffer(e) {
              this.uniforms.predicationBuffer.value = e;
            }
            get predicationThreshold() {
              return Number(this.defines.PREDICATION_THRESHOLD);
            }
            set predicationThreshold(e) {
              (this.defines.PREDICATION_THRESHOLD = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationThreshold() {
              return this.predicationThreshold;
            }
            setPredicationThreshold(e) {
              this.predicationThreshold = e;
            }
            get predicationScale() {
              return Number(this.defines.PREDICATION_SCALE);
            }
            set predicationScale(e) {
              (this.defines.PREDICATION_SCALE = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationScale() {
              return this.predicationScale;
            }
            setPredicationScale(e) {
              this.predicationScale = e;
            }
            get predicationStrength() {
              return Number(this.defines.PREDICATION_STRENGTH);
            }
            set predicationStrength(e) {
              (this.defines.PREDICATION_STRENGTH = e.toFixed("6")),
                (this.needsUpdate = !0);
            }
            getPredicationStrength() {
              return this.predicationStrength;
            }
            setPredicationStrength(e) {
              this.predicationStrength = e;
            }
            setSize(e, t) {
              this.uniforms.texelSize.value.set(1 / e, 1 / t);
            }
          }),
        Ne = class extends i.BKk {
          constructor(e = new i.I9Y(), t = new i.I9Y()) {
            super({
              name: "SMAAWeightsMaterial",
              defines: {
                MAX_SEARCH_STEPS_INT: "16",
                MAX_SEARCH_STEPS_FLOAT: "16.0",
                MAX_SEARCH_STEPS_DIAG_INT: "8",
                MAX_SEARCH_STEPS_DIAG_FLOAT: "8.0",
                CORNER_ROUNDING: "25",
                CORNER_ROUNDING_NORM: "0.25",
                AREATEX_MAX_DISTANCE: "16.0",
                AREATEX_MAX_DISTANCE_DIAG: "20.0",
                AREATEX_PIXEL_SIZE: "(1.0 / vec2(160.0, 560.0))",
                AREATEX_SUBTEX_SIZE: "(1.0 / 7.0)",
                SEARCHTEX_SIZE: "vec2(66.0, 33.0)",
                SEARCHTEX_PACKED_SIZE: "vec2(64.0, 16.0)",
              },
              uniforms: {
                inputBuffer: new i.nc$(null),
                searchTexture: new i.nc$(null),
                areaTexture: new i.nc$(null),
                resolution: new i.nc$(t),
                texelSize: new i.nc$(e),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#define sampleLevelZeroOffset(t, coord, offset) texture2D(t, coord + offset * texelSize)\n#if __VERSION__ < 300\n#define round(v) floor(v + 0.5)\n#endif\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\nuniform lowp sampler2D areaTexture;uniform lowp sampler2D searchTexture;uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}vec2 decodeDiagBilinearAccess(in vec2 e){e.r=e.r*abs(5.0*e.r-5.0*0.75);return round(e);}vec4 decodeDiagBilinearAccess(in vec4 e){e.rb=e.rb*abs(5.0*e.rb-5.0*0.75);return round(e);}vec2 searchDiag1(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 searchDiag2(const in vec2 texCoord,const in vec2 dir,out vec2 e){vec4 coord=vec4(texCoord,-1.0,1.0);coord.x+=0.25*texelSize.x;vec3 t=vec3(texelSize,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(coord.z<float(MAX_SEARCH_STEPS_DIAG_INT-1)&&coord.w>0.9)){break;}coord.xyz=t*vec3(dir,1.0)+coord.xyz;e=texture2D(inputBuffer,coord.xy).rg;e=decodeDiagBilinearAccess(e);coord.w=dot(e,vec2(0.5));}return coord.zw;}vec2 areaDiag(const in vec2 dist,const in vec2 e,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE_DIAG,AREATEX_MAX_DISTANCE_DIAG)*e+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.x+=0.5;texCoord.y+=AREATEX_SUBTEX_SIZE*offset;return texture2D(areaTexture,texCoord).rg;}vec2 calculateDiagWeights(const in vec2 texCoord,const in vec2 e,const in vec4 subsampleIndices){vec2 weights=vec2(0.0);vec4 d;vec2 end;if(e.r>0.0){d.xz=searchDiag1(texCoord,vec2(-1.0,1.0),end);d.x+=float(end.y>0.9);}else{d.xz=vec2(0.0);}d.yw=searchDiag1(texCoord,vec2(1.0,-1.0),end);if(d.x+d.y>2.0){vec4 coords=vec4(-d.x+0.25,d.x,d.y,-d.y-0.25)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.xy=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).rg;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).rg;c.yxwz=decodeDiagBilinearAccess(c.xyzw);vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.z);}d.xz=searchDiag2(texCoord,vec2(-1.0,-1.0),end);if(sampleLevelZeroOffset(inputBuffer,texCoord,vec2(1,0)).r>0.0){d.yw=searchDiag2(texCoord,vec2(1.0),end);d.y+=float(end.y>0.9);}else{d.yw=vec2(0.0);}if(d.x+d.y>2.0){vec4 coords=vec4(-d.x,-d.x,d.y,d.y)*texelSize.xyxy+texCoord.xyxy;vec4 c;c.x=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(-1,0)).g;c.y=sampleLevelZeroOffset(inputBuffer,coords.xy,vec2(0,-1)).r;c.zw=sampleLevelZeroOffset(inputBuffer,coords.zw,vec2(1,0)).gr;vec2 cc=vec2(2.0)*c.xz+c.yw;movec(bvec2(step(0.9,d.zw)),cc,vec2(0.0));weights+=areaDiag(d.xy,cc,subsampleIndices.w).gr;}return weights;}float searchLength(const in vec2 e,const in float offset){vec2 scale=SEARCHTEX_SIZE*vec2(0.5,-1.0);vec2 bias=SEARCHTEX_SIZE*vec2(offset,1.0);scale+=vec2(-1.0,1.0);bias+=vec2(0.5,-0.5);scale*=1.0/SEARCHTEX_PACKED_SIZE;bias*=1.0/SEARCHTEX_PACKED_SIZE;return texture2D(searchTexture,scale*e+bias).r;}float searchXLeft(in vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x>end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(-2.0,0.0)*texelSize+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.0)+3.25;return texelSize.x*offset+texCoord.x;}float searchXRight(vec2 texCoord,const in float end){vec2 e=vec2(0.0,1.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.x<end&&e.g>0.8281&&e.r==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(2.0,0.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e,0.5)+3.25;return-texelSize.x*offset+texCoord.x;}float searchYUp(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;++i){if(!(texCoord.y>end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=-vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.0)+3.25;return texelSize.y*offset+texCoord.y;}float searchYDown(vec2 texCoord,const in float end){vec2 e=vec2(1.0,0.0);for(int i=0;i<MAX_SEARCH_STEPS_INT;i++){if(!(texCoord.y<end&&e.r>0.8281&&e.g==0.0)){break;}e=texture2D(inputBuffer,texCoord).rg;texCoord=vec2(0.0,2.0)*texelSize.xy+texCoord;}float offset=-(255.0/127.0)*searchLength(e.gr,0.5)+3.25;return-texelSize.y*offset+texCoord.y;}vec2 area(const in vec2 dist,const in float e1,const in float e2,const in float offset){vec2 texCoord=vec2(AREATEX_MAX_DISTANCE)*round(4.0*vec2(e1,e2))+dist;texCoord=AREATEX_PIXEL_SIZE*texCoord+0.5*AREATEX_PIXEL_SIZE;texCoord.y=AREATEX_SUBTEX_SIZE*offset+texCoord.y;return texture2D(areaTexture,texCoord).rg;}void detectHorizontalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,1)).r;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).r;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(0,-2)).r;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,-2)).r;weights*=clamp(factor,0.0,1.0);\n#endif\n}void detectVerticalCornerPattern(inout vec2 weights,const in vec4 texCoord,const in vec2 d){\n#if !defined(DISABLE_CORNER_DETECTION)\nvec2 leftRight=step(d.xy,d.yx);vec2 rounding=(1.0-CORNER_ROUNDING_NORM)*leftRight;rounding/=leftRight.x+leftRight.y;vec2 factor=vec2(1.0);factor.x-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(1,0)).g;factor.x-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(1,1)).g;factor.y-=rounding.x*sampleLevelZeroOffset(inputBuffer,texCoord.xy,vec2(-2,0)).g;factor.y-=rounding.y*sampleLevelZeroOffset(inputBuffer,texCoord.zw,vec2(-2,1)).g;weights*=clamp(factor,0.0,1.0);\n#endif\n}void main(){vec4 weights=vec4(0.0);vec4 subsampleIndices=vec4(0.0);vec2 e=texture2D(inputBuffer,vUv).rg;if(e.g>0.0){\n#if !defined(DISABLE_DIAG_DETECTION)\nweights.rg=calculateDiagWeights(vUv,e,subsampleIndices);if(weights.r==-weights.g){\n#endif\nvec2 d;vec3 coords;coords.x=searchXLeft(vOffset[0].xy,vOffset[2].x);coords.y=vOffset[1].y;d.x=coords.x;float e1=texture2D(inputBuffer,coords.xy).r;coords.z=searchXRight(vOffset[0].zw,vOffset[2].y);d.y=coords.z;d=round(resolution.xx*d+-vPixCoord.xx);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.zy,vec2(1,0)).r;weights.rg=area(sqrtD,e1,e2,subsampleIndices.y);coords.y=vUv.y;detectHorizontalCornerPattern(weights.rg,coords.xyzy,d);\n#if !defined(DISABLE_DIAG_DETECTION)\n}else{e.r=0.0;}\n#endif\n}if(e.r>0.0){vec2 d;vec3 coords;coords.y=searchYUp(vOffset[1].xy,vOffset[2].z);coords.x=vOffset[0].x;d.x=coords.y;float e1=texture2D(inputBuffer,coords.xy).g;coords.z=searchYDown(vOffset[1].zw,vOffset[2].w);d.y=coords.z;d=round(resolution.yy*d-vPixCoord.yy);vec2 sqrtD=sqrt(abs(d));float e2=sampleLevelZeroOffset(inputBuffer,coords.xz,vec2(0,1)).g;weights.ba=area(sqrtD,e1,e2,subsampleIndices.x);coords.x=vUv.x;detectVerticalCornerPattern(weights.ba,coords.xyxz,d);}gl_FragColor=weights;}",
              vertexShader:
                "uniform vec2 texelSize;uniform vec2 resolution;varying vec2 vUv;varying vec4 vOffset[3];varying vec2 vPixCoord;void main(){vUv=position.xy*0.5+0.5;vPixCoord=vUv*resolution;vOffset[0]=vUv.xyxy+texelSize.xyxy*vec4(-0.25,-0.125,1.25,-0.125);vOffset[1]=vUv.xyxy+texelSize.xyxy*vec4(-0.125,-0.25,-0.125,1.25);vOffset[2]=vec4(vOffset[0].xz,vOffset[1].yw)+vec4(-2.0,2.0,-2.0,2.0)*texelSize.xxyy*MAX_SEARCH_STEPS_FLOAT;gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set inputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          setInputBuffer(e) {
            this.uniforms.inputBuffer.value = e;
          }
          get searchTexture() {
            return this.uniforms.searchTexture.value;
          }
          set searchTexture(e) {
            this.uniforms.searchTexture.value = e;
          }
          get areaTexture() {
            return this.uniforms.areaTexture.value;
          }
          set areaTexture(e) {
            this.uniforms.areaTexture.value = e;
          }
          setLookupTextures(e, t) {
            (this.searchTexture = e), (this.areaTexture = t);
          }
          get orthogonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_INT);
          }
          set orthogonalSearchSteps(e) {
            const t = Math.min(Math.max(e, 0), 112);
            (this.defines.MAX_SEARCH_STEPS_INT = t.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_FLOAT = t.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setOrthogonalSearchSteps(e) {
            this.orthogonalSearchSteps = e;
          }
          get diagonalSearchSteps() {
            return Number(this.defines.MAX_SEARCH_STEPS_DIAG_INT);
          }
          set diagonalSearchSteps(e) {
            const t = Math.min(Math.max(e, 0), 20);
            (this.defines.MAX_SEARCH_STEPS_DIAG_INT = t.toFixed("0")),
              (this.defines.MAX_SEARCH_STEPS_DIAG_FLOAT = t.toFixed("1")),
              (this.needsUpdate = !0);
          }
          setDiagonalSearchSteps(e) {
            this.diagonalSearchSteps = e;
          }
          get diagonalDetection() {
            return void 0 === this.defines.DISABLE_DIAG_DETECTION;
          }
          set diagonalDetection(e) {
            e
              ? delete this.defines.DISABLE_DIAG_DETECTION
              : (this.defines.DISABLE_DIAG_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isDiagonalDetectionEnabled() {
            return this.diagonalDetection;
          }
          setDiagonalDetectionEnabled(e) {
            this.diagonalDetection = e;
          }
          get cornerRounding() {
            return Number(this.defines.CORNER_ROUNDING);
          }
          set cornerRounding(e) {
            const t = Math.min(Math.max(e, 0), 100);
            (this.defines.CORNER_ROUNDING = t.toFixed("4")),
              (this.defines.CORNER_ROUNDING_NORM = (t / 100).toFixed("4")),
              (this.needsUpdate = !0);
          }
          setCornerRounding(e) {
            this.cornerRounding = e;
          }
          get cornerDetection() {
            return void 0 === this.defines.DISABLE_CORNER_DETECTION;
          }
          set cornerDetection(e) {
            e
              ? delete this.defines.DISABLE_CORNER_DETECTION
              : (this.defines.DISABLE_CORNER_DETECTION = "1"),
              (this.needsUpdate = !0);
          }
          isCornerRoundingEnabled() {
            return this.cornerDetection;
          }
          setCornerRoundingEnabled(e) {
            this.cornerDetection = e;
          }
          setSize(e, t) {
            const n = this.uniforms;
            n.texelSize.value.set(1 / e, 1 / t), n.resolution.value.set(e, t);
          }
        },
        Oe =
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAAAQCAYAAACm53kpAAAAeElEQVRYR+2XSwqAMAxEJ168ePEqwRSKhIIiuHjJqiU0gWE+1CQdApcVAMUAuARaMGCX1MIL/Ow13++9lW2s3mW9MWvsnWc/2fvGygwPAN4E8QzAA4CXAB6AHjG4JTHYI1ey3pcx6FHnEfhLDOIBKAmUBK6/ANUDTlROXAHd9EC1AAAAAElFTkSuQmCC",
        Qe =
          "data:image/png;base64,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",
        ke = class extends j {
          constructor({
            blendFunction: e = P,
            preset: t = xe,
            edgeDetectionMode: n = me,
            predicationMode: r = ve,
          } = {}) {
            let s, a;
            super(
              "SMAAEffect",
              "uniform sampler2D weightMap;varying vec2 vOffset0;varying vec2 vOffset1;void movec(const in bvec2 c,inout vec2 variable,const in vec2 value){if(c.x){variable.x=value.x;}if(c.y){variable.y=value.y;}}void movec(const in bvec4 c,inout vec4 variable,const in vec4 value){movec(c.xy,variable.xy,value.xy);movec(c.zw,variable.zw,value.zw);}void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 a;a.x=texture2D(weightMap,vOffset0).a;a.y=texture2D(weightMap,vOffset1).g;a.wz=texture2D(weightMap,uv).rb;vec4 color=inputColor;if(dot(a,vec4(1.0))>=1e-5){bool h=max(a.x,a.z)>max(a.y,a.w);vec4 blendingOffset=vec4(0.0,a.y,0.0,a.w);vec2 blendingWeight=a.yw;movec(bvec4(h),blendingOffset,vec4(a.x,0.0,a.z,0.0));movec(bvec2(h),blendingWeight,a.xz);blendingWeight/=dot(blendingWeight,vec2(1.0));vec4 blendingCoord=blendingOffset*vec4(texelSize,-texelSize)+uv.xyxy;color=blendingWeight.x*texture2D(inputBuffer,blendingCoord.xy);color+=blendingWeight.y*texture2D(inputBuffer,blendingCoord.zw);}outputColor=color;}",
              {
                vertexShader:
                  "varying vec2 vOffset0;varying vec2 vOffset1;void mainSupport(const in vec2 uv){vOffset0=uv+texelSize*vec2(1.0,0.0);vOffset1=uv+texelSize*vec2(0.0,1.0);}",
                blendFunction: e,
                attributes: g.CONVOLUTION | g.DEPTH,
                uniforms: new Map([["weightMap", new i.nc$(null)]]),
              }
            ),
              arguments.length > 1 &&
                ((s = arguments[0]),
                (a = arguments[1]),
                arguments.length > 2 && (t = arguments[2]),
                arguments.length > 3 && (n = arguments[3])),
              (this.renderTargetEdges = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTargetEdges.texture.name = "SMAA.Edges"),
              (this.renderTargetWeights = this.renderTargetEdges.clone()),
              (this.renderTargetWeights.texture.name = "SMAA.Weights"),
              (this.uniforms.get("weightMap").value =
                this.renderTargetWeights.texture),
              (this.clearPass = new p(!0, !1, !1)),
              (this.clearPass.overrideClearColor = new i.Q1f(0)),
              (this.clearPass.overrideClearAlpha = 1),
              (this.edgeDetectionPass = new se(new Fe())),
              (this.edgeDetectionMaterial.edgeDetectionMode = n),
              (this.edgeDetectionMaterial.predicationMode = r),
              (this.weightsPass = new se(new Ne()));
            const o = new i.KPJ();
            (o.onLoad = () => {
              const e = new i.gPd(s);
              (e.name = "SMAA.Search"),
                (e.magFilter = i.hxR),
                (e.minFilter = i.hxR),
                (e.generateMipmaps = !1),
                (e.needsUpdate = !0),
                (e.flipY = !0),
                (this.weightsMaterial.searchTexture = e);
              const t = new i.gPd(a);
              (t.name = "SMAA.Area"),
                (t.magFilter = i.k6q),
                (t.minFilter = i.k6q),
                (t.generateMipmaps = !1),
                (t.needsUpdate = !0),
                (t.flipY = !1),
                (this.weightsMaterial.areaTexture = t),
                this.dispatchEvent({ type: "load" });
            }),
              o.itemStart("search"),
              o.itemStart("area"),
              void 0 !== s && void 0 !== a
                ? (o.itemEnd("search"), o.itemEnd("area"))
                : "undefined" != typeof Image &&
                  ((s = new Image()),
                  (a = new Image()),
                  s.addEventListener("load", () => o.itemEnd("search")),
                  a.addEventListener("load", () => o.itemEnd("area")),
                  (s.src = Oe),
                  (a.src = Qe)),
              this.applyPreset(t);
          }
          get edgesTexture() {
            return this.renderTargetEdges.texture;
          }
          getEdgesTexture() {
            return this.edgesTexture;
          }
          get weightsTexture() {
            return this.renderTargetWeights.texture;
          }
          getWeightsTexture() {
            return this.weightsTexture;
          }
          get edgeDetectionMaterial() {
            return this.edgeDetectionPass.fullscreenMaterial;
          }
          get colorEdgesMaterial() {
            return this.edgeDetectionMaterial;
          }
          getEdgeDetectionMaterial() {
            return this.edgeDetectionMaterial;
          }
          get weightsMaterial() {
            return this.weightsPass.fullscreenMaterial;
          }
          getWeightsMaterial() {
            return this.weightsMaterial;
          }
          setEdgeDetectionThreshold(e) {
            this.edgeDetectionMaterial.edgeDetectionThreshold = e;
          }
          setOrthogonalSearchSteps(e) {
            this.weightsMaterial.orthogonalSearchSteps = e;
          }
          applyPreset(e) {
            const t = this.edgeDetectionMaterial,
              n = this.weightsMaterial;
            switch (e) {
              case ye:
                (t.edgeDetectionThreshold = 0.15),
                  (n.orthogonalSearchSteps = 4),
                  (n.diagonalDetection = !1),
                  (n.cornerDetection = !1);
                break;
              case xe:
                (t.edgeDetectionThreshold = 0.1),
                  (n.orthogonalSearchSteps = 8),
                  (n.diagonalDetection = !1),
                  (n.cornerDetection = !1);
                break;
              case _e:
                (t.edgeDetectionThreshold = 0.1),
                  (n.orthogonalSearchSteps = 16),
                  (n.diagonalSearchSteps = 8),
                  (n.cornerRounding = 25),
                  (n.diagonalDetection = !0),
                  (n.cornerDetection = !0);
                break;
              case be:
                (t.edgeDetectionThreshold = 0.05),
                  (n.orthogonalSearchSteps = 32),
                  (n.diagonalSearchSteps = 16),
                  (n.cornerRounding = 25),
                  (n.diagonalDetection = !0),
                  (n.cornerDetection = !0);
            }
          }
          setDepthTexture(e, t = i.Rkk) {
            (this.edgeDetectionMaterial.depthBuffer = e),
              (this.edgeDetectionMaterial.depthPacking = t);
          }
          update(e, t, n) {
            this.clearPass.render(e, this.renderTargetEdges),
              this.edgeDetectionPass.render(e, t, this.renderTargetEdges),
              this.weightsPass.render(
                e,
                this.renderTargetEdges,
                this.renderTargetWeights
              );
          }
          setSize(e, t) {
            this.edgeDetectionMaterial.setSize(e, t),
              this.weightsMaterial.setSize(e, t),
              this.renderTargetEdges.setSize(e, t),
              this.renderTargetWeights.setSize(e, t);
          }
          dispose() {
            const { searchTexture: e, areaTexture: t } = this.weightsMaterial;
            null !== e && null !== t && (e.dispose(), t.dispose()),
              super.dispose();
          }
          static get searchImageDataURL() {
            return Oe;
          }
          static get areaImageDataURL() {
            return Qe;
          }
        },
        Ge = class extends i.BKk {
          constructor(e) {
            super({
              name: "SSAOMaterial",
              defines: {
                SAMPLES_INT: "0",
                INV_SAMPLES_FLOAT: "0.0",
                SPIRAL_TURNS: "0.0",
                RADIUS: "1.0",
                RADIUS_SQ: "1.0",
                DISTANCE_SCALING: "1",
                DEPTH_PACKING: "0",
              },
              uniforms: {
                depthBuffer: new i.nc$(null),
                normalBuffer: new i.nc$(null),
                normalDepthBuffer: new i.nc$(null),
                noiseTexture: new i.nc$(null),
                inverseProjectionMatrix: new i.nc$(new i.kn4()),
                projectionMatrix: new i.nc$(new i.kn4()),
                texelSize: new i.nc$(new i.I9Y()),
                cameraNearFar: new i.nc$(new i.I9Y()),
                distanceCutoff: new i.nc$(new i.I9Y()),
                proximityCutoff: new i.nc$(new i.I9Y()),
                noiseScale: new i.nc$(new i.I9Y()),
                minRadiusScale: new i.nc$(0.33),
                intensity: new i.nc$(1),
                fade: new i.nc$(0.01),
                bias: new i.nc$(0),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <common>\n#include <packing>\n#ifdef NORMAL_DEPTH\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){return texture2D(normalDepthBuffer,uv).a;}\n#else\nuniform lowp sampler2D normalBuffer;\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nfloat readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}\n#endif\nuniform lowp sampler2D noiseTexture;uniform mat4 inverseProjectionMatrix;uniform mat4 projectionMatrix;uniform vec2 texelSize;uniform vec2 cameraNearFar;uniform float intensity;uniform float minRadiusScale;uniform float fade;uniform float bias;uniform vec2 distanceCutoff;uniform vec2 proximityCutoff;varying vec2 vUv;varying vec2 vUv2;float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);\n#endif\n}vec3 getViewPosition(const in vec2 screenPosition,const in float depth,const in float viewZ){vec4 clipPosition=vec4(vec3(screenPosition,depth)*2.0-1.0,1.0);float clipW=projectionMatrix[2][3]*viewZ+projectionMatrix[3][3];clipPosition*=clipW;return(inverseProjectionMatrix*clipPosition).xyz;}float getAmbientOcclusion(const in vec3 p,const in vec3 n,const in float depth,const in vec2 uv){float radiusScale=1.0-smoothstep(0.0,distanceCutoff.y,depth);radiusScale=radiusScale*(1.0-minRadiusScale)+minRadiusScale;float radius=RADIUS*radiusScale;float noise=texture2D(noiseTexture,vUv2).r;float baseAngle=noise*PI2;float rings=SPIRAL_TURNS*PI2;float occlusion=0.0;int taps=0;for(int i=0;i<SAMPLES_INT;++i){float alpha=(float(i)+0.5)*INV_SAMPLES_FLOAT;float angle=alpha*rings+baseAngle;vec2 rotation=vec2(cos(angle),sin(angle));vec2 coords=alpha*radius*rotation*texelSize+uv;if(coords.s<0.0||coords.s>1.0||coords.t<0.0||coords.t>1.0){continue;}float sampleDepth=readDepth(coords);float viewZ=getViewZ(sampleDepth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearSampleDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearSampleDepth=sampleDepth;\n#endif\nfloat proximity=abs(depth-linearSampleDepth);if(proximity<proximityCutoff.y){float falloff=1.0-smoothstep(proximityCutoff.x,proximityCutoff.y,proximity);vec3 Q=getViewPosition(coords,sampleDepth,viewZ);vec3 v=Q-p;float vv=dot(v,v);float vn=dot(v,n)-bias;float f=max(RADIUS_SQ-vv,0.0)/RADIUS_SQ;occlusion+=(f*f*f*max(vn/(fade+vv),0.0))*falloff;}++taps;}return occlusion/(4.0*max(float(taps),1.0));}void main(){\n#ifdef NORMAL_DEPTH\nvec4 normalDepth=texture2D(normalDepthBuffer,vUv);\n#else\nvec4 normalDepth=vec4(texture2D(normalBuffer,vUv).xyz,readDepth(vUv));\n#endif\nfloat ao=0.0;float depth=normalDepth.a;float viewZ=getViewZ(depth);\n#ifdef PERSPECTIVE_CAMERA\nfloat linearDepth=viewZToOrthographicDepth(viewZ,cameraNearFar.x,cameraNearFar.y);\n#else\nfloat linearDepth=depth;\n#endif\nif(linearDepth<distanceCutoff.y){vec3 viewPosition=getViewPosition(vUv,depth,viewZ);vec3 viewNormal=unpackRGBToNormal(normalDepth.rgb);ao+=getAmbientOcclusion(viewPosition,viewNormal,linearDepth,vUv);float d=smoothstep(distanceCutoff.x,distanceCutoff.y,linearDepth);ao=mix(ao,0.0,d);\n#ifdef LEGACY_INTENSITY\nao=clamp(1.0-pow(1.0-ao,abs(intensity)),0.0,1.0);\n#endif\n}gl_FragColor.r=ao;}",
              vertexShader:
                "uniform vec2 noiseScale;varying vec2 vUv;varying vec2 vUv2;void main(){vUv=position.xy*0.5+0.5;vUv2=vUv*noiseScale;gl_Position=vec4(position.xy,1.0,1.0);}",
            }),
              this.copyCameraSettings(e),
              (this.resolution = new i.I9Y()),
              (this.r = 1);
          }
          get near() {
            return this.uniforms.cameraNearFar.value.x;
          }
          get far() {
            return this.uniforms.cameraNearFar.value.y;
          }
          set normalDepthBuffer(e) {
            (this.uniforms.normalDepthBuffer.value = e),
              null !== e
                ? (this.defines.NORMAL_DEPTH = "1")
                : delete this.defines.NORMAL_DEPTH,
              (this.needsUpdate = !0);
          }
          setNormalDepthBuffer(e) {
            this.normalDepthBuffer = e;
          }
          set normalBuffer(e) {
            this.uniforms.normalBuffer.value = e;
          }
          setNormalBuffer(e) {
            this.uniforms.normalBuffer.value = e;
          }
          set depthBuffer(e) {
            this.uniforms.depthBuffer.value = e;
          }
          set depthPacking(e) {
            (this.defines.DEPTH_PACKING = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(e, t = i.Rkk) {
            (this.depthBuffer = e), (this.depthPacking = t);
          }
          set noiseTexture(e) {
            this.uniforms.noiseTexture.value = e;
          }
          setNoiseTexture(e) {
            this.uniforms.noiseTexture.value = e;
          }
          get samples() {
            return Number(this.defines.SAMPLES_INT);
          }
          set samples(e) {
            (this.defines.SAMPLES_INT = e.toFixed(0)),
              (this.defines.INV_SAMPLES_FLOAT = (1 / e).toFixed(9)),
              (this.needsUpdate = !0);
          }
          getSamples() {
            return this.samples;
          }
          setSamples(e) {
            this.samples = e;
          }
          get rings() {
            return Number(this.defines.SPIRAL_TURNS);
          }
          set rings(e) {
            (this.defines.SPIRAL_TURNS = e.toFixed(1)), (this.needsUpdate = !0);
          }
          getRings() {
            return this.rings;
          }
          setRings(e) {
            this.rings = e;
          }
          get intensity() {
            return this.uniforms.intensity.value;
          }
          set intensity(e) {
            (this.uniforms.intensity.value = e),
              void 0 === this.defines.LEGACY_INTENSITY &&
                ((this.defines.LEGACY_INTENSITY = "1"),
                (this.needsUpdate = !0));
          }
          getIntensity() {
            return this.uniforms.intensity.value;
          }
          setIntensity(e) {
            this.uniforms.intensity.value = e;
          }
          get fade() {
            return this.uniforms.fade.value;
          }
          set fade(e) {
            this.uniforms.fade.value = e;
          }
          getFade() {
            return this.uniforms.fade.value;
          }
          setFade(e) {
            this.uniforms.fade.value = e;
          }
          get bias() {
            return this.uniforms.bias.value;
          }
          set bias(e) {
            this.uniforms.bias.value = e;
          }
          getBias() {
            return this.uniforms.bias.value;
          }
          setBias(e) {
            this.uniforms.bias.value = e;
          }
          get minRadiusScale() {
            return this.uniforms.minRadiusScale.value;
          }
          set minRadiusScale(e) {
            this.uniforms.minRadiusScale.value = e;
          }
          getMinRadiusScale() {
            return this.uniforms.minRadiusScale.value;
          }
          setMinRadiusScale(e) {
            this.uniforms.minRadiusScale.value = e;
          }
          updateRadius() {
            const e = this.r * this.resolution.height;
            (this.defines.RADIUS = e.toFixed(11)),
              (this.defines.RADIUS_SQ = (e * e).toFixed(11)),
              (this.needsUpdate = !0);
          }
          get radius() {
            return this.r;
          }
          set radius(e) {
            (this.r = Math.min(Math.max(e, 1e-6), 1)), this.updateRadius();
          }
          getRadius() {
            return this.radius;
          }
          setRadius(e) {
            this.radius = e;
          }
          get distanceScaling() {
            return !0;
          }
          set distanceScaling(e) {}
          isDistanceScalingEnabled() {
            return this.distanceScaling;
          }
          setDistanceScalingEnabled(e) {
            this.distanceScaling = e;
          }
          get distanceThreshold() {
            return this.uniforms.distanceCutoff.value.x;
          }
          set distanceThreshold(e) {
            this.uniforms.distanceCutoff.value.set(
              Math.min(Math.max(e, 0), 1),
              Math.min(Math.max(e + this.distanceFalloff, 0), 1)
            );
          }
          get worldDistanceThreshold() {
            return -te(this.distanceThreshold, this.near, this.far);
          }
          set worldDistanceThreshold(e) {
            this.distanceThreshold = ne(-e, this.near, this.far);
          }
          get distanceFalloff() {
            return (
              this.uniforms.distanceCutoff.value.y - this.distanceThreshold
            );
          }
          set distanceFalloff(e) {
            this.uniforms.distanceCutoff.value.y = Math.min(
              Math.max(this.distanceThreshold + e, 0),
              1
            );
          }
          get worldDistanceFalloff() {
            return -te(this.distanceFalloff, this.near, this.far);
          }
          set worldDistanceFalloff(e) {
            this.distanceFalloff = ne(-e, this.near, this.far);
          }
          setDistanceCutoff(e, t) {
            this.uniforms.distanceCutoff.value.set(
              Math.min(Math.max(e, 0), 1),
              Math.min(Math.max(e + t, 0), 1)
            );
          }
          get proximityThreshold() {
            return this.uniforms.proximityCutoff.value.x;
          }
          set proximityThreshold(e) {
            this.uniforms.proximityCutoff.value.set(
              Math.min(Math.max(e, 0), 1),
              Math.min(Math.max(e + this.proximityFalloff, 0), 1)
            );
          }
          get worldProximityThreshold() {
            return -te(this.proximityThreshold, this.near, this.far);
          }
          set worldProximityThreshold(e) {
            this.proximityThreshold = ne(-e, this.near, this.far);
          }
          get proximityFalloff() {
            return (
              this.uniforms.proximityCutoff.value.y - this.proximityThreshold
            );
          }
          set proximityFalloff(e) {
            this.uniforms.proximityCutoff.value.y = Math.min(
              Math.max(this.proximityThreshold + e, 0),
              1
            );
          }
          get worldProximityFalloff() {
            return -te(this.proximityFalloff, this.near, this.far);
          }
          set worldProximityFalloff(e) {
            this.proximityFalloff = ne(-e, this.near, this.far);
          }
          setProximityCutoff(e, t) {
            this.uniforms.proximityCutoff.value.set(
              Math.min(Math.max(e, 0), 1),
              Math.min(Math.max(e + t, 0), 1)
            );
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t);
          }
          adoptCameraSettings(e) {
            this.copyCameraSettings(e);
          }
          copyCameraSettings(e) {
            e &&
              (this.uniforms.cameraNearFar.value.set(e.near, e.far),
              this.uniforms.projectionMatrix.value.copy(e.projectionMatrix),
              this.uniforms.inverseProjectionMatrix.value
                .copy(e.projectionMatrix)
                .invert(),
              e instanceof i.ubm
                ? (this.defines.PERSPECTIVE_CAMERA = "1")
                : delete this.defines.PERSPECTIVE_CAMERA,
              (this.needsUpdate = !0));
          }
          setSize(e, t) {
            const n = this.uniforms,
              i = n.noiseTexture.value;
            null !== i &&
              n.noiseScale.value.set(e / i.image.width, t / i.image.height),
              n.texelSize.value.set(1 / e, 1 / t),
              this.resolution.set(e, t),
              this.updateRadius();
          }
        },
        He = class extends i.BKk {
          constructor() {
            super({
              name: "DepthDownsamplingMaterial",
              defines: { DEPTH_PACKING: "0" },
              uniforms: {
                depthBuffer: new i.nc$(null),
                normalBuffer: new i.nc$(null),
                texelSize: new i.nc$(new i.I9Y()),
              },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <packing>\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\n#ifdef DOWNSAMPLE_NORMALS\nuniform lowp sampler2D normalBuffer;\n#endif\nvarying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);\n#ifdef DOWNSAMPLE_NORMALS\nvec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;\n#else\nvec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);\n#endif\ngl_FragColor=vec4(n[index],d[index]);}",
              vertexShader:
                "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",
            });
          }
          set depthBuffer(e) {
            this.uniforms.depthBuffer.value = e;
          }
          set depthPacking(e) {
            (this.defines.DEPTH_PACKING = e.toFixed(0)),
              (this.needsUpdate = !0);
          }
          setDepthBuffer(e, t = i.Rkk) {
            (this.depthBuffer = e), (this.depthPacking = t);
          }
          set normalBuffer(e) {
            (this.uniforms.normalBuffer.value = e),
              null !== e
                ? (this.defines.DOWNSAMPLE_NORMALS = "1")
                : delete this.defines.DOWNSAMPLE_NORMALS,
              (this.needsUpdate = !0);
          }
          setNormalBuffer(e) {
            this.normalBuffer = e;
          }
          setTexelSize(e, t) {
            this.uniforms.texelSize.value.set(e, t);
          }
          setSize(e, t) {
            this.uniforms.texelSize.value.set(1 / e, 1 / t);
          }
        },
        ze = class extends o {
          constructor({
            normalBuffer: e = null,
            resolutionScale: t = 0.5,
            width: n = w.AUTO_SIZE,
            height: r = w.AUTO_SIZE,
            resolutionX: s = n,
            resolutionY: a = r,
          } = {}) {
            super("DepthDownsamplingPass");
            const o = new He();
            (o.normalBuffer = e),
              (this.fullscreenMaterial = o),
              (this.needsDepthTexture = !0),
              (this.needsSwap = !1),
              (this.renderTarget = new i.nWS(1, 1, {
                minFilter: i.hxR,
                magFilter: i.hxR,
                depthBuffer: !1,
                type: i.RQf,
              })),
              (this.renderTarget.texture.name = "DepthDownsamplingPass.Target"),
              (this.renderTarget.texture.generateMipmaps = !1);
            const l = (this.resolution = new w(this, s, a, t));
            l.addEventListener("change", (e) =>
              this.setSize(l.baseWidth, l.baseHeight)
            );
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          setDepthTexture(e, t = i.Rkk) {
            (this.fullscreenMaterial.depthBuffer = e),
              (this.fullscreenMaterial.depthPacking = t);
          }
          render(e, t, n, i, r) {
            e.setRenderTarget(this.renderToScreen ? null : this.renderTarget),
              e.render(this.scene, this.camera);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t),
              this.renderTarget.setSize(n.width, n.height),
              this.fullscreenMaterial.setSize(e, t);
          }
          initialize(e, t, n) {
            const i = e.getContext();
            if (
              !(
                i.getExtension("EXT_color_buffer_float") ||
                i.getExtension("EXT_color_buffer_half_float")
              )
            )
              throw new Error("Rendering to float texture is not supported.");
          }
        },
        Ve = class extends j {
          constructor(
            e,
            t,
            {
              blendFunction: n = T,
              samples: r = 9,
              rings: s = 7,
              normalDepthBuffer: a = null,
              depthAwareUpsampling: o = !0,
              worldDistanceThreshold: l,
              worldDistanceFalloff: c,
              worldProximityThreshold: u,
              worldProximityFalloff: h,
              distanceThreshold: d = 0.97,
              distanceFalloff: p = 0.03,
              rangeThreshold: f = 5e-4,
              rangeFalloff: A = 0.001,
              minRadiusScale: m = 0.1,
              luminanceInfluence: v = 0.7,
              radius: y = 0.1825,
              intensity: x = 1,
              bias: _ = 0.025,
              fade: b = 0.01,
              color: E = null,
              resolutionScale: C = 1,
              width: I = w.AUTO_SIZE,
              height: S = w.AUTO_SIZE,
              resolutionX: M = I,
              resolutionY: B = S,
            } = {}
          ) {
            super(
              "SSAOEffect",
              "uniform lowp sampler2D aoBuffer;uniform float luminanceInfluence;uniform float intensity;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH)\n#ifdef GL_FRAGMENT_PRECISION_HIGH\nuniform highp sampler2D normalDepthBuffer;\n#else\nuniform mediump sampler2D normalDepthBuffer;\n#endif\n#endif\n#ifdef COLORIZE\nuniform vec3 color;\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,const in float depth,out vec4 outputColor){float aoLinear=texture2D(aoBuffer,uv).r;\n#if defined(DEPTH_AWARE_UPSAMPLING) && defined(NORMAL_DEPTH) && __VERSION__ == 300\nvec4 normalDepth[4];normalDepth[0]=textureOffset(normalDepthBuffer,uv,ivec2(0,0));normalDepth[1]=textureOffset(normalDepthBuffer,uv,ivec2(0,1));normalDepth[2]=textureOffset(normalDepthBuffer,uv,ivec2(1,0));normalDepth[3]=textureOffset(normalDepthBuffer,uv,ivec2(1,1));float dot01=dot(normalDepth[0].rgb,normalDepth[1].rgb);float dot02=dot(normalDepth[0].rgb,normalDepth[2].rgb);float dot03=dot(normalDepth[0].rgb,normalDepth[3].rgb);float minDot=min(dot01,min(dot02,dot03));float s=step(THRESHOLD,minDot);float smallestDistance=1.0;int index;for(int i=0;i<4;++i){float distance=abs(depth-normalDepth[i].a);if(distance<smallestDistance){smallestDistance=distance;index=i;}}ivec2 offsets[4];offsets[0]=ivec2(0,0);offsets[1]=ivec2(0,1);offsets[2]=ivec2(1,0);offsets[3]=ivec2(1,1);ivec2 coord=ivec2(uv*vec2(textureSize(aoBuffer,0)))+offsets[index];float aoNearest=texelFetch(aoBuffer,coord,0).r;float ao=mix(aoNearest,aoLinear,s);\n#else\nfloat ao=aoLinear;\n#endif\nfloat l=luminance(inputColor.rgb);ao=mix(ao,0.0,l*luminanceInfluence);ao=clamp(ao*intensity,0.0,1.0);\n#ifdef COLORIZE\noutputColor=vec4(1.0-ao*(1.0-color),inputColor.a);\n#else\noutputColor=vec4(vec3(1.0-ao),inputColor.a);\n#endif\n}",
              {
                blendFunction: n,
                attributes: g.DEPTH,
                defines: new Map([["THRESHOLD", "0.997"]]),
                uniforms: new Map([
                  ["aoBuffer", new i.nc$(null)],
                  ["normalDepthBuffer", new i.nc$(a)],
                  ["luminanceInfluence", new i.nc$(v)],
                  ["color", new i.nc$(null)],
                  ["intensity", new i.nc$(x)],
                  ["scale", new i.nc$(0)],
                ]),
              }
            ),
              (this.renderTarget = new i.nWS(1, 1, { depthBuffer: !1 })),
              (this.renderTarget.texture.name = "AO.Target"),
              (this.uniforms.get("aoBuffer").value = this.renderTarget.texture);
            const R = (this.resolution = new w(this, M, B, C));
            R.addEventListener("change", (e) =>
              this.setSize(R.baseWidth, R.baseHeight)
            ),
              (this.camera = e),
              (this.depthDownsamplingPass = new ze({
                normalBuffer: t,
                resolutionScale: C,
              })),
              (this.depthDownsamplingPass.enabled = null === a),
              (this.ssaoPass = new se(new Ge(e)));
            const D = new oe(64, 64, i.GWd);
            D.wrapS = D.wrapT = i.GJx;
            const P = this.ssaoMaterial;
            (P.normalBuffer = t),
              (P.noiseTexture = D),
              (P.minRadiusScale = m),
              (P.samples = r),
              (P.radius = y),
              (P.rings = s),
              (P.fade = b),
              (P.bias = _),
              (P.distanceThreshold = d),
              (P.distanceFalloff = p),
              (P.proximityThreshold = f),
              (P.proximityFalloff = A),
              void 0 !== l && (P.worldDistanceThreshold = l),
              void 0 !== c && (P.worldDistanceFalloff = c),
              void 0 !== u && (P.worldProximityThreshold = u),
              void 0 !== h && (P.worldProximityFalloff = h),
              null !== a &&
                ((this.ssaoMaterial.normalDepthBuffer = a),
                this.defines.set("NORMAL_DEPTH", "1")),
              (this.depthAwareUpsampling = o),
              (this.color = E);
          }
          set mainCamera(e) {
            (this.camera = e), this.ssaoMaterial.copyCameraSettings(e);
          }
          get normalBuffer() {
            return this.ssaoMaterial.normalBuffer;
          }
          set normalBuffer(e) {
            (this.ssaoMaterial.normalBuffer = e),
              (this.depthDownsamplingPass.fullscreenMaterial.normalBuffer = e);
          }
          getResolution() {
            return this.resolution;
          }
          get ssaoMaterial() {
            return this.ssaoPass.fullscreenMaterial;
          }
          getSSAOMaterial() {
            return this.ssaoMaterial;
          }
          get samples() {
            return this.ssaoMaterial.samples;
          }
          set samples(e) {
            this.ssaoMaterial.samples = e;
          }
          get rings() {
            return this.ssaoMaterial.rings;
          }
          set rings(e) {
            this.ssaoMaterial.rings = e;
          }
          get radius() {
            return this.ssaoMaterial.radius;
          }
          set radius(e) {
            this.ssaoMaterial.radius = e;
          }
          get depthAwareUpsampling() {
            return this.defines.has("DEPTH_AWARE_UPSAMPLING");
          }
          set depthAwareUpsampling(e) {
            this.depthAwareUpsampling !== e &&
              (e
                ? this.defines.set("DEPTH_AWARE_UPSAMPLING", "1")
                : this.defines.delete("DEPTH_AWARE_UPSAMPLING"),
              this.setChanged());
          }
          isDepthAwareUpsamplingEnabled() {
            return this.depthAwareUpsampling;
          }
          setDepthAwareUpsamplingEnabled(e) {
            this.depthAwareUpsampling = e;
          }
          get distanceScaling() {
            return !0;
          }
          set distanceScaling(e) {}
          get color() {
            return this.uniforms.get("color").value;
          }
          set color(e) {
            const t = this.uniforms,
              n = this.defines;
            null !== e
              ? n.has("COLORIZE")
                ? t.get("color").value.set(e)
                : (n.set("COLORIZE", "1"),
                  (t.get("color").value = new i.Q1f(e)),
                  this.setChanged())
              : n.has("COLORIZE") &&
                (n.delete("COLORIZE"),
                (t.get("color").value = null),
                this.setChanged());
          }
          get luminanceInfluence() {
            return this.uniforms.get("luminanceInfluence").value;
          }
          set luminanceInfluence(e) {
            this.uniforms.get("luminanceInfluence").value = e;
          }
          get intensity() {
            return this.uniforms.get("intensity").value;
          }
          set intensity(e) {
            this.uniforms.get("intensity").value = e;
          }
          getColor() {
            return this.color;
          }
          setColor(e) {
            this.color = e;
          }
          setDistanceCutoff(e, t) {
            (this.ssaoMaterial.distanceThreshold = e),
              (this.ssaoMaterial.distanceFalloff = t);
          }
          setProximityCutoff(e, t) {
            (this.ssaoMaterial.proximityThreshold = e),
              (this.ssaoMaterial.proximityFalloff = t);
          }
          setDepthTexture(e, t = i.Rkk) {
            this.depthDownsamplingPass.setDepthTexture(e, t),
              (this.ssaoMaterial.depthBuffer = e),
              (this.ssaoMaterial.depthPacking = t);
          }
          update(e, t, n) {
            const i = this.renderTarget;
            this.depthDownsamplingPass.enabled &&
              this.depthDownsamplingPass.render(e),
              this.ssaoPass.render(e, null, i);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t);
            const i = n.width,
              r = n.height;
            this.ssaoMaterial.copyCameraSettings(this.camera),
              this.ssaoMaterial.setSize(i, r),
              this.renderTarget.setSize(i, r),
              (this.depthDownsamplingPass.resolution.scale = n.scale),
              this.depthDownsamplingPass.setSize(e, t);
          }
          initialize(e, t, n) {
            try {
              let i = this.uniforms.get("normalDepthBuffer").value;
              null === i &&
                (this.depthDownsamplingPass.initialize(e, t, n),
                (i = this.depthDownsamplingPass.texture),
                (this.uniforms.get("normalDepthBuffer").value = i),
                (this.ssaoMaterial.normalDepthBuffer = i),
                this.defines.set("NORMAL_DEPTH", "1"));
            } catch (e) {
              this.depthDownsamplingPass.enabled = !1;
            }
          }
        },
        We = class extends i.BKk {
          constructor() {
            super({
              name: "AdaptiveLuminanceMaterial",
              defines: { MIP_LEVEL_1X1: "0.0" },
              uniforms: {
                luminanceBuffer0: new i.nc$(null),
                luminanceBuffer1: new i.nc$(null),
                minLuminance: new i.nc$(0.01),
                deltaTime: new i.nc$(0),
                tau: new i.nc$(1),
              },
              extensions: { shaderTextureLOD: !0 },
              blending: i.XIg,
              toneMapped: !1,
              depthWrite: !1,
              depthTest: !1,
              fragmentShader:
                "#include <packing>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\nuniform lowp sampler2D luminanceBuffer0;uniform lowp sampler2D luminanceBuffer1;uniform float minLuminance;uniform float deltaTime;uniform float tau;varying vec2 vUv;void main(){float l0=unpackRGBAToFloat(texture2D(luminanceBuffer0,vUv));\n#if __VERSION__ < 300\nfloat l1=texture2DLodEXT(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#else\nfloat l1=textureLod(luminanceBuffer1,vUv,MIP_LEVEL_1X1).r;\n#endif\nl0=max(minLuminance,l0);l1=max(minLuminance,l1);float adaptedLum=l0+(l1-l0)*(1.0-exp(-deltaTime*tau));gl_FragColor=(adaptedLum==1.0)?vec4(1.0):packFloatToRGBA(adaptedLum);}",
              vertexShader: c,
            });
          }
          set luminanceBuffer0(e) {
            this.uniforms.luminanceBuffer0.value = e;
          }
          setLuminanceBuffer0(e) {
            this.uniforms.luminanceBuffer0.value = e;
          }
          set luminanceBuffer1(e) {
            this.uniforms.luminanceBuffer1.value = e;
          }
          setLuminanceBuffer1(e) {
            this.uniforms.luminanceBuffer1.value = e;
          }
          set mipLevel1x1(e) {
            (this.defines.MIP_LEVEL_1X1 = e.toFixed(1)),
              (this.needsUpdate = !0);
          }
          setMipLevel1x1(e) {
            this.mipLevel1x1 = e;
          }
          set deltaTime(e) {
            this.uniforms.deltaTime.value = e;
          }
          setDeltaTime(e) {
            this.uniforms.deltaTime.value = e;
          }
          get minLuminance() {
            return this.uniforms.minLuminance.value;
          }
          set minLuminance(e) {
            this.uniforms.minLuminance.value = e;
          }
          getMinLuminance() {
            return this.uniforms.minLuminance.value;
          }
          setMinLuminance(e) {
            this.uniforms.minLuminance.value = e;
          }
          get adaptationRate() {
            return this.uniforms.tau.value;
          }
          set adaptationRate(e) {
            this.uniforms.tau.value = e;
          }
          getAdaptationRate() {
            return this.uniforms.tau.value;
          }
          setAdaptationRate(e) {
            this.uniforms.tau.value = e;
          }
        },
        je = class extends o {
          constructor(
            e,
            { minLuminance: t = 0.01, adaptationRate: n = 1 } = {}
          ) {
            super("AdaptiveLuminancePass"),
              (this.fullscreenMaterial = new We()),
              (this.needsSwap = !1),
              (this.renderTargetPrevious = new i.nWS(1, 1, {
                minFilter: i.hxR,
                magFilter: i.hxR,
                depthBuffer: !1,
              })),
              (this.renderTargetPrevious.texture.name = "Luminance.Previous");
            const r = this.fullscreenMaterial;
            (r.luminanceBuffer0 = this.renderTargetPrevious.texture),
              (r.luminanceBuffer1 = e),
              (r.minLuminance = t),
              (r.adaptationRate = n),
              (this.renderTargetAdapted = this.renderTargetPrevious.clone()),
              (this.renderTargetAdapted.texture.name = "Luminance.Adapted"),
              (this.copyPass = new h(this.renderTargetPrevious, !1));
          }
          get texture() {
            return this.renderTargetAdapted.texture;
          }
          getTexture() {
            return this.renderTargetAdapted.texture;
          }
          set mipLevel1x1(e) {
            this.fullscreenMaterial.mipLevel1x1 = e;
          }
          get adaptationRate() {
            return this.fullscreenMaterial.adaptationRate;
          }
          set adaptationRate(e) {
            this.fullscreenMaterial.adaptationRate = e;
          }
          render(e, t, n, i, r) {
            (this.fullscreenMaterial.deltaTime = i),
              e.setRenderTarget(
                this.renderToScreen ? null : this.renderTargetAdapted
              ),
              e.render(this.scene, this.camera),
              this.copyPass.render(e, this.renderTargetAdapted);
          }
        },
        qe = class extends j {
          constructor({
            blendFunction: e = P,
            adaptive: t = !1,
            mode: n = t ? Ie : Be,
            resolution: r = 256,
            maxLuminance: s = 4,
            whitePoint: a = s,
            middleGrey: o = 0.6,
            minLuminance: l = 0.01,
            averageLuminance: c = 1,
            adaptationRate: u = 1,
          } = {}) {
            super(
              "ToneMappingEffect",
              "#include <tonemapping_pars_fragment>\nuniform float whitePoint;\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\nuniform float middleGrey;\n#if TONE_MAPPING_MODE == 3\nuniform lowp sampler2D luminanceBuffer;\n#else\nuniform float averageLuminance;\n#endif\nvec3 Reinhard2ToneMapping(vec3 color){color*=toneMappingExposure;float l=luminance(color);\n#if TONE_MAPPING_MODE == 3\nfloat lumAvg=unpackRGBAToFloat(texture2D(luminanceBuffer,vec2(0.5)));\n#else\nfloat lumAvg=averageLuminance;\n#endif\nfloat lumScaled=(l*middleGrey)/max(lumAvg,1e-6);float lumCompressed=lumScaled*(1.0+lumScaled/(whitePoint*whitePoint));lumCompressed/=(1.0+lumScaled);return clamp(lumCompressed*color,0.0,1.0);}\n#elif TONE_MAPPING_MODE == 4\n#define A 0.15\n#define B 0.50\n#define C 0.10\n#define D 0.20\n#define E 0.02\n#define F 0.30\nvec3 Uncharted2Helper(const in vec3 x){return((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;}vec3 Uncharted2ToneMapping(vec3 color){color*=toneMappingExposure;return clamp(Uncharted2Helper(color)/Uncharted2Helper(vec3(whitePoint)),0.0,1.0);}\n#endif\nvoid mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){\n#if TONE_MAPPING_MODE == 2 || TONE_MAPPING_MODE == 3\noutputColor=vec4(Reinhard2ToneMapping(inputColor.rgb),inputColor.a);\n#elif TONE_MAPPING_MODE == 4\noutputColor=vec4(Uncharted2ToneMapping(inputColor.rgb),inputColor.a);\n#else\noutputColor=vec4(toneMapping(inputColor.rgb),inputColor.a);\n#endif\n}",
              {
                blendFunction: e,
                uniforms: new Map([
                  ["luminanceBuffer", new i.nc$(null)],
                  ["maxLuminance", new i.nc$(s)],
                  ["whitePoint", new i.nc$(a)],
                  ["middleGrey", new i.nc$(o)],
                  ["averageLuminance", new i.nc$(c)],
                ]),
              }
            ),
              (this.renderTargetLuminance = new i.nWS(1, 1, {
                minFilter: i.$_I,
                depthBuffer: !1,
              })),
              (this.renderTargetLuminance.texture.generateMipmaps = !0),
              (this.renderTargetLuminance.texture.name = "Luminance"),
              (this.luminancePass = new H({
                renderTarget: this.renderTargetLuminance,
              })),
              (this.adaptiveLuminancePass = new je(this.luminancePass.texture, {
                minLuminance: l,
                adaptationRate: u,
              })),
              (this.uniforms.get("luminanceBuffer").value =
                this.adaptiveLuminancePass.texture),
              (this.resolution = r),
              (this.mode = n);
          }
          get mode() {
            return Number(this.defines.get("TONE_MAPPING_MODE"));
          }
          set mode(e) {
            if (this.mode === e) return;
            const t =
              i.sPf.replace(/\D+/g, "") >= 168
                ? "CineonToneMapping(texel)"
                : "OptimizedCineonToneMapping(texel)";
            switch (
              (this.defines.clear(),
              this.defines.set("TONE_MAPPING_MODE", e.toFixed(0)),
              e)
            ) {
              case Ee:
                this.defines.set(
                  "toneMapping(texel)",
                  "LinearToneMapping(texel)"
                );
                break;
              case we:
                this.defines.set(
                  "toneMapping(texel)",
                  "ReinhardToneMapping(texel)"
                );
                break;
              case Me:
              case Se:
                this.defines.set("toneMapping(texel)", t);
                break;
              case Te:
                this.defines.set(
                  "toneMapping(texel)",
                  "ACESFilmicToneMapping(texel)"
                );
                break;
              case Be:
                this.defines.set("toneMapping(texel)", "AgXToneMapping(texel)");
                break;
              case Re:
                this.defines.set(
                  "toneMapping(texel)",
                  "NeutralToneMapping(texel)"
                );
                break;
              default:
                this.defines.set("toneMapping(texel)", "texel");
            }
            (this.adaptiveLuminancePass.enabled = e === Ie), this.setChanged();
          }
          getMode() {
            return this.mode;
          }
          setMode(e) {
            this.mode = e;
          }
          get whitePoint() {
            return this.uniforms.get("whitePoint").value;
          }
          set whitePoint(e) {
            this.uniforms.get("whitePoint").value = e;
          }
          get middleGrey() {
            return this.uniforms.get("middleGrey").value;
          }
          set middleGrey(e) {
            this.uniforms.get("middleGrey").value = e;
          }
          get averageLuminance() {
            return this.uniforms.get("averageLuminance").value;
          }
          set averageLuminance(e) {
            this.uniforms.get("averageLuminance").value = e;
          }
          get adaptiveLuminanceMaterial() {
            return this.adaptiveLuminancePass.fullscreenMaterial;
          }
          getAdaptiveLuminanceMaterial() {
            return this.adaptiveLuminanceMaterial;
          }
          get resolution() {
            return this.luminancePass.resolution.width;
          }
          set resolution(e) {
            const t = Math.max(0, Math.ceil(Math.log2(e))),
              n = Math.pow(2, t);
            this.luminancePass.resolution.setPreferredSize(n, n),
              (this.adaptiveLuminanceMaterial.mipLevel1x1 = t);
          }
          getResolution() {
            return this.resolution;
          }
          setResolution(e) {
            this.resolution = e;
          }
          get adaptive() {
            return this.mode === Ie;
          }
          set adaptive(e) {
            this.mode = e ? Ie : Ce;
          }
          get adaptationRate() {
            return this.adaptiveLuminanceMaterial.adaptationRate;
          }
          set adaptationRate(e) {
            this.adaptiveLuminanceMaterial.adaptationRate = e;
          }
          get distinction() {
            return console.warn(this.name, "distinction was removed."), 1;
          }
          set distinction(e) {
            console.warn(this.name, "distinction was removed.");
          }
          update(e, t, n) {
            this.adaptiveLuminancePass.enabled &&
              (this.luminancePass.render(e, t),
              this.adaptiveLuminancePass.render(e, null, null, n));
          }
          initialize(e, t, n) {
            this.adaptiveLuminancePass.initialize(e, t, n);
          }
        },
        Ye = class extends j {
          constructor({
            blendFunction: e,
            eskil: t = !1,
            technique: n = t ? Pe : De,
            offset: r = 0.5,
            darkness: s = 0.5,
          } = {}) {
            super(
              "VignetteEffect",
              "uniform float offset;uniform float darkness;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){const vec2 center=vec2(0.5);vec3 color=inputColor.rgb;\n#if VIGNETTE_TECHNIQUE == 0\nfloat d=distance(uv,center);color*=smoothstep(0.8,offset*0.799,d*(darkness+offset));\n#else\nvec2 coord=(uv-center)*vec2(offset);color=mix(color,vec3(1.0-darkness),dot(coord,coord));\n#endif\noutputColor=vec4(color,inputColor.a);}",
              {
                blendFunction: e,
                defines: new Map([["VIGNETTE_TECHNIQUE", n.toFixed(0)]]),
                uniforms: new Map([
                  ["offset", new i.nc$(r)],
                  ["darkness", new i.nc$(s)],
                ]),
              }
            );
          }
          get technique() {
            return Number(this.defines.get("VIGNETTE_TECHNIQUE"));
          }
          set technique(e) {
            this.technique !== e &&
              (this.defines.set("VIGNETTE_TECHNIQUE", e.toFixed(0)),
              this.setChanged());
          }
          get eskil() {
            return this.technique === Pe;
          }
          set eskil(e) {
            this.technique = e ? Pe : De;
          }
          getTechnique() {
            return this.technique;
          }
          setTechnique(e) {
            this.technique = e;
          }
          get offset() {
            return this.uniforms.get("offset").value;
          }
          set offset(e) {
            this.uniforms.get("offset").value = e;
          }
          getOffset() {
            return this.offset;
          }
          setOffset(e) {
            this.offset = e;
          }
          get darkness() {
            return this.uniforms.get("darkness").value;
          }
          set darkness(e) {
            this.uniforms.get("darkness").value = e;
          }
          getDarkness() {
            return this.darkness;
          }
          setDarkness(e) {
            this.darkness = e;
          }
        },
        Xe =
          (i.BKk,
          i.BKk,
          class extends i.BKk {
            constructor(e, t, n, r, s = !1) {
              super({
                name: "EffectMaterial",
                defines: {
                  THREE_REVISION: i.sPf.replace(/\D+/g, ""),
                  DEPTH_PACKING: "0",
                  ENCODE_OUTPUT: "1",
                },
                uniforms: {
                  inputBuffer: new i.nc$(null),
                  depthBuffer: new i.nc$(null),
                  resolution: new i.nc$(new i.I9Y()),
                  texelSize: new i.nc$(new i.I9Y()),
                  cameraNear: new i.nc$(0.3),
                  cameraFar: new i.nc$(1e3),
                  aspect: new i.nc$(1),
                  time: new i.nc$(0),
                },
                blending: i.XIg,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                dithering: s,
              }),
                e && this.setShaderParts(e),
                t && this.setDefines(t),
                n && this.setUniforms(n),
                this.copyCameraSettings(r);
            }
            set inputBuffer(e) {
              this.uniforms.inputBuffer.value = e;
            }
            setInputBuffer(e) {
              this.uniforms.inputBuffer.value = e;
            }
            get depthBuffer() {
              return this.uniforms.depthBuffer.value;
            }
            set depthBuffer(e) {
              this.uniforms.depthBuffer.value = e;
            }
            get depthPacking() {
              return Number(this.defines.DEPTH_PACKING);
            }
            set depthPacking(e) {
              (this.defines.DEPTH_PACKING = e.toFixed(0)),
                (this.needsUpdate = !0);
            }
            setDepthBuffer(e, t = i.Rkk) {
              (this.depthBuffer = e), (this.depthPacking = t);
            }
            setShaderData(e) {
              this.setShaderParts(e.shaderParts),
                this.setDefines(e.defines),
                this.setUniforms(e.uniforms),
                this.setExtensions(e.extensions);
            }
            setShaderParts(e) {
              return (
                (this.fragmentShader =
                  "#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#define packFloatToRGBA(v) packDepthToRGBA(v)\n#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)\n#ifdef FRAMEBUFFER_PRECISION_HIGH\nuniform mediump sampler2D inputBuffer;\n#else\nuniform lowp sampler2D inputBuffer;\n#endif\n#if DEPTH_PACKING == 3201\nuniform lowp sampler2D depthBuffer;\n#elif defined(GL_FRAGMENT_PRECISION_HIGH)\nuniform highp sampler2D depthBuffer;\n#else\nuniform mediump sampler2D depthBuffer;\n#endif\nuniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){\n#if DEPTH_PACKING == 3201\nreturn unpackRGBAToDepth(texture2D(depthBuffer,uv));\n#else\nreturn texture2D(depthBuffer,uv).r;\n#endif\n}float getViewZ(const in float depth){\n#ifdef PERSPECTIVE_CAMERA\nreturn perspectiveDepthToViewZ(depth,cameraNear,cameraFar);\n#else\nreturn orthographicDepthToViewZ(depth,cameraNear,cameraFar);\n#endif\n}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;\n#ifdef ENCODE_OUTPUT\n#include <colorspace_fragment>\n#endif\n#include <dithering_fragment>\n}"
                    .replace(m.FRAGMENT_HEAD, e.get(m.FRAGMENT_HEAD) || "")
                    .replace(
                      m.FRAGMENT_MAIN_UV,
                      e.get(m.FRAGMENT_MAIN_UV) || ""
                    )
                    .replace(
                      m.FRAGMENT_MAIN_IMAGE,
                      e.get(m.FRAGMENT_MAIN_IMAGE) || ""
                    )),
                (this.vertexShader =
                  "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}"
                    .replace(m.VERTEX_HEAD, e.get(m.VERTEX_HEAD) || "")
                    .replace(
                      m.VERTEX_MAIN_SUPPORT,
                      e.get(m.VERTEX_MAIN_SUPPORT) || ""
                    )),
                (this.needsUpdate = !0),
                this
              );
            }
            setDefines(e) {
              for (const t of e.entries()) this.defines[t[0]] = t[1];
              return (this.needsUpdate = !0), this;
            }
            setUniforms(e) {
              for (const t of e.entries()) this.uniforms[t[0]] = t[1];
              return this;
            }
            setExtensions(e) {
              this.extensions = {};
              for (const t of e) this.extensions[t] = !0;
              return this;
            }
            get encodeOutput() {
              return void 0 !== this.defines.ENCODE_OUTPUT;
            }
            set encodeOutput(e) {
              this.encodeOutput !== e &&
                (e
                  ? (this.defines.ENCODE_OUTPUT = "1")
                  : delete this.defines.ENCODE_OUTPUT,
                (this.needsUpdate = !0));
            }
            isOutputEncodingEnabled(e) {
              return this.encodeOutput;
            }
            setOutputEncodingEnabled(e) {
              this.encodeOutput = e;
            }
            get time() {
              return this.uniforms.time.value;
            }
            set time(e) {
              this.uniforms.time.value = e;
            }
            setDeltaTime(e) {
              this.uniforms.time.value += e;
            }
            adoptCameraSettings(e) {
              this.copyCameraSettings(e);
            }
            copyCameraSettings(e) {
              e &&
                ((this.uniforms.cameraNear.value = e.near),
                (this.uniforms.cameraFar.value = e.far),
                e instanceof i.ubm
                  ? (this.defines.PERSPECTIVE_CAMERA = "1")
                  : delete this.defines.PERSPECTIVE_CAMERA,
                (this.needsUpdate = !0));
            }
            setSize(e, t) {
              const n = this.uniforms;
              n.resolution.value.set(e, t),
                n.texelSize.value.set(1 / e, 1 / t),
                (n.aspect.value = e / t);
            }
            static get Section() {
              return m;
            }
          }),
        Ke = (i.BKk, Number(i.sPf.replace(/\D+/g, "")), 255 / 256);
      new Float32Array([
        5.9371814131736755e-8,
        Ke / 65536,
        0.0038909912109375,
        Ke,
      ]),
        new Float32Array([Ke, 0.0038909912109375, Ke / 65536, 1 / 256 ** 3]);
      function Je(e, t, n) {
        for (const i of t) {
          const t = "$1" + e + i.charAt(0).toUpperCase() + i.slice(1),
            r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
          for (const e of n.entries())
            null !== e[1] && n.set(e[0], e[1].replace(r, t));
        }
      }
      function Ze(e, t, n) {
        let r = t.getFragmentShader(),
          s = t.getVertexShader();
        const a = void 0 !== r && /mainImage/.test(r),
          o = void 0 !== r && /mainUv/.test(r);
        if (((n.attributes |= t.getAttributes()), void 0 === r))
          throw new Error(`Missing fragment shader (${t.name})`);
        if (o && n.attributes & g.CONVOLUTION)
          throw new Error(
            `Effects that transform UVs are incompatible with convolution effects (${t.name})`
          );
        if (!a && !o)
          throw new Error(
            `Could not find mainImage or mainUv function (${t.name})`
          );
        {
          const l = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
            c = n.shaderParts;
          let u = c.get(m.FRAGMENT_HEAD) || "",
            h = c.get(m.FRAGMENT_MAIN_UV) || "",
            d = c.get(m.FRAGMENT_MAIN_IMAGE) || "",
            p = c.get(m.VERTEX_HEAD) || "",
            f = c.get(m.VERTEX_MAIN_SUPPORT) || "";
          const A = new Set(),
            v = new Set();
          if (
            (o && ((h += `\t${e}MainUv(UV);\n`), (n.uvTransformation = !0)),
            null !== s && /mainSupport/.test(s))
          ) {
            const t = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
            (f += `\t${e}MainSupport(`), (f += t ? "vUv);\n" : ");\n");
            for (const e of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
              for (const t of e[1].split(/\s*,\s*/))
                n.varyings.add(t), A.add(t), v.add(t);
            for (const e of s.matchAll(l)) v.add(e[1]);
          }
          for (const e of r.matchAll(l)) v.add(e[1]);
          for (const e of t.defines.keys())
            v.add(e.replace(/\([\w\s,]*\)/g, ""));
          for (const e of t.uniforms.keys()) v.add(e);
          v.delete("while"),
            v.delete("for"),
            v.delete("if"),
            t.uniforms.forEach((t, i) =>
              n.uniforms.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)
            ),
            t.defines.forEach((t, i) =>
              n.defines.set(e + i.charAt(0).toUpperCase() + i.slice(1), t)
            );
          const y = new Map([
            ["fragment", r],
            ["vertex", s],
          ]);
          Je(e, v, n.defines),
            Je(e, v, y),
            (r = y.get("fragment")),
            (s = y.get("vertex"));
          const x = t.blendMode;
          if ((n.blendModes.set(x.blendFunction, x), a)) {
            null !== t.inputColorSpace &&
              t.inputColorSpace !== n.colorSpace &&
              (d +=
                t.inputColorSpace === i.er$
                  ? "color0 = sRGBTransferOETF(color0);\n\t"
                  : "color0 = sRGBToLinear(color0);\n\t"),
              t.outputColorSpace !== i.jf0
                ? (n.colorSpace = t.outputColorSpace)
                : null !== t.inputColorSpace &&
                  (n.colorSpace = t.inputColorSpace);
            const s = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            (d += `${e}MainImage(color0, UV, `),
              n.attributes & g.DEPTH &&
                s.test(r) &&
                ((d += "depth, "), (n.readDepth = !0)),
              (d += "color1);\n\t");
            const a = e + "BlendOpacity";
            n.uniforms.set(a, x.opacity),
              (d += `color0 = blend${x.blendFunction}(color0, color1, ${a});\n\n\t`),
              (u += `uniform float ${a};\n\n`);
          }
          if (
            ((u += r + "\n"),
            null !== s && (p += s + "\n"),
            c.set(m.FRAGMENT_HEAD, u),
            c.set(m.FRAGMENT_MAIN_UV, h),
            c.set(m.FRAGMENT_MAIN_IMAGE, d),
            c.set(m.VERTEX_HEAD, p),
            c.set(m.VERTEX_MAIN_SUPPORT, f),
            null !== t.extensions)
          )
            for (const e of t.extensions) n.extensions.add(e);
        }
      }
      var $e = class extends o {
          constructor(e, ...t) {
            super("EffectPass"),
              (this.fullscreenMaterial = new Xe(null, null, null, e)),
              (this.listener = (e) => this.handleEvent(e)),
              (this.effects = []),
              this.setEffects(t),
              (this.skipRendering = !1),
              (this.minTime = 1),
              (this.maxTime = Number.POSITIVE_INFINITY),
              (this.timeScale = 1);
          }
          set mainScene(e) {
            for (const t of this.effects) t.mainScene = e;
          }
          set mainCamera(e) {
            this.fullscreenMaterial.copyCameraSettings(e);
            for (const t of this.effects) t.mainCamera = e;
          }
          get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput;
          }
          set encodeOutput(e) {
            this.fullscreenMaterial.encodeOutput = e;
          }
          get dithering() {
            return this.fullscreenMaterial.dithering;
          }
          set dithering(e) {
            const t = this.fullscreenMaterial;
            (t.dithering = e), (t.needsUpdate = !0);
          }
          setEffects(e) {
            for (const e of this.effects)
              e.removeEventListener("change", this.listener);
            this.effects = e.sort((e, t) => t.attributes - e.attributes);
            for (const e of this.effects)
              e.addEventListener("change", this.listener);
          }
          updateMaterial() {
            const e = new v();
            let t = 0;
            for (const n of this.effects)
              if (n.blendMode.blendFunction === M)
                e.attributes |= n.getAttributes() & g.DEPTH;
              else {
                if (e.attributes & n.getAttributes() & g.CONVOLUTION)
                  throw new Error(
                    `Convolution effects cannot be merged (${n.name})`
                  );
                Ze("e" + t++, n, e);
              }
            let n = e.shaderParts.get(m.FRAGMENT_HEAD),
              r = e.shaderParts.get(m.FRAGMENT_MAIN_IMAGE),
              s = e.shaderParts.get(m.FRAGMENT_MAIN_UV);
            const a = /\bblend\b/g;
            for (const t of e.blendModes.values())
              n +=
                t.getShaderCode().replace(a, `blend${t.blendFunction}`) + "\n";
            e.attributes & g.DEPTH
              ? (e.readDepth && (r = "float depth = readDepth(UV);\n\n\t" + r),
                (this.needsDepthTexture = null === this.getDepthTexture()))
              : (this.needsDepthTexture = !1),
              e.colorSpace === i.er$ &&
                (r += "color0 = sRGBToLinear(color0);\n\t"),
              e.uvTransformation
                ? ((s = "vec2 transformedUv = vUv;\n" + s),
                  e.defines.set("UV", "transformedUv"))
                : e.defines.set("UV", "vUv"),
              e.shaderParts.set(m.FRAGMENT_HEAD, n),
              e.shaderParts.set(m.FRAGMENT_MAIN_IMAGE, r),
              e.shaderParts.set(m.FRAGMENT_MAIN_UV, s);
            for (const [t, n] of e.shaderParts)
              null !== n && e.shaderParts.set(t, n.trim().replace(/^#/, "\n#"));
            (this.skipRendering = 0 === t),
              (this.needsSwap = !this.skipRendering),
              this.fullscreenMaterial.setShaderData(e);
          }
          recompile() {
            this.updateMaterial();
          }
          getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer;
          }
          setDepthTexture(e, t = i.Rkk) {
            (this.fullscreenMaterial.depthBuffer = e),
              (this.fullscreenMaterial.depthPacking = t);
            for (const n of this.effects) n.setDepthTexture(e, t);
          }
          render(e, t, n, i, r) {
            for (const n of this.effects) n.update(e, t, i);
            if (!this.skipRendering || this.renderToScreen) {
              const r = this.fullscreenMaterial;
              (r.inputBuffer = t.texture),
                (r.time += i * this.timeScale),
                e.setRenderTarget(this.renderToScreen ? null : n),
                e.render(this.scene, this.camera);
            }
          }
          setSize(e, t) {
            this.fullscreenMaterial.setSize(e, t);
            for (const n of this.effects) n.setSize(e, t);
          }
          initialize(e, t, n) {
            this.renderer = e;
            for (const i of this.effects) i.initialize(e, t, n);
            this.updateMaterial(),
              void 0 !== n &&
                n !== i.OUM &&
                (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH =
                  "1");
          }
          dispose() {
            super.dispose();
            for (const e of this.effects)
              e.removeEventListener("change", this.listener), e.dispose();
          }
          handleEvent(e) {
            if ("change" === e.type) this.recompile();
          }
        },
        et = class extends o {
          constructor(
            e,
            t,
            {
              renderTarget: n,
              resolutionScale: r = 1,
              width: s = w.AUTO_SIZE,
              height: a = w.AUTO_SIZE,
              resolutionX: o = s,
              resolutionY: l = a,
            } = {}
          ) {
            super("NormalPass"),
              (this.needsSwap = !1),
              (this.renderPass = new ue(e, t, new i.qBx()));
            const c = this.renderPass;
            (c.ignoreBackground = !0), (c.skipShadowMapUpdate = !0);
            const u = c.getClearPass();
            (u.overrideClearColor = new i.Q1f(7829503)),
              (u.overrideClearAlpha = 1),
              (this.renderTarget = n),
              void 0 === this.renderTarget &&
                ((this.renderTarget = new i.nWS(1, 1, {
                  minFilter: i.hxR,
                  magFilter: i.hxR,
                })),
                (this.renderTarget.texture.name = "NormalPass.Target"));
            const h = (this.resolution = new w(this, o, l, r));
            h.addEventListener("change", (e) =>
              this.setSize(h.baseWidth, h.baseHeight)
            );
          }
          set mainScene(e) {
            this.renderPass.mainScene = e;
          }
          set mainCamera(e) {
            this.renderPass.mainCamera = e;
          }
          get texture() {
            return this.renderTarget.texture;
          }
          getTexture() {
            return this.renderTarget.texture;
          }
          getResolution() {
            return this.resolution;
          }
          getResolutionScale() {
            return this.resolution.scale;
          }
          setResolutionScale(e) {
            this.resolution.scale = e;
          }
          render(e, t, n, i, r) {
            const s = this.renderToScreen ? null : this.renderTarget;
            this.renderPass.render(e, s, s);
          }
          setSize(e, t) {
            const n = this.resolution;
            n.setBaseSize(e, t), this.renderTarget.setSize(n.width, n.height);
          }
        };
      new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array(3),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([1, 0, 0]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([1, 0, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([1, 1, 0]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 1, 0]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]),
        new Float32Array([0, 0, 0]),
        new Float32Array([0, 0, 1]),
        new Float32Array([0, 1, 1]),
        new Float32Array([1, 1, 1]);
      new Float32Array(2),
        new Float32Array(2),
        new Float32Array([0, -0.25, 0.25, -0.125, 0.125, -0.375, 0.375]),
        new Float32Array([0, 0]),
        new Float32Array([0.25, -0.25]),
        new Float32Array([-0.25, 0.25]),
        new Float32Array([0.125, -0.125]),
        new Float32Array([-0.125, 0.125]),
        new Uint8Array([0, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([0, 3]),
        new Uint8Array([3, 3]),
        new Uint8Array([1, 0]),
        new Uint8Array([4, 0]),
        new Uint8Array([1, 3]),
        new Uint8Array([4, 3]),
        new Uint8Array([0, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([0, 4]),
        new Uint8Array([3, 4]),
        new Uint8Array([1, 1]),
        new Uint8Array([4, 1]),
        new Uint8Array([1, 4]),
        new Uint8Array([4, 4]),
        new Uint8Array([0, 0]),
        new Uint8Array([1, 0]),
        new Uint8Array([0, 2]),
        new Uint8Array([1, 2]),
        new Uint8Array([2, 0]),
        new Uint8Array([3, 0]),
        new Uint8Array([2, 2]),
        new Uint8Array([3, 2]),
        new Uint8Array([0, 1]),
        new Uint8Array([1, 1]),
        new Uint8Array([0, 3]),
        new Uint8Array([1, 3]),
        new Uint8Array([2, 1]),
        new Uint8Array([3, 1]),
        new Uint8Array([2, 3]),
        new Uint8Array([3, 3]);
      nt(0, 0, 0, 0),
        new Float32Array([0, 0, 0, 0]),
        nt(0, 0, 0, 1),
        new Float32Array([0, 0, 0, 1]),
        nt(0, 0, 1, 0),
        new Float32Array([0, 0, 1, 0]),
        nt(0, 0, 1, 1),
        new Float32Array([0, 0, 1, 1]),
        nt(0, 1, 0, 0),
        new Float32Array([0, 1, 0, 0]),
        nt(0, 1, 0, 1),
        new Float32Array([0, 1, 0, 1]),
        nt(0, 1, 1, 0),
        new Float32Array([0, 1, 1, 0]),
        nt(0, 1, 1, 1),
        new Float32Array([0, 1, 1, 1]),
        nt(1, 0, 0, 0),
        new Float32Array([1, 0, 0, 0]),
        nt(1, 0, 0, 1),
        new Float32Array([1, 0, 0, 1]),
        nt(1, 0, 1, 0),
        new Float32Array([1, 0, 1, 0]),
        nt(1, 0, 1, 1),
        new Float32Array([1, 0, 1, 1]),
        nt(1, 1, 0, 0),
        new Float32Array([1, 1, 0, 0]),
        nt(1, 1, 0, 1),
        new Float32Array([1, 1, 0, 1]),
        nt(1, 1, 1, 0),
        new Float32Array([1, 1, 1, 0]),
        nt(1, 1, 1, 1),
        new Float32Array([1, 1, 1, 1]);
      function tt(e, t, n) {
        return e + (t - e) * n;
      }
      function nt(e, t, n, i) {
        const r = tt(e, t, 0.75),
          s = tt(n, i, 0.75);
        return tt(r, s, 0.875);
      }
    },
    4428: (e, t, n) => {
      "use strict";
      n.d(t, {
        $J: () => o,
        BE: () => u,
        Gm: () => r,
        Ne: () => c,
        Q7: () => i,
        Xe: () => s,
        bf: () => h,
        nw: () => l,
        vl: () => d,
        yj: () => a,
      });
      const i = 0,
        r = 1,
        s = 2,
        a = 2,
        o = 1.25,
        l = 1,
        c = 32,
        u = 65535,
        h = Math.pow(2, -24),
        d = Symbol("SKIP_GENERATION");
    },
    387: (e, t, n) => {
      "use strict";
      n.d(t, { zQ: () => Dt, LO: () => Pt, je: () => Lt });
      var i = n(5062);
      function r(e, t, n) {
        return null === e
          ? null
          : (e.point.applyMatrix4(t.matrixWorld),
            (e.distance = e.point.distanceTo(n.ray.origin)),
            (e.object = t),
            e.distance < n.near || e.distance > n.far ? null : e);
      }
      var s = n(4428);
      function a(e) {
        return (
          (function (e) {
            return e.index ? e.index.count : e.attributes.position.count;
          })(e) / 3
        );
      }
      function o(e, t) {
        if (!e.index) {
          const n = e.attributes.position.count,
            r = (function (e, t = ArrayBuffer) {
              return e > 65535
                ? new Uint32Array(new t(4 * e))
                : new Uint16Array(new t(2 * e));
            })(n, t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer);
          e.setIndex(new i.THS(r, 1));
          for (let e = 0; e < n; e++) r[e] = e;
        }
      }
      function l(e) {
        const t = a(e),
          n = e.drawRange,
          i = n.start / 3,
          r = (n.start + n.count) / 3,
          s = Math.max(0, i),
          o = Math.min(t, r) - s;
        return [{ offset: Math.floor(s), count: Math.floor(o) }];
      }
      function c(e) {
        if (!e.groups || !e.groups.length) return l(e);
        const t = [],
          n = new Set(),
          i = e.drawRange,
          r = i.start / 3,
          s = (i.start + i.count) / 3;
        for (const t of e.groups) {
          const e = t.start / 3,
            i = (t.start + t.count) / 3;
          n.add(Math.max(r, e)), n.add(Math.min(s, i));
        }
        const a = Array.from(n.values()).sort((e, t) => e - t);
        for (let e = 0; e < a.length - 1; e++) {
          const n = a[e],
            i = a[e + 1];
          t.push({ offset: Math.floor(n), count: Math.floor(i - n) });
        }
        return t;
      }
      function u(e, t, n, i, r) {
        let s = 1 / 0,
          a = 1 / 0,
          o = 1 / 0,
          l = -1 / 0,
          c = -1 / 0,
          u = -1 / 0,
          h = 1 / 0,
          d = 1 / 0,
          p = 1 / 0,
          f = -1 / 0,
          A = -1 / 0,
          g = -1 / 0;
        for (let i = 6 * t, r = 6 * (t + n); i < r; i += 6) {
          const t = e[i + 0],
            n = e[i + 1],
            r = t - n,
            m = t + n;
          r < s && (s = r),
            m > l && (l = m),
            t < h && (h = t),
            t > f && (f = t);
          const v = e[i + 2],
            y = e[i + 3],
            x = v - y,
            _ = v + y;
          x < a && (a = x),
            _ > c && (c = _),
            v < d && (d = v),
            v > A && (A = v);
          const b = e[i + 4],
            E = e[i + 5],
            w = b - E,
            C = b + E;
          w < o && (o = w),
            C > u && (u = C),
            b < p && (p = b),
            b > g && (g = b);
        }
        (i[0] = s),
          (i[1] = a),
          (i[2] = o),
          (i[3] = l),
          (i[4] = c),
          (i[5] = u),
          (r[0] = h),
          (r[1] = d),
          (r[2] = p),
          (r[3] = f),
          (r[4] = A),
          (r[5] = g);
      }
      function h(e, t, n) {
        return (
          (n.min.x = t[e]),
          (n.min.y = t[e + 1]),
          (n.min.z = t[e + 2]),
          (n.max.x = t[e + 3]),
          (n.max.y = t[e + 4]),
          (n.max.z = t[e + 5]),
          n
        );
      }
      function d(e) {
        let t = -1,
          n = -1 / 0;
        for (let i = 0; i < 3; i++) {
          const r = e[i + 3] - e[i];
          r > n && ((n = r), (t = i));
        }
        return t;
      }
      function p(e, t) {
        t.set(e);
      }
      function f(e, t, n) {
        let i, r;
        for (let s = 0; s < 3; s++) {
          const a = s + 3;
          (i = e[s]),
            (r = t[s]),
            (n[s] = i < r ? i : r),
            (i = e[a]),
            (r = t[a]),
            (n[a] = i > r ? i : r);
        }
      }
      function A(e, t, n) {
        for (let i = 0; i < 3; i++) {
          const r = t[e + 2 * i],
            s = t[e + 2 * i + 1],
            a = r - s,
            o = r + s;
          a < n[i] && (n[i] = a), o > n[i + 3] && (n[i + 3] = o);
        }
      }
      function g(e) {
        const t = e[3] - e[0],
          n = e[4] - e[1],
          i = e[5] - e[2];
        return 2 * (t * n + n * i + i * t);
      }
      const m = 32,
        v = (e, t) => e.candidate - t.candidate,
        y = new Array(m)
          .fill()
          .map(() => ({
            count: 0,
            bounds: new Float32Array(6),
            rightCacheBounds: new Float32Array(6),
            leftCacheBounds: new Float32Array(6),
            candidate: 0,
          })),
        x = new Float32Array(6);
      class _ {
        constructor() {
          this.boundingData = new Float32Array(6);
        }
      }
      function b(e, t, n, i, r, s) {
        let a = i,
          o = i + r - 1;
        const l = s.pos,
          c = 2 * s.axis;
        for (;;) {
          for (; a <= o && n[6 * a + c] < l; ) a++;
          for (; a <= o && n[6 * o + c] >= l; ) o--;
          if (!(a < o)) return a;
          for (let e = 0; e < 3; e++) {
            let n = t[3 * a + e];
            (t[3 * a + e] = t[3 * o + e]), (t[3 * o + e] = n);
          }
          for (let e = 0; e < 6; e++) {
            let t = n[6 * a + e];
            (n[6 * a + e] = n[6 * o + e]), (n[6 * o + e] = t);
          }
          a++, o--;
        }
      }
      function E(e, t, n, i, r, s) {
        let a = i,
          o = i + r - 1;
        const l = s.pos,
          c = 2 * s.axis;
        for (;;) {
          for (; a <= o && n[6 * a + c] < l; ) a++;
          for (; a <= o && n[6 * o + c] >= l; ) o--;
          if (!(a < o)) return a;
          {
            let t = e[a];
            (e[a] = e[o]), (e[o] = t);
            for (let e = 0; e < 6; e++) {
              let t = n[6 * a + e];
              (n[6 * a + e] = n[6 * o + e]), (n[6 * o + e] = t);
            }
            a++, o--;
          }
        }
      }
      function w(e, t) {
        return 65535 === t[e + 15];
      }
      function C(e, t) {
        return t[e + 6];
      }
      function I(e, t) {
        return t[e + 14];
      }
      function S(e) {
        return e + 8;
      }
      function M(e, t) {
        return t[e + 6];
      }
      function T(e, t) {
        return t[e + 7];
      }
      let B, R, D, P;
      const L = Math.pow(2, 32);
      function U(e) {
        return "count" in e ? 1 : 1 + U(e.left) + U(e.right);
      }
      function F(e, t, n) {
        return (
          (B = new Float32Array(n)),
          (R = new Uint32Array(n)),
          (D = new Uint16Array(n)),
          (P = new Uint8Array(n)),
          N(e, t)
        );
      }
      function N(e, t) {
        const n = e / 4,
          i = e / 2,
          r = "count" in t,
          a = t.boundingData;
        for (let e = 0; e < 6; e++) B[n + e] = a[e];
        if (r) {
          if (t.buffer) {
            const i = t.buffer;
            P.set(new Uint8Array(i), e);
            for (let t = e, r = e + i.byteLength; t < r; t += s.Ne) {
              w(t / 2, D) || (R[t / 4 + 6] += n);
            }
            return e + i.byteLength;
          }
          {
            const r = t.offset,
              a = t.count;
            return (
              (R[n + 6] = r), (D[i + 14] = a), (D[i + 15] = s.BE), e + s.Ne
            );
          }
        }
        {
          const i = t.left,
            r = t.right,
            a = t.splitAxis;
          let o;
          if (((o = N(e + s.Ne, i)), o / 4 > L))
            throw new Error(
              "MeshBVH: Cannot store child pointer greater than 32 bits."
            );
          return (R[n + 6] = o / 4), (o = N(o, r)), (R[n + 7] = a), o;
        }
      }
      function O(e, t, n, i, r) {
        const {
            maxDepth: o,
            verbose: l,
            maxLeafTris: c,
            strategy: h,
            onProgress: w,
            indirect: C,
          } = r,
          I = e._indirectBuffer,
          S = e.geometry,
          M = S.index ? S.index.array : null,
          T = C ? E : b,
          B = a(S),
          R = new Float32Array(6);
        let D = !1;
        const P = new _();
        return (
          u(t, n, i, P.boundingData, R),
          (function e(n, i, r, a = null, b = 0) {
            !D &&
              b >= o &&
              ((D = !0),
              l &&
                (console.warn(
                  `MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`
                ),
                console.warn(S)));
            if (r <= c || b >= o)
              return L(i + r), (n.offset = i), (n.count = r), n;
            const E = (function (e, t, n, i, r, a) {
              let o = -1,
                l = 0;
              if (a === s.Q7)
                (o = d(t)), -1 !== o && (l = (t[o] + t[o + 3]) / 2);
              else if (a === s.Gm)
                (o = d(e)),
                  -1 !== o &&
                    (l = (function (e, t, n, i) {
                      let r = 0;
                      for (let s = t, a = t + n; s < a; s++)
                        r += e[6 * s + 2 * i];
                      return r / n;
                    })(n, i, r, o));
              else if (a === s.Xe) {
                const a = g(e);
                let c = s.$J * r;
                const u = 6 * i,
                  h = 6 * (i + r);
                for (let e = 0; e < 3; e++) {
                  const i = t[e],
                    d = (t[e + 3] - i) / m;
                  if (r < m / 4) {
                    const t = [...y];
                    t.length = r;
                    let i = 0;
                    for (let r = u; r < h; r += 6, i++) {
                      const s = t[i];
                      (s.candidate = n[r + 2 * e]), (s.count = 0);
                      const {
                        bounds: a,
                        leftCacheBounds: o,
                        rightCacheBounds: l,
                      } = s;
                      for (let e = 0; e < 3; e++)
                        (l[e] = 1 / 0),
                          (l[e + 3] = -1 / 0),
                          (o[e] = 1 / 0),
                          (o[e + 3] = -1 / 0),
                          (a[e] = 1 / 0),
                          (a[e + 3] = -1 / 0);
                      A(r, n, a);
                    }
                    t.sort(v);
                    let d = r;
                    for (let e = 0; e < d; e++) {
                      const n = t[e];
                      for (; e + 1 < d && t[e + 1].candidate === n.candidate; )
                        t.splice(e + 1, 1), d--;
                    }
                    for (let i = u; i < h; i += 6) {
                      const r = n[i + 2 * e];
                      for (let e = 0; e < d; e++) {
                        const s = t[e];
                        r >= s.candidate
                          ? A(i, n, s.rightCacheBounds)
                          : (A(i, n, s.leftCacheBounds), s.count++);
                      }
                    }
                    for (let n = 0; n < d; n++) {
                      const i = t[n],
                        u = i.count,
                        h = r - i.count,
                        d = i.leftCacheBounds,
                        p = i.rightCacheBounds;
                      let f = 0;
                      0 !== u && (f = g(d) / a);
                      let A = 0;
                      0 !== h && (A = g(p) / a);
                      const m = s.nw + s.$J * (f * u + A * h);
                      m < c && ((o = e), (c = m), (l = i.candidate));
                    }
                  } else {
                    for (let e = 0; e < m; e++) {
                      const t = y[e];
                      (t.count = 0), (t.candidate = i + d + e * d);
                      const n = t.bounds;
                      for (let e = 0; e < 3; e++)
                        (n[e] = 1 / 0), (n[e + 3] = -1 / 0);
                    }
                    for (let t = u; t < h; t += 6) {
                      let r = ~~((n[t + 2 * e] - i) / d);
                      r >= m && (r = m - 1);
                      const s = y[r];
                      s.count++, A(t, n, s.bounds);
                    }
                    const t = y[m - 1];
                    p(t.bounds, t.rightCacheBounds);
                    for (let e = m - 2; e >= 0; e--) {
                      const t = y[e],
                        n = y[e + 1];
                      f(t.bounds, n.rightCacheBounds, t.rightCacheBounds);
                    }
                    let v = 0;
                    for (let t = 0; t < m - 1; t++) {
                      const n = y[t],
                        i = n.count,
                        u = n.bounds,
                        h = y[t + 1].rightCacheBounds;
                      0 !== i && (0 === v ? p(u, x) : f(u, x, x)), (v += i);
                      let d = 0,
                        A = 0;
                      0 !== v && (d = g(x) / a);
                      const m = r - v;
                      0 !== m && (A = g(h) / a);
                      const _ = s.nw + s.$J * (d * v + A * m);
                      _ < c && ((o = e), (c = _), (l = n.candidate));
                    }
                  }
                }
              } else
                console.warn(
                  `MeshBVH: Invalid build strategy value ${a} used.`
                );
              return { axis: o, pos: l };
            })(n.boundingData, a, t, i, r, h);
            if (-1 === E.axis)
              return L(i + r), (n.offset = i), (n.count = r), n;
            const w = T(I, M, t, i, r, E);
            if (w === i || w === i + r) L(i + r), (n.offset = i), (n.count = r);
            else {
              n.splitAxis = E.axis;
              const s = new _(),
                a = i,
                o = w - i;
              (n.left = s), u(t, a, o, s.boundingData, R), e(s, a, o, R, b + 1);
              const l = new _(),
                c = w,
                h = r - o;
              (n.right = l),
                u(t, c, h, l.boundingData, R),
                e(l, c, h, R, b + 1);
            }
            return n;
          })(P, n, i, R),
          P
        );
        function L(e) {
          w && w(e / B);
        }
      }
      function Q(e, t) {
        const n = e.geometry;
        t.indirect &&
          ((e._indirectBuffer = (function (e, t) {
            const n =
                (e.index ? e.index.count : e.attributes.position.count) / 3,
              i = n > 65536,
              r = i ? 4 : 2,
              s = t ? new SharedArrayBuffer(n * r) : new ArrayBuffer(n * r),
              a = i ? new Uint32Array(s) : new Uint16Array(s);
            for (let e = 0, t = a.length; e < t; e++) a[e] = e;
            return a;
          })(n, t.useSharedArrayBuffer)),
          (function (e) {
            if (0 === e.groups.length) return !1;
            const t = a(e),
              n = c(e).sort((e, t) => e.offset - t.offset),
              i = n[n.length - 1];
            i.count = Math.min(t - i.offset, i.count);
            let r = 0;
            return n.forEach(({ count: e }) => (r += e)), t !== r;
          })(n) &&
            !t.verbose &&
            console.warn(
              'MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.'
            )),
          e._indirectBuffer || o(n, t);
        const i = t.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer,
          r = (function (e, t = null, n = null, i = null) {
            const r = e.attributes.position,
              o = e.index ? e.index.array : null,
              l = a(e),
              c = r.normalized;
            let u;
            null === t
              ? ((u = new Float32Array(6 * l * 4)), (n = 0), (i = l))
              : ((u = t), (n = n || 0), (i = i || l));
            const h = r.array,
              d = r.offset || 0;
            let p = 3;
            r.isInterleavedBufferAttribute && (p = r.data.stride);
            const f = ["getX", "getY", "getZ"];
            for (let e = n; e < n + i; e++) {
              const t = 3 * e,
                n = 6 * e;
              let i = t + 0,
                a = t + 1,
                l = t + 2;
              o && ((i = o[i]), (a = o[a]), (l = o[l])),
                c || ((i = i * p + d), (a = a * p + d), (l = l * p + d));
              for (let e = 0; e < 3; e++) {
                let t, o, d;
                c
                  ? ((t = r[f[e]](i)), (o = r[f[e]](a)), (d = r[f[e]](l)))
                  : ((t = h[i + e]), (o = h[a + e]), (d = h[l + e]));
                let p = t;
                o < p && (p = o), d < p && (p = d);
                let A = t;
                o > A && (A = o), d > A && (A = d);
                const g = (A - p) / 2,
                  m = 2 * e;
                (u[n + m + 0] = p + g),
                  (u[n + m + 1] = g + (Math.abs(p) + g) * s.bf);
              }
            }
            return u;
          })(n),
          u = t.indirect ? l(n) : c(n);
        e._roots = u.map((n) => {
          const a = O(e, r, n.offset, n.count, t),
            o = U(a),
            l = new i(s.Ne * o);
          return F(0, a, l), l;
        });
      }
      class k {
        constructor() {
          (this.min = 1 / 0), (this.max = -1 / 0);
        }
        setFromPointsField(e, t) {
          let n = 1 / 0,
            i = -1 / 0;
          for (let r = 0, s = e.length; r < s; r++) {
            const s = e[r][t];
            (n = s < n ? s : n), (i = s > i ? s : i);
          }
          (this.min = n), (this.max = i);
        }
        setFromPoints(e, t) {
          let n = 1 / 0,
            i = -1 / 0;
          for (let r = 0, s = t.length; r < s; r++) {
            const s = t[r],
              a = e.dot(s);
            (n = a < n ? a : n), (i = a > i ? a : i);
          }
          (this.min = n), (this.max = i);
        }
        isSeparated(e) {
          return this.min > e.max || e.min > this.max;
        }
      }
      k.prototype.setFromBox = (function () {
        const e = new i.Pq0();
        return function (t, n) {
          const i = n.min,
            r = n.max;
          let s = 1 / 0,
            a = -1 / 0;
          for (let n = 0; n <= 1; n++)
            for (let o = 0; o <= 1; o++)
              for (let l = 0; l <= 1; l++) {
                (e.x = i.x * n + r.x * (1 - n)),
                  (e.y = i.y * o + r.y * (1 - o)),
                  (e.z = i.z * l + r.z * (1 - l));
                const c = t.dot(e);
                (s = Math.min(c, s)), (a = Math.max(c, a));
              }
          (this.min = s), (this.max = a);
        };
      })();
      !(function () {
        const e = new k();
      })();
      const G = (function () {
          const e = new i.Pq0(),
            t = new i.Pq0(),
            n = new i.Pq0();
          return function (i, r, s) {
            const a = i.start,
              o = e,
              l = r.start,
              c = t;
            n.subVectors(a, l),
              e.subVectors(i.end, i.start),
              t.subVectors(r.end, r.start);
            const u = n.dot(c),
              h = c.dot(o),
              d = c.dot(c),
              p = n.dot(o),
              f = o.dot(o) * d - h * h;
            let A, g;
            (A = 0 !== f ? (u * h - p * d) / f : 0),
              (g = (u + A * h) / d),
              (s.x = A),
              (s.y = g);
          };
        })(),
        H = (function () {
          const e = new i.I9Y(),
            t = new i.Pq0(),
            n = new i.Pq0();
          return function (i, r, s, a) {
            G(i, r, e);
            let o = e.x,
              l = e.y;
            if (o >= 0 && o <= 1 && l >= 0 && l <= 1)
              return i.at(o, s), void r.at(l, a);
            if (o >= 0 && o <= 1)
              return (
                l < 0 ? r.at(0, a) : r.at(1, a),
                void i.closestPointToPoint(a, !0, s)
              );
            if (l >= 0 && l <= 1)
              return (
                o < 0 ? i.at(0, s) : i.at(1, s),
                void r.closestPointToPoint(s, !0, a)
              );
            {
              let e, c;
              (e = o < 0 ? i.start : i.end), (c = l < 0 ? r.start : r.end);
              const u = t,
                h = n;
              return (
                i.closestPointToPoint(c, !0, t),
                r.closestPointToPoint(e, !0, n),
                u.distanceToSquared(c) <= h.distanceToSquared(e)
                  ? (s.copy(u), void a.copy(c))
                  : (s.copy(e), void a.copy(h))
              );
            }
          };
        })(),
        z = (function () {
          const e = new i.Pq0(),
            t = new i.Pq0(),
            n = new i.Zcv(),
            r = new i.cZY();
          return function (i, s) {
            const { radius: a, center: o } = i,
              { a: l, b: c, c: u } = s;
            (r.start = l), (r.end = c);
            if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            (r.start = l), (r.end = u);
            if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            (r.start = c), (r.end = u);
            if (r.closestPointToPoint(o, !0, e).distanceTo(o) <= a) return !0;
            const h = s.getPlane(n);
            if (Math.abs(h.distanceToPoint(o)) <= a) {
              const e = h.projectPoint(o, t);
              if (s.containsPoint(e)) return !0;
            }
            return !1;
          };
        })();
      function V(e) {
        return Math.abs(e) < 1e-15;
      }
      class W extends i.lMl {
        constructor(...e) {
          super(...e),
            (this.isExtendedTriangle = !0),
            (this.satAxes = new Array(4).fill().map(() => new i.Pq0())),
            (this.satBounds = new Array(4).fill().map(() => new k())),
            (this.points = [this.a, this.b, this.c]),
            (this.sphere = new i.iyt()),
            (this.plane = new i.Zcv()),
            (this.needsUpdate = !0);
        }
        intersectsSphere(e) {
          return z(e, this);
        }
        update() {
          const e = this.a,
            t = this.b,
            n = this.c,
            i = this.points,
            r = this.satAxes,
            s = this.satBounds,
            a = r[0],
            o = s[0];
          this.getNormal(a), o.setFromPoints(a, i);
          const l = r[1],
            c = s[1];
          l.subVectors(e, t), c.setFromPoints(l, i);
          const u = r[2],
            h = s[2];
          u.subVectors(t, n), h.setFromPoints(u, i);
          const d = r[3],
            p = s[3];
          d.subVectors(n, e),
            p.setFromPoints(d, i),
            this.sphere.setFromPoints(this.points),
            this.plane.setFromNormalAndCoplanarPoint(a, e),
            (this.needsUpdate = !1);
        }
      }
      (W.prototype.closestPointToSegment = (function () {
        const e = new i.Pq0(),
          t = new i.Pq0(),
          n = new i.cZY();
        return function (i, r = null, s = null) {
          const { start: a, end: o } = i,
            l = this.points;
          let c,
            u = 1 / 0;
          for (let a = 0; a < 3; a++) {
            const o = (a + 1) % 3;
            n.start.copy(l[a]),
              n.end.copy(l[o]),
              H(n, i, e, t),
              (c = e.distanceToSquared(t)),
              c < u && ((u = c), r && r.copy(e), s && s.copy(t));
          }
          return (
            this.closestPointToPoint(a, e),
            (c = a.distanceToSquared(e)),
            c < u && ((u = c), r && r.copy(e), s && s.copy(a)),
            this.closestPointToPoint(o, e),
            (c = o.distanceToSquared(e)),
            c < u && ((u = c), r && r.copy(e), s && s.copy(o)),
            Math.sqrt(u)
          );
        };
      })()),
        (W.prototype.intersectsTriangle = (function () {
          const e = new W(),
            t = new Array(3),
            n = new Array(3),
            r = new k(),
            s = new k(),
            a = new i.Pq0(),
            o = new i.Pq0(),
            l = new i.Pq0(),
            c = new i.Pq0(),
            u = new i.Pq0(),
            h = new i.cZY(),
            d = new i.cZY(),
            p = new i.cZY(),
            f = new i.Pq0();
          function A(e, t, n) {
            const i = e.points;
            let r = 0,
              s = -1;
            for (let e = 0; e < 3; e++) {
              const { start: a, end: l } = h;
              a.copy(i[e]), l.copy(i[(e + 1) % 3]), h.delta(o);
              const c = V(t.distanceToPoint(a));
              if (V(t.normal.dot(o)) && c) {
                n.copy(h), (r = 2);
                break;
              }
              const u = t.intersectLine(h, f);
              if ((!u && c && f.copy(a), (u || c) && !V(f.distanceTo(l)))) {
                if (r <= 1) {
                  (1 === r ? n.start : n.end).copy(f), c && (s = r);
                } else if (r >= 2) {
                  (1 === s ? n.start : n.end).copy(f), (r = 2);
                  break;
                }
                if ((r++, 2 === r && -1 === s)) break;
              }
            }
            return r;
          }
          return function (i, o = null, h = !1) {
            this.needsUpdate && this.update(),
              i.isExtendedTriangle
                ? i.needsUpdate && i.update()
                : (e.copy(i), e.update(), (i = e));
            const f = this.plane,
              g = i.plane;
            if (Math.abs(f.normal.dot(g.normal)) > 1 - 1e-10) {
              const e = this.satBounds,
                l = this.satAxes;
              (n[0] = i.a), (n[1] = i.b), (n[2] = i.c);
              for (let t = 0; t < 4; t++) {
                const i = e[t],
                  s = l[t];
                if ((r.setFromPoints(s, n), i.isSeparated(r))) return !1;
              }
              const c = i.satBounds,
                u = i.satAxes;
              (t[0] = this.a), (t[1] = this.b), (t[2] = this.c);
              for (let e = 0; e < 4; e++) {
                const n = c[e],
                  i = u[e];
                if ((r.setFromPoints(i, t), n.isSeparated(r))) return !1;
              }
              for (let e = 0; e < 4; e++) {
                const i = l[e];
                for (let e = 0; e < 4; e++) {
                  const o = u[e];
                  if (
                    (a.crossVectors(i, o),
                    r.setFromPoints(a, t),
                    s.setFromPoints(a, n),
                    r.isSeparated(s))
                  )
                    return !1;
                }
              }
              return (
                o &&
                  (h ||
                    console.warn(
                      "ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."
                    ),
                  o.start.set(0, 0, 0),
                  o.end.set(0, 0, 0)),
                !0
              );
            }
            {
              const e = A(this, g, d);
              if (1 === e && i.containsPoint(d.end))
                return o && (o.start.copy(d.end), o.end.copy(d.end)), !0;
              if (2 !== e) return !1;
              const t = A(i, f, p);
              if (1 === t && this.containsPoint(p.end))
                return o && (o.start.copy(p.end), o.end.copy(p.end)), !0;
              if (2 !== t) return !1;
              if ((d.delta(l), p.delta(c), l.dot(c) < 0)) {
                let e = p.start;
                (p.start = p.end), (p.end = e);
              }
              const n = d.start.dot(l),
                r = d.end.dot(l),
                s = p.start.dot(l),
                a = p.end.dot(l);
              return (
                (n === a || s === r || r < s !== n < a) &&
                (o &&
                  (u.subVectors(d.start, p.start),
                  u.dot(l) > 0 ? o.start.copy(d.start) : o.start.copy(p.start),
                  u.subVectors(d.end, p.end),
                  u.dot(l) < 0 ? o.end.copy(d.end) : o.end.copy(p.end)),
                !0)
              );
            }
          };
        })()),
        (W.prototype.distanceToPoint = (function () {
          const e = new i.Pq0();
          return function (t) {
            return this.closestPointToPoint(t, e), t.distanceTo(e);
          };
        })()),
        (W.prototype.distanceToTriangle = (function () {
          const e = new i.Pq0(),
            t = new i.Pq0(),
            n = ["a", "b", "c"],
            r = new i.cZY(),
            s = new i.cZY();
          return function (i, a = null, o = null) {
            const l = a || o ? r : null;
            if (this.intersectsTriangle(i, l))
              return (a || o) && (a && l.getCenter(a), o && l.getCenter(o)), 0;
            let c = 1 / 0;
            for (let t = 0; t < 3; t++) {
              let r;
              const s = n[t],
                l = i[s];
              this.closestPointToPoint(l, e),
                (r = l.distanceToSquared(e)),
                r < c && ((c = r), a && a.copy(e), o && o.copy(l));
              const u = this[s];
              i.closestPointToPoint(u, e),
                (r = u.distanceToSquared(e)),
                r < c && ((c = r), a && a.copy(u), o && o.copy(e));
            }
            for (let l = 0; l < 3; l++) {
              const u = n[l],
                h = n[(l + 1) % 3];
              r.set(this[u], this[h]);
              for (let l = 0; l < 3; l++) {
                const u = n[l],
                  h = n[(l + 1) % 3];
                s.set(i[u], i[h]), H(r, s, e, t);
                const d = e.distanceToSquared(t);
                d < c && ((c = d), a && a.copy(e), o && o.copy(t));
              }
            }
            return Math.sqrt(c);
          };
        })());
      class j {
        constructor(e, t, n) {
          (this.isOrientedBox = !0),
            (this.min = new i.Pq0()),
            (this.max = new i.Pq0()),
            (this.matrix = new i.kn4()),
            (this.invMatrix = new i.kn4()),
            (this.points = new Array(8).fill().map(() => new i.Pq0())),
            (this.satAxes = new Array(3).fill().map(() => new i.Pq0())),
            (this.satBounds = new Array(3).fill().map(() => new k())),
            (this.alignedSatBounds = new Array(3).fill().map(() => new k())),
            (this.needsUpdate = !1),
            e && this.min.copy(e),
            t && this.max.copy(t),
            n && this.matrix.copy(n);
        }
        set(e, t, n) {
          this.min.copy(e),
            this.max.copy(t),
            this.matrix.copy(n),
            (this.needsUpdate = !0);
        }
        copy(e) {
          this.min.copy(e.min),
            this.max.copy(e.max),
            this.matrix.copy(e.matrix),
            (this.needsUpdate = !0);
        }
      }
      (j.prototype.update = function () {
        const e = this.matrix,
          t = this.min,
          n = this.max,
          i = this.points;
        for (let r = 0; r <= 1; r++)
          for (let s = 0; s <= 1; s++)
            for (let a = 0; a <= 1; a++) {
              const o = i[(1 * r) | (2 * s) | (4 * a)];
              (o.x = r ? n.x : t.x),
                (o.y = s ? n.y : t.y),
                (o.z = a ? n.z : t.z),
                o.applyMatrix4(e);
            }
        const r = this.satBounds,
          s = this.satAxes,
          a = i[0];
        for (let e = 0; e < 3; e++) {
          const t = s[e],
            n = r[e],
            o = i[1 << e];
          t.subVectors(a, o), n.setFromPoints(t, i);
        }
        const o = this.alignedSatBounds;
        o[0].setFromPointsField(i, "x"),
          o[1].setFromPointsField(i, "y"),
          o[2].setFromPointsField(i, "z"),
          this.invMatrix.copy(this.matrix).invert(),
          (this.needsUpdate = !1);
      }),
        (j.prototype.intersectsBox = (function () {
          const e = new k();
          return function (t) {
            this.needsUpdate && this.update();
            const n = t.min,
              i = t.max,
              r = this.satBounds,
              s = this.satAxes,
              a = this.alignedSatBounds;
            if (((e.min = n.x), (e.max = i.x), a[0].isSeparated(e))) return !1;
            if (((e.min = n.y), (e.max = i.y), a[1].isSeparated(e))) return !1;
            if (((e.min = n.z), (e.max = i.z), a[2].isSeparated(e))) return !1;
            for (let n = 0; n < 3; n++) {
              const i = s[n],
                a = r[n];
              if ((e.setFromBox(i, t), a.isSeparated(e))) return !1;
            }
            return !0;
          };
        })()),
        (j.prototype.intersectsTriangle = (function () {
          const e = new W(),
            t = new Array(3),
            n = new k(),
            r = new k(),
            s = new i.Pq0();
          return function (i) {
            this.needsUpdate && this.update(),
              i.isExtendedTriangle
                ? i.needsUpdate && i.update()
                : (e.copy(i), e.update(), (i = e));
            const a = this.satBounds,
              o = this.satAxes;
            (t[0] = i.a), (t[1] = i.b), (t[2] = i.c);
            for (let e = 0; e < 3; e++) {
              const i = a[e],
                r = o[e];
              if ((n.setFromPoints(r, t), i.isSeparated(n))) return !1;
            }
            const l = i.satBounds,
              c = i.satAxes,
              u = this.points;
            for (let e = 0; e < 3; e++) {
              const t = l[e],
                i = c[e];
              if ((n.setFromPoints(i, u), t.isSeparated(n))) return !1;
            }
            for (let e = 0; e < 3; e++) {
              const i = o[e];
              for (let e = 0; e < 4; e++) {
                const a = c[e];
                if (
                  (s.crossVectors(i, a),
                  n.setFromPoints(s, t),
                  r.setFromPoints(s, u),
                  n.isSeparated(r))
                )
                  return !1;
              }
            }
            return !0;
          };
        })()),
        (j.prototype.closestPointToPoint = function (e, t) {
          return (
            this.needsUpdate && this.update(),
            t
              .copy(e)
              .applyMatrix4(this.invMatrix)
              .clamp(this.min, this.max)
              .applyMatrix4(this.matrix),
            t
          );
        }),
        (j.prototype.distanceToPoint = (function () {
          const e = new i.Pq0();
          return function (t) {
            return this.closestPointToPoint(t, e), t.distanceTo(e);
          };
        })()),
        (j.prototype.distanceToBox = (function () {
          const e = ["x", "y", "z"],
            t = new Array(12).fill().map(() => new i.cZY()),
            n = new Array(12).fill().map(() => new i.cZY()),
            r = new i.Pq0(),
            s = new i.Pq0();
          return function (i, a = 0, o = null, l = null) {
            if ((this.needsUpdate && this.update(), this.intersectsBox(i)))
              return (
                (o || l) &&
                  (i.getCenter(s),
                  this.closestPointToPoint(s, r),
                  i.closestPointToPoint(r, s),
                  o && o.copy(r),
                  l && l.copy(s)),
                0
              );
            const c = a * a,
              u = i.min,
              h = i.max,
              d = this.points;
            let p = 1 / 0;
            for (let e = 0; e < 8; e++) {
              const t = d[e];
              s.copy(t).clamp(u, h);
              const n = t.distanceToSquared(s);
              if (n < p && ((p = n), o && o.copy(t), l && l.copy(s), n < c))
                return Math.sqrt(n);
            }
            let f = 0;
            for (let i = 0; i < 3; i++)
              for (let r = 0; r <= 1; r++)
                for (let s = 0; s <= 1; s++) {
                  const a = (i + 1) % 3,
                    o = (i + 2) % 3,
                    l = (1 << i) | (r << a) | (s << o),
                    c = d[(r << a) | (s << o)],
                    p = d[l];
                  t[f].set(c, p);
                  const A = e[i],
                    g = e[a],
                    m = e[o],
                    v = n[f],
                    y = v.start,
                    x = v.end;
                  (y[A] = u[A]),
                    (y[g] = r ? u[g] : h[g]),
                    (y[m] = s ? u[m] : h[g]),
                    (x[A] = h[A]),
                    (x[g] = r ? u[g] : h[g]),
                    (x[m] = s ? u[m] : h[g]),
                    f++;
                }
            for (let e = 0; e <= 1; e++)
              for (let t = 0; t <= 1; t++)
                for (let n = 0; n <= 1; n++) {
                  (s.x = e ? h.x : u.x),
                    (s.y = t ? h.y : u.y),
                    (s.z = n ? h.z : u.z),
                    this.closestPointToPoint(s, r);
                  const i = s.distanceToSquared(r);
                  if (i < p && ((p = i), o && o.copy(r), l && l.copy(s), i < c))
                    return Math.sqrt(i);
                }
            for (let e = 0; e < 12; e++) {
              const i = t[e];
              for (let e = 0; e < 12; e++) {
                const t = n[e];
                H(i, t, r, s);
                const a = r.distanceToSquared(s);
                if (a < p && ((p = a), o && o.copy(r), l && l.copy(s), a < c))
                  return Math.sqrt(a);
              }
            }
            return Math.sqrt(p);
          };
        })());
      class q {
        constructor(e) {
          (this._getNewPrimitive = e), (this._primitives = []);
        }
        getPrimitive() {
          const e = this._primitives;
          return 0 === e.length ? this._getNewPrimitive() : e.pop();
        }
        releasePrimitive(e) {
          this._primitives.push(e);
        }
      }
      class Y extends q {
        constructor() {
          super(() => new W());
        }
      }
      const X = new Y();
      const K = new (class {
        constructor() {
          (this.float32Array = null),
            (this.uint16Array = null),
            (this.uint32Array = null);
          const e = [];
          let t = null;
          (this.setBuffer = (n) => {
            t && e.push(t),
              (t = n),
              (this.float32Array = new Float32Array(n)),
              (this.uint16Array = new Uint16Array(n)),
              (this.uint32Array = new Uint32Array(n));
          }),
            (this.clearBuffer = () => {
              (t = null),
                (this.float32Array = null),
                (this.uint16Array = null),
                (this.uint32Array = null),
                0 !== e.length && this.setBuffer(e.pop());
            });
        }
      })();
      let J, Z;
      const $ = [],
        ee = new q(() => new i.NRn());
      function te(e, t, n, i, r, s) {
        (J = ee.getPrimitive()),
          (Z = ee.getPrimitive()),
          $.push(J, Z),
          K.setBuffer(e._roots[t]);
        const a = ne(0, e.geometry, n, i, r, s);
        K.clearBuffer(),
          ee.releasePrimitive(J),
          ee.releasePrimitive(Z),
          $.pop(),
          $.pop();
        const o = $.length;
        return o > 0 && ((Z = $[o - 1]), (J = $[o - 2])), a;
      }
      function ne(e, t, n, i, r = null, a = 0, o = 0) {
        const { float32Array: l, uint16Array: c, uint32Array: u } = K;
        let d = 2 * e;
        if (w(d, c)) {
          const p = C(e, u),
            f = I(d, c);
          return h(e, l, J), i(p, f, !1, o, a + e, J);
        }
        {
          const A = S(e),
            g = M(e, u);
          let m,
            v,
            y,
            x,
            _ = A,
            b = g;
          if (
            r &&
            ((y = J),
            (x = Z),
            h(_, l, y),
            h(b, l, x),
            (m = r(y)),
            (v = r(x)),
            v < m)
          ) {
            (_ = g), (b = A);
            const L = m;
            (m = v), (v = L), (y = x);
          }
          y || ((y = J), h(_, l, y));
          const E = n(y, w(2 * _, c), m, o + 1, a + _);
          let T;
          if (E === s.yj) {
            const U = D(_);
            T = i(U, P(_) - U, !0, o + 1, a + _, y);
          } else T = E && ne(_, t, n, i, r, a, o + 1);
          if (T) return !0;
          (x = Z), h(b, l, x);
          const B = n(x, w(2 * b, c), v, o + 1, a + b);
          let R;
          if (B === s.yj) {
            const F = D(b);
            R = i(F, P(b) - F, !0, o + 1, a + b, x);
          } else R = B && ne(b, t, n, i, r, a, o + 1);
          return !!R;
          function D(e) {
            const { uint16Array: t, uint32Array: n } = K;
            let i = 2 * e;
            for (; !w(i, t); ) i = 2 * (e = S(e));
            return C(e, n);
          }
          function P(e) {
            const { uint16Array: t, uint32Array: n } = K;
            let i = 2 * e;
            for (; !w(i, t); ) i = 2 * (e = M(e, n));
            return C(e, n) + I(i, t);
          }
        }
      }
      const ie = new i.Pq0(),
        re = new i.Pq0();
      const se = new i.Pq0(),
        ae = new i.Pq0(),
        oe = new i.Pq0(),
        le = new i.I9Y(),
        ce = new i.I9Y(),
        ue = new i.I9Y(),
        he = new i.Pq0(),
        de = new i.Pq0(),
        pe = new i.Pq0(),
        fe = new i.Pq0();
      function Ae(e, t, n, r, s, a, o, l, c) {
        se.fromBufferAttribute(t, a),
          ae.fromBufferAttribute(t, o),
          oe.fromBufferAttribute(t, l);
        const u = (function (e, t, n, r, s, a) {
          let o;
          return (
            (o =
              a === i.hsX
                ? e.intersectTriangle(r, n, t, !0, s)
                : e.intersectTriangle(t, n, r, a !== i.$EB, s)),
            null === o
              ? null
              : { distance: e.origin.distanceTo(s), point: s.clone() }
          );
        })(e, se, ae, oe, fe, c);
        if (u) {
          r &&
            (le.fromBufferAttribute(r, a),
            ce.fromBufferAttribute(r, o),
            ue.fromBufferAttribute(r, l),
            (u.uv = i.lMl.getInterpolation(
              fe,
              se,
              ae,
              oe,
              le,
              ce,
              ue,
              new i.I9Y()
            ))),
            s &&
              (le.fromBufferAttribute(s, a),
              ce.fromBufferAttribute(s, o),
              ue.fromBufferAttribute(s, l),
              (u.uv1 = i.lMl.getInterpolation(
                fe,
                se,
                ae,
                oe,
                le,
                ce,
                ue,
                new i.I9Y()
              ))),
            n &&
              (he.fromBufferAttribute(n, a),
              de.fromBufferAttribute(n, o),
              pe.fromBufferAttribute(n, l),
              (u.normal = i.lMl.getInterpolation(
                fe,
                se,
                ae,
                oe,
                he,
                de,
                pe,
                new i.Pq0()
              )),
              u.normal.dot(e.direction) > 0 && u.normal.multiplyScalar(-1));
          const t = { a, b: o, c: l, normal: new i.Pq0(), materialIndex: 0 };
          i.lMl.getNormal(se, ae, oe, t.normal),
            (u.face = t),
            (u.faceIndex = a);
        }
        return u;
      }
      function ge(e, t, n, i, r) {
        const s = 3 * i;
        let a = s + 0,
          o = s + 1,
          l = s + 2;
        const c = e.index;
        e.index && ((a = c.getX(a)), (o = c.getX(o)), (l = c.getX(l)));
        const { position: u, normal: h, uv: d, uv1: p } = e.attributes,
          f = Ae(n, u, h, d, p, a, o, l, t);
        return f ? ((f.faceIndex = i), r && r.push(f), f) : null;
      }
      function me(e, t, n, i) {
        const r = e.a,
          s = e.b,
          a = e.c;
        let o = t,
          l = t + 1,
          c = t + 2;
        n && ((o = n.getX(o)), (l = n.getX(l)), (c = n.getX(c))),
          (r.x = i.getX(o)),
          (r.y = i.getY(o)),
          (r.z = i.getZ(o)),
          (s.x = i.getX(l)),
          (s.y = i.getY(l)),
          (s.z = i.getZ(l)),
          (a.x = i.getX(c)),
          (a.y = i.getY(c)),
          (a.z = i.getZ(c));
      }
      function ve(e, t, n, i, r, s, a) {
        const { geometry: o } = n,
          { index: l } = o,
          c = o.attributes.position;
        for (let n = e, o = t + e; n < o; n++) {
          let e;
          if (
            ((e = n), me(a, 3 * e, l, c), (a.needsUpdate = !0), i(a, e, r, s))
          )
            return !0;
        }
        return !1;
      }
      function ye(e, t = null) {
        t && Array.isArray(t) && (t = new Set(t));
        const n = e.geometry,
          i = n.index ? n.index.array : null,
          r = n.attributes.position;
        let a,
          o,
          l,
          c,
          u = 0;
        const h = e._roots;
        for (let e = 0, t = h.length; e < t; e++)
          (a = h[e]),
            (o = new Uint32Array(a)),
            (l = new Uint16Array(a)),
            (c = new Float32Array(a)),
            d(0, u),
            (u += a.byteLength);
        function d(e, n, a = !1) {
          const u = 2 * e;
          if (l[u + 15] === s.BE) {
            const t = o[e + 6];
            let n = 1 / 0,
              s = 1 / 0,
              a = 1 / 0,
              h = -1 / 0,
              d = -1 / 0,
              p = -1 / 0;
            for (let e = 3 * t, o = 3 * (t + l[u + 14]); e < o; e++) {
              let t = i[e];
              const o = r.getX(t),
                l = r.getY(t),
                c = r.getZ(t);
              o < n && (n = o),
                o > h && (h = o),
                l < s && (s = l),
                l > d && (d = l),
                c < a && (a = c),
                c > p && (p = c);
            }
            return (
              (c[e + 0] !== n ||
                c[e + 1] !== s ||
                c[e + 2] !== a ||
                c[e + 3] !== h ||
                c[e + 4] !== d ||
                c[e + 5] !== p) &&
              ((c[e + 0] = n),
              (c[e + 1] = s),
              (c[e + 2] = a),
              (c[e + 3] = h),
              (c[e + 4] = d),
              (c[e + 5] = p),
              !0)
            );
          }
          {
            const i = e + 8,
              r = o[e + 6],
              s = i + n,
              l = r + n;
            let u = a,
              h = !1,
              p = !1;
            t
              ? u || ((h = t.has(s)), (p = t.has(l)), (u = !h && !p))
              : ((h = !0), (p = !0));
            const f = u || p;
            let A = !1;
            (u || h) && (A = d(i, n, u));
            let g = !1;
            f && (g = d(r, n, u));
            const m = A || g;
            if (m)
              for (let t = 0; t < 3; t++) {
                const n = i + t,
                  s = r + t,
                  a = c[n],
                  o = c[n + 3],
                  l = c[s],
                  u = c[s + 3];
                (c[e + t] = a < l ? a : l), (c[e + t + 3] = o > u ? o : u);
              }
            return m;
          }
        }
      }
      const xe = new i.NRn();
      function _e(e, t, n, i) {
        return h(e, t, xe), n.intersectBox(xe, i);
      }
      const be = new i.Pq0();
      function Ee(e, t, n, i, r) {
        K.setBuffer(e._roots[t]), we(0, e, n, i, r), K.clearBuffer();
      }
      function we(e, t, n, i, r) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = K,
          l = 2 * e;
        if (w(l, a)) {
          !(function (e, t, n, i, r, s) {
            const { geometry: a, _indirectBuffer: o } = e;
            for (let e = i, o = i + r; e < o; e++) ge(a, t, n, e, s);
          })(t, n, i, C(e, o), I(l, a), r);
        } else {
          const a = S(e);
          _e(a, s, i, be) && we(a, t, n, i, r);
          const l = M(e, o);
          _e(l, s, i, be) && we(l, t, n, i, r);
        }
      }
      const Ce = new i.Pq0(),
        Ie = ["x", "y", "z"];
      function Se(e, t, n, i) {
        K.setBuffer(e._roots[t]);
        const r = Me(0, e, n, i);
        return K.clearBuffer(), r;
      }
      function Me(e, t, n, i) {
        const { float32Array: r, uint16Array: s, uint32Array: a } = K;
        let o = 2 * e;
        if (w(o, s)) {
          return (function (e, t, n, i, r) {
            const { geometry: s, _indirectBuffer: a } = e;
            let o = 1 / 0,
              l = null;
            for (let e = i, a = i + r; e < a; e++) {
              let i;
              (i = ge(s, t, n, e)),
                i && i.distance < o && ((l = i), (o = i.distance));
            }
            return l;
          })(t, n, i, C(e, a), I(o, s));
        }
        {
          const s = T(e, a),
            o = Ie[s],
            l = i.direction[o] >= 0;
          let c, u;
          l ? ((c = S(e)), (u = M(e, a))) : ((c = M(e, a)), (u = S(e)));
          const h = _e(c, r, i, Ce) ? Me(c, t, n, i) : null;
          if (h) {
            const e = h.point[o];
            if (l ? e <= r[u + s] : e >= r[u + s + 3]) return h;
          }
          const d = _e(u, r, i, Ce) ? Me(u, t, n, i) : null;
          return h && d ? (h.distance <= d.distance ? h : d) : h || d || null;
        }
      }
      const Te = new i.NRn(),
        Be = new W(),
        Re = new W(),
        De = new i.kn4(),
        Pe = new j(),
        Le = new j();
      function Ue(e, t, n, i) {
        K.setBuffer(e._roots[t]);
        const r = Fe(0, e, n, i);
        return K.clearBuffer(), r;
      }
      function Fe(e, t, n, i, r = null) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = K;
        let l = 2 * e;
        null === r &&
          (n.boundingBox || n.computeBoundingBox(),
          Pe.set(n.boundingBox.min, n.boundingBox.max, i),
          (r = Pe));
        if (!w(l, a)) {
          const a = e + 8,
            l = o[e + 6];
          h(a, s, Te);
          if (r.intersectsBox(Te) && Fe(a, t, n, i, r)) return !0;
          h(l, s, Te);
          return !!(r.intersectsBox(Te) && Fe(l, t, n, i, r));
        }
        {
          const r = t.geometry,
            c = r.index,
            u = r.attributes.position,
            d = n.index,
            p = n.attributes.position,
            f = C(e, o),
            A = I(l, a);
          if ((De.copy(i).invert(), n.boundsTree)) {
            h(e, s, Le), Le.matrix.copy(De), (Le.needsUpdate = !0);
            return n.boundsTree.shapecast({
              intersectsBounds: (e) => Le.intersectsBox(e),
              intersectsTriangle: (e) => {
                e.a.applyMatrix4(i),
                  e.b.applyMatrix4(i),
                  e.c.applyMatrix4(i),
                  (e.needsUpdate = !0);
                for (let t = 3 * f, n = 3 * (A + f); t < n; t += 3)
                  if (
                    (me(Re, t, c, u),
                    (Re.needsUpdate = !0),
                    e.intersectsTriangle(Re))
                  )
                    return !0;
                return !1;
              },
            });
          }
          for (let e = 3 * f, t = 3 * (A + f); e < t; e += 3) {
            me(Be, e, c, u),
              Be.a.applyMatrix4(De),
              Be.b.applyMatrix4(De),
              Be.c.applyMatrix4(De),
              (Be.needsUpdate = !0);
            for (let e = 0, t = d.count; e < t; e += 3)
              if (
                (me(Re, e, d, p),
                (Re.needsUpdate = !0),
                Be.intersectsTriangle(Re))
              )
                return !0;
          }
        }
      }
      const Ne = new i.kn4(),
        Oe = new j(),
        Qe = new j(),
        ke = new i.Pq0(),
        Ge = new i.Pq0(),
        He = new i.Pq0(),
        ze = new i.Pq0();
      function Ve(e, t, n, i = {}, r = {}, s = 0, o = 1 / 0) {
        t.boundingBox || t.computeBoundingBox(),
          Oe.set(t.boundingBox.min, t.boundingBox.max, n),
          (Oe.needsUpdate = !0);
        const l = e.geometry,
          c = l.attributes.position,
          u = l.index,
          h = t.attributes.position,
          d = t.index,
          p = X.getPrimitive(),
          f = X.getPrimitive();
        let A = ke,
          g = Ge,
          m = null,
          v = null;
        r && ((m = He), (v = ze));
        let y = 1 / 0,
          x = null,
          _ = null;
        return (
          Ne.copy(n).invert(),
          Qe.matrix.copy(Ne),
          e.shapecast({
            boundsTraverseOrder: (e) => Oe.distanceToBox(e),
            intersectsBounds: (e, t, n) =>
              n < y &&
              n < o &&
              (t &&
                (Qe.min.copy(e.min), Qe.max.copy(e.max), (Qe.needsUpdate = !0)),
              !0),
            intersectsRange: (e, i) => {
              if (t.boundsTree) {
                return t.boundsTree.shapecast({
                  boundsTraverseOrder: (e) => Qe.distanceToBox(e),
                  intersectsBounds: (e, t, n) => n < y && n < o,
                  intersectsRange: (t, r) => {
                    for (let a = t, o = t + r; a < o; a++) {
                      me(f, 3 * a, d, h),
                        f.a.applyMatrix4(n),
                        f.b.applyMatrix4(n),
                        f.c.applyMatrix4(n),
                        (f.needsUpdate = !0);
                      for (let t = e, n = e + i; t < n; t++) {
                        me(p, 3 * t, u, c), (p.needsUpdate = !0);
                        const e = p.distanceToTriangle(f, A, m);
                        if (
                          (e < y &&
                            (g.copy(A),
                            v && v.copy(m),
                            (y = e),
                            (x = t),
                            (_ = a)),
                          e < s)
                        )
                          return !0;
                      }
                    }
                  },
                });
              }
              for (let r = 0, o = a(t); r < o; r++) {
                me(f, 3 * r, d, h),
                  f.a.applyMatrix4(n),
                  f.b.applyMatrix4(n),
                  f.c.applyMatrix4(n),
                  (f.needsUpdate = !0);
                for (let t = e, n = e + i; t < n; t++) {
                  me(p, 3 * t, u, c), (p.needsUpdate = !0);
                  const e = p.distanceToTriangle(f, A, m);
                  if (
                    (e < y &&
                      (g.copy(A), v && v.copy(m), (y = e), (x = t), (_ = r)),
                    e < s)
                  )
                    return !0;
                }
              }
            },
          }),
          X.releasePrimitive(p),
          X.releasePrimitive(f),
          y === 1 / 0
            ? null
            : (i.point ? i.point.copy(g) : (i.point = g.clone()),
              (i.distance = y),
              (i.faceIndex = x),
              r &&
                (r.point ? r.point.copy(v) : (r.point = v.clone()),
                r.point.applyMatrix4(Ne),
                g.applyMatrix4(Ne),
                (r.distance = g.sub(r.point).length()),
                (r.faceIndex = _)),
              i)
        );
      }
      function We(e, t, n, i, r, s, a) {
        const { geometry: o } = n,
          { index: l } = o,
          c = o.attributes.position;
        for (let o = e, u = t + e; o < u; o++) {
          let e;
          if (
            ((e = n.resolveTriangleIndex(o)),
            me(a, 3 * e, l, c),
            (a.needsUpdate = !0),
            i(a, e, r, s))
          )
            return !0;
        }
        return !1;
      }
      function je(e, t = null) {
        t && Array.isArray(t) && (t = new Set(t));
        const n = e.geometry,
          i = n.index ? n.index.array : null,
          r = n.attributes.position;
        let a,
          o,
          l,
          c,
          u = 0;
        const h = e._roots;
        for (let e = 0, t = h.length; e < t; e++)
          (a = h[e]),
            (o = new Uint32Array(a)),
            (l = new Uint16Array(a)),
            (c = new Float32Array(a)),
            d(0, u),
            (u += a.byteLength);
        function d(n, a, u = !1) {
          const h = 2 * n;
          if (l[h + 15] === s.BE) {
            const t = o[n + 6];
            let s = 1 / 0,
              a = 1 / 0,
              u = 1 / 0,
              d = -1 / 0,
              p = -1 / 0,
              f = -1 / 0;
            for (let n = t, o = t + l[h + 14]; n < o; n++) {
              const t = 3 * e.resolveTriangleIndex(n);
              for (let e = 0; e < 3; e++) {
                let n = t + e;
                n = i ? i[n] : n;
                const o = r.getX(n),
                  l = r.getY(n),
                  c = r.getZ(n);
                o < s && (s = o),
                  o > d && (d = o),
                  l < a && (a = l),
                  l > p && (p = l),
                  c < u && (u = c),
                  c > f && (f = c);
              }
            }
            return (
              (c[n + 0] !== s ||
                c[n + 1] !== a ||
                c[n + 2] !== u ||
                c[n + 3] !== d ||
                c[n + 4] !== p ||
                c[n + 5] !== f) &&
              ((c[n + 0] = s),
              (c[n + 1] = a),
              (c[n + 2] = u),
              (c[n + 3] = d),
              (c[n + 4] = p),
              (c[n + 5] = f),
              !0)
            );
          }
          {
            const e = n + 8,
              i = o[n + 6],
              r = e + a,
              s = i + a;
            let l = u,
              h = !1,
              p = !1;
            t
              ? l || ((h = t.has(r)), (p = t.has(s)), (l = !h && !p))
              : ((h = !0), (p = !0));
            const f = l || p;
            let A = !1;
            (l || h) && (A = d(e, a, l));
            let g = !1;
            f && (g = d(i, a, l));
            const m = A || g;
            if (m)
              for (let t = 0; t < 3; t++) {
                const r = e + t,
                  s = i + t,
                  a = c[r],
                  o = c[r + 3],
                  l = c[s],
                  u = c[s + 3];
                (c[n + t] = a < l ? a : l), (c[n + t + 3] = o > u ? o : u);
              }
            return m;
          }
        }
      }
      const qe = new i.Pq0();
      function Ye(e, t, n, i, r) {
        K.setBuffer(e._roots[t]), Xe(0, e, n, i, r), K.clearBuffer();
      }
      function Xe(e, t, n, i, r) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = K,
          l = 2 * e;
        if (w(l, a)) {
          !(function (e, t, n, i, r, s) {
            const { geometry: a, _indirectBuffer: o } = e;
            for (let e = i, l = i + r; e < l; e++) ge(a, t, n, o ? o[e] : e, s);
          })(t, n, i, C(e, o), I(l, a), r);
        } else {
          const a = S(e);
          _e(a, s, i, qe) && Xe(a, t, n, i, r);
          const l = M(e, o);
          _e(l, s, i, qe) && Xe(l, t, n, i, r);
        }
      }
      const Ke = new i.Pq0(),
        Je = ["x", "y", "z"];
      function Ze(e, t, n, i) {
        K.setBuffer(e._roots[t]);
        const r = $e(0, e, n, i);
        return K.clearBuffer(), r;
      }
      function $e(e, t, n, i) {
        const { float32Array: r, uint16Array: s, uint32Array: a } = K;
        let o = 2 * e;
        if (w(o, s)) {
          return (function (e, t, n, i, r) {
            const { geometry: s, _indirectBuffer: a } = e;
            let o = 1 / 0,
              l = null;
            for (let e = i, c = i + r; e < c; e++) {
              let i;
              (i = ge(s, t, n, a ? a[e] : e)),
                i && i.distance < o && ((l = i), (o = i.distance));
            }
            return l;
          })(t, n, i, C(e, a), I(o, s));
        }
        {
          const s = T(e, a),
            o = Je[s],
            l = i.direction[o] >= 0;
          let c, u;
          l ? ((c = S(e)), (u = M(e, a))) : ((c = M(e, a)), (u = S(e)));
          const h = _e(c, r, i, Ke) ? $e(c, t, n, i) : null;
          if (h) {
            const e = h.point[o];
            if (l ? e <= r[u + s] : e >= r[u + s + 3]) return h;
          }
          const d = _e(u, r, i, Ke) ? $e(u, t, n, i) : null;
          return h && d ? (h.distance <= d.distance ? h : d) : h || d || null;
        }
      }
      const et = new i.NRn(),
        tt = new W(),
        nt = new W(),
        it = new i.kn4(),
        rt = new j(),
        st = new j();
      function at(e, t, n, i) {
        K.setBuffer(e._roots[t]);
        const r = ot(0, e, n, i);
        return K.clearBuffer(), r;
      }
      function ot(e, t, n, i, r = null) {
        const { float32Array: s, uint16Array: a, uint32Array: o } = K;
        let l = 2 * e;
        null === r &&
          (n.boundingBox || n.computeBoundingBox(),
          rt.set(n.boundingBox.min, n.boundingBox.max, i),
          (r = rt));
        if (!w(l, a)) {
          const a = e + 8,
            l = o[e + 6];
          h(a, s, et);
          if (r.intersectsBox(et) && ot(a, t, n, i, r)) return !0;
          h(l, s, et);
          return !!(r.intersectsBox(et) && ot(l, t, n, i, r));
        }
        {
          const r = t.geometry,
            c = r.index,
            u = r.attributes.position,
            d = n.index,
            p = n.attributes.position,
            f = C(e, o),
            A = I(l, a);
          if ((it.copy(i).invert(), n.boundsTree)) {
            h(e, s, st), st.matrix.copy(it), (st.needsUpdate = !0);
            return n.boundsTree.shapecast({
              intersectsBounds: (e) => st.intersectsBox(e),
              intersectsTriangle: (e) => {
                e.a.applyMatrix4(i),
                  e.b.applyMatrix4(i),
                  e.c.applyMatrix4(i),
                  (e.needsUpdate = !0);
                for (let n = f, i = A + f; n < i; n++)
                  if (
                    (me(nt, 3 * t.resolveTriangleIndex(n), c, u),
                    (nt.needsUpdate = !0),
                    e.intersectsTriangle(nt))
                  )
                    return !0;
                return !1;
              },
            });
          }
          for (let e = f, n = A + f; e < n; e++) {
            const n = t.resolveTriangleIndex(e);
            me(tt, 3 * n, c, u),
              tt.a.applyMatrix4(it),
              tt.b.applyMatrix4(it),
              tt.c.applyMatrix4(it),
              (tt.needsUpdate = !0);
            for (let e = 0, t = d.count; e < t; e += 3)
              if (
                (me(nt, e, d, p),
                (nt.needsUpdate = !0),
                tt.intersectsTriangle(nt))
              )
                return !0;
          }
        }
      }
      const lt = new i.kn4(),
        ct = new j(),
        ut = new j(),
        ht = new i.Pq0(),
        dt = new i.Pq0(),
        pt = new i.Pq0(),
        ft = new i.Pq0();
      function At(e, t, n, i = {}, r = {}, s = 0, o = 1 / 0) {
        t.boundingBox || t.computeBoundingBox(),
          ct.set(t.boundingBox.min, t.boundingBox.max, n),
          (ct.needsUpdate = !0);
        const l = e.geometry,
          c = l.attributes.position,
          u = l.index,
          h = t.attributes.position,
          d = t.index,
          p = X.getPrimitive(),
          f = X.getPrimitive();
        let A = ht,
          g = dt,
          m = null,
          v = null;
        r && ((m = pt), (v = ft));
        let y = 1 / 0,
          x = null,
          _ = null;
        return (
          lt.copy(n).invert(),
          ut.matrix.copy(lt),
          e.shapecast({
            boundsTraverseOrder: (e) => ct.distanceToBox(e),
            intersectsBounds: (e, t, n) =>
              n < y &&
              n < o &&
              (t &&
                (ut.min.copy(e.min), ut.max.copy(e.max), (ut.needsUpdate = !0)),
              !0),
            intersectsRange: (i, r) => {
              if (t.boundsTree) {
                const a = t.boundsTree;
                return a.shapecast({
                  boundsTraverseOrder: (e) => ut.distanceToBox(e),
                  intersectsBounds: (e, t, n) => n < y && n < o,
                  intersectsRange: (t, o) => {
                    for (let l = t, b = t + o; l < b; l++) {
                      const t = a.resolveTriangleIndex(l);
                      me(f, 3 * t, d, h),
                        f.a.applyMatrix4(n),
                        f.b.applyMatrix4(n),
                        f.c.applyMatrix4(n),
                        (f.needsUpdate = !0);
                      for (let t = i, n = i + r; t < n; t++) {
                        const n = e.resolveTriangleIndex(t);
                        me(p, 3 * n, u, c), (p.needsUpdate = !0);
                        const i = p.distanceToTriangle(f, A, m);
                        if (
                          (i < y &&
                            (g.copy(A),
                            v && v.copy(m),
                            (y = i),
                            (x = t),
                            (_ = l)),
                          i < s)
                        )
                          return !0;
                      }
                    }
                  },
                });
              }
              for (let o = 0, l = a(t); o < l; o++) {
                me(f, 3 * o, d, h),
                  f.a.applyMatrix4(n),
                  f.b.applyMatrix4(n),
                  f.c.applyMatrix4(n),
                  (f.needsUpdate = !0);
                for (let t = i, n = i + r; t < n; t++) {
                  const n = e.resolveTriangleIndex(t);
                  me(p, 3 * n, u, c), (p.needsUpdate = !0);
                  const i = p.distanceToTriangle(f, A, m);
                  if (
                    (i < y &&
                      (g.copy(A), v && v.copy(m), (y = i), (x = t), (_ = o)),
                    i < s)
                  )
                    return !0;
                }
              }
            },
          }),
          X.releasePrimitive(p),
          X.releasePrimitive(f),
          y === 1 / 0
            ? null
            : (i.point ? i.point.copy(g) : (i.point = g.clone()),
              (i.distance = y),
              (i.faceIndex = x),
              r &&
                (r.point ? r.point.copy(v) : (r.point = v.clone()),
                r.point.applyMatrix4(lt),
                g.applyMatrix4(lt),
                (r.distance = g.sub(r.point).length()),
                (r.faceIndex = _)),
              i)
        );
      }
      const gt = new K.constructor(),
        mt = new K.constructor(),
        vt = new q(() => new i.NRn()),
        yt = new i.NRn(),
        xt = new i.NRn(),
        _t = new i.NRn(),
        bt = new i.NRn();
      let Et = !1;
      function wt(e, t, n, i, r, s = 0, a = 0, o = 0, l = 0, c = null, u = !1) {
        let d, p;
        u ? ((d = mt), (p = gt)) : ((d = gt), (p = mt));
        const f = d.float32Array,
          A = d.uint32Array,
          g = d.uint16Array,
          m = p.float32Array,
          v = p.uint32Array,
          y = p.uint16Array,
          x = 2 * t,
          _ = w(2 * e, g),
          b = w(x, y);
        let E = !1;
        if (b && _)
          E = u
            ? r(C(t, v), I(2 * t, y), C(e, A), I(2 * e, g), l, a + t, o, s + e)
            : r(C(e, A), I(2 * e, g), C(t, v), I(2 * t, y), o, s + e, l, a + t);
        else if (b) {
          const c = vt.getPrimitive();
          h(t, m, c), c.applyMatrix4(n);
          const d = S(e),
            p = M(e, A);
          h(d, f, yt), h(p, f, xt);
          const g = c.intersectsBox(yt),
            v = c.intersectsBox(xt);
          (E =
            (g && wt(t, d, i, n, r, a, s, l, o + 1, c, !u)) ||
            (v && wt(t, p, i, n, r, a, s, l, o + 1, c, !u))),
            vt.releasePrimitive(c);
        } else {
          const d = S(t),
            p = M(t, v);
          h(d, m, _t), h(p, m, bt);
          const g = c.intersectsBox(_t),
            y = c.intersectsBox(bt);
          if (g && y)
            E =
              wt(e, d, n, i, r, s, a, o, l + 1, c, u) ||
              wt(e, p, n, i, r, s, a, o, l + 1, c, u);
          else if (g)
            if (_) E = wt(e, d, n, i, r, s, a, o, l + 1, c, u);
            else {
              const t = vt.getPrimitive();
              t.copy(_t).applyMatrix4(n);
              const c = S(e),
                p = M(e, A);
              h(c, f, yt), h(p, f, xt);
              const g = t.intersectsBox(yt),
                m = t.intersectsBox(xt);
              (E =
                (g && wt(d, c, i, n, r, a, s, l, o + 1, t, !u)) ||
                (m && wt(d, p, i, n, r, a, s, l, o + 1, t, !u))),
                vt.releasePrimitive(t);
            }
          else if (y)
            if (_) E = wt(e, p, n, i, r, s, a, o, l + 1, c, u);
            else {
              const t = vt.getPrimitive();
              t.copy(bt).applyMatrix4(n);
              const c = S(e),
                d = M(e, A);
              h(c, f, yt), h(d, f, xt);
              const g = t.intersectsBox(yt),
                m = t.intersectsBox(xt);
              (E =
                (g && wt(p, c, i, n, r, a, s, l, o + 1, t, !u)) ||
                (m && wt(p, d, i, n, r, a, s, l, o + 1, t, !u))),
                vt.releasePrimitive(t);
            }
        }
        return E;
      }
      const Ct = new j(),
        It = new i.NRn(),
        St = {
          strategy: s.Q7,
          maxDepth: 40,
          maxLeafTris: 10,
          useSharedArrayBuffer: !1,
          setBoundingBox: !0,
          onProgress: null,
          indirect: !1,
          verbose: !0,
        };
      class Mt {
        static serialize(e, t = {}) {
          t = { cloneBuffers: !0, ...t };
          const n = e.geometry,
            i = e._roots,
            r = e._indirectBuffer,
            s = n.getIndex();
          let a;
          return (
            (a = t.cloneBuffers
              ? {
                  roots: i.map((e) => e.slice()),
                  index: s.array.slice(),
                  indirectBuffer: r ? r.slice() : null,
                }
              : { roots: i, index: s.array, indirectBuffer: r }),
            a
          );
        }
        static deserialize(e, t, n = {}) {
          n = { setIndex: !0, indirect: Boolean(e.indirectBuffer), ...n };
          const { index: r, roots: a, indirectBuffer: o } = e,
            l = new Mt(t, { ...n, [s.vl]: !0 });
          if (((l._roots = a), (l._indirectBuffer = o || null), n.setIndex)) {
            const n = t.getIndex();
            if (null === n) {
              const n = new i.THS(e.index, 1, !1);
              t.setIndex(n);
            } else n.array !== r && (n.array.set(r), (n.needsUpdate = !0));
          }
          return l;
        }
        get indirect() {
          return !!this._indirectBuffer;
        }
        constructor(e, t = {}) {
          if (!e.isBufferGeometry)
            throw new Error("MeshBVH: Only BufferGeometries are supported.");
          if (e.index && e.index.isInterleavedBufferAttribute)
            throw new Error(
              "MeshBVH: InterleavedBufferAttribute is not supported for the index attribute."
            );
          if (
            (t = Object.assign({ ...St, [s.vl]: !1 }, t))
              .useSharedArrayBuffer &&
            "undefined" == typeof SharedArrayBuffer
          )
            throw new Error("MeshBVH: SharedArrayBuffer is not available.");
          (this.geometry = e),
            (this._roots = null),
            (this._indirectBuffer = null),
            t[s.vl] ||
              (Q(this, t),
              !e.boundingBox &&
                t.setBoundingBox &&
                (e.boundingBox = this.getBoundingBox(new i.NRn())));
          const { _indirectBuffer: n } = this;
          this.resolveTriangleIndex = t.indirect ? (e) => n[e] : (e) => e;
        }
        refit(e = null) {
          return (this.indirect ? je : ye)(this, e);
        }
        traverse(e, t = 0) {
          const n = this._roots[t],
            i = new Uint32Array(n),
            r = new Uint16Array(n);
          !(function t(a, o = 0) {
            const l = 2 * a,
              c = r[l + 15] === s.BE;
            if (c) {
              const t = i[a + 6],
                s = r[l + 14];
              e(o, c, new Float32Array(n, 4 * a, 6), t, s);
            } else {
              const r = a + s.Ne / 4,
                l = i[a + 6],
                u = i[a + 7];
              e(o, c, new Float32Array(n, 4 * a, 6), u) ||
                (t(r, o + 1), t(l, o + 1));
            }
          })(0);
        }
        raycast(e, t = i.hB5) {
          const n = this._roots,
            r = this.geometry,
            s = [],
            a = t.isMaterial,
            o = Array.isArray(t),
            l = r.groups,
            c = a ? t.side : t,
            u = this.indirect ? Ye : Ee;
          for (let i = 0, r = n.length; i < r; i++) {
            const n = o ? t[l[i].materialIndex].side : c,
              r = s.length;
            if ((u(this, i, n, e, s), o)) {
              const e = l[i].materialIndex;
              for (let t = r, n = s.length; t < n; t++)
                s[t].face.materialIndex = e;
            }
          }
          return s;
        }
        raycastFirst(e, t = i.hB5) {
          const n = this._roots,
            r = this.geometry,
            s = t.isMaterial,
            a = Array.isArray(t);
          let o = null;
          const l = r.groups,
            c = s ? t.side : t,
            u = this.indirect ? Ze : Se;
          for (let i = 0, r = n.length; i < r; i++) {
            const n = u(this, i, a ? t[l[i].materialIndex].side : c, e);
            null != n &&
              (null == o || n.distance < o.distance) &&
              ((o = n), a && (n.face.materialIndex = l[i].materialIndex));
          }
          return o;
        }
        intersectsGeometry(e, t) {
          let n = !1;
          const i = this._roots,
            r = this.indirect ? at : Ue;
          for (
            let s = 0, a = i.length;
            s < a && ((n = r(this, s, e, t)), !n);
            s++
          );
          return n;
        }
        shapecast(e) {
          const t = X.getPrimitive(),
            n = this.indirect ? We : ve;
          let {
            boundsTraverseOrder: i,
            intersectsBounds: r,
            intersectsRange: s,
            intersectsTriangle: a,
          } = e;
          if (s && a) {
            const e = s;
            s = (i, r, s, o, l) =>
              !!e(i, r, s, o, l) || n(i, r, this, a, s, o, t);
          } else
            s ||
              (s = a
                ? (e, i, r, s) => n(e, i, this, a, r, s, t)
                : (e, t, n) => n);
          let o = !1,
            l = 0;
          const c = this._roots;
          for (let e = 0, t = c.length; e < t; e++) {
            const t = c[e];
            if (((o = te(this, e, r, s, i, l)), o)) break;
            l += t.byteLength;
          }
          return X.releasePrimitive(t), o;
        }
        bvhcast(e, t, n) {
          let { intersectsRanges: r, intersectsTriangles: s } = n;
          const a = X.getPrimitive(),
            o = this.geometry.index,
            l = this.geometry.attributes.position,
            c = this.indirect
              ? (e) => {
                  const t = this.resolveTriangleIndex(e);
                  me(a, 3 * t, o, l);
                }
              : (e) => {
                  me(a, 3 * e, o, l);
                },
            u = X.getPrimitive(),
            d = e.geometry.index,
            p = e.geometry.attributes.position,
            f = e.indirect
              ? (t) => {
                  const n = e.resolveTriangleIndex(t);
                  me(u, 3 * n, d, p);
                }
              : (e) => {
                  me(u, 3 * e, d, p);
                };
          if (s) {
            const e = (e, n, i, r, o, l, h, d) => {
              for (let p = i, A = i + r; p < A; p++) {
                f(p),
                  u.a.applyMatrix4(t),
                  u.b.applyMatrix4(t),
                  u.c.applyMatrix4(t),
                  (u.needsUpdate = !0);
                for (let t = e, i = e + n; t < i; t++)
                  if ((c(t), (a.needsUpdate = !0), s(a, u, t, p, o, l, h, d)))
                    return !0;
              }
              return !1;
            };
            if (r) {
              const t = r;
              r = function (n, i, r, s, a, o, l, c) {
                return !!t(n, i, r, s, a, o, l, c) || e(n, i, r, s, a, o, l, c);
              };
            } else r = e;
          }
          return (function (e, t, n, r) {
            if (Et)
              throw new Error(
                "MeshBVH: Recursive calls to bvhcast not supported."
              );
            Et = !0;
            const s = e._roots,
              a = t._roots;
            let o,
              l = 0,
              c = 0;
            const u = new i.kn4().copy(n).invert();
            for (let e = 0, t = s.length; e < t; e++) {
              gt.setBuffer(s[e]), (c = 0);
              const t = vt.getPrimitive();
              h(0, gt.float32Array, t), t.applyMatrix4(u);
              for (
                let i = 0, s = a.length;
                i < s &&
                (mt.setBuffer(a[e]),
                (o = wt(0, 0, n, u, r, l, c, 0, 0, t)),
                mt.clearBuffer(),
                (c += a[i].length),
                !o);
                i++
              );
              if (
                (vt.releasePrimitive(t),
                gt.clearBuffer(),
                (l += s[e].length),
                o)
              )
                break;
            }
            return (Et = !1), o;
          })(this, e, t, r);
        }
        intersectsBox(e, t) {
          return (
            Ct.set(e.min, e.max, t),
            (Ct.needsUpdate = !0),
            this.shapecast({
              intersectsBounds: (e) => Ct.intersectsBox(e),
              intersectsTriangle: (e) => Ct.intersectsTriangle(e),
            })
          );
        }
        intersectsSphere(e) {
          return this.shapecast({
            intersectsBounds: (t) => e.intersectsBox(t),
            intersectsTriangle: (t) => t.intersectsSphere(e),
          });
        }
        closestPointToGeometry(e, t, n = {}, i = {}, r = 0, s = 1 / 0) {
          return (this.indirect ? At : Ve)(this, e, t, n, i, r, s);
        }
        closestPointToPoint(e, t = {}, n = 0, i = 1 / 0) {
          return (function (e, t, n = {}, i = 0, r = 1 / 0) {
            const s = i * i,
              a = r * r;
            let o = 1 / 0,
              l = null;
            if (
              (e.shapecast({
                boundsTraverseOrder: (e) => (
                  ie.copy(t).clamp(e.min, e.max), ie.distanceToSquared(t)
                ),
                intersectsBounds: (e, t, n) => n < o && n < a,
                intersectsTriangle: (e, n) => {
                  e.closestPointToPoint(t, ie);
                  const i = t.distanceToSquared(ie);
                  return i < o && (re.copy(ie), (o = i), (l = n)), i < s;
                },
              }),
              o === 1 / 0)
            )
              return null;
            const c = Math.sqrt(o);
            return (
              n.point ? n.point.copy(re) : (n.point = re.clone()),
              (n.distance = c),
              (n.faceIndex = l),
              n
            );
          })(this, e, t, n, i);
        }
        getBoundingBox(e) {
          e.makeEmpty();
          return (
            this._roots.forEach((t) => {
              h(0, new Float32Array(t), It), e.union(It);
            }),
            e
          );
        }
      }
      const Tt = new i.RlV(),
        Bt = new i.kn4(),
        Rt = i.eaF.prototype.raycast;
      function Dt(e, t) {
        if (this.geometry.boundsTree) {
          if (void 0 === this.material) return;
          Bt.copy(this.matrixWorld).invert(), Tt.copy(e.ray).applyMatrix4(Bt);
          const n = this.geometry.boundsTree;
          if (!0 === e.firstHitOnly) {
            const i = r(n.raycastFirst(Tt, this.material), this, e);
            i && t.push(i);
          } else {
            const i = n.raycast(Tt, this.material);
            for (let n = 0, s = i.length; n < s; n++) {
              const s = r(i[n], this, e);
              s && t.push(s);
            }
          }
        } else Rt.call(this, e, t);
      }
      function Pt(e) {
        return (this.boundsTree = new Mt(this, e)), this.boundsTree;
      }
      function Lt() {
        this.boundsTree = null;
      }
    },
    5062: (e, t, n) => {
      "use strict";
      n.d(t, {
        $EB: () => c,
        $Kf: () => zo,
        $_I: () => W,
        $p8: () => tu,
        A$4: () => Hi,
        B69: () => ui,
        BH$: () => ml,
        BKk: () => mr,
        BRH: () => Qc,
        BXX: () => ye,
        BdL: () => os,
        CSG: () => lo,
        CVz: () => we,
        Cfg: () => H,
        DXC: () => Al,
        EAD: () => qo,
        FCc: () => gl,
        Fn: () => Ge,
        FvD: () => Cl,
        G3T: () => Ye,
        GJx: () => N,
        GWd: () => ae,
        GYF: () => Vo,
        G_z: () => hc,
        Gu$: () => sc,
        Gwm: () => m,
        GxU: () => Oi,
        HXV: () => be,
        HiM: () => Zc,
        Hit: () => wc,
        Ho_: () => Tl,
        I46: () => Ho,
        I9Y: () => Rt,
        IUQ: () => en,
        Ipv: () => Ml,
        Iw4: () => gu,
        JeP: () => So,
        K52: () => v,
        KDk: () => Ie,
        KLL: () => dt,
        KPJ: () => Dc,
        Ke9: () => nt,
        Kzg: () => iu,
        Kzv: () => oe,
        LlO: () => gr,
        LoY: () => Zi,
        MBL: () => Ic,
        N1A: () => hl,
        N5j: () => ot,
        NRn: () => un,
        Nv2: () => wl,
        Nwf: () => pu,
        Nz6: () => me,
        O3Y: () => ac,
        O49: () => rt,
        O9p: () => qn,
        ONl: () => bl,
        OUM: () => j,
        PJ3: () => Je,
        PPD: () => Pr,
        PTz: () => an,
        Pq0: () => on,
        Q1f: () => Ti,
        Qev: () => yt,
        Qrf: () => Re,
        RJ4: () => it,
        RQf: () => Z,
        RiT: () => Mc,
        Riy: () => Ce,
        Rkk: () => at,
        RlV: () => Fn,
        THS: () => Gi,
        Tap: () => kc,
        U3G: () => g,
        UtB: () => Eu,
        V3x: () => ne,
        V9B: () => Pi,
        VCu: () => xs,
        VT0: () => he,
        VxR: () => ht,
        W9U: () => ze,
        Wk7: () => s,
        XIg: () => u,
        Y9S: () => Nc,
        YJl: () => vo,
        Z58: () => To,
        ZLX: () => nl,
        Zcv: () => Br,
        Zr2: () => ut,
        ZyN: () => eu,
        _4j: () => oc,
        aHM: () => Lc,
        aMy: () => Xe,
        bdM: () => Fr,
        bkx: () => J,
        brA: () => f,
        bw0: () => y,
        c5h: () => Sl,
        cZY: () => Iu,
        cj9: () => Bt,
        dYF: () => sn,
        dcC: () => ue,
        dwI: () => Dt,
        eB$: () => Bo,
        eHc: () => d,
        eHs: () => Do,
        eaF: () => ur,
        er$: () => ct,
        fCn: () => Or,
        gPd: () => $t,
        ghU: () => O,
        hB5: () => o,
        hsX: () => l,
        hxR: () => k,
        i7d: () => vr,
        iNn: () => dr,
        iOZ: () => Il,
        imn: () => Di,
        ix0: () => $,
        iyt: () => Mn,
        jUj: () => Mo,
        jf0: () => lt,
        k6Q: () => xe,
        k6q: () => z,
        kRr: () => V,
        kTW: () => Q,
        kn4: () => Nn,
        lGu: () => p,
        lGw: () => mc,
        lMl: () => wi,
        ljd: () => Ke,
        mrM: () => il,
        nCl: () => qc,
        nWS: () => nn,
        nc$: () => mu,
        pHI: () => G,
        paN: () => pe,
        ppV: () => Qt,
        qBx: () => uc,
        qFE: () => Bl,
        qUd: () => Xr,
        qa3: () => Se,
        qtW: () => Vi,
        r6x: () => nu,
        rYR: () => st,
        sPf: () => i,
        tBo: () => yu,
        tXL: () => cc,
        tz3: () => Tc,
        uSd: () => lc,
        uV5: () => U,
        uWO: () => Yo,
        ubm: () => br,
        wfO: () => L,
        xJ6: () => nc,
        xSv: () => A,
        zD7: () => ru,
      });
      const i = "170",
        r = 1,
        s = 2,
        a = 3,
        o = 0,
        l = 1,
        c = 2,
        u = 0,
        h = 100,
        d = 0,
        p = 1,
        f = 2,
        A = 3,
        g = 4,
        m = 5,
        v = 6,
        y = 7,
        x = 0,
        _ = 1,
        b = 2,
        E = 0,
        w = 1,
        C = 2,
        I = 3,
        S = 4,
        M = 5,
        T = 6,
        B = 7,
        R = "attached",
        D = 301,
        P = 302,
        L = 303,
        U = 304,
        F = 306,
        N = 1e3,
        O = 1001,
        Q = 1002,
        k = 1003,
        G = 1004,
        H = 1005,
        z = 1006,
        V = 1007,
        W = 1008,
        j = 1009,
        q = 1010,
        Y = 1011,
        X = 1012,
        K = 1013,
        J = 1014,
        Z = 1015,
        $ = 1016,
        ee = 1017,
        te = 1018,
        ne = 1020,
        ie = 35902,
        re = 1021,
        se = 1022,
        ae = 1023,
        oe = 1024,
        le = 1025,
        ce = 1026,
        ue = 1027,
        he = 1028,
        de = 1029,
        pe = 1030,
        fe = 1031,
        Ae = 1033,
        ge = 33776,
        me = 33777,
        ve = 33778,
        ye = 33779,
        xe = 35840,
        _e = 35841,
        be = 35842,
        Ee = 35843,
        we = 36196,
        Ce = 37492,
        Ie = 37496,
        Se = 37808,
        Me = 37809,
        Te = 37810,
        Be = 37811,
        Re = 37812,
        De = 37813,
        Pe = 37814,
        Le = 37815,
        Ue = 37816,
        Fe = 37817,
        Ne = 37818,
        Oe = 37819,
        Qe = 37820,
        ke = 37821,
        Ge = 36492,
        He = 36494,
        ze = 36495,
        Ve = 36283,
        We = 36284,
        je = 36285,
        qe = 36286,
        Ye = 2200,
        Xe = 2201,
        Ke = 2300,
        Je = 2301,
        Ze = 2302,
        $e = 2400,
        et = 2401,
        tt = 2402,
        nt = 2500,
        it = 0,
        rt = 1,
        st = 2,
        at = 3200,
        ot = 3201,
        lt = "",
        ct = "srgb",
        ut = "srgb-linear",
        ht = "linear",
        dt = "srgb",
        pt = 7680,
        ft = 515,
        At = 35044,
        gt = "300 es",
        mt = 2e3,
        vt = 2001;
      class yt {
        addEventListener(e, t) {
          void 0 === this._listeners && (this._listeners = {});
          const n = this._listeners;
          void 0 === n[e] && (n[e] = []),
            -1 === n[e].indexOf(t) && n[e].push(t);
        }
        hasEventListener(e, t) {
          if (void 0 === this._listeners) return !1;
          const n = this._listeners;
          return void 0 !== n[e] && -1 !== n[e].indexOf(t);
        }
        removeEventListener(e, t) {
          if (void 0 === this._listeners) return;
          const n = this._listeners[e];
          if (void 0 !== n) {
            const e = n.indexOf(t);
            -1 !== e && n.splice(e, 1);
          }
        }
        dispatchEvent(e) {
          if (void 0 === this._listeners) return;
          const t = this._listeners[e.type];
          if (void 0 !== t) {
            e.target = this;
            const n = t.slice(0);
            for (let t = 0, i = n.length; t < i; t++) n[t].call(this, e);
            e.target = null;
          }
        }
      }
      const xt = [
        "00",
        "01",
        "02",
        "03",
        "04",
        "05",
        "06",
        "07",
        "08",
        "09",
        "0a",
        "0b",
        "0c",
        "0d",
        "0e",
        "0f",
        "10",
        "11",
        "12",
        "13",
        "14",
        "15",
        "16",
        "17",
        "18",
        "19",
        "1a",
        "1b",
        "1c",
        "1d",
        "1e",
        "1f",
        "20",
        "21",
        "22",
        "23",
        "24",
        "25",
        "26",
        "27",
        "28",
        "29",
        "2a",
        "2b",
        "2c",
        "2d",
        "2e",
        "2f",
        "30",
        "31",
        "32",
        "33",
        "34",
        "35",
        "36",
        "37",
        "38",
        "39",
        "3a",
        "3b",
        "3c",
        "3d",
        "3e",
        "3f",
        "40",
        "41",
        "42",
        "43",
        "44",
        "45",
        "46",
        "47",
        "48",
        "49",
        "4a",
        "4b",
        "4c",
        "4d",
        "4e",
        "4f",
        "50",
        "51",
        "52",
        "53",
        "54",
        "55",
        "56",
        "57",
        "58",
        "59",
        "5a",
        "5b",
        "5c",
        "5d",
        "5e",
        "5f",
        "60",
        "61",
        "62",
        "63",
        "64",
        "65",
        "66",
        "67",
        "68",
        "69",
        "6a",
        "6b",
        "6c",
        "6d",
        "6e",
        "6f",
        "70",
        "71",
        "72",
        "73",
        "74",
        "75",
        "76",
        "77",
        "78",
        "79",
        "7a",
        "7b",
        "7c",
        "7d",
        "7e",
        "7f",
        "80",
        "81",
        "82",
        "83",
        "84",
        "85",
        "86",
        "87",
        "88",
        "89",
        "8a",
        "8b",
        "8c",
        "8d",
        "8e",
        "8f",
        "90",
        "91",
        "92",
        "93",
        "94",
        "95",
        "96",
        "97",
        "98",
        "99",
        "9a",
        "9b",
        "9c",
        "9d",
        "9e",
        "9f",
        "a0",
        "a1",
        "a2",
        "a3",
        "a4",
        "a5",
        "a6",
        "a7",
        "a8",
        "a9",
        "aa",
        "ab",
        "ac",
        "ad",
        "ae",
        "af",
        "b0",
        "b1",
        "b2",
        "b3",
        "b4",
        "b5",
        "b6",
        "b7",
        "b8",
        "b9",
        "ba",
        "bb",
        "bc",
        "bd",
        "be",
        "bf",
        "c0",
        "c1",
        "c2",
        "c3",
        "c4",
        "c5",
        "c6",
        "c7",
        "c8",
        "c9",
        "ca",
        "cb",
        "cc",
        "cd",
        "ce",
        "cf",
        "d0",
        "d1",
        "d2",
        "d3",
        "d4",
        "d5",
        "d6",
        "d7",
        "d8",
        "d9",
        "da",
        "db",
        "dc",
        "dd",
        "de",
        "df",
        "e0",
        "e1",
        "e2",
        "e3",
        "e4",
        "e5",
        "e6",
        "e7",
        "e8",
        "e9",
        "ea",
        "eb",
        "ec",
        "ed",
        "ee",
        "ef",
        "f0",
        "f1",
        "f2",
        "f3",
        "f4",
        "f5",
        "f6",
        "f7",
        "f8",
        "f9",
        "fa",
        "fb",
        "fc",
        "fd",
        "fe",
        "ff",
      ];
      let _t = 1234567;
      const bt = Math.PI / 180,
        Et = 180 / Math.PI;
      function wt() {
        const e = (4294967295 * Math.random()) | 0,
          t = (4294967295 * Math.random()) | 0,
          n = (4294967295 * Math.random()) | 0,
          i = (4294967295 * Math.random()) | 0;
        return (
          xt[255 & e] +
          xt[(e >> 8) & 255] +
          xt[(e >> 16) & 255] +
          xt[(e >> 24) & 255] +
          "-" +
          xt[255 & t] +
          xt[(t >> 8) & 255] +
          "-" +
          xt[((t >> 16) & 15) | 64] +
          xt[(t >> 24) & 255] +
          "-" +
          xt[(63 & n) | 128] +
          xt[(n >> 8) & 255] +
          "-" +
          xt[(n >> 16) & 255] +
          xt[(n >> 24) & 255] +
          xt[255 & i] +
          xt[(i >> 8) & 255] +
          xt[(i >> 16) & 255] +
          xt[(i >> 24) & 255]
        ).toLowerCase();
      }
      function Ct(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
      function It(e, t) {
        return ((e % t) + t) % t;
      }
      function St(e, t, n) {
        return (1 - n) * e + n * t;
      }
      function Mt(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return e / 4294967295;
          case Uint16Array:
            return e / 65535;
          case Uint8Array:
            return e / 255;
          case Int32Array:
            return Math.max(e / 2147483647, -1);
          case Int16Array:
            return Math.max(e / 32767, -1);
          case Int8Array:
            return Math.max(e / 127, -1);
          default:
            throw new Error("Invalid component type.");
        }
      }
      function Tt(e, t) {
        switch (t.constructor) {
          case Float32Array:
            return e;
          case Uint32Array:
            return Math.round(4294967295 * e);
          case Uint16Array:
            return Math.round(65535 * e);
          case Uint8Array:
            return Math.round(255 * e);
          case Int32Array:
            return Math.round(2147483647 * e);
          case Int16Array:
            return Math.round(32767 * e);
          case Int8Array:
            return Math.round(127 * e);
          default:
            throw new Error("Invalid component type.");
        }
      }
      const Bt = {
        DEG2RAD: bt,
        RAD2DEG: Et,
        generateUUID: wt,
        clamp: Ct,
        euclideanModulo: It,
        mapLinear: function (e, t, n, i, r) {
          return i + ((e - t) * (r - i)) / (n - t);
        },
        inverseLerp: function (e, t, n) {
          return e !== t ? (n - e) / (t - e) : 0;
        },
        lerp: St,
        damp: function (e, t, n, i) {
          return St(e, t, 1 - Math.exp(-n * i));
        },
        pingpong: function (e, t = 1) {
          return t - Math.abs(It(e, 2 * t) - t);
        },
        smoothstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * (3 - 2 * e);
        },
        smootherstep: function (e, t, n) {
          return e <= t
            ? 0
            : e >= n
            ? 1
            : (e = (e - t) / (n - t)) * e * e * (e * (6 * e - 15) + 10);
        },
        randInt: function (e, t) {
          return e + Math.floor(Math.random() * (t - e + 1));
        },
        randFloat: function (e, t) {
          return e + Math.random() * (t - e);
        },
        randFloatSpread: function (e) {
          return e * (0.5 - Math.random());
        },
        seededRandom: function (e) {
          void 0 !== e && (_t = e);
          let t = (_t += 1831565813);
          return (
            (t = Math.imul(t ^ (t >>> 15), 1 | t)),
            (t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)),
            ((t ^ (t >>> 14)) >>> 0) / 4294967296
          );
        },
        degToRad: function (e) {
          return e * bt;
        },
        radToDeg: function (e) {
          return e * Et;
        },
        isPowerOfTwo: function (e) {
          return !(e & (e - 1)) && 0 !== e;
        },
        ceilPowerOfTwo: function (e) {
          return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
        },
        floorPowerOfTwo: function (e) {
          return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
        },
        setQuaternionFromProperEuler: function (e, t, n, i, r) {
          const s = Math.cos,
            a = Math.sin,
            o = s(n / 2),
            l = a(n / 2),
            c = s((t + i) / 2),
            u = a((t + i) / 2),
            h = s((t - i) / 2),
            d = a((t - i) / 2),
            p = s((i - t) / 2),
            f = a((i - t) / 2);
          switch (r) {
            case "XYX":
              e.set(o * u, l * h, l * d, o * c);
              break;
            case "YZY":
              e.set(l * d, o * u, l * h, o * c);
              break;
            case "ZXZ":
              e.set(l * h, l * d, o * u, o * c);
              break;
            case "XZX":
              e.set(o * u, l * f, l * p, o * c);
              break;
            case "YXY":
              e.set(l * p, o * u, l * f, o * c);
              break;
            case "ZYZ":
              e.set(l * f, l * p, o * u, o * c);
              break;
            default:
              console.warn(
                "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
                  r
              );
          }
        },
        normalize: Tt,
        denormalize: Mt,
      };
      class Rt {
        constructor(e = 0, t = 0) {
          (Rt.prototype.isVector2 = !0), (this.x = e), (this.y = t);
        }
        get width() {
          return this.x;
        }
        set width(e) {
          this.x = e;
        }
        get height() {
          return this.y;
        }
        set height(e) {
          this.y = e;
        }
        set(e, t) {
          return (this.x = e), (this.y = t), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), this;
        }
        addVectors(e, t) {
          return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
        }
        addScaledVector(e, t) {
          return (this.x += e.x * t), (this.y += e.y * t), this;
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), this;
        }
        subVectors(e, t) {
          return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), this;
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = e.elements;
          return (
            (this.x = i[0] * t + i[3] * n + i[6]),
            (this.y = i[1] * t + i[4] * n + i[7]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this
          );
        }
        negate() {
          return (this.x = -this.x), (this.y = -this.y), this;
        }
        dot(e) {
          return this.x * e.x + this.y * e.y;
        }
        cross(e) {
          return this.x * e.y - this.y * e.x;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        angle() {
          return Math.atan2(-this.y, -this.x) + Math.PI;
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(Ct(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y;
          return t * t + n * n;
        }
        manhattanDistanceTo(e) {
          return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            this
          );
        }
        equals(e) {
          return e.x === this.x && e.y === this.y;
        }
        fromArray(e, t = 0) {
          return (this.x = e[t]), (this.y = e[t + 1]), this;
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), e;
        }
        fromBufferAttribute(e, t) {
          return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
        }
        rotateAround(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = this.x - e.x,
            s = this.y - e.y;
          return (
            (this.x = r * n - s * i + e.x), (this.y = r * i + s * n + e.y), this
          );
        }
        random() {
          return (this.x = Math.random()), (this.y = Math.random()), this;
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y;
        }
      }
      class Dt {
        constructor(e, t, n, i, r, s, a, o, l) {
          (Dt.prototype.isMatrix3 = !0),
            (this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            void 0 !== e && this.set(e, t, n, i, r, s, a, o, l);
        }
        set(e, t, n, i, r, s, a, o, l) {
          const c = this.elements;
          return (
            (c[0] = e),
            (c[1] = i),
            (c[2] = a),
            (c[3] = t),
            (c[4] = r),
            (c[5] = o),
            (c[6] = n),
            (c[7] = s),
            (c[8] = l),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this;
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrix3Column(this, 0),
            t.setFromMatrix3Column(this, 1),
            n.setFromMatrix3Column(this, 2),
            this
          );
        }
        setFromMatrix4(e) {
          const t = e.elements;
          return (
            this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[3],
            o = n[6],
            l = n[1],
            c = n[4],
            u = n[7],
            h = n[2],
            d = n[5],
            p = n[8],
            f = i[0],
            A = i[3],
            g = i[6],
            m = i[1],
            v = i[4],
            y = i[7],
            x = i[2],
            _ = i[5],
            b = i[8];
          return (
            (r[0] = s * f + a * m + o * x),
            (r[3] = s * A + a * v + o * _),
            (r[6] = s * g + a * y + o * b),
            (r[1] = l * f + c * m + u * x),
            (r[4] = l * A + c * v + u * _),
            (r[7] = l * g + c * y + u * b),
            (r[2] = h * f + d * m + p * x),
            (r[5] = h * A + d * v + p * _),
            (r[8] = h * g + d * y + p * b),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[3] *= e),
            (t[6] *= e),
            (t[1] *= e),
            (t[4] *= e),
            (t[7] *= e),
            (t[2] *= e),
            (t[5] *= e),
            (t[8] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8];
          return (
            t * s * c -
            t * a * l -
            n * r * c +
            n * a * o +
            i * r * l -
            i * s * o
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8],
            u = c * s - a * l,
            h = a * o - c * r,
            d = l * r - s * o,
            p = t * u + n * h + i * d;
          if (0 === p) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
          const f = 1 / p;
          return (
            (e[0] = u * f),
            (e[1] = (i * l - c * n) * f),
            (e[2] = (a * n - i * s) * f),
            (e[3] = h * f),
            (e[4] = (c * t - i * o) * f),
            (e[5] = (i * r - a * t) * f),
            (e[6] = d * f),
            (e[7] = (n * o - l * t) * f),
            (e[8] = (s * t - n * r) * f),
            this
          );
        }
        transpose() {
          let e;
          const t = this.elements;
          return (
            (e = t[1]),
            (t[1] = t[3]),
            (t[3] = e),
            (e = t[2]),
            (t[2] = t[6]),
            (t[6] = e),
            (e = t[5]),
            (t[5] = t[7]),
            (t[7] = e),
            this
          );
        }
        getNormalMatrix(e) {
          return this.setFromMatrix4(e).invert().transpose();
        }
        transposeIntoArray(e) {
          const t = this.elements;
          return (
            (e[0] = t[0]),
            (e[1] = t[3]),
            (e[2] = t[6]),
            (e[3] = t[1]),
            (e[4] = t[4]),
            (e[5] = t[7]),
            (e[6] = t[2]),
            (e[7] = t[5]),
            (e[8] = t[8]),
            this
          );
        }
        setUvTransform(e, t, n, i, r, s, a) {
          const o = Math.cos(r),
            l = Math.sin(r);
          return (
            this.set(
              n * o,
              n * l,
              -n * (o * s + l * a) + s + e,
              -i * l,
              i * o,
              -i * (-l * s + o * a) + a + t,
              0,
              0,
              1
            ),
            this
          );
        }
        scale(e, t) {
          return this.premultiply(Pt.makeScale(e, t)), this;
        }
        rotate(e) {
          return this.premultiply(Pt.makeRotation(-e)), this;
        }
        translate(e, t) {
          return this.premultiply(Pt.makeTranslation(e, t)), this;
        }
        makeTranslation(e, t) {
          return (
            e.isVector2
              ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1)
              : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
            this
          );
        }
        makeRotation(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this;
        }
        makeScale(e, t) {
          return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this;
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 9; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            e
          );
        }
        clone() {
          return new this.constructor().fromArray(this.elements);
        }
      }
      const Pt = new Dt();
      function Lt(e) {
        for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
        return !1;
      }
      Int8Array,
        Uint8Array,
        Uint8ClampedArray,
        Int16Array,
        Uint16Array,
        Int32Array,
        Uint32Array,
        Float32Array,
        Float64Array;
      function Ut(e) {
        return document.createElementNS("http://www.w3.org/1999/xhtml", e);
      }
      function Ft() {
        const e = Ut("canvas");
        return (e.style.display = "block"), e;
      }
      const Nt = {};
      function Ot(e) {
        e in Nt || ((Nt[e] = !0), console.warn(e));
      }
      const Qt = {
        enabled: !0,
        workingColorSpace: ut,
        spaces: {},
        convert: function (e, t, n) {
          return !1 !== this.enabled && t !== n && t && n
            ? (this.spaces[t].transfer === dt &&
                ((e.r = kt(e.r)), (e.g = kt(e.g)), (e.b = kt(e.b))),
              this.spaces[t].primaries !== this.spaces[n].primaries &&
                (e.applyMatrix3(this.spaces[t].toXYZ),
                e.applyMatrix3(this.spaces[n].fromXYZ)),
              this.spaces[n].transfer === dt &&
                ((e.r = Gt(e.r)), (e.g = Gt(e.g)), (e.b = Gt(e.b))),
              e)
            : e;
        },
        fromWorkingColorSpace: function (e, t) {
          return this.convert(e, this.workingColorSpace, t);
        },
        toWorkingColorSpace: function (e, t) {
          return this.convert(e, t, this.workingColorSpace);
        },
        getPrimaries: function (e) {
          return this.spaces[e].primaries;
        },
        getTransfer: function (e) {
          return e === lt ? ht : this.spaces[e].transfer;
        },
        getLuminanceCoefficients: function (e, t = this.workingColorSpace) {
          return e.fromArray(this.spaces[t].luminanceCoefficients);
        },
        define: function (e) {
          Object.assign(this.spaces, e);
        },
        _getMatrix: function (e, t, n) {
          return e.copy(this.spaces[t].toXYZ).multiply(this.spaces[n].fromXYZ);
        },
        _getDrawingBufferColorSpace: function (e) {
          return this.spaces[e].outputColorSpaceConfig.drawingBufferColorSpace;
        },
        _getUnpackColorSpace: function (e = this.workingColorSpace) {
          return this.spaces[e].workingColorSpaceConfig.unpackColorSpace;
        },
      };
      function kt(e) {
        return e < 0.04045
          ? 0.0773993808 * e
          : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
      }
      function Gt(e) {
        return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
      }
      const Ht = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06],
        zt = [0.2126, 0.7152, 0.0722],
        Vt = [0.3127, 0.329],
        Wt = new Dt().set(
          0.4123908,
          0.3575843,
          0.1804808,
          0.212639,
          0.7151687,
          0.0721923,
          0.0193308,
          0.1191948,
          0.9505322
        ),
        jt = new Dt().set(
          3.2409699,
          -1.5373832,
          -0.4986108,
          -0.9692436,
          1.8759675,
          0.0415551,
          0.0556301,
          -0.203977,
          1.0569715
        );
      let qt;
      Qt.define({
        [ut]: {
          primaries: Ht,
          whitePoint: Vt,
          transfer: ht,
          toXYZ: Wt,
          fromXYZ: jt,
          luminanceCoefficients: zt,
          workingColorSpaceConfig: { unpackColorSpace: ct },
          outputColorSpaceConfig: { drawingBufferColorSpace: ct },
        },
        [ct]: {
          primaries: Ht,
          whitePoint: Vt,
          transfer: dt,
          toXYZ: Wt,
          fromXYZ: jt,
          luminanceCoefficients: zt,
          outputColorSpaceConfig: { drawingBufferColorSpace: ct },
        },
      });
      class Yt {
        static getDataURL(e) {
          if (/^data:/i.test(e.src)) return e.src;
          if ("undefined" == typeof HTMLCanvasElement) return e.src;
          let t;
          if (e instanceof HTMLCanvasElement) t = e;
          else {
            void 0 === qt && (qt = Ut("canvas")),
              (qt.width = e.width),
              (qt.height = e.height);
            const n = qt.getContext("2d");
            e instanceof ImageData
              ? n.putImageData(e, 0, 0)
              : n.drawImage(e, 0, 0, e.width, e.height),
              (t = qt);
          }
          return t.width > 2048 || t.height > 2048
            ? (console.warn(
                "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
                e
              ),
              t.toDataURL("image/jpeg", 0.6))
            : t.toDataURL("image/png");
        }
        static sRGBToLinear(e) {
          if (
            ("undefined" != typeof HTMLImageElement &&
              e instanceof HTMLImageElement) ||
            ("undefined" != typeof HTMLCanvasElement &&
              e instanceof HTMLCanvasElement) ||
            ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ) {
            const t = Ut("canvas");
            (t.width = e.width), (t.height = e.height);
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
              r = i.data;
            for (let e = 0; e < r.length; e++) r[e] = 255 * kt(r[e] / 255);
            return n.putImageData(i, 0, 0), t;
          }
          if (e.data) {
            const t = e.data.slice(0);
            for (let e = 0; e < t.length; e++)
              t instanceof Uint8Array || t instanceof Uint8ClampedArray
                ? (t[e] = Math.floor(255 * kt(t[e] / 255)))
                : (t[e] = kt(t[e]));
            return { data: t, width: e.width, height: e.height };
          }
          return (
            console.warn(
              "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
            ),
            e
          );
        }
      }
      let Xt = 0;
      class Kt {
        constructor(e = null) {
          (this.isSource = !0),
            Object.defineProperty(this, "id", { value: Xt++ }),
            (this.uuid = wt()),
            (this.data = e),
            (this.dataReady = !0),
            (this.version = 0);
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.images[this.uuid]) return e.images[this.uuid];
          const n = { uuid: this.uuid, url: "" },
            i = this.data;
          if (null !== i) {
            let e;
            if (Array.isArray(i)) {
              e = [];
              for (let t = 0, n = i.length; t < n; t++)
                i[t].isDataTexture ? e.push(Jt(i[t].image)) : e.push(Jt(i[t]));
            } else e = Jt(i);
            n.url = e;
          }
          return t || (e.images[this.uuid] = n), n;
        }
      }
      function Jt(e) {
        return ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
          ("undefined" != typeof HTMLCanvasElement &&
            e instanceof HTMLCanvasElement) ||
          ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
          ? Yt.getDataURL(e)
          : e.data
          ? {
              data: Array.from(e.data),
              width: e.width,
              height: e.height,
              type: e.data.constructor.name,
            }
          : (console.warn("THREE.Texture: Unable to serialize Texture."), {});
      }
      let Zt = 0;
      class $t extends yt {
        constructor(
          e = $t.DEFAULT_IMAGE,
          t = $t.DEFAULT_MAPPING,
          n = O,
          i = O,
          r = z,
          s = W,
          a = ae,
          o = j,
          l = $t.DEFAULT_ANISOTROPY,
          c = lt
        ) {
          super(),
            (this.isTexture = !0),
            Object.defineProperty(this, "id", { value: Zt++ }),
            (this.uuid = wt()),
            (this.name = ""),
            (this.source = new Kt(e)),
            (this.mipmaps = []),
            (this.mapping = t),
            (this.channel = 0),
            (this.wrapS = n),
            (this.wrapT = i),
            (this.magFilter = r),
            (this.minFilter = s),
            (this.anisotropy = l),
            (this.format = a),
            (this.internalFormat = null),
            (this.type = o),
            (this.offset = new Rt(0, 0)),
            (this.repeat = new Rt(1, 1)),
            (this.center = new Rt(0, 0)),
            (this.rotation = 0),
            (this.matrixAutoUpdate = !0),
            (this.matrix = new Dt()),
            (this.generateMipmaps = !0),
            (this.premultiplyAlpha = !1),
            (this.flipY = !0),
            (this.unpackAlignment = 4),
            (this.colorSpace = c),
            (this.userData = {}),
            (this.version = 0),
            (this.onUpdate = null),
            (this.isRenderTargetTexture = !1),
            (this.pmremVersion = 0);
        }
        get image() {
          return this.source.data;
        }
        set image(e = null) {
          this.source.data = e;
        }
        updateMatrix() {
          this.matrix.setUvTransform(
            this.offset.x,
            this.offset.y,
            this.repeat.x,
            this.repeat.y,
            this.rotation,
            this.center.x,
            this.center.y
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.source = e.source),
            (this.mipmaps = e.mipmaps.slice(0)),
            (this.mapping = e.mapping),
            (this.channel = e.channel),
            (this.wrapS = e.wrapS),
            (this.wrapT = e.wrapT),
            (this.magFilter = e.magFilter),
            (this.minFilter = e.minFilter),
            (this.anisotropy = e.anisotropy),
            (this.format = e.format),
            (this.internalFormat = e.internalFormat),
            (this.type = e.type),
            this.offset.copy(e.offset),
            this.repeat.copy(e.repeat),
            this.center.copy(e.center),
            (this.rotation = e.rotation),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this.matrix.copy(e.matrix),
            (this.generateMipmaps = e.generateMipmaps),
            (this.premultiplyAlpha = e.premultiplyAlpha),
            (this.flipY = e.flipY),
            (this.unpackAlignment = e.unpackAlignment),
            (this.colorSpace = e.colorSpace),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            (this.needsUpdate = !0),
            this
          );
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          if (!t && void 0 !== e.textures[this.uuid])
            return e.textures[this.uuid];
          const n = {
            metadata: {
              version: 4.6,
              type: "Texture",
              generator: "Texture.toJSON",
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment,
          };
          return (
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            t || (e.textures[this.uuid] = n),
            n
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        transformUv(e) {
          if (300 !== this.mapping) return e;
          if ((e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1))
            switch (this.wrapS) {
              case N:
                e.x = e.x - Math.floor(e.x);
                break;
              case O:
                e.x = e.x < 0 ? 0 : 1;
                break;
              case Q:
                1 === Math.abs(Math.floor(e.x) % 2)
                  ? (e.x = Math.ceil(e.x) - e.x)
                  : (e.x = e.x - Math.floor(e.x));
            }
          if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
              case N:
                e.y = e.y - Math.floor(e.y);
                break;
              case O:
                e.y = e.y < 0 ? 0 : 1;
                break;
              case Q:
                1 === Math.abs(Math.floor(e.y) % 2)
                  ? (e.y = Math.ceil(e.y) - e.y)
                  : (e.y = e.y - Math.floor(e.y));
            }
          return this.flipY && (e.y = 1 - e.y), e;
        }
        set needsUpdate(e) {
          !0 === e && (this.version++, (this.source.needsUpdate = !0));
        }
        set needsPMREMUpdate(e) {
          !0 === e && this.pmremVersion++;
        }
      }
      ($t.DEFAULT_IMAGE = null),
        ($t.DEFAULT_MAPPING = 300),
        ($t.DEFAULT_ANISOTROPY = 1);
      class en {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (en.prototype.isVector4 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            (this.w = i);
        }
        get width() {
          return this.z;
        }
        set width(e) {
          this.z = e;
        }
        get height() {
          return this.w;
        }
        set height(e) {
          this.w = e;
        }
        set(e, t, n, i) {
          return (this.x = e), (this.y = t), (this.z = n), (this.w = i), this;
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), (this.w = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setW(e) {
          return (this.w = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            case 3:
              this.w = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            case 3:
              return this.w;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z, this.w);
        }
        copy(e) {
          return (
            (this.x = e.x),
            (this.y = e.y),
            (this.z = e.z),
            (this.w = void 0 !== e.w ? e.w : 1),
            this
          );
        }
        add(e) {
          return (
            (this.x += e.x),
            (this.y += e.y),
            (this.z += e.z),
            (this.w += e.w),
            this
          );
        }
        addScalar(e) {
          return (
            (this.x += e), (this.y += e), (this.z += e), (this.w += e), this
          );
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            (this.w = e.w + t.w),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t),
            (this.y += e.y * t),
            (this.z += e.z * t),
            (this.w += e.w * t),
            this
          );
        }
        sub(e) {
          return (
            (this.x -= e.x),
            (this.y -= e.y),
            (this.z -= e.z),
            (this.w -= e.w),
            this
          );
        }
        subScalar(e) {
          return (
            (this.x -= e), (this.y -= e), (this.z -= e), (this.w -= e), this
          );
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            (this.w = e.w - t.w),
            this
          );
        }
        multiply(e) {
          return (
            (this.x *= e.x),
            (this.y *= e.y),
            (this.z *= e.z),
            (this.w *= e.w),
            this
          );
        }
        multiplyScalar(e) {
          return (
            (this.x *= e), (this.y *= e), (this.z *= e), (this.w *= e), this
          );
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = this.w,
            s = e.elements;
          return (
            (this.x = s[0] * t + s[4] * n + s[8] * i + s[12] * r),
            (this.y = s[1] * t + s[5] * n + s[9] * i + s[13] * r),
            (this.z = s[2] * t + s[6] * n + s[10] * i + s[14] * r),
            (this.w = s[3] * t + s[7] * n + s[11] * i + s[15] * r),
            this
          );
        }
        divide(e) {
          return (
            (this.x /= e.x),
            (this.y /= e.y),
            (this.z /= e.z),
            (this.w /= e.w),
            this
          );
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        setAxisAngleFromQuaternion(e) {
          this.w = 2 * Math.acos(e.w);
          const t = Math.sqrt(1 - e.w * e.w);
          return (
            t < 1e-4
              ? ((this.x = 1), (this.y = 0), (this.z = 0))
              : ((this.x = e.x / t), (this.y = e.y / t), (this.z = e.z / t)),
            this
          );
        }
        setAxisAngleFromRotationMatrix(e) {
          let t, n, i, r;
          const s = 0.01,
            a = 0.1,
            o = e.elements,
            l = o[0],
            c = o[4],
            u = o[8],
            h = o[1],
            d = o[5],
            p = o[9],
            f = o[2],
            A = o[6],
            g = o[10];
          if (
            Math.abs(c - h) < s &&
            Math.abs(u - f) < s &&
            Math.abs(p - A) < s
          ) {
            if (
              Math.abs(c + h) < a &&
              Math.abs(u + f) < a &&
              Math.abs(p + A) < a &&
              Math.abs(l + d + g - 3) < a
            )
              return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const e = (l + 1) / 2,
              o = (d + 1) / 2,
              m = (g + 1) / 2,
              v = (c + h) / 4,
              y = (u + f) / 4,
              x = (p + A) / 4;
            return (
              e > o && e > m
                ? e < s
                  ? ((n = 0), (i = 0.707106781), (r = 0.707106781))
                  : ((n = Math.sqrt(e)), (i = v / n), (r = y / n))
                : o > m
                ? o < s
                  ? ((n = 0.707106781), (i = 0), (r = 0.707106781))
                  : ((i = Math.sqrt(o)), (n = v / i), (r = x / i))
                : m < s
                ? ((n = 0.707106781), (i = 0.707106781), (r = 0))
                : ((r = Math.sqrt(m)), (n = y / r), (i = x / r)),
              this.set(n, i, r, t),
              this
            );
          }
          let m = Math.sqrt(
            (A - p) * (A - p) + (u - f) * (u - f) + (h - c) * (h - c)
          );
          return (
            Math.abs(m) < 0.001 && (m = 1),
            (this.x = (A - p) / m),
            (this.y = (u - f) / m),
            (this.z = (h - c) / m),
            (this.w = Math.acos((l + d + g - 1) / 2)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (
            (this.x = t[12]),
            (this.y = t[13]),
            (this.z = t[14]),
            (this.w = t[15]),
            this
          );
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            (this.w = Math.min(this.w, e.w)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            (this.w = Math.max(this.w, e.w)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            (this.w = Math.max(e.w, Math.min(t.w, this.w))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            (this.w = Math.max(e, Math.min(t, this.w))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            (this.w = Math.floor(this.w)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            (this.w = Math.ceil(this.w)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            (this.w = Math.round(this.w)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            (this.w = Math.trunc(this.w)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x),
            (this.y = -this.y),
            (this.z = -this.z),
            (this.w = -this.w),
            this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w;
        }
        lengthSq() {
          return (
            this.x * this.x +
            this.y * this.y +
            this.z * this.z +
            this.w * this.w
          );
        }
        length() {
          return Math.sqrt(
            this.x * this.x +
              this.y * this.y +
              this.z * this.z +
              this.w * this.w
          );
        }
        manhattanLength() {
          return (
            Math.abs(this.x) +
            Math.abs(this.y) +
            Math.abs(this.z) +
            Math.abs(this.w)
          );
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            (this.w += (e.w - this.w) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            (this.w = e.w + (t.w - e.w) * n),
            this
          );
        }
        equals(e) {
          return (
            e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]),
            (this.y = e[t + 1]),
            (this.z = e[t + 2]),
            (this.w = e[t + 3]),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this.x),
            (e[t + 1] = this.y),
            (e[t + 2] = this.z),
            (e[t + 3] = this.w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            (this.w = e.getW(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            (this.w = Math.random()),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z, yield this.w;
        }
      }
      class tn extends yt {
        constructor(e = 1, t = 1, n = {}) {
          super(),
            (this.isRenderTarget = !0),
            (this.width = e),
            (this.height = t),
            (this.depth = 1),
            (this.scissor = new en(0, 0, e, t)),
            (this.scissorTest = !1),
            (this.viewport = new en(0, 0, e, t));
          const i = { width: e, height: t, depth: 1 };
          n = Object.assign(
            {
              generateMipmaps: !1,
              internalFormat: null,
              minFilter: z,
              depthBuffer: !0,
              stencilBuffer: !1,
              resolveDepthBuffer: !0,
              resolveStencilBuffer: !0,
              depthTexture: null,
              samples: 0,
              count: 1,
            },
            n
          );
          const r = new $t(
            i,
            n.mapping,
            n.wrapS,
            n.wrapT,
            n.magFilter,
            n.minFilter,
            n.format,
            n.type,
            n.anisotropy,
            n.colorSpace
          );
          (r.flipY = !1),
            (r.generateMipmaps = n.generateMipmaps),
            (r.internalFormat = n.internalFormat),
            (this.textures = []);
          const s = n.count;
          for (let e = 0; e < s; e++)
            (this.textures[e] = r.clone()),
              (this.textures[e].isRenderTargetTexture = !0);
          (this.depthBuffer = n.depthBuffer),
            (this.stencilBuffer = n.stencilBuffer),
            (this.resolveDepthBuffer = n.resolveDepthBuffer),
            (this.resolveStencilBuffer = n.resolveStencilBuffer),
            (this.depthTexture = n.depthTexture),
            (this.samples = n.samples);
        }
        get texture() {
          return this.textures[0];
        }
        set texture(e) {
          this.textures[0] = e;
        }
        setSize(e, t, n = 1) {
          if (this.width !== e || this.height !== t || this.depth !== n) {
            (this.width = e), (this.height = t), (this.depth = n);
            for (let i = 0, r = this.textures.length; i < r; i++)
              (this.textures[i].image.width = e),
                (this.textures[i].image.height = t),
                (this.textures[i].image.depth = n);
            this.dispose();
          }
          this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.width = e.width),
            (this.height = e.height),
            (this.depth = e.depth),
            this.scissor.copy(e.scissor),
            (this.scissorTest = e.scissorTest),
            this.viewport.copy(e.viewport),
            (this.textures.length = 0);
          for (let t = 0, n = e.textures.length; t < n; t++)
            (this.textures[t] = e.textures[t].clone()),
              (this.textures[t].isRenderTargetTexture = !0);
          const t = Object.assign({}, e.texture.image);
          return (
            (this.texture.source = new Kt(t)),
            (this.depthBuffer = e.depthBuffer),
            (this.stencilBuffer = e.stencilBuffer),
            (this.resolveDepthBuffer = e.resolveDepthBuffer),
            (this.resolveStencilBuffer = e.resolveStencilBuffer),
            null !== e.depthTexture &&
              (this.depthTexture = e.depthTexture.clone()),
            (this.samples = e.samples),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      class nn extends tn {
        constructor(e = 1, t = 1, n = {}) {
          super(e, t, n), (this.isWebGLRenderTarget = !0);
        }
      }
      class rn extends $t {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isDataArrayTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = k),
            (this.minFilter = k),
            (this.wrapR = O),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class sn extends $t {
        constructor(e = null, t = 1, n = 1, i = 1) {
          super(null),
            (this.isData3DTexture = !0),
            (this.image = { data: e, width: t, height: n, depth: i }),
            (this.magFilter = k),
            (this.minFilter = k),
            (this.wrapR = O),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      class an {
        constructor(e = 0, t = 0, n = 0, i = 1) {
          (this.isQuaternion = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i);
        }
        static slerpFlat(e, t, n, i, r, s, a) {
          let o = n[i + 0],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3];
          const h = r[s + 0],
            d = r[s + 1],
            p = r[s + 2],
            f = r[s + 3];
          if (0 === a)
            return (
              (e[t + 0] = o),
              (e[t + 1] = l),
              (e[t + 2] = c),
              void (e[t + 3] = u)
            );
          if (1 === a)
            return (
              (e[t + 0] = h),
              (e[t + 1] = d),
              (e[t + 2] = p),
              void (e[t + 3] = f)
            );
          if (u !== f || o !== h || l !== d || c !== p) {
            let e = 1 - a;
            const t = o * h + l * d + c * p + u * f,
              n = t >= 0 ? 1 : -1,
              i = 1 - t * t;
            if (i > Number.EPSILON) {
              const r = Math.sqrt(i),
                s = Math.atan2(r, t * n);
              (e = Math.sin(e * s) / r), (a = Math.sin(a * s) / r);
            }
            const r = a * n;
            if (
              ((o = o * e + h * r),
              (l = l * e + d * r),
              (c = c * e + p * r),
              (u = u * e + f * r),
              e === 1 - a)
            ) {
              const e = 1 / Math.sqrt(o * o + l * l + c * c + u * u);
              (o *= e), (l *= e), (c *= e), (u *= e);
            }
          }
          (e[t] = o), (e[t + 1] = l), (e[t + 2] = c), (e[t + 3] = u);
        }
        static multiplyQuaternionsFlat(e, t, n, i, r, s) {
          const a = n[i],
            o = n[i + 1],
            l = n[i + 2],
            c = n[i + 3],
            u = r[s],
            h = r[s + 1],
            d = r[s + 2],
            p = r[s + 3];
          return (
            (e[t] = a * p + c * u + o * d - l * h),
            (e[t + 1] = o * p + c * h + l * u - a * d),
            (e[t + 2] = l * p + c * d + a * h - o * u),
            (e[t + 3] = c * p - a * u - o * h - l * d),
            e
          );
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get w() {
          return this._w;
        }
        set w(e) {
          (this._w = e), this._onChangeCallback();
        }
        set(e, t, n, i) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._w = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._w);
        }
        copy(e) {
          return (
            (this._x = e.x),
            (this._y = e.y),
            (this._z = e.z),
            (this._w = e.w),
            this._onChangeCallback(),
            this
          );
        }
        setFromEuler(e, t = !0) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._order,
            a = Math.cos,
            o = Math.sin,
            l = a(n / 2),
            c = a(i / 2),
            u = a(r / 2),
            h = o(n / 2),
            d = o(i / 2),
            p = o(r / 2);
          switch (s) {
            case "XYZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "YXZ":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "ZXY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "ZYX":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            case "YZX":
              (this._x = h * c * u + l * d * p),
                (this._y = l * d * u + h * c * p),
                (this._z = l * c * p - h * d * u),
                (this._w = l * c * u - h * d * p);
              break;
            case "XZY":
              (this._x = h * c * u - l * d * p),
                (this._y = l * d * u - h * c * p),
                (this._z = l * c * p + h * d * u),
                (this._w = l * c * u + h * d * p);
              break;
            default:
              console.warn(
                "THREE.Quaternion: .setFromEuler() encountered an unknown order: " +
                  s
              );
          }
          return !0 === t && this._onChangeCallback(), this;
        }
        setFromAxisAngle(e, t) {
          const n = t / 2,
            i = Math.sin(n);
          return (
            (this._x = e.x * i),
            (this._y = e.y * i),
            (this._z = e.z * i),
            (this._w = Math.cos(n)),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e) {
          const t = e.elements,
            n = t[0],
            i = t[4],
            r = t[8],
            s = t[1],
            a = t[5],
            o = t[9],
            l = t[2],
            c = t[6],
            u = t[10],
            h = n + a + u;
          if (h > 0) {
            const e = 0.5 / Math.sqrt(h + 1);
            (this._w = 0.25 / e),
              (this._x = (c - o) * e),
              (this._y = (r - l) * e),
              (this._z = (s - i) * e);
          } else if (n > a && n > u) {
            const e = 2 * Math.sqrt(1 + n - a - u);
            (this._w = (c - o) / e),
              (this._x = 0.25 * e),
              (this._y = (i + s) / e),
              (this._z = (r + l) / e);
          } else if (a > u) {
            const e = 2 * Math.sqrt(1 + a - n - u);
            (this._w = (r - l) / e),
              (this._x = (i + s) / e),
              (this._y = 0.25 * e),
              (this._z = (o + c) / e);
          } else {
            const e = 2 * Math.sqrt(1 + u - n - a);
            (this._w = (s - i) / e),
              (this._x = (r + l) / e),
              (this._y = (o + c) / e),
              (this._z = 0.25 * e);
          }
          return this._onChangeCallback(), this;
        }
        setFromUnitVectors(e, t) {
          let n = e.dot(t) + 1;
          return (
            n < Number.EPSILON
              ? ((n = 0),
                Math.abs(e.x) > Math.abs(e.z)
                  ? ((this._x = -e.y),
                    (this._y = e.x),
                    (this._z = 0),
                    (this._w = n))
                  : ((this._x = 0),
                    (this._y = -e.z),
                    (this._z = e.y),
                    (this._w = n)))
              : ((this._x = e.y * t.z - e.z * t.y),
                (this._y = e.z * t.x - e.x * t.z),
                (this._z = e.x * t.y - e.y * t.x),
                (this._w = n)),
            this.normalize()
          );
        }
        angleTo(e) {
          return 2 * Math.acos(Math.abs(Ct(this.dot(e), -1, 1)));
        }
        rotateTowards(e, t) {
          const n = this.angleTo(e);
          if (0 === n) return this;
          const i = Math.min(1, t / n);
          return this.slerp(e, i), this;
        }
        identity() {
          return this.set(0, 0, 0, 1);
        }
        invert() {
          return this.conjugate();
        }
        conjugate() {
          return (
            (this._x *= -1),
            (this._y *= -1),
            (this._z *= -1),
            this._onChangeCallback(),
            this
          );
        }
        dot(e) {
          return (
            this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
          );
        }
        lengthSq() {
          return (
            this._x * this._x +
            this._y * this._y +
            this._z * this._z +
            this._w * this._w
          );
        }
        length() {
          return Math.sqrt(
            this._x * this._x +
              this._y * this._y +
              this._z * this._z +
              this._w * this._w
          );
        }
        normalize() {
          let e = this.length();
          return (
            0 === e
              ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
              : ((e = 1 / e),
                (this._x = this._x * e),
                (this._y = this._y * e),
                (this._z = this._z * e),
                (this._w = this._w * e)),
            this._onChangeCallback(),
            this
          );
        }
        multiply(e) {
          return this.multiplyQuaternions(this, e);
        }
        premultiply(e) {
          return this.multiplyQuaternions(e, this);
        }
        multiplyQuaternions(e, t) {
          const n = e._x,
            i = e._y,
            r = e._z,
            s = e._w,
            a = t._x,
            o = t._y,
            l = t._z,
            c = t._w;
          return (
            (this._x = n * c + s * a + i * l - r * o),
            (this._y = i * c + s * o + r * a - n * l),
            (this._z = r * c + s * l + n * o - i * a),
            (this._w = s * c - n * a - i * o - r * l),
            this._onChangeCallback(),
            this
          );
        }
        slerp(e, t) {
          if (0 === t) return this;
          if (1 === t) return this.copy(e);
          const n = this._x,
            i = this._y,
            r = this._z,
            s = this._w;
          let a = s * e._w + n * e._x + i * e._y + r * e._z;
          if (
            (a < 0
              ? ((this._w = -e._w),
                (this._x = -e._x),
                (this._y = -e._y),
                (this._z = -e._z),
                (a = -a))
              : this.copy(e),
            a >= 1)
          )
            return (
              (this._w = s), (this._x = n), (this._y = i), (this._z = r), this
            );
          const o = 1 - a * a;
          if (o <= Number.EPSILON) {
            const e = 1 - t;
            return (
              (this._w = e * s + t * this._w),
              (this._x = e * n + t * this._x),
              (this._y = e * i + t * this._y),
              (this._z = e * r + t * this._z),
              this.normalize(),
              this
            );
          }
          const l = Math.sqrt(o),
            c = Math.atan2(l, a),
            u = Math.sin((1 - t) * c) / l,
            h = Math.sin(t * c) / l;
          return (
            (this._w = s * u + this._w * h),
            (this._x = n * u + this._x * h),
            (this._y = i * u + this._y * h),
            (this._z = r * u + this._z * h),
            this._onChangeCallback(),
            this
          );
        }
        slerpQuaternions(e, t, n) {
          return this.copy(e).slerp(t, n);
        }
        random() {
          const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            n = Math.random(),
            i = Math.sqrt(1 - n),
            r = Math.sqrt(n);
          return this.set(
            i * Math.sin(e),
            i * Math.cos(e),
            r * Math.sin(t),
            r * Math.cos(t)
          );
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._w === this._w
          );
        }
        fromArray(e, t = 0) {
          return (
            (this._x = e[t]),
            (this._y = e[t + 1]),
            (this._z = e[t + 2]),
            (this._w = e[t + 3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._w),
            e
          );
        }
        fromBufferAttribute(e, t) {
          return (
            (this._x = e.getX(t)),
            (this._y = e.getY(t)),
            (this._z = e.getZ(t)),
            (this._w = e.getW(t)),
            this._onChangeCallback(),
            this
          );
        }
        toJSON() {
          return this.toArray();
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._w;
        }
      }
      class on {
        constructor(e = 0, t = 0, n = 0) {
          (on.prototype.isVector3 = !0),
            (this.x = e),
            (this.y = t),
            (this.z = n);
        }
        set(e, t, n) {
          return (
            void 0 === n && (n = this.z),
            (this.x = e),
            (this.y = t),
            (this.z = n),
            this
          );
        }
        setScalar(e) {
          return (this.x = e), (this.y = e), (this.z = e), this;
        }
        setX(e) {
          return (this.x = e), this;
        }
        setY(e) {
          return (this.y = e), this;
        }
        setZ(e) {
          return (this.z = e), this;
        }
        setComponent(e, t) {
          switch (e) {
            case 0:
              this.x = t;
              break;
            case 1:
              this.y = t;
              break;
            case 2:
              this.z = t;
              break;
            default:
              throw new Error("index is out of range: " + e);
          }
          return this;
        }
        getComponent(e) {
          switch (e) {
            case 0:
              return this.x;
            case 1:
              return this.y;
            case 2:
              return this.z;
            default:
              throw new Error("index is out of range: " + e);
          }
        }
        clone() {
          return new this.constructor(this.x, this.y, this.z);
        }
        copy(e) {
          return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
        }
        add(e) {
          return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
        }
        addScalar(e) {
          return (this.x += e), (this.y += e), (this.z += e), this;
        }
        addVectors(e, t) {
          return (
            (this.x = e.x + t.x),
            (this.y = e.y + t.y),
            (this.z = e.z + t.z),
            this
          );
        }
        addScaledVector(e, t) {
          return (
            (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this
          );
        }
        sub(e) {
          return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
        }
        subScalar(e) {
          return (this.x -= e), (this.y -= e), (this.z -= e), this;
        }
        subVectors(e, t) {
          return (
            (this.x = e.x - t.x),
            (this.y = e.y - t.y),
            (this.z = e.z - t.z),
            this
          );
        }
        multiply(e) {
          return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
        }
        multiplyScalar(e) {
          return (this.x *= e), (this.y *= e), (this.z *= e), this;
        }
        multiplyVectors(e, t) {
          return (
            (this.x = e.x * t.x),
            (this.y = e.y * t.y),
            (this.z = e.z * t.z),
            this
          );
        }
        applyEuler(e) {
          return this.applyQuaternion(cn.setFromEuler(e));
        }
        applyAxisAngle(e, t) {
          return this.applyQuaternion(cn.setFromAxisAngle(e, t));
        }
        applyMatrix3(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[3] * n + r[6] * i),
            (this.y = r[1] * t + r[4] * n + r[7] * i),
            (this.z = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        applyNormalMatrix(e) {
          return this.applyMatrix3(e).normalize();
        }
        applyMatrix4(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements,
            s = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
          return (
            (this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * s),
            (this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * s),
            (this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * s),
            this
          );
        }
        applyQuaternion(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.x,
            s = e.y,
            a = e.z,
            o = e.w,
            l = 2 * (s * i - a * n),
            c = 2 * (a * t - r * i),
            u = 2 * (r * n - s * t);
          return (
            (this.x = t + o * l + s * u - a * c),
            (this.y = n + o * c + a * l - r * u),
            (this.z = i + o * u + r * c - s * l),
            this
          );
        }
        project(e) {
          return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
            e.projectionMatrix
          );
        }
        unproject(e) {
          return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
            e.matrixWorld
          );
        }
        transformDirection(e) {
          const t = this.x,
            n = this.y,
            i = this.z,
            r = e.elements;
          return (
            (this.x = r[0] * t + r[4] * n + r[8] * i),
            (this.y = r[1] * t + r[5] * n + r[9] * i),
            (this.z = r[2] * t + r[6] * n + r[10] * i),
            this.normalize()
          );
        }
        divide(e) {
          return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
        }
        divideScalar(e) {
          return this.multiplyScalar(1 / e);
        }
        min(e) {
          return (
            (this.x = Math.min(this.x, e.x)),
            (this.y = Math.min(this.y, e.y)),
            (this.z = Math.min(this.z, e.z)),
            this
          );
        }
        max(e) {
          return (
            (this.x = Math.max(this.x, e.x)),
            (this.y = Math.max(this.y, e.y)),
            (this.z = Math.max(this.z, e.z)),
            this
          );
        }
        clamp(e, t) {
          return (
            (this.x = Math.max(e.x, Math.min(t.x, this.x))),
            (this.y = Math.max(e.y, Math.min(t.y, this.y))),
            (this.z = Math.max(e.z, Math.min(t.z, this.z))),
            this
          );
        }
        clampScalar(e, t) {
          return (
            (this.x = Math.max(e, Math.min(t, this.x))),
            (this.y = Math.max(e, Math.min(t, this.y))),
            (this.z = Math.max(e, Math.min(t, this.z))),
            this
          );
        }
        clampLength(e, t) {
          const n = this.length();
          return this.divideScalar(n || 1).multiplyScalar(
            Math.max(e, Math.min(t, n))
          );
        }
        floor() {
          return (
            (this.x = Math.floor(this.x)),
            (this.y = Math.floor(this.y)),
            (this.z = Math.floor(this.z)),
            this
          );
        }
        ceil() {
          return (
            (this.x = Math.ceil(this.x)),
            (this.y = Math.ceil(this.y)),
            (this.z = Math.ceil(this.z)),
            this
          );
        }
        round() {
          return (
            (this.x = Math.round(this.x)),
            (this.y = Math.round(this.y)),
            (this.z = Math.round(this.z)),
            this
          );
        }
        roundToZero() {
          return (
            (this.x = Math.trunc(this.x)),
            (this.y = Math.trunc(this.y)),
            (this.z = Math.trunc(this.z)),
            this
          );
        }
        negate() {
          return (
            (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this
          );
        }
        dot(e) {
          return this.x * e.x + this.y * e.y + this.z * e.z;
        }
        lengthSq() {
          return this.x * this.x + this.y * this.y + this.z * this.z;
        }
        length() {
          return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
        }
        manhattanLength() {
          return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
        }
        normalize() {
          return this.divideScalar(this.length() || 1);
        }
        setLength(e) {
          return this.normalize().multiplyScalar(e);
        }
        lerp(e, t) {
          return (
            (this.x += (e.x - this.x) * t),
            (this.y += (e.y - this.y) * t),
            (this.z += (e.z - this.z) * t),
            this
          );
        }
        lerpVectors(e, t, n) {
          return (
            (this.x = e.x + (t.x - e.x) * n),
            (this.y = e.y + (t.y - e.y) * n),
            (this.z = e.z + (t.z - e.z) * n),
            this
          );
        }
        cross(e) {
          return this.crossVectors(this, e);
        }
        crossVectors(e, t) {
          const n = e.x,
            i = e.y,
            r = e.z,
            s = t.x,
            a = t.y,
            o = t.z;
          return (
            (this.x = i * o - r * a),
            (this.y = r * s - n * o),
            (this.z = n * a - i * s),
            this
          );
        }
        projectOnVector(e) {
          const t = e.lengthSq();
          if (0 === t) return this.set(0, 0, 0);
          const n = e.dot(this) / t;
          return this.copy(e).multiplyScalar(n);
        }
        projectOnPlane(e) {
          return ln.copy(this).projectOnVector(e), this.sub(ln);
        }
        reflect(e) {
          return this.sub(ln.copy(e).multiplyScalar(2 * this.dot(e)));
        }
        angleTo(e) {
          const t = Math.sqrt(this.lengthSq() * e.lengthSq());
          if (0 === t) return Math.PI / 2;
          const n = this.dot(e) / t;
          return Math.acos(Ct(n, -1, 1));
        }
        distanceTo(e) {
          return Math.sqrt(this.distanceToSquared(e));
        }
        distanceToSquared(e) {
          const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
          return t * t + n * n + i * i;
        }
        manhattanDistanceTo(e) {
          return (
            Math.abs(this.x - e.x) +
            Math.abs(this.y - e.y) +
            Math.abs(this.z - e.z)
          );
        }
        setFromSpherical(e) {
          return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
        }
        setFromSphericalCoords(e, t, n) {
          const i = Math.sin(t) * e;
          return (
            (this.x = i * Math.sin(n)),
            (this.y = Math.cos(t) * e),
            (this.z = i * Math.cos(n)),
            this
          );
        }
        setFromCylindrical(e) {
          return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
        }
        setFromCylindricalCoords(e, t, n) {
          return (
            (this.x = e * Math.sin(t)),
            (this.y = n),
            (this.z = e * Math.cos(t)),
            this
          );
        }
        setFromMatrixPosition(e) {
          const t = e.elements;
          return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
        }
        setFromMatrixScale(e) {
          const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
          return (this.x = t), (this.y = n), (this.z = i), this;
        }
        setFromMatrixColumn(e, t) {
          return this.fromArray(e.elements, 4 * t);
        }
        setFromMatrix3Column(e, t) {
          return this.fromArray(e.elements, 3 * t);
        }
        setFromEuler(e) {
          return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
        }
        setFromColor(e) {
          return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
        }
        equals(e) {
          return e.x === this.x && e.y === this.y && e.z === this.z;
        }
        fromArray(e, t = 0) {
          return (
            (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.x = e.getX(t)),
            (this.y = e.getY(t)),
            (this.z = e.getZ(t)),
            this
          );
        }
        random() {
          return (
            (this.x = Math.random()),
            (this.y = Math.random()),
            (this.z = Math.random()),
            this
          );
        }
        randomDirection() {
          const e = Math.random() * Math.PI * 2,
            t = 2 * Math.random() - 1,
            n = Math.sqrt(1 - t * t);
          return (
            (this.x = n * Math.cos(e)),
            (this.y = t),
            (this.z = n * Math.sin(e)),
            this
          );
        }
        *[Symbol.iterator]() {
          yield this.x, yield this.y, yield this.z;
        }
      }
      const ln = new on(),
        cn = new an();
      class un {
        constructor(
          e = new on(1 / 0, 1 / 0, 1 / 0),
          t = new on(-1 / 0, -1 / 0, -1 / 0)
        ) {
          (this.isBox3 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromArray(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(dn.fromArray(e, t));
          return this;
        }
        setFromBufferAttribute(e) {
          this.makeEmpty();
          for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(dn.fromBufferAttribute(e, t));
          return this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = dn.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        setFromObject(e, t = !1) {
          return this.makeEmpty(), this.expandByObject(e, t);
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = this.min.z = 1 / 0),
            (this.max.x = this.max.y = this.max.z = -1 / 0),
            this
          );
        }
        isEmpty() {
          return (
            this.max.x < this.min.x ||
            this.max.y < this.min.y ||
            this.max.z < this.min.z
          );
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        expandByObject(e, t = !1) {
          e.updateWorldMatrix(!1, !1);
          const n = e.geometry;
          if (void 0 !== n) {
            const i = n.getAttribute("position");
            if (!0 === t && void 0 !== i && !0 !== e.isInstancedMesh)
              for (let t = 0, n = i.count; t < n; t++)
                !0 === e.isMesh
                  ? e.getVertexPosition(t, dn)
                  : dn.fromBufferAttribute(i, t),
                  dn.applyMatrix4(e.matrixWorld),
                  this.expandByPoint(dn);
            else
              void 0 !== e.boundingBox
                ? (null === e.boundingBox && e.computeBoundingBox(),
                  pn.copy(e.boundingBox))
                : (null === n.boundingBox && n.computeBoundingBox(),
                  pn.copy(n.boundingBox)),
                pn.applyMatrix4(e.matrixWorld),
                this.union(pn);
          }
          const i = e.children;
          for (let e = 0, n = i.length; e < n; e++)
            this.expandByObject(i[e], t);
          return this;
        }
        containsPoint(e) {
          return (
            e.x >= this.min.x &&
            e.x <= this.max.x &&
            e.y >= this.min.y &&
            e.y <= this.max.y &&
            e.z >= this.min.z &&
            e.z <= this.max.z
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y &&
            this.min.z <= e.min.z &&
            e.max.z <= this.max.z
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y),
            (e.z - this.min.z) / (this.max.z - this.min.z)
          );
        }
        intersectsBox(e) {
          return (
            e.max.x >= this.min.x &&
            e.min.x <= this.max.x &&
            e.max.y >= this.min.y &&
            e.min.y <= this.max.y &&
            e.max.z >= this.min.z &&
            e.min.z <= this.max.z
          );
        }
        intersectsSphere(e) {
          return (
            this.clampPoint(e.center, dn),
            dn.distanceToSquared(e.center) <= e.radius * e.radius
          );
        }
        intersectsPlane(e) {
          let t, n;
          return (
            e.normal.x > 0
              ? ((t = e.normal.x * this.min.x), (n = e.normal.x * this.max.x))
              : ((t = e.normal.x * this.max.x), (n = e.normal.x * this.min.x)),
            e.normal.y > 0
              ? ((t += e.normal.y * this.min.y), (n += e.normal.y * this.max.y))
              : ((t += e.normal.y * this.max.y),
                (n += e.normal.y * this.min.y)),
            e.normal.z > 0
              ? ((t += e.normal.z * this.min.z), (n += e.normal.z * this.max.z))
              : ((t += e.normal.z * this.max.z),
                (n += e.normal.z * this.min.z)),
            t <= -e.constant && n >= -e.constant
          );
        }
        intersectsTriangle(e) {
          if (this.isEmpty()) return !1;
          this.getCenter(xn),
            _n.subVectors(this.max, xn),
            fn.subVectors(e.a, xn),
            An.subVectors(e.b, xn),
            gn.subVectors(e.c, xn),
            mn.subVectors(An, fn),
            vn.subVectors(gn, An),
            yn.subVectors(fn, gn);
          let t = [
            0,
            -mn.z,
            mn.y,
            0,
            -vn.z,
            vn.y,
            0,
            -yn.z,
            yn.y,
            mn.z,
            0,
            -mn.x,
            vn.z,
            0,
            -vn.x,
            yn.z,
            0,
            -yn.x,
            -mn.y,
            mn.x,
            0,
            -vn.y,
            vn.x,
            0,
            -yn.y,
            yn.x,
            0,
          ];
          return (
            !!wn(t, fn, An, gn, _n) &&
            ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
            !!wn(t, fn, An, gn, _n) &&
              (bn.crossVectors(mn, vn),
              (t = [bn.x, bn.y, bn.z]),
              wn(t, fn, An, gn, _n)))
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, dn).distanceTo(e);
        }
        getBoundingSphere(e) {
          return (
            this.isEmpty()
              ? e.makeEmpty()
              : (this.getCenter(e.center),
                (e.radius = 0.5 * this.getSize(dn).length())),
            e
          );
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        applyMatrix4(e) {
          return (
            this.isEmpty() ||
              (hn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
              hn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
              hn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
              hn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
              hn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
              hn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
              hn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
              hn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
              this.setFromPoints(hn)),
            this
          );
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const hn = [
          new on(),
          new on(),
          new on(),
          new on(),
          new on(),
          new on(),
          new on(),
          new on(),
        ],
        dn = new on(),
        pn = new un(),
        fn = new on(),
        An = new on(),
        gn = new on(),
        mn = new on(),
        vn = new on(),
        yn = new on(),
        xn = new on(),
        _n = new on(),
        bn = new on(),
        En = new on();
      function wn(e, t, n, i, r) {
        for (let s = 0, a = e.length - 3; s <= a; s += 3) {
          En.fromArray(e, s);
          const a =
              r.x * Math.abs(En.x) +
              r.y * Math.abs(En.y) +
              r.z * Math.abs(En.z),
            o = t.dot(En),
            l = n.dot(En),
            c = i.dot(En);
          if (Math.max(-Math.max(o, l, c), Math.min(o, l, c)) > a) return !1;
        }
        return !0;
      }
      const Cn = new un(),
        In = new on(),
        Sn = new on();
      class Mn {
        constructor(e = new on(), t = -1) {
          (this.isSphere = !0), (this.center = e), (this.radius = t);
        }
        set(e, t) {
          return this.center.copy(e), (this.radius = t), this;
        }
        setFromPoints(e, t) {
          const n = this.center;
          void 0 !== t ? n.copy(t) : Cn.setFromPoints(e).getCenter(n);
          let i = 0;
          for (let t = 0, r = e.length; t < r; t++)
            i = Math.max(i, n.distanceToSquared(e[t]));
          return (this.radius = Math.sqrt(i)), this;
        }
        copy(e) {
          return this.center.copy(e.center), (this.radius = e.radius), this;
        }
        isEmpty() {
          return this.radius < 0;
        }
        makeEmpty() {
          return this.center.set(0, 0, 0), (this.radius = -1), this;
        }
        containsPoint(e) {
          return e.distanceToSquared(this.center) <= this.radius * this.radius;
        }
        distanceToPoint(e) {
          return e.distanceTo(this.center) - this.radius;
        }
        intersectsSphere(e) {
          const t = this.radius + e.radius;
          return e.center.distanceToSquared(this.center) <= t * t;
        }
        intersectsBox(e) {
          return e.intersectsSphere(this);
        }
        intersectsPlane(e) {
          return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
        }
        clampPoint(e, t) {
          const n = this.center.distanceToSquared(e);
          return (
            t.copy(e),
            n > this.radius * this.radius &&
              (t.sub(this.center).normalize(),
              t.multiplyScalar(this.radius).add(this.center)),
            t
          );
        }
        getBoundingBox(e) {
          return this.isEmpty()
            ? (e.makeEmpty(), e)
            : (e.set(this.center, this.center),
              e.expandByScalar(this.radius),
              e);
        }
        applyMatrix4(e) {
          return (
            this.center.applyMatrix4(e),
            (this.radius = this.radius * e.getMaxScaleOnAxis()),
            this
          );
        }
        translate(e) {
          return this.center.add(e), this;
        }
        expandByPoint(e) {
          if (this.isEmpty())
            return this.center.copy(e), (this.radius = 0), this;
          In.subVectors(e, this.center);
          const t = In.lengthSq();
          if (t > this.radius * this.radius) {
            const e = Math.sqrt(t),
              n = 0.5 * (e - this.radius);
            this.center.addScaledVector(In, n / e), (this.radius += n);
          }
          return this;
        }
        union(e) {
          return e.isEmpty()
            ? this
            : this.isEmpty()
            ? (this.copy(e), this)
            : (!0 === this.center.equals(e.center)
                ? (this.radius = Math.max(this.radius, e.radius))
                : (Sn.subVectors(e.center, this.center).setLength(e.radius),
                  this.expandByPoint(In.copy(e.center).add(Sn)),
                  this.expandByPoint(In.copy(e.center).sub(Sn))),
              this);
        }
        equals(e) {
          return e.center.equals(this.center) && e.radius === this.radius;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Tn = new on(),
        Bn = new on(),
        Rn = new on(),
        Dn = new on(),
        Pn = new on(),
        Ln = new on(),
        Un = new on();
      class Fn {
        constructor(e = new on(), t = new on(0, 0, -1)) {
          (this.origin = e), (this.direction = t);
        }
        set(e, t) {
          return this.origin.copy(e), this.direction.copy(t), this;
        }
        copy(e) {
          return (
            this.origin.copy(e.origin), this.direction.copy(e.direction), this
          );
        }
        at(e, t) {
          return t.copy(this.origin).addScaledVector(this.direction, e);
        }
        lookAt(e) {
          return this.direction.copy(e).sub(this.origin).normalize(), this;
        }
        recast(e) {
          return this.origin.copy(this.at(e, Tn)), this;
        }
        closestPointToPoint(e, t) {
          t.subVectors(e, this.origin);
          const n = t.dot(this.direction);
          return n < 0
            ? t.copy(this.origin)
            : t.copy(this.origin).addScaledVector(this.direction, n);
        }
        distanceToPoint(e) {
          return Math.sqrt(this.distanceSqToPoint(e));
        }
        distanceSqToPoint(e) {
          const t = Tn.subVectors(e, this.origin).dot(this.direction);
          return t < 0
            ? this.origin.distanceToSquared(e)
            : (Tn.copy(this.origin).addScaledVector(this.direction, t),
              Tn.distanceToSquared(e));
        }
        distanceSqToSegment(e, t, n, i) {
          Bn.copy(e).add(t).multiplyScalar(0.5),
            Rn.copy(t).sub(e).normalize(),
            Dn.copy(this.origin).sub(Bn);
          const r = 0.5 * e.distanceTo(t),
            s = -this.direction.dot(Rn),
            a = Dn.dot(this.direction),
            o = -Dn.dot(Rn),
            l = Dn.lengthSq(),
            c = Math.abs(1 - s * s);
          let u, h, d, p;
          if (c > 0)
            if (((u = s * o - a), (h = s * a - o), (p = r * c), u >= 0))
              if (h >= -p)
                if (h <= p) {
                  const e = 1 / c;
                  (u *= e),
                    (h *= e),
                    (d = u * (u + s * h + 2 * a) + h * (s * u + h + 2 * o) + l);
                } else
                  (h = r),
                    (u = Math.max(0, -(s * h + a))),
                    (d = -u * u + h * (h + 2 * o) + l);
              else
                (h = -r),
                  (u = Math.max(0, -(s * h + a))),
                  (d = -u * u + h * (h + 2 * o) + l);
            else
              h <= -p
                ? ((u = Math.max(0, -(-s * r + a))),
                  (h = u > 0 ? -r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + l))
                : h <= p
                ? ((u = 0),
                  (h = Math.min(Math.max(-r, -o), r)),
                  (d = h * (h + 2 * o) + l))
                : ((u = Math.max(0, -(s * r + a))),
                  (h = u > 0 ? r : Math.min(Math.max(-r, -o), r)),
                  (d = -u * u + h * (h + 2 * o) + l));
          else
            (h = s > 0 ? -r : r),
              (u = Math.max(0, -(s * h + a))),
              (d = -u * u + h * (h + 2 * o) + l);
          return (
            n && n.copy(this.origin).addScaledVector(this.direction, u),
            i && i.copy(Bn).addScaledVector(Rn, h),
            d
          );
        }
        intersectSphere(e, t) {
          Tn.subVectors(e.center, this.origin);
          const n = Tn.dot(this.direction),
            i = Tn.dot(Tn) - n * n,
            r = e.radius * e.radius;
          if (i > r) return null;
          const s = Math.sqrt(r - i),
            a = n - s,
            o = n + s;
          return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
        }
        intersectsSphere(e) {
          return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
        }
        distanceToPlane(e) {
          const t = e.normal.dot(this.direction);
          if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
          const n = -(this.origin.dot(e.normal) + e.constant) / t;
          return n >= 0 ? n : null;
        }
        intersectPlane(e, t) {
          const n = this.distanceToPlane(e);
          return null === n ? null : this.at(n, t);
        }
        intersectsPlane(e) {
          const t = e.distanceToPoint(this.origin);
          if (0 === t) return !0;
          return e.normal.dot(this.direction) * t < 0;
        }
        intersectBox(e, t) {
          let n, i, r, s, a, o;
          const l = 1 / this.direction.x,
            c = 1 / this.direction.y,
            u = 1 / this.direction.z,
            h = this.origin;
          return (
            l >= 0
              ? ((n = (e.min.x - h.x) * l), (i = (e.max.x - h.x) * l))
              : ((n = (e.max.x - h.x) * l), (i = (e.min.x - h.x) * l)),
            c >= 0
              ? ((r = (e.min.y - h.y) * c), (s = (e.max.y - h.y) * c))
              : ((r = (e.max.y - h.y) * c), (s = (e.min.y - h.y) * c)),
            n > s || r > i
              ? null
              : ((r > n || isNaN(n)) && (n = r),
                (s < i || isNaN(i)) && (i = s),
                u >= 0
                  ? ((a = (e.min.z - h.z) * u), (o = (e.max.z - h.z) * u))
                  : ((a = (e.max.z - h.z) * u), (o = (e.min.z - h.z) * u)),
                n > o || a > i
                  ? null
                  : ((a > n || n != n) && (n = a),
                    (o < i || i != i) && (i = o),
                    i < 0 ? null : this.at(n >= 0 ? n : i, t)))
          );
        }
        intersectsBox(e) {
          return null !== this.intersectBox(e, Tn);
        }
        intersectTriangle(e, t, n, i, r) {
          Pn.subVectors(t, e), Ln.subVectors(n, e), Un.crossVectors(Pn, Ln);
          let s,
            a = this.direction.dot(Un);
          if (a > 0) {
            if (i) return null;
            s = 1;
          } else {
            if (!(a < 0)) return null;
            (s = -1), (a = -a);
          }
          Dn.subVectors(this.origin, e);
          const o = s * this.direction.dot(Ln.crossVectors(Dn, Ln));
          if (o < 0) return null;
          const l = s * this.direction.dot(Pn.cross(Dn));
          if (l < 0) return null;
          if (o + l > a) return null;
          const c = -s * Dn.dot(Un);
          return c < 0 ? null : this.at(c / a, r);
        }
        applyMatrix4(e) {
          return (
            this.origin.applyMatrix4(e),
            this.direction.transformDirection(e),
            this
          );
        }
        equals(e) {
          return (
            e.origin.equals(this.origin) && e.direction.equals(this.direction)
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      class Nn {
        constructor(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A) {
          (Nn.prototype.isMatrix4 = !0),
            (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
            void 0 !== e &&
              this.set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A);
        }
        set(e, t, n, i, r, s, a, o, l, c, u, h, d, p, f, A) {
          const g = this.elements;
          return (
            (g[0] = e),
            (g[4] = t),
            (g[8] = n),
            (g[12] = i),
            (g[1] = r),
            (g[5] = s),
            (g[9] = a),
            (g[13] = o),
            (g[2] = l),
            (g[6] = c),
            (g[10] = u),
            (g[14] = h),
            (g[3] = d),
            (g[7] = p),
            (g[11] = f),
            (g[15] = A),
            this
          );
        }
        identity() {
          return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
        }
        clone() {
          return new Nn().fromArray(this.elements);
        }
        copy(e) {
          const t = this.elements,
            n = e.elements;
          return (
            (t[0] = n[0]),
            (t[1] = n[1]),
            (t[2] = n[2]),
            (t[3] = n[3]),
            (t[4] = n[4]),
            (t[5] = n[5]),
            (t[6] = n[6]),
            (t[7] = n[7]),
            (t[8] = n[8]),
            (t[9] = n[9]),
            (t[10] = n[10]),
            (t[11] = n[11]),
            (t[12] = n[12]),
            (t[13] = n[13]),
            (t[14] = n[14]),
            (t[15] = n[15]),
            this
          );
        }
        copyPosition(e) {
          const t = this.elements,
            n = e.elements;
          return (t[12] = n[12]), (t[13] = n[13]), (t[14] = n[14]), this;
        }
        setFromMatrix3(e) {
          const t = e.elements;
          return (
            this.set(
              t[0],
              t[3],
              t[6],
              0,
              t[1],
              t[4],
              t[7],
              0,
              t[2],
              t[5],
              t[8],
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractBasis(e, t, n) {
          return (
            e.setFromMatrixColumn(this, 0),
            t.setFromMatrixColumn(this, 1),
            n.setFromMatrixColumn(this, 2),
            this
          );
        }
        makeBasis(e, t, n) {
          return (
            this.set(
              e.x,
              t.x,
              n.x,
              0,
              e.y,
              t.y,
              n.y,
              0,
              e.z,
              t.z,
              n.z,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        extractRotation(e) {
          const t = this.elements,
            n = e.elements,
            i = 1 / On.setFromMatrixColumn(e, 0).length(),
            r = 1 / On.setFromMatrixColumn(e, 1).length(),
            s = 1 / On.setFromMatrixColumn(e, 2).length();
          return (
            (t[0] = n[0] * i),
            (t[1] = n[1] * i),
            (t[2] = n[2] * i),
            (t[3] = 0),
            (t[4] = n[4] * r),
            (t[5] = n[5] * r),
            (t[6] = n[6] * r),
            (t[7] = 0),
            (t[8] = n[8] * s),
            (t[9] = n[9] * s),
            (t[10] = n[10] * s),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromEuler(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z,
            s = Math.cos(n),
            a = Math.sin(n),
            o = Math.cos(i),
            l = Math.sin(i),
            c = Math.cos(r),
            u = Math.sin(r);
          if ("XYZ" === e.order) {
            const e = s * c,
              n = s * u,
              i = a * c,
              r = a * u;
            (t[0] = o * c),
              (t[4] = -o * u),
              (t[8] = l),
              (t[1] = n + i * l),
              (t[5] = e - r * l),
              (t[9] = -a * o),
              (t[2] = r - e * l),
              (t[6] = i + n * l),
              (t[10] = s * o);
          } else if ("YXZ" === e.order) {
            const e = o * c,
              n = o * u,
              i = l * c,
              r = l * u;
            (t[0] = e + r * a),
              (t[4] = i * a - n),
              (t[8] = s * l),
              (t[1] = s * u),
              (t[5] = s * c),
              (t[9] = -a),
              (t[2] = n * a - i),
              (t[6] = r + e * a),
              (t[10] = s * o);
          } else if ("ZXY" === e.order) {
            const e = o * c,
              n = o * u,
              i = l * c,
              r = l * u;
            (t[0] = e - r * a),
              (t[4] = -s * u),
              (t[8] = i + n * a),
              (t[1] = n + i * a),
              (t[5] = s * c),
              (t[9] = r - e * a),
              (t[2] = -s * l),
              (t[6] = a),
              (t[10] = s * o);
          } else if ("ZYX" === e.order) {
            const e = s * c,
              n = s * u,
              i = a * c,
              r = a * u;
            (t[0] = o * c),
              (t[4] = i * l - n),
              (t[8] = e * l + r),
              (t[1] = o * u),
              (t[5] = r * l + e),
              (t[9] = n * l - i),
              (t[2] = -l),
              (t[6] = a * o),
              (t[10] = s * o);
          } else if ("YZX" === e.order) {
            const e = s * o,
              n = s * l,
              i = a * o,
              r = a * l;
            (t[0] = o * c),
              (t[4] = r - e * u),
              (t[8] = i * u + n),
              (t[1] = u),
              (t[5] = s * c),
              (t[9] = -a * c),
              (t[2] = -l * c),
              (t[6] = n * u + i),
              (t[10] = e - r * u);
          } else if ("XZY" === e.order) {
            const e = s * o,
              n = s * l,
              i = a * o,
              r = a * l;
            (t[0] = o * c),
              (t[4] = -u),
              (t[8] = l * c),
              (t[1] = e * u + r),
              (t[5] = s * c),
              (t[9] = n * u - i),
              (t[2] = i * u - n),
              (t[6] = a * c),
              (t[10] = r * u + e);
          }
          return (
            (t[3] = 0),
            (t[7] = 0),
            (t[11] = 0),
            (t[12] = 0),
            (t[13] = 0),
            (t[14] = 0),
            (t[15] = 1),
            this
          );
        }
        makeRotationFromQuaternion(e) {
          return this.compose(kn, e, Gn);
        }
        lookAt(e, t, n) {
          const i = this.elements;
          return (
            Vn.subVectors(e, t),
            0 === Vn.lengthSq() && (Vn.z = 1),
            Vn.normalize(),
            Hn.crossVectors(n, Vn),
            0 === Hn.lengthSq() &&
              (1 === Math.abs(n.z) ? (Vn.x += 1e-4) : (Vn.z += 1e-4),
              Vn.normalize(),
              Hn.crossVectors(n, Vn)),
            Hn.normalize(),
            zn.crossVectors(Vn, Hn),
            (i[0] = Hn.x),
            (i[4] = zn.x),
            (i[8] = Vn.x),
            (i[1] = Hn.y),
            (i[5] = zn.y),
            (i[9] = Vn.y),
            (i[2] = Hn.z),
            (i[6] = zn.z),
            (i[10] = Vn.z),
            this
          );
        }
        multiply(e) {
          return this.multiplyMatrices(this, e);
        }
        premultiply(e) {
          return this.multiplyMatrices(e, this);
        }
        multiplyMatrices(e, t) {
          const n = e.elements,
            i = t.elements,
            r = this.elements,
            s = n[0],
            a = n[4],
            o = n[8],
            l = n[12],
            c = n[1],
            u = n[5],
            h = n[9],
            d = n[13],
            p = n[2],
            f = n[6],
            A = n[10],
            g = n[14],
            m = n[3],
            v = n[7],
            y = n[11],
            x = n[15],
            _ = i[0],
            b = i[4],
            E = i[8],
            w = i[12],
            C = i[1],
            I = i[5],
            S = i[9],
            M = i[13],
            T = i[2],
            B = i[6],
            R = i[10],
            D = i[14],
            P = i[3],
            L = i[7],
            U = i[11],
            F = i[15];
          return (
            (r[0] = s * _ + a * C + o * T + l * P),
            (r[4] = s * b + a * I + o * B + l * L),
            (r[8] = s * E + a * S + o * R + l * U),
            (r[12] = s * w + a * M + o * D + l * F),
            (r[1] = c * _ + u * C + h * T + d * P),
            (r[5] = c * b + u * I + h * B + d * L),
            (r[9] = c * E + u * S + h * R + d * U),
            (r[13] = c * w + u * M + h * D + d * F),
            (r[2] = p * _ + f * C + A * T + g * P),
            (r[6] = p * b + f * I + A * B + g * L),
            (r[10] = p * E + f * S + A * R + g * U),
            (r[14] = p * w + f * M + A * D + g * F),
            (r[3] = m * _ + v * C + y * T + x * P),
            (r[7] = m * b + v * I + y * B + x * L),
            (r[11] = m * E + v * S + y * R + x * U),
            (r[15] = m * w + v * M + y * D + x * F),
            this
          );
        }
        multiplyScalar(e) {
          const t = this.elements;
          return (
            (t[0] *= e),
            (t[4] *= e),
            (t[8] *= e),
            (t[12] *= e),
            (t[1] *= e),
            (t[5] *= e),
            (t[9] *= e),
            (t[13] *= e),
            (t[2] *= e),
            (t[6] *= e),
            (t[10] *= e),
            (t[14] *= e),
            (t[3] *= e),
            (t[7] *= e),
            (t[11] *= e),
            (t[15] *= e),
            this
          );
        }
        determinant() {
          const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            r = e[12],
            s = e[1],
            a = e[5],
            o = e[9],
            l = e[13],
            c = e[2],
            u = e[6],
            h = e[10],
            d = e[14];
          return (
            e[3] *
              (+r * o * u -
                i * l * u -
                r * a * h +
                n * l * h +
                i * a * d -
                n * o * d) +
            e[7] *
              (+t * o * d -
                t * l * h +
                r * s * h -
                i * s * d +
                i * l * c -
                r * o * c) +
            e[11] *
              (+t * l * u -
                t * a * d -
                r * s * u +
                n * s * d +
                r * a * c -
                n * l * c) +
            e[15] *
              (-i * a * c -
                t * o * u +
                t * a * h +
                i * s * u -
                n * s * h +
                n * o * c)
          );
        }
        transpose() {
          const e = this.elements;
          let t;
          return (
            (t = e[1]),
            (e[1] = e[4]),
            (e[4] = t),
            (t = e[2]),
            (e[2] = e[8]),
            (e[8] = t),
            (t = e[6]),
            (e[6] = e[9]),
            (e[9] = t),
            (t = e[3]),
            (e[3] = e[12]),
            (e[12] = t),
            (t = e[7]),
            (e[7] = e[13]),
            (e[13] = t),
            (t = e[11]),
            (e[11] = e[14]),
            (e[14] = t),
            this
          );
        }
        setPosition(e, t, n) {
          const i = this.elements;
          return (
            e.isVector3
              ? ((i[12] = e.x), (i[13] = e.y), (i[14] = e.z))
              : ((i[12] = e), (i[13] = t), (i[14] = n)),
            this
          );
        }
        invert() {
          const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            r = e[3],
            s = e[4],
            a = e[5],
            o = e[6],
            l = e[7],
            c = e[8],
            u = e[9],
            h = e[10],
            d = e[11],
            p = e[12],
            f = e[13],
            A = e[14],
            g = e[15],
            m =
              u * A * l -
              f * h * l +
              f * o * d -
              a * A * d -
              u * o * g +
              a * h * g,
            v =
              p * h * l -
              c * A * l -
              p * o * d +
              s * A * d +
              c * o * g -
              s * h * g,
            y =
              c * f * l -
              p * u * l +
              p * a * d -
              s * f * d -
              c * a * g +
              s * u * g,
            x =
              p * u * o -
              c * f * o -
              p * a * h +
              s * f * h +
              c * a * A -
              s * u * A,
            _ = t * m + n * v + i * y + r * x;
          if (0 === _)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
          const b = 1 / _;
          return (
            (e[0] = m * b),
            (e[1] =
              (f * h * r -
                u * A * r -
                f * i * d +
                n * A * d +
                u * i * g -
                n * h * g) *
              b),
            (e[2] =
              (a * A * r -
                f * o * r +
                f * i * l -
                n * A * l -
                a * i * g +
                n * o * g) *
              b),
            (e[3] =
              (u * o * r -
                a * h * r -
                u * i * l +
                n * h * l +
                a * i * d -
                n * o * d) *
              b),
            (e[4] = v * b),
            (e[5] =
              (c * A * r -
                p * h * r +
                p * i * d -
                t * A * d -
                c * i * g +
                t * h * g) *
              b),
            (e[6] =
              (p * o * r -
                s * A * r -
                p * i * l +
                t * A * l +
                s * i * g -
                t * o * g) *
              b),
            (e[7] =
              (s * h * r -
                c * o * r +
                c * i * l -
                t * h * l -
                s * i * d +
                t * o * d) *
              b),
            (e[8] = y * b),
            (e[9] =
              (p * u * r -
                c * f * r -
                p * n * d +
                t * f * d +
                c * n * g -
                t * u * g) *
              b),
            (e[10] =
              (s * f * r -
                p * a * r +
                p * n * l -
                t * f * l -
                s * n * g +
                t * a * g) *
              b),
            (e[11] =
              (c * a * r -
                s * u * r -
                c * n * l +
                t * u * l +
                s * n * d -
                t * a * d) *
              b),
            (e[12] = x * b),
            (e[13] =
              (c * f * i -
                p * u * i +
                p * n * h -
                t * f * h -
                c * n * A +
                t * u * A) *
              b),
            (e[14] =
              (p * a * i -
                s * f * i -
                p * n * o +
                t * f * o +
                s * n * A -
                t * a * A) *
              b),
            (e[15] =
              (s * u * i -
                c * a * i +
                c * n * o -
                t * u * o -
                s * n * h +
                t * a * h) *
              b),
            this
          );
        }
        scale(e) {
          const t = this.elements,
            n = e.x,
            i = e.y,
            r = e.z;
          return (
            (t[0] *= n),
            (t[4] *= i),
            (t[8] *= r),
            (t[1] *= n),
            (t[5] *= i),
            (t[9] *= r),
            (t[2] *= n),
            (t[6] *= i),
            (t[10] *= r),
            (t[3] *= n),
            (t[7] *= i),
            (t[11] *= r),
            this
          );
        }
        getMaxScaleOnAxis() {
          const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
          return Math.sqrt(Math.max(t, n, i));
        }
        makeTranslation(e, t, n) {
          return (
            e.isVector3
              ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
              : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
            this
          );
        }
        makeRotationX(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationY(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationZ(e) {
          const t = Math.cos(e),
            n = Math.sin(e);
          return (
            this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
          );
        }
        makeRotationAxis(e, t) {
          const n = Math.cos(t),
            i = Math.sin(t),
            r = 1 - n,
            s = e.x,
            a = e.y,
            o = e.z,
            l = r * s,
            c = r * a;
          return (
            this.set(
              l * s + n,
              l * a - i * o,
              l * o + i * a,
              0,
              l * a + i * o,
              c * a + n,
              c * o - i * s,
              0,
              l * o - i * a,
              c * o + i * s,
              r * o * o + n,
              0,
              0,
              0,
              0,
              1
            ),
            this
          );
        }
        makeScale(e, t, n) {
          return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this;
        }
        makeShear(e, t, n, i, r, s) {
          return this.set(1, n, r, 0, e, 1, s, 0, t, i, 1, 0, 0, 0, 0, 1), this;
        }
        compose(e, t, n) {
          const i = this.elements,
            r = t._x,
            s = t._y,
            a = t._z,
            o = t._w,
            l = r + r,
            c = s + s,
            u = a + a,
            h = r * l,
            d = r * c,
            p = r * u,
            f = s * c,
            A = s * u,
            g = a * u,
            m = o * l,
            v = o * c,
            y = o * u,
            x = n.x,
            _ = n.y,
            b = n.z;
          return (
            (i[0] = (1 - (f + g)) * x),
            (i[1] = (d + y) * x),
            (i[2] = (p - v) * x),
            (i[3] = 0),
            (i[4] = (d - y) * _),
            (i[5] = (1 - (h + g)) * _),
            (i[6] = (A + m) * _),
            (i[7] = 0),
            (i[8] = (p + v) * b),
            (i[9] = (A - m) * b),
            (i[10] = (1 - (h + f)) * b),
            (i[11] = 0),
            (i[12] = e.x),
            (i[13] = e.y),
            (i[14] = e.z),
            (i[15] = 1),
            this
          );
        }
        decompose(e, t, n) {
          const i = this.elements;
          let r = On.set(i[0], i[1], i[2]).length();
          const s = On.set(i[4], i[5], i[6]).length(),
            a = On.set(i[8], i[9], i[10]).length();
          this.determinant() < 0 && (r = -r),
            (e.x = i[12]),
            (e.y = i[13]),
            (e.z = i[14]),
            Qn.copy(this);
          const o = 1 / r,
            l = 1 / s,
            c = 1 / a;
          return (
            (Qn.elements[0] *= o),
            (Qn.elements[1] *= o),
            (Qn.elements[2] *= o),
            (Qn.elements[4] *= l),
            (Qn.elements[5] *= l),
            (Qn.elements[6] *= l),
            (Qn.elements[8] *= c),
            (Qn.elements[9] *= c),
            (Qn.elements[10] *= c),
            t.setFromRotationMatrix(Qn),
            (n.x = r),
            (n.y = s),
            (n.z = a),
            this
          );
        }
        makePerspective(e, t, n, i, r, s, a = 2e3) {
          const o = this.elements,
            l = (2 * r) / (t - e),
            c = (2 * r) / (n - i),
            u = (t + e) / (t - e),
            h = (n + i) / (n - i);
          let d, p;
          if (a === mt) (d = -(s + r) / (s - r)), (p = (-2 * s * r) / (s - r));
          else {
            if (a !== vt)
              throw new Error(
                "THREE.Matrix4.makePerspective(): Invalid coordinate system: " +
                  a
              );
            (d = -s / (s - r)), (p = (-s * r) / (s - r));
          }
          return (
            (o[0] = l),
            (o[4] = 0),
            (o[8] = u),
            (o[12] = 0),
            (o[1] = 0),
            (o[5] = c),
            (o[9] = h),
            (o[13] = 0),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = d),
            (o[14] = p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = -1),
            (o[15] = 0),
            this
          );
        }
        makeOrthographic(e, t, n, i, r, s, a = 2e3) {
          const o = this.elements,
            l = 1 / (t - e),
            c = 1 / (n - i),
            u = 1 / (s - r),
            h = (t + e) * l,
            d = (n + i) * c;
          let p, f;
          if (a === mt) (p = (s + r) * u), (f = -2 * u);
          else {
            if (a !== vt)
              throw new Error(
                "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " +
                  a
              );
            (p = r * u), (f = -1 * u);
          }
          return (
            (o[0] = 2 * l),
            (o[4] = 0),
            (o[8] = 0),
            (o[12] = -h),
            (o[1] = 0),
            (o[5] = 2 * c),
            (o[9] = 0),
            (o[13] = -d),
            (o[2] = 0),
            (o[6] = 0),
            (o[10] = f),
            (o[14] = -p),
            (o[3] = 0),
            (o[7] = 0),
            (o[11] = 0),
            (o[15] = 1),
            this
          );
        }
        equals(e) {
          const t = this.elements,
            n = e.elements;
          for (let e = 0; e < 16; e++) if (t[e] !== n[e]) return !1;
          return !0;
        }
        fromArray(e, t = 0) {
          for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
          return this;
        }
        toArray(e = [], t = 0) {
          const n = this.elements;
          return (
            (e[t] = n[0]),
            (e[t + 1] = n[1]),
            (e[t + 2] = n[2]),
            (e[t + 3] = n[3]),
            (e[t + 4] = n[4]),
            (e[t + 5] = n[5]),
            (e[t + 6] = n[6]),
            (e[t + 7] = n[7]),
            (e[t + 8] = n[8]),
            (e[t + 9] = n[9]),
            (e[t + 10] = n[10]),
            (e[t + 11] = n[11]),
            (e[t + 12] = n[12]),
            (e[t + 13] = n[13]),
            (e[t + 14] = n[14]),
            (e[t + 15] = n[15]),
            e
          );
        }
      }
      const On = new on(),
        Qn = new Nn(),
        kn = new on(0, 0, 0),
        Gn = new on(1, 1, 1),
        Hn = new on(),
        zn = new on(),
        Vn = new on(),
        Wn = new Nn(),
        jn = new an();
      class qn {
        constructor(e = 0, t = 0, n = 0, i = qn.DEFAULT_ORDER) {
          (this.isEuler = !0),
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i);
        }
        get x() {
          return this._x;
        }
        set x(e) {
          (this._x = e), this._onChangeCallback();
        }
        get y() {
          return this._y;
        }
        set y(e) {
          (this._y = e), this._onChangeCallback();
        }
        get z() {
          return this._z;
        }
        set z(e) {
          (this._z = e), this._onChangeCallback();
        }
        get order() {
          return this._order;
        }
        set order(e) {
          (this._order = e), this._onChangeCallback();
        }
        set(e, t, n, i = this._order) {
          return (
            (this._x = e),
            (this._y = t),
            (this._z = n),
            (this._order = i),
            this._onChangeCallback(),
            this
          );
        }
        clone() {
          return new this.constructor(this._x, this._y, this._z, this._order);
        }
        copy(e) {
          return (
            (this._x = e._x),
            (this._y = e._y),
            (this._z = e._z),
            (this._order = e._order),
            this._onChangeCallback(),
            this
          );
        }
        setFromRotationMatrix(e, t = this._order, n = !0) {
          const i = e.elements,
            r = i[0],
            s = i[4],
            a = i[8],
            o = i[1],
            l = i[5],
            c = i[9],
            u = i[2],
            h = i[6],
            d = i[10];
          switch (t) {
            case "XYZ":
              (this._y = Math.asin(Ct(a, -1, 1))),
                Math.abs(a) < 0.9999999
                  ? ((this._x = Math.atan2(-c, d)),
                    (this._z = Math.atan2(-s, r)))
                  : ((this._x = Math.atan2(h, l)), (this._z = 0));
              break;
            case "YXZ":
              (this._x = Math.asin(-Ct(c, -1, 1))),
                Math.abs(c) < 0.9999999
                  ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
                  : ((this._y = Math.atan2(-u, r)), (this._z = 0));
              break;
            case "ZXY":
              (this._x = Math.asin(Ct(h, -1, 1))),
                Math.abs(h) < 0.9999999
                  ? ((this._y = Math.atan2(-u, d)),
                    (this._z = Math.atan2(-s, l)))
                  : ((this._y = 0), (this._z = Math.atan2(o, r)));
              break;
            case "ZYX":
              (this._y = Math.asin(-Ct(u, -1, 1))),
                Math.abs(u) < 0.9999999
                  ? ((this._x = Math.atan2(h, d)), (this._z = Math.atan2(o, r)))
                  : ((this._x = 0), (this._z = Math.atan2(-s, l)));
              break;
            case "YZX":
              (this._z = Math.asin(Ct(o, -1, 1))),
                Math.abs(o) < 0.9999999
                  ? ((this._x = Math.atan2(-c, l)),
                    (this._y = Math.atan2(-u, r)))
                  : ((this._x = 0), (this._y = Math.atan2(a, d)));
              break;
            case "XZY":
              (this._z = Math.asin(-Ct(s, -1, 1))),
                Math.abs(s) < 0.9999999
                  ? ((this._x = Math.atan2(h, l)), (this._y = Math.atan2(a, r)))
                  : ((this._x = Math.atan2(-c, d)), (this._y = 0));
              break;
            default:
              console.warn(
                "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
                  t
              );
          }
          return (this._order = t), !0 === n && this._onChangeCallback(), this;
        }
        setFromQuaternion(e, t, n) {
          return (
            Wn.makeRotationFromQuaternion(e),
            this.setFromRotationMatrix(Wn, t, n)
          );
        }
        setFromVector3(e, t = this._order) {
          return this.set(e.x, e.y, e.z, t);
        }
        reorder(e) {
          return jn.setFromEuler(this), this.setFromQuaternion(jn, e);
        }
        equals(e) {
          return (
            e._x === this._x &&
            e._y === this._y &&
            e._z === this._z &&
            e._order === this._order
          );
        }
        fromArray(e) {
          return (
            (this._x = e[0]),
            (this._y = e[1]),
            (this._z = e[2]),
            void 0 !== e[3] && (this._order = e[3]),
            this._onChangeCallback(),
            this
          );
        }
        toArray(e = [], t = 0) {
          return (
            (e[t] = this._x),
            (e[t + 1] = this._y),
            (e[t + 2] = this._z),
            (e[t + 3] = this._order),
            e
          );
        }
        _onChange(e) {
          return (this._onChangeCallback = e), this;
        }
        _onChangeCallback() {}
        *[Symbol.iterator]() {
          yield this._x, yield this._y, yield this._z, yield this._order;
        }
      }
      qn.DEFAULT_ORDER = "XYZ";
      class Yn {
        constructor() {
          this.mask = 1;
        }
        set(e) {
          this.mask = (1 << e) >>> 0;
        }
        enable(e) {
          this.mask |= 1 << e;
        }
        enableAll() {
          this.mask = -1;
        }
        toggle(e) {
          this.mask ^= 1 << e;
        }
        disable(e) {
          this.mask &= ~(1 << e);
        }
        disableAll() {
          this.mask = 0;
        }
        test(e) {
          return !!(this.mask & e.mask);
        }
        isEnabled(e) {
          return !!(this.mask & (1 << e));
        }
      }
      let Xn = 0;
      const Kn = new on(),
        Jn = new an(),
        Zn = new Nn(),
        $n = new on(),
        ei = new on(),
        ti = new on(),
        ni = new an(),
        ii = new on(1, 0, 0),
        ri = new on(0, 1, 0),
        si = new on(0, 0, 1),
        ai = { type: "added" },
        oi = { type: "removed" },
        li = { type: "childadded", child: null },
        ci = { type: "childremoved", child: null };
      class ui extends yt {
        constructor() {
          super(),
            (this.isObject3D = !0),
            Object.defineProperty(this, "id", { value: Xn++ }),
            (this.uuid = wt()),
            (this.name = ""),
            (this.type = "Object3D"),
            (this.parent = null),
            (this.children = []),
            (this.up = ui.DEFAULT_UP.clone());
          const e = new on(),
            t = new qn(),
            n = new an(),
            i = new on(1, 1, 1);
          t._onChange(function () {
            n.setFromEuler(t, !1);
          }),
            n._onChange(function () {
              t.setFromQuaternion(n, void 0, !1);
            }),
            Object.defineProperties(this, {
              position: { configurable: !0, enumerable: !0, value: e },
              rotation: { configurable: !0, enumerable: !0, value: t },
              quaternion: { configurable: !0, enumerable: !0, value: n },
              scale: { configurable: !0, enumerable: !0, value: i },
              modelViewMatrix: { value: new Nn() },
              normalMatrix: { value: new Dt() },
            }),
            (this.matrix = new Nn()),
            (this.matrixWorld = new Nn()),
            (this.matrixAutoUpdate = ui.DEFAULT_MATRIX_AUTO_UPDATE),
            (this.matrixWorldAutoUpdate = ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
            (this.matrixWorldNeedsUpdate = !1),
            (this.layers = new Yn()),
            (this.visible = !0),
            (this.castShadow = !1),
            (this.receiveShadow = !1),
            (this.frustumCulled = !0),
            (this.renderOrder = 0),
            (this.animations = []),
            (this.userData = {});
        }
        onBeforeShadow() {}
        onAfterShadow() {}
        onBeforeRender() {}
        onAfterRender() {}
        applyMatrix4(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            this.matrix.premultiply(e),
            this.matrix.decompose(this.position, this.quaternion, this.scale);
        }
        applyQuaternion(e) {
          return this.quaternion.premultiply(e), this;
        }
        setRotationFromAxisAngle(e, t) {
          this.quaternion.setFromAxisAngle(e, t);
        }
        setRotationFromEuler(e) {
          this.quaternion.setFromEuler(e, !0);
        }
        setRotationFromMatrix(e) {
          this.quaternion.setFromRotationMatrix(e);
        }
        setRotationFromQuaternion(e) {
          this.quaternion.copy(e);
        }
        rotateOnAxis(e, t) {
          return Jn.setFromAxisAngle(e, t), this.quaternion.multiply(Jn), this;
        }
        rotateOnWorldAxis(e, t) {
          return (
            Jn.setFromAxisAngle(e, t), this.quaternion.premultiply(Jn), this
          );
        }
        rotateX(e) {
          return this.rotateOnAxis(ii, e);
        }
        rotateY(e) {
          return this.rotateOnAxis(ri, e);
        }
        rotateZ(e) {
          return this.rotateOnAxis(si, e);
        }
        translateOnAxis(e, t) {
          return (
            Kn.copy(e).applyQuaternion(this.quaternion),
            this.position.add(Kn.multiplyScalar(t)),
            this
          );
        }
        translateX(e) {
          return this.translateOnAxis(ii, e);
        }
        translateY(e) {
          return this.translateOnAxis(ri, e);
        }
        translateZ(e) {
          return this.translateOnAxis(si, e);
        }
        localToWorld(e) {
          return (
            this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
          );
        }
        worldToLocal(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.applyMatrix4(Zn.copy(this.matrixWorld).invert())
          );
        }
        lookAt(e, t, n) {
          e.isVector3 ? $n.copy(e) : $n.set(e, t, n);
          const i = this.parent;
          this.updateWorldMatrix(!0, !1),
            ei.setFromMatrixPosition(this.matrixWorld),
            this.isCamera || this.isLight
              ? Zn.lookAt(ei, $n, this.up)
              : Zn.lookAt($n, ei, this.up),
            this.quaternion.setFromRotationMatrix(Zn),
            i &&
              (Zn.extractRotation(i.matrixWorld),
              Jn.setFromRotationMatrix(Zn),
              this.quaternion.premultiply(Jn.invert()));
        }
        add(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
            return this;
          }
          return e === this
            ? (console.error(
                "THREE.Object3D.add: object can't be added as a child of itself.",
                e
              ),
              this)
            : (e && e.isObject3D
                ? (e.removeFromParent(),
                  (e.parent = this),
                  this.children.push(e),
                  e.dispatchEvent(ai),
                  (li.child = e),
                  this.dispatchEvent(li),
                  (li.child = null))
                : console.error(
                    "THREE.Object3D.add: object not an instance of THREE.Object3D.",
                    e
                  ),
              this);
        }
        remove(e) {
          if (arguments.length > 1) {
            for (let e = 0; e < arguments.length; e++)
              this.remove(arguments[e]);
            return this;
          }
          const t = this.children.indexOf(e);
          return (
            -1 !== t &&
              ((e.parent = null),
              this.children.splice(t, 1),
              e.dispatchEvent(oi),
              (ci.child = e),
              this.dispatchEvent(ci),
              (ci.child = null)),
            this
          );
        }
        removeFromParent() {
          const e = this.parent;
          return null !== e && e.remove(this), this;
        }
        clear() {
          return this.remove(...this.children);
        }
        attach(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            Zn.copy(this.matrixWorld).invert(),
            null !== e.parent &&
              (e.parent.updateWorldMatrix(!0, !1),
              Zn.multiply(e.parent.matrixWorld)),
            e.applyMatrix4(Zn),
            e.removeFromParent(),
            (e.parent = this),
            this.children.push(e),
            e.updateWorldMatrix(!1, !0),
            e.dispatchEvent(ai),
            (li.child = e),
            this.dispatchEvent(li),
            (li.child = null),
            this
          );
        }
        getObjectById(e) {
          return this.getObjectByProperty("id", e);
        }
        getObjectByName(e) {
          return this.getObjectByProperty("name", e);
        }
        getObjectByProperty(e, t) {
          if (this[e] === t) return this;
          for (let n = 0, i = this.children.length; n < i; n++) {
            const i = this.children[n].getObjectByProperty(e, t);
            if (void 0 !== i) return i;
          }
        }
        getObjectsByProperty(e, t, n = []) {
          this[e] === t && n.push(this);
          const i = this.children;
          for (let r = 0, s = i.length; r < s; r++)
            i[r].getObjectsByProperty(e, t, n);
          return n;
        }
        getWorldPosition(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            e.setFromMatrixPosition(this.matrixWorld)
          );
        }
        getWorldQuaternion(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(ei, e, ti),
            e
          );
        }
        getWorldScale(e) {
          return (
            this.updateWorldMatrix(!0, !1),
            this.matrixWorld.decompose(ei, ni, e),
            e
          );
        }
        getWorldDirection(e) {
          this.updateWorldMatrix(!0, !1);
          const t = this.matrixWorld.elements;
          return e.set(t[8], t[9], t[10]).normalize();
        }
        raycast() {}
        traverse(e) {
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e);
        }
        traverseVisible(e) {
          if (!1 === this.visible) return;
          e(this);
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e);
        }
        traverseAncestors(e) {
          const t = this.parent;
          null !== t && (e(t), t.traverseAncestors(e));
        }
        updateMatrix() {
          this.matrix.compose(this.position, this.quaternion, this.scale),
            (this.matrixWorldNeedsUpdate = !0);
        }
        updateMatrixWorld(e) {
          this.matrixAutoUpdate && this.updateMatrix(),
            (this.matrixWorldNeedsUpdate || e) &&
              (!0 === this.matrixWorldAutoUpdate &&
                (null === this.parent
                  ? this.matrixWorld.copy(this.matrix)
                  : this.matrixWorld.multiplyMatrices(
                      this.parent.matrixWorld,
                      this.matrix
                    )),
              (this.matrixWorldNeedsUpdate = !1),
              (e = !0));
          const t = this.children;
          for (let n = 0, i = t.length; n < i; n++) {
            t[n].updateMatrixWorld(e);
          }
        }
        updateWorldMatrix(e, t) {
          const n = this.parent;
          if (
            (!0 === e && null !== n && n.updateWorldMatrix(!0, !1),
            this.matrixAutoUpdate && this.updateMatrix(),
            !0 === this.matrixWorldAutoUpdate &&
              (null === this.parent
                ? this.matrixWorld.copy(this.matrix)
                : this.matrixWorld.multiplyMatrices(
                    this.parent.matrixWorld,
                    this.matrix
                  )),
            !0 === t)
          ) {
            const e = this.children;
            for (let t = 0, n = e.length; t < n; t++) {
              e[t].updateWorldMatrix(!1, !0);
            }
          }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e,
            n = {};
          t &&
            ((e = {
              geometries: {},
              materials: {},
              textures: {},
              images: {},
              shapes: {},
              skeletons: {},
              animations: {},
              nodes: {},
            }),
            (n.metadata = {
              version: 4.6,
              type: "Object",
              generator: "Object3D.toJSON",
            }));
          const i = {};
          function r(t, n) {
            return void 0 === t[n.uuid] && (t[n.uuid] = n.toJSON(e)), n.uuid;
          }
          if (
            ((i.uuid = this.uuid),
            (i.type = this.type),
            "" !== this.name && (i.name = this.name),
            !0 === this.castShadow && (i.castShadow = !0),
            !0 === this.receiveShadow && (i.receiveShadow = !0),
            !1 === this.visible && (i.visible = !1),
            !1 === this.frustumCulled && (i.frustumCulled = !1),
            0 !== this.renderOrder && (i.renderOrder = this.renderOrder),
            Object.keys(this.userData).length > 0 &&
              (i.userData = this.userData),
            (i.layers = this.layers.mask),
            (i.matrix = this.matrix.toArray()),
            (i.up = this.up.toArray()),
            !1 === this.matrixAutoUpdate && (i.matrixAutoUpdate = !1),
            this.isInstancedMesh &&
              ((i.type = "InstancedMesh"),
              (i.count = this.count),
              (i.instanceMatrix = this.instanceMatrix.toJSON()),
              null !== this.instanceColor &&
                (i.instanceColor = this.instanceColor.toJSON())),
            this.isBatchedMesh &&
              ((i.type = "BatchedMesh"),
              (i.perObjectFrustumCulled = this.perObjectFrustumCulled),
              (i.sortObjects = this.sortObjects),
              (i.drawRanges = this._drawRanges),
              (i.reservedRanges = this._reservedRanges),
              (i.visibility = this._visibility),
              (i.active = this._active),
              (i.bounds = this._bounds.map((e) => ({
                boxInitialized: e.boxInitialized,
                boxMin: e.box.min.toArray(),
                boxMax: e.box.max.toArray(),
                sphereInitialized: e.sphereInitialized,
                sphereRadius: e.sphere.radius,
                sphereCenter: e.sphere.center.toArray(),
              }))),
              (i.maxInstanceCount = this._maxInstanceCount),
              (i.maxVertexCount = this._maxVertexCount),
              (i.maxIndexCount = this._maxIndexCount),
              (i.geometryInitialized = this._geometryInitialized),
              (i.geometryCount = this._geometryCount),
              (i.matricesTexture = this._matricesTexture.toJSON(e)),
              null !== this._colorsTexture &&
                (i.colorsTexture = this._colorsTexture.toJSON(e)),
              null !== this.boundingSphere &&
                (i.boundingSphere = {
                  center: i.boundingSphere.center.toArray(),
                  radius: i.boundingSphere.radius,
                }),
              null !== this.boundingBox &&
                (i.boundingBox = {
                  min: i.boundingBox.min.toArray(),
                  max: i.boundingBox.max.toArray(),
                })),
            this.isScene)
          )
            this.background &&
              (this.background.isColor
                ? (i.background = this.background.toJSON())
                : this.background.isTexture &&
                  (i.background = this.background.toJSON(e).uuid)),
              this.environment &&
                this.environment.isTexture &&
                !0 !== this.environment.isRenderTargetTexture &&
                (i.environment = this.environment.toJSON(e).uuid);
          else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const t = this.geometry.parameters;
            if (void 0 !== t && void 0 !== t.shapes) {
              const n = t.shapes;
              if (Array.isArray(n))
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  r(e.shapes, i);
                }
              else r(e.shapes, n);
            }
          }
          if (
            (this.isSkinnedMesh &&
              ((i.bindMode = this.bindMode),
              (i.bindMatrix = this.bindMatrix.toArray()),
              void 0 !== this.skeleton &&
                (r(e.skeletons, this.skeleton),
                (i.skeleton = this.skeleton.uuid))),
            void 0 !== this.material)
          )
            if (Array.isArray(this.material)) {
              const t = [];
              for (let n = 0, i = this.material.length; n < i; n++)
                t.push(r(e.materials, this.material[n]));
              i.material = t;
            } else i.material = r(e.materials, this.material);
          if (this.children.length > 0) {
            i.children = [];
            for (let t = 0; t < this.children.length; t++)
              i.children.push(this.children[t].toJSON(e).object);
          }
          if (this.animations.length > 0) {
            i.animations = [];
            for (let t = 0; t < this.animations.length; t++) {
              const n = this.animations[t];
              i.animations.push(r(e.animations, n));
            }
          }
          if (t) {
            const t = s(e.geometries),
              i = s(e.materials),
              r = s(e.textures),
              a = s(e.images),
              o = s(e.shapes),
              l = s(e.skeletons),
              c = s(e.animations),
              u = s(e.nodes);
            t.length > 0 && (n.geometries = t),
              i.length > 0 && (n.materials = i),
              r.length > 0 && (n.textures = r),
              a.length > 0 && (n.images = a),
              o.length > 0 && (n.shapes = o),
              l.length > 0 && (n.skeletons = l),
              c.length > 0 && (n.animations = c),
              u.length > 0 && (n.nodes = u);
          }
          return (n.object = i), n;
          function s(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
        }
        clone(e) {
          return new this.constructor().copy(this, e);
        }
        copy(e, t = !0) {
          if (
            ((this.name = e.name),
            this.up.copy(e.up),
            this.position.copy(e.position),
            (this.rotation.order = e.rotation.order),
            this.quaternion.copy(e.quaternion),
            this.scale.copy(e.scale),
            this.matrix.copy(e.matrix),
            this.matrixWorld.copy(e.matrixWorld),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
            (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
            (this.layers.mask = e.layers.mask),
            (this.visible = e.visible),
            (this.castShadow = e.castShadow),
            (this.receiveShadow = e.receiveShadow),
            (this.frustumCulled = e.frustumCulled),
            (this.renderOrder = e.renderOrder),
            (this.animations = e.animations.slice()),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            !0 === t)
          )
            for (let t = 0; t < e.children.length; t++) {
              const n = e.children[t];
              this.add(n.clone());
            }
          return this;
        }
      }
      (ui.DEFAULT_UP = new on(0, 1, 0)),
        (ui.DEFAULT_MATRIX_AUTO_UPDATE = !0),
        (ui.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
      const hi = new on(),
        di = new on(),
        pi = new on(),
        fi = new on(),
        Ai = new on(),
        gi = new on(),
        mi = new on(),
        vi = new on(),
        yi = new on(),
        xi = new on(),
        _i = new en(),
        bi = new en(),
        Ei = new en();
      class wi {
        constructor(e = new on(), t = new on(), n = new on()) {
          (this.a = e), (this.b = t), (this.c = n);
        }
        static getNormal(e, t, n, i) {
          i.subVectors(n, t), hi.subVectors(e, t), i.cross(hi);
          const r = i.lengthSq();
          return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0);
        }
        static getBarycoord(e, t, n, i, r) {
          hi.subVectors(i, t), di.subVectors(n, t), pi.subVectors(e, t);
          const s = hi.dot(hi),
            a = hi.dot(di),
            o = hi.dot(pi),
            l = di.dot(di),
            c = di.dot(pi),
            u = s * l - a * a;
          if (0 === u) return r.set(0, 0, 0), null;
          const h = 1 / u,
            d = (l * o - a * c) * h,
            p = (s * c - a * o) * h;
          return r.set(1 - d - p, p, d);
        }
        static containsPoint(e, t, n, i) {
          return (
            null !== this.getBarycoord(e, t, n, i, fi) &&
            fi.x >= 0 &&
            fi.y >= 0 &&
            fi.x + fi.y <= 1
          );
        }
        static getInterpolation(e, t, n, i, r, s, a, o) {
          return null === this.getBarycoord(e, t, n, i, fi)
            ? ((o.x = 0),
              (o.y = 0),
              "z" in o && (o.z = 0),
              "w" in o && (o.w = 0),
              null)
            : (o.setScalar(0),
              o.addScaledVector(r, fi.x),
              o.addScaledVector(s, fi.y),
              o.addScaledVector(a, fi.z),
              o);
        }
        static getInterpolatedAttribute(e, t, n, i, r, s) {
          return (
            _i.setScalar(0),
            bi.setScalar(0),
            Ei.setScalar(0),
            _i.fromBufferAttribute(e, t),
            bi.fromBufferAttribute(e, n),
            Ei.fromBufferAttribute(e, i),
            s.setScalar(0),
            s.addScaledVector(_i, r.x),
            s.addScaledVector(bi, r.y),
            s.addScaledVector(Ei, r.z),
            s
          );
        }
        static isFrontFacing(e, t, n, i) {
          return (
            hi.subVectors(n, t), di.subVectors(e, t), hi.cross(di).dot(i) < 0
          );
        }
        set(e, t, n) {
          return this.a.copy(e), this.b.copy(t), this.c.copy(n), this;
        }
        setFromPointsAndIndices(e, t, n, i) {
          return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this;
        }
        setFromAttributeAndIndices(e, t, n, i) {
          return (
            this.a.fromBufferAttribute(e, t),
            this.b.fromBufferAttribute(e, n),
            this.c.fromBufferAttribute(e, i),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
        }
        getArea() {
          return (
            hi.subVectors(this.c, this.b),
            di.subVectors(this.a, this.b),
            0.5 * hi.cross(di).length()
          );
        }
        getMidpoint(e) {
          return e
            .addVectors(this.a, this.b)
            .add(this.c)
            .multiplyScalar(1 / 3);
        }
        getNormal(e) {
          return wi.getNormal(this.a, this.b, this.c, e);
        }
        getPlane(e) {
          return e.setFromCoplanarPoints(this.a, this.b, this.c);
        }
        getBarycoord(e, t) {
          return wi.getBarycoord(e, this.a, this.b, this.c, t);
        }
        getInterpolation(e, t, n, i, r) {
          return wi.getInterpolation(e, this.a, this.b, this.c, t, n, i, r);
        }
        containsPoint(e) {
          return wi.containsPoint(e, this.a, this.b, this.c);
        }
        isFrontFacing(e) {
          return wi.isFrontFacing(this.a, this.b, this.c, e);
        }
        intersectsBox(e) {
          return e.intersectsTriangle(this);
        }
        closestPointToPoint(e, t) {
          const n = this.a,
            i = this.b,
            r = this.c;
          let s, a;
          Ai.subVectors(i, n), gi.subVectors(r, n), vi.subVectors(e, n);
          const o = Ai.dot(vi),
            l = gi.dot(vi);
          if (o <= 0 && l <= 0) return t.copy(n);
          yi.subVectors(e, i);
          const c = Ai.dot(yi),
            u = gi.dot(yi);
          if (c >= 0 && u <= c) return t.copy(i);
          const h = o * u - c * l;
          if (h <= 0 && o >= 0 && c <= 0)
            return (s = o / (o - c)), t.copy(n).addScaledVector(Ai, s);
          xi.subVectors(e, r);
          const d = Ai.dot(xi),
            p = gi.dot(xi);
          if (p >= 0 && d <= p) return t.copy(r);
          const f = d * l - o * p;
          if (f <= 0 && l >= 0 && p <= 0)
            return (a = l / (l - p)), t.copy(n).addScaledVector(gi, a);
          const A = c * p - d * u;
          if (A <= 0 && u - c >= 0 && d - p >= 0)
            return (
              mi.subVectors(r, i),
              (a = (u - c) / (u - c + (d - p))),
              t.copy(i).addScaledVector(mi, a)
            );
          const g = 1 / (A + f + h);
          return (
            (s = f * g),
            (a = h * g),
            t.copy(n).addScaledVector(Ai, s).addScaledVector(gi, a)
          );
        }
        equals(e) {
          return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
        }
      }
      const Ci = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        },
        Ii = { h: 0, s: 0, l: 0 },
        Si = { h: 0, s: 0, l: 0 };
      function Mi(e, t, n) {
        return (
          n < 0 && (n += 1),
          n > 1 && (n -= 1),
          n < 1 / 6
            ? e + 6 * (t - e) * n
            : n < 0.5
            ? t
            : n < 2 / 3
            ? e + 6 * (t - e) * (2 / 3 - n)
            : e
        );
      }
      class Ti {
        constructor(e, t, n) {
          return (
            (this.isColor = !0),
            (this.r = 1),
            (this.g = 1),
            (this.b = 1),
            this.set(e, t, n)
          );
        }
        set(e, t, n) {
          if (void 0 === t && void 0 === n) {
            const t = e;
            t && t.isColor
              ? this.copy(t)
              : "number" == typeof t
              ? this.setHex(t)
              : "string" == typeof t && this.setStyle(t);
          } else this.setRGB(e, t, n);
          return this;
        }
        setScalar(e) {
          return (this.r = e), (this.g = e), (this.b = e), this;
        }
        setHex(e, t = ct) {
          return (
            (e = Math.floor(e)),
            (this.r = ((e >> 16) & 255) / 255),
            (this.g = ((e >> 8) & 255) / 255),
            (this.b = (255 & e) / 255),
            Qt.toWorkingColorSpace(this, t),
            this
          );
        }
        setRGB(e, t, n, i = Qt.workingColorSpace) {
          return (
            (this.r = e),
            (this.g = t),
            (this.b = n),
            Qt.toWorkingColorSpace(this, i),
            this
          );
        }
        setHSL(e, t, n, i = Qt.workingColorSpace) {
          if (((e = It(e, 1)), (t = Ct(t, 0, 1)), (n = Ct(n, 0, 1)), 0 === t))
            this.r = this.g = this.b = n;
          else {
            const i = n <= 0.5 ? n * (1 + t) : n + t - n * t,
              r = 2 * n - i;
            (this.r = Mi(r, i, e + 1 / 3)),
              (this.g = Mi(r, i, e)),
              (this.b = Mi(r, i, e - 1 / 3));
          }
          return Qt.toWorkingColorSpace(this, i), this;
        }
        setStyle(e, t = ct) {
          function n(t) {
            void 0 !== t &&
              parseFloat(t) < 1 &&
              console.warn(
                "THREE.Color: Alpha component of " + e + " will be ignored."
              );
          }
          let i;
          if ((i = /^(\w+)\(([^\)]*)\)/.exec(e))) {
            let r;
            const s = i[1],
              a = i[2];
            switch (s) {
              case "rgb":
              case "rgba":
                if (
                  (r =
                    /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(255, parseInt(r[1], 10)) / 255,
                      Math.min(255, parseInt(r[2], 10)) / 255,
                      Math.min(255, parseInt(r[3], 10)) / 255,
                      t
                    )
                  );
                if (
                  (r =
                    /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setRGB(
                      Math.min(100, parseInt(r[1], 10)) / 100,
                      Math.min(100, parseInt(r[2], 10)) / 100,
                      Math.min(100, parseInt(r[3], 10)) / 100,
                      t
                    )
                  );
                break;
              case "hsl":
              case "hsla":
                if (
                  (r =
                    /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                      a
                    ))
                )
                  return (
                    n(r[4]),
                    this.setHSL(
                      parseFloat(r[1]) / 360,
                      parseFloat(r[2]) / 100,
                      parseFloat(r[3]) / 100,
                      t
                    )
                  );
                break;
              default:
                console.warn("THREE.Color: Unknown color model " + e);
            }
          } else if ((i = /^\#([A-Fa-f\d]+)$/.exec(e))) {
            const n = i[1],
              r = n.length;
            if (3 === r)
              return this.setRGB(
                parseInt(n.charAt(0), 16) / 15,
                parseInt(n.charAt(1), 16) / 15,
                parseInt(n.charAt(2), 16) / 15,
                t
              );
            if (6 === r) return this.setHex(parseInt(n, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e);
          } else if (e && e.length > 0) return this.setColorName(e, t);
          return this;
        }
        setColorName(e, t = ct) {
          const n = Ci[e.toLowerCase()];
          return (
            void 0 !== n
              ? this.setHex(n, t)
              : console.warn("THREE.Color: Unknown color " + e),
            this
          );
        }
        clone() {
          return new this.constructor(this.r, this.g, this.b);
        }
        copy(e) {
          return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
        }
        copySRGBToLinear(e) {
          return (
            (this.r = kt(e.r)), (this.g = kt(e.g)), (this.b = kt(e.b)), this
          );
        }
        copyLinearToSRGB(e) {
          return (
            (this.r = Gt(e.r)), (this.g = Gt(e.g)), (this.b = Gt(e.b)), this
          );
        }
        convertSRGBToLinear() {
          return this.copySRGBToLinear(this), this;
        }
        convertLinearToSRGB() {
          return this.copyLinearToSRGB(this), this;
        }
        getHex(e = ct) {
          return (
            Qt.fromWorkingColorSpace(Bi.copy(this), e),
            65536 * Math.round(Ct(255 * Bi.r, 0, 255)) +
              256 * Math.round(Ct(255 * Bi.g, 0, 255)) +
              Math.round(Ct(255 * Bi.b, 0, 255))
          );
        }
        getHexString(e = ct) {
          return ("000000" + this.getHex(e).toString(16)).slice(-6);
        }
        getHSL(e, t = Qt.workingColorSpace) {
          Qt.fromWorkingColorSpace(Bi.copy(this), t);
          const n = Bi.r,
            i = Bi.g,
            r = Bi.b,
            s = Math.max(n, i, r),
            a = Math.min(n, i, r);
          let o, l;
          const c = (a + s) / 2;
          if (a === s) (o = 0), (l = 0);
          else {
            const e = s - a;
            switch (((l = c <= 0.5 ? e / (s + a) : e / (2 - s - a)), s)) {
              case n:
                o = (i - r) / e + (i < r ? 6 : 0);
                break;
              case i:
                o = (r - n) / e + 2;
                break;
              case r:
                o = (n - i) / e + 4;
            }
            o /= 6;
          }
          return (e.h = o), (e.s = l), (e.l = c), e;
        }
        getRGB(e, t = Qt.workingColorSpace) {
          return (
            Qt.fromWorkingColorSpace(Bi.copy(this), t),
            (e.r = Bi.r),
            (e.g = Bi.g),
            (e.b = Bi.b),
            e
          );
        }
        getStyle(e = ct) {
          Qt.fromWorkingColorSpace(Bi.copy(this), e);
          const t = Bi.r,
            n = Bi.g,
            i = Bi.b;
          return e !== ct
            ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})`
            : `rgb(${Math.round(255 * t)},${Math.round(255 * n)},${Math.round(
                255 * i
              )})`;
        }
        offsetHSL(e, t, n) {
          return this.getHSL(Ii), this.setHSL(Ii.h + e, Ii.s + t, Ii.l + n);
        }
        add(e) {
          return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
        }
        addColors(e, t) {
          return (
            (this.r = e.r + t.r),
            (this.g = e.g + t.g),
            (this.b = e.b + t.b),
            this
          );
        }
        addScalar(e) {
          return (this.r += e), (this.g += e), (this.b += e), this;
        }
        sub(e) {
          return (
            (this.r = Math.max(0, this.r - e.r)),
            (this.g = Math.max(0, this.g - e.g)),
            (this.b = Math.max(0, this.b - e.b)),
            this
          );
        }
        multiply(e) {
          return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
        }
        multiplyScalar(e) {
          return (this.r *= e), (this.g *= e), (this.b *= e), this;
        }
        lerp(e, t) {
          return (
            (this.r += (e.r - this.r) * t),
            (this.g += (e.g - this.g) * t),
            (this.b += (e.b - this.b) * t),
            this
          );
        }
        lerpColors(e, t, n) {
          return (
            (this.r = e.r + (t.r - e.r) * n),
            (this.g = e.g + (t.g - e.g) * n),
            (this.b = e.b + (t.b - e.b) * n),
            this
          );
        }
        lerpHSL(e, t) {
          this.getHSL(Ii), e.getHSL(Si);
          const n = St(Ii.h, Si.h, t),
            i = St(Ii.s, Si.s, t),
            r = St(Ii.l, Si.l, t);
          return this.setHSL(n, i, r), this;
        }
        setFromVector3(e) {
          return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
        }
        applyMatrix3(e) {
          const t = this.r,
            n = this.g,
            i = this.b,
            r = e.elements;
          return (
            (this.r = r[0] * t + r[3] * n + r[6] * i),
            (this.g = r[1] * t + r[4] * n + r[7] * i),
            (this.b = r[2] * t + r[5] * n + r[8] * i),
            this
          );
        }
        equals(e) {
          return e.r === this.r && e.g === this.g && e.b === this.b;
        }
        fromArray(e, t = 0) {
          return (
            (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this
          );
        }
        toArray(e = [], t = 0) {
          return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
        }
        fromBufferAttribute(e, t) {
          return (
            (this.r = e.getX(t)),
            (this.g = e.getY(t)),
            (this.b = e.getZ(t)),
            this
          );
        }
        toJSON() {
          return this.getHex();
        }
        *[Symbol.iterator]() {
          yield this.r, yield this.g, yield this.b;
        }
      }
      const Bi = new Ti();
      Ti.NAMES = Ci;
      let Ri = 0;
      class Di extends yt {
        static get type() {
          return "Material";
        }
        get type() {
          return this.constructor.type;
        }
        set type(e) {}
        constructor() {
          super(),
            (this.isMaterial = !0),
            Object.defineProperty(this, "id", { value: Ri++ }),
            (this.uuid = wt()),
            (this.name = ""),
            (this.blending = 1),
            (this.side = o),
            (this.vertexColors = !1),
            (this.opacity = 1),
            (this.transparent = !1),
            (this.alphaHash = !1),
            (this.blendSrc = 204),
            (this.blendDst = 205),
            (this.blendEquation = h),
            (this.blendSrcAlpha = null),
            (this.blendDstAlpha = null),
            (this.blendEquationAlpha = null),
            (this.blendColor = new Ti(0, 0, 0)),
            (this.blendAlpha = 0),
            (this.depthFunc = A),
            (this.depthTest = !0),
            (this.depthWrite = !0),
            (this.stencilWriteMask = 255),
            (this.stencilFunc = 519),
            (this.stencilRef = 0),
            (this.stencilFuncMask = 255),
            (this.stencilFail = pt),
            (this.stencilZFail = pt),
            (this.stencilZPass = pt),
            (this.stencilWrite = !1),
            (this.clippingPlanes = null),
            (this.clipIntersection = !1),
            (this.clipShadows = !1),
            (this.shadowSide = null),
            (this.colorWrite = !0),
            (this.precision = null),
            (this.polygonOffset = !1),
            (this.polygonOffsetFactor = 0),
            (this.polygonOffsetUnits = 0),
            (this.dithering = !1),
            (this.alphaToCoverage = !1),
            (this.premultipliedAlpha = !1),
            (this.forceSinglePass = !1),
            (this.visible = !0),
            (this.toneMapped = !0),
            (this.userData = {}),
            (this.version = 0),
            (this._alphaTest = 0);
        }
        get alphaTest() {
          return this._alphaTest;
        }
        set alphaTest(e) {
          this._alphaTest > 0 != e > 0 && this.version++, (this._alphaTest = e);
        }
        onBeforeRender() {}
        onBeforeCompile() {}
        customProgramCacheKey() {
          return this.onBeforeCompile.toString();
        }
        setValues(e) {
          if (void 0 !== e)
            for (const t in e) {
              const n = e[t];
              if (void 0 === n) {
                console.warn(
                  `THREE.Material: parameter '${t}' has value of undefined.`
                );
                continue;
              }
              const i = this[t];
              void 0 !== i
                ? i && i.isColor
                  ? i.set(n)
                  : i && i.isVector3 && n && n.isVector3
                  ? i.copy(n)
                  : (this[t] = n)
                : console.warn(
                    `THREE.Material: '${t}' is not a property of THREE.${this.type}.`
                  );
            }
        }
        toJSON(e) {
          const t = void 0 === e || "string" == typeof e;
          t && (e = { textures: {}, images: {} });
          const n = {
            metadata: {
              version: 4.6,
              type: "Material",
              generator: "Material.toJSON",
            },
          };
          function i(e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              delete i.metadata, t.push(i);
            }
            return t;
          }
          if (
            ((n.uuid = this.uuid),
            (n.type = this.type),
            "" !== this.name && (n.name = this.name),
            this.color && this.color.isColor && (n.color = this.color.getHex()),
            void 0 !== this.roughness && (n.roughness = this.roughness),
            void 0 !== this.metalness && (n.metalness = this.metalness),
            void 0 !== this.sheen && (n.sheen = this.sheen),
            this.sheenColor &&
              this.sheenColor.isColor &&
              (n.sheenColor = this.sheenColor.getHex()),
            void 0 !== this.sheenRoughness &&
              (n.sheenRoughness = this.sheenRoughness),
            this.emissive &&
              this.emissive.isColor &&
              (n.emissive = this.emissive.getHex()),
            void 0 !== this.emissiveIntensity &&
              1 !== this.emissiveIntensity &&
              (n.emissiveIntensity = this.emissiveIntensity),
            this.specular &&
              this.specular.isColor &&
              (n.specular = this.specular.getHex()),
            void 0 !== this.specularIntensity &&
              (n.specularIntensity = this.specularIntensity),
            this.specularColor &&
              this.specularColor.isColor &&
              (n.specularColor = this.specularColor.getHex()),
            void 0 !== this.shininess && (n.shininess = this.shininess),
            void 0 !== this.clearcoat && (n.clearcoat = this.clearcoat),
            void 0 !== this.clearcoatRoughness &&
              (n.clearcoatRoughness = this.clearcoatRoughness),
            this.clearcoatMap &&
              this.clearcoatMap.isTexture &&
              (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
            this.clearcoatRoughnessMap &&
              this.clearcoatRoughnessMap.isTexture &&
              (n.clearcoatRoughnessMap =
                this.clearcoatRoughnessMap.toJSON(e).uuid),
            this.clearcoatNormalMap &&
              this.clearcoatNormalMap.isTexture &&
              ((n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid),
              (n.clearcoatNormalScale = this.clearcoatNormalScale.toArray())),
            void 0 !== this.dispersion && (n.dispersion = this.dispersion),
            void 0 !== this.iridescence && (n.iridescence = this.iridescence),
            void 0 !== this.iridescenceIOR &&
              (n.iridescenceIOR = this.iridescenceIOR),
            void 0 !== this.iridescenceThicknessRange &&
              (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
            this.iridescenceMap &&
              this.iridescenceMap.isTexture &&
              (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
            this.iridescenceThicknessMap &&
              this.iridescenceThicknessMap.isTexture &&
              (n.iridescenceThicknessMap =
                this.iridescenceThicknessMap.toJSON(e).uuid),
            void 0 !== this.anisotropy && (n.anisotropy = this.anisotropy),
            void 0 !== this.anisotropyRotation &&
              (n.anisotropyRotation = this.anisotropyRotation),
            this.anisotropyMap &&
              this.anisotropyMap.isTexture &&
              (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
            this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
            this.matcap &&
              this.matcap.isTexture &&
              (n.matcap = this.matcap.toJSON(e).uuid),
            this.alphaMap &&
              this.alphaMap.isTexture &&
              (n.alphaMap = this.alphaMap.toJSON(e).uuid),
            this.lightMap &&
              this.lightMap.isTexture &&
              ((n.lightMap = this.lightMap.toJSON(e).uuid),
              (n.lightMapIntensity = this.lightMapIntensity)),
            this.aoMap &&
              this.aoMap.isTexture &&
              ((n.aoMap = this.aoMap.toJSON(e).uuid),
              (n.aoMapIntensity = this.aoMapIntensity)),
            this.bumpMap &&
              this.bumpMap.isTexture &&
              ((n.bumpMap = this.bumpMap.toJSON(e).uuid),
              (n.bumpScale = this.bumpScale)),
            this.normalMap &&
              this.normalMap.isTexture &&
              ((n.normalMap = this.normalMap.toJSON(e).uuid),
              (n.normalMapType = this.normalMapType),
              (n.normalScale = this.normalScale.toArray())),
            this.displacementMap &&
              this.displacementMap.isTexture &&
              ((n.displacementMap = this.displacementMap.toJSON(e).uuid),
              (n.displacementScale = this.displacementScale),
              (n.displacementBias = this.displacementBias)),
            this.roughnessMap &&
              this.roughnessMap.isTexture &&
              (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
            this.metalnessMap &&
              this.metalnessMap.isTexture &&
              (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
            this.emissiveMap &&
              this.emissiveMap.isTexture &&
              (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
            this.specularMap &&
              this.specularMap.isTexture &&
              (n.specularMap = this.specularMap.toJSON(e).uuid),
            this.specularIntensityMap &&
              this.specularIntensityMap.isTexture &&
              (n.specularIntensityMap =
                this.specularIntensityMap.toJSON(e).uuid),
            this.specularColorMap &&
              this.specularColorMap.isTexture &&
              (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
            this.envMap &&
              this.envMap.isTexture &&
              ((n.envMap = this.envMap.toJSON(e).uuid),
              void 0 !== this.combine && (n.combine = this.combine)),
            void 0 !== this.envMapRotation &&
              (n.envMapRotation = this.envMapRotation.toArray()),
            void 0 !== this.envMapIntensity &&
              (n.envMapIntensity = this.envMapIntensity),
            void 0 !== this.reflectivity &&
              (n.reflectivity = this.reflectivity),
            void 0 !== this.refractionRatio &&
              (n.refractionRatio = this.refractionRatio),
            this.gradientMap &&
              this.gradientMap.isTexture &&
              (n.gradientMap = this.gradientMap.toJSON(e).uuid),
            void 0 !== this.transmission &&
              (n.transmission = this.transmission),
            this.transmissionMap &&
              this.transmissionMap.isTexture &&
              (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
            void 0 !== this.thickness && (n.thickness = this.thickness),
            this.thicknessMap &&
              this.thicknessMap.isTexture &&
              (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
            void 0 !== this.attenuationDistance &&
              this.attenuationDistance !== 1 / 0 &&
              (n.attenuationDistance = this.attenuationDistance),
            void 0 !== this.attenuationColor &&
              (n.attenuationColor = this.attenuationColor.getHex()),
            void 0 !== this.size && (n.size = this.size),
            null !== this.shadowSide && (n.shadowSide = this.shadowSide),
            void 0 !== this.sizeAttenuation &&
              (n.sizeAttenuation = this.sizeAttenuation),
            1 !== this.blending && (n.blending = this.blending),
            this.side !== o && (n.side = this.side),
            !0 === this.vertexColors && (n.vertexColors = !0),
            this.opacity < 1 && (n.opacity = this.opacity),
            !0 === this.transparent && (n.transparent = !0),
            204 !== this.blendSrc && (n.blendSrc = this.blendSrc),
            205 !== this.blendDst && (n.blendDst = this.blendDst),
            this.blendEquation !== h && (n.blendEquation = this.blendEquation),
            null !== this.blendSrcAlpha &&
              (n.blendSrcAlpha = this.blendSrcAlpha),
            null !== this.blendDstAlpha &&
              (n.blendDstAlpha = this.blendDstAlpha),
            null !== this.blendEquationAlpha &&
              (n.blendEquationAlpha = this.blendEquationAlpha),
            this.blendColor &&
              this.blendColor.isColor &&
              (n.blendColor = this.blendColor.getHex()),
            0 !== this.blendAlpha && (n.blendAlpha = this.blendAlpha),
            this.depthFunc !== A && (n.depthFunc = this.depthFunc),
            !1 === this.depthTest && (n.depthTest = this.depthTest),
            !1 === this.depthWrite && (n.depthWrite = this.depthWrite),
            !1 === this.colorWrite && (n.colorWrite = this.colorWrite),
            255 !== this.stencilWriteMask &&
              (n.stencilWriteMask = this.stencilWriteMask),
            519 !== this.stencilFunc && (n.stencilFunc = this.stencilFunc),
            0 !== this.stencilRef && (n.stencilRef = this.stencilRef),
            255 !== this.stencilFuncMask &&
              (n.stencilFuncMask = this.stencilFuncMask),
            this.stencilFail !== pt && (n.stencilFail = this.stencilFail),
            this.stencilZFail !== pt && (n.stencilZFail = this.stencilZFail),
            this.stencilZPass !== pt && (n.stencilZPass = this.stencilZPass),
            !0 === this.stencilWrite && (n.stencilWrite = this.stencilWrite),
            void 0 !== this.rotation &&
              0 !== this.rotation &&
              (n.rotation = this.rotation),
            !0 === this.polygonOffset && (n.polygonOffset = !0),
            0 !== this.polygonOffsetFactor &&
              (n.polygonOffsetFactor = this.polygonOffsetFactor),
            0 !== this.polygonOffsetUnits &&
              (n.polygonOffsetUnits = this.polygonOffsetUnits),
            void 0 !== this.linewidth &&
              1 !== this.linewidth &&
              (n.linewidth = this.linewidth),
            void 0 !== this.dashSize && (n.dashSize = this.dashSize),
            void 0 !== this.gapSize && (n.gapSize = this.gapSize),
            void 0 !== this.scale && (n.scale = this.scale),
            !0 === this.dithering && (n.dithering = !0),
            this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
            !0 === this.alphaHash && (n.alphaHash = !0),
            !0 === this.alphaToCoverage && (n.alphaToCoverage = !0),
            !0 === this.premultipliedAlpha && (n.premultipliedAlpha = !0),
            !0 === this.forceSinglePass && (n.forceSinglePass = !0),
            !0 === this.wireframe && (n.wireframe = !0),
            this.wireframeLinewidth > 1 &&
              (n.wireframeLinewidth = this.wireframeLinewidth),
            "round" !== this.wireframeLinecap &&
              (n.wireframeLinecap = this.wireframeLinecap),
            "round" !== this.wireframeLinejoin &&
              (n.wireframeLinejoin = this.wireframeLinejoin),
            !0 === this.flatShading && (n.flatShading = !0),
            !1 === this.visible && (n.visible = !1),
            !1 === this.toneMapped && (n.toneMapped = !1),
            !1 === this.fog && (n.fog = !1),
            Object.keys(this.userData).length > 0 &&
              (n.userData = this.userData),
            t)
          ) {
            const t = i(e.textures),
              r = i(e.images);
            t.length > 0 && (n.textures = t), r.length > 0 && (n.images = r);
          }
          return n;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.name = e.name),
            (this.blending = e.blending),
            (this.side = e.side),
            (this.vertexColors = e.vertexColors),
            (this.opacity = e.opacity),
            (this.transparent = e.transparent),
            (this.blendSrc = e.blendSrc),
            (this.blendDst = e.blendDst),
            (this.blendEquation = e.blendEquation),
            (this.blendSrcAlpha = e.blendSrcAlpha),
            (this.blendDstAlpha = e.blendDstAlpha),
            (this.blendEquationAlpha = e.blendEquationAlpha),
            this.blendColor.copy(e.blendColor),
            (this.blendAlpha = e.blendAlpha),
            (this.depthFunc = e.depthFunc),
            (this.depthTest = e.depthTest),
            (this.depthWrite = e.depthWrite),
            (this.stencilWriteMask = e.stencilWriteMask),
            (this.stencilFunc = e.stencilFunc),
            (this.stencilRef = e.stencilRef),
            (this.stencilFuncMask = e.stencilFuncMask),
            (this.stencilFail = e.stencilFail),
            (this.stencilZFail = e.stencilZFail),
            (this.stencilZPass = e.stencilZPass),
            (this.stencilWrite = e.stencilWrite);
          const t = e.clippingPlanes;
          let n = null;
          if (null !== t) {
            const e = t.length;
            n = new Array(e);
            for (let i = 0; i !== e; ++i) n[i] = t[i].clone();
          }
          return (
            (this.clippingPlanes = n),
            (this.clipIntersection = e.clipIntersection),
            (this.clipShadows = e.clipShadows),
            (this.shadowSide = e.shadowSide),
            (this.colorWrite = e.colorWrite),
            (this.precision = e.precision),
            (this.polygonOffset = e.polygonOffset),
            (this.polygonOffsetFactor = e.polygonOffsetFactor),
            (this.polygonOffsetUnits = e.polygonOffsetUnits),
            (this.dithering = e.dithering),
            (this.alphaTest = e.alphaTest),
            (this.alphaHash = e.alphaHash),
            (this.alphaToCoverage = e.alphaToCoverage),
            (this.premultipliedAlpha = e.premultipliedAlpha),
            (this.forceSinglePass = e.forceSinglePass),
            (this.visible = e.visible),
            (this.toneMapped = e.toneMapped),
            (this.userData = JSON.parse(JSON.stringify(e.userData))),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        onBuild() {
          console.warn("Material: onBuild() has been removed.");
        }
      }
      class Pi extends Di {
        static get type() {
          return "MeshBasicMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshBasicMaterial = !0),
            (this.color = new Ti(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new qn()),
            (this.combine = x),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const Li = Ui();
      function Ui() {
        const e = new ArrayBuffer(4),
          t = new Float32Array(e),
          n = new Uint32Array(e),
          i = new Uint32Array(512),
          r = new Uint32Array(512);
        for (let e = 0; e < 256; ++e) {
          const t = e - 127;
          t < -27
            ? ((i[e] = 0), (i[256 | e] = 32768), (r[e] = 24), (r[256 | e] = 24))
            : t < -14
            ? ((i[e] = 1024 >> (-t - 14)),
              (i[256 | e] = (1024 >> (-t - 14)) | 32768),
              (r[e] = -t - 1),
              (r[256 | e] = -t - 1))
            : t <= 15
            ? ((i[e] = (t + 15) << 10),
              (i[256 | e] = ((t + 15) << 10) | 32768),
              (r[e] = 13),
              (r[256 | e] = 13))
            : t < 128
            ? ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 24),
              (r[256 | e] = 24))
            : ((i[e] = 31744),
              (i[256 | e] = 64512),
              (r[e] = 13),
              (r[256 | e] = 13));
        }
        const s = new Uint32Array(2048),
          a = new Uint32Array(64),
          o = new Uint32Array(64);
        for (let e = 1; e < 1024; ++e) {
          let t = e << 13,
            n = 0;
          for (; !(8388608 & t); ) (t <<= 1), (n -= 8388608);
          (t &= -8388609), (n += 947912704), (s[e] = t | n);
        }
        for (let e = 1024; e < 2048; ++e) s[e] = 939524096 + ((e - 1024) << 13);
        for (let e = 1; e < 31; ++e) a[e] = e << 23;
        (a[31] = 1199570944), (a[32] = 2147483648);
        for (let e = 33; e < 63; ++e) a[e] = 2147483648 + ((e - 32) << 23);
        a[63] = 3347054592;
        for (let e = 1; e < 64; ++e) 32 !== e && (o[e] = 1024);
        return {
          floatView: t,
          uint32View: n,
          baseTable: i,
          shiftTable: r,
          mantissaTable: s,
          exponentTable: a,
          offsetTable: o,
        };
      }
      function Fi(e) {
        Math.abs(e) > 65504 &&
          console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
          (e = Ct(e, -65504, 65504)),
          (Li.floatView[0] = e);
        const t = Li.uint32View[0],
          n = (t >> 23) & 511;
        return Li.baseTable[n] + ((8388607 & t) >> Li.shiftTable[n]);
      }
      function Ni(e) {
        const t = e >> 10;
        return (
          (Li.uint32View[0] =
            Li.mantissaTable[Li.offsetTable[t] + (1023 & e)] +
            Li.exponentTable[t]),
          Li.floatView[0]
        );
      }
      const Oi = { toHalfFloat: Fi, fromHalfFloat: Ni },
        Qi = new on(),
        ki = new Rt();
      class Gi {
        constructor(e, t, n = !1) {
          if (Array.isArray(e))
            throw new TypeError(
              "THREE.BufferAttribute: array should be a Typed Array."
            );
          (this.isBufferAttribute = !0),
            (this.name = ""),
            (this.array = e),
            (this.itemSize = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.normalized = n),
            (this.usage = At),
            (this.updateRanges = []),
            (this.gpuType = Z),
            (this.version = 0);
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (
            (this.name = e.name),
            (this.array = new e.array.constructor(e.array)),
            (this.itemSize = e.itemSize),
            (this.count = e.count),
            (this.normalized = e.normalized),
            (this.usage = e.usage),
            (this.gpuType = e.gpuType),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.itemSize), (n *= t.itemSize);
          for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        copyArray(e) {
          return this.array.set(e), this;
        }
        applyMatrix3(e) {
          if (2 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              ki.fromBufferAttribute(this, t),
                ki.applyMatrix3(e),
                this.setXY(t, ki.x, ki.y);
          else if (3 === this.itemSize)
            for (let t = 0, n = this.count; t < n; t++)
              Qi.fromBufferAttribute(this, t),
                Qi.applyMatrix3(e),
                this.setXYZ(t, Qi.x, Qi.y, Qi.z);
          return this;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Qi.fromBufferAttribute(this, t),
              Qi.applyMatrix4(e),
              this.setXYZ(t, Qi.x, Qi.y, Qi.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Qi.fromBufferAttribute(this, t),
              Qi.applyNormalMatrix(e),
              this.setXYZ(t, Qi.x, Qi.y, Qi.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Qi.fromBufferAttribute(this, t),
              Qi.transformDirection(e),
              this.setXYZ(t, Qi.x, Qi.y, Qi.z);
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        getComponent(e, t) {
          let n = this.array[e * this.itemSize + t];
          return this.normalized && (n = Mt(n, this.array)), n;
        }
        setComponent(e, t, n) {
          return (
            this.normalized && (n = Tt(n, this.array)),
            (this.array[e * this.itemSize + t] = n),
            this
          );
        }
        getX(e) {
          let t = this.array[e * this.itemSize];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        setX(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize] = t),
            this
          );
        }
        getY(e) {
          let t = this.array[e * this.itemSize + 1];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        setY(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 1] = t),
            this
          );
        }
        getZ(e) {
          let t = this.array[e * this.itemSize + 2];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        setZ(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 2] = t),
            this
          );
        }
        getW(e) {
          let t = this.array[e * this.itemSize + 3];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        setW(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.array[e * this.itemSize + 3] = t),
            this
          );
        }
        setXY(e, t, n) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = Tt(t, this.array)), (n = Tt(n, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = Tt(t, this.array)),
              (n = Tt(n, this.array)),
              (i = Tt(i, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e *= this.itemSize),
            this.normalized &&
              ((t = Tt(t, this.array)),
              (n = Tt(n, this.array)),
              (i = Tt(i, this.array)),
              (r = Tt(r, this.array))),
            (this.array[e + 0] = t),
            (this.array[e + 1] = n),
            (this.array[e + 2] = i),
            (this.array[e + 3] = r),
            this
          );
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        clone() {
          return new this.constructor(this.array, this.itemSize).copy(this);
        }
        toJSON() {
          const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized,
          };
          return (
            "" !== this.name && (e.name = this.name),
            this.usage !== At && (e.usage = this.usage),
            e
          );
        }
      }
      class Hi extends Gi {
        constructor(e, t, n) {
          super(new Uint16Array(e), t, n);
        }
      }
      class zi extends Gi {
        constructor(e, t, n) {
          super(new Uint32Array(e), t, n);
        }
      }
      class Vi extends Gi {
        constructor(e, t, n) {
          super(new Float32Array(e), t, n);
        }
      }
      let Wi = 0;
      const ji = new Nn(),
        qi = new ui(),
        Yi = new on(),
        Xi = new un(),
        Ki = new un(),
        Ji = new on();
      class Zi extends yt {
        constructor() {
          super(),
            (this.isBufferGeometry = !0),
            Object.defineProperty(this, "id", { value: Wi++ }),
            (this.uuid = wt()),
            (this.name = ""),
            (this.type = "BufferGeometry"),
            (this.index = null),
            (this.indirect = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.morphTargetsRelative = !1),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null),
            (this.drawRange = { start: 0, count: 1 / 0 }),
            (this.userData = {});
        }
        getIndex() {
          return this.index;
        }
        setIndex(e) {
          return (
            Array.isArray(e)
              ? (this.index = new (Lt(e) ? zi : Hi)(e, 1))
              : (this.index = e),
            this
          );
        }
        setIndirect(e) {
          return (this.indirect = e), this;
        }
        getIndirect() {
          return this.indirect;
        }
        getAttribute(e) {
          return this.attributes[e];
        }
        setAttribute(e, t) {
          return (this.attributes[e] = t), this;
        }
        deleteAttribute(e) {
          return delete this.attributes[e], this;
        }
        hasAttribute(e) {
          return void 0 !== this.attributes[e];
        }
        addGroup(e, t, n = 0) {
          this.groups.push({ start: e, count: t, materialIndex: n });
        }
        clearGroups() {
          this.groups = [];
        }
        setDrawRange(e, t) {
          (this.drawRange.start = e), (this.drawRange.count = t);
        }
        applyMatrix4(e) {
          const t = this.attributes.position;
          void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
          const n = this.attributes.normal;
          if (void 0 !== n) {
            const t = new Dt().getNormalMatrix(e);
            n.applyNormalMatrix(t), (n.needsUpdate = !0);
          }
          const i = this.attributes.tangent;
          return (
            void 0 !== i && (i.transformDirection(e), (i.needsUpdate = !0)),
            null !== this.boundingBox && this.computeBoundingBox(),
            null !== this.boundingSphere && this.computeBoundingSphere(),
            this
          );
        }
        applyQuaternion(e) {
          return ji.makeRotationFromQuaternion(e), this.applyMatrix4(ji), this;
        }
        rotateX(e) {
          return ji.makeRotationX(e), this.applyMatrix4(ji), this;
        }
        rotateY(e) {
          return ji.makeRotationY(e), this.applyMatrix4(ji), this;
        }
        rotateZ(e) {
          return ji.makeRotationZ(e), this.applyMatrix4(ji), this;
        }
        translate(e, t, n) {
          return ji.makeTranslation(e, t, n), this.applyMatrix4(ji), this;
        }
        scale(e, t, n) {
          return ji.makeScale(e, t, n), this.applyMatrix4(ji), this;
        }
        lookAt(e) {
          return (
            qi.lookAt(e), qi.updateMatrix(), this.applyMatrix4(qi.matrix), this
          );
        }
        center() {
          return (
            this.computeBoundingBox(),
            this.boundingBox.getCenter(Yi).negate(),
            this.translate(Yi.x, Yi.y, Yi.z),
            this
          );
        }
        setFromPoints(e) {
          const t = this.getAttribute("position");
          if (void 0 === t) {
            const t = [];
            for (let n = 0, i = e.length; n < i; n++) {
              const i = e[n];
              t.push(i.x, i.y, i.z || 0);
            }
            this.setAttribute("position", new Vi(t, 3));
          } else {
            for (let n = 0, i = t.count; n < i; n++) {
              const i = e[n];
              t.setXYZ(n, i.x, i.y, i.z || 0);
            }
            e.length > t.count &&
              console.warn(
                "THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."
              ),
              (t.needsUpdate = !0);
          }
          return this;
        }
        computeBoundingBox() {
          null === this.boundingBox && (this.boundingBox = new un());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",
                this
              ),
              void this.boundingBox.set(
                new on(-1 / 0, -1 / 0, -1 / 0),
                new on(1 / 0, 1 / 0, 1 / 0)
              )
            );
          if (void 0 !== e) {
            if ((this.boundingBox.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Xi.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Ji.addVectors(this.boundingBox.min, Xi.min),
                      this.boundingBox.expandByPoint(Ji),
                      Ji.addVectors(this.boundingBox.max, Xi.max),
                      this.boundingBox.expandByPoint(Ji))
                    : (this.boundingBox.expandByPoint(Xi.min),
                      this.boundingBox.expandByPoint(Xi.max));
              }
          } else this.boundingBox.makeEmpty();
          (isNaN(this.boundingBox.min.x) ||
            isNaN(this.boundingBox.min.y) ||
            isNaN(this.boundingBox.min.z)) &&
            console.error(
              'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
              this
            );
        }
        computeBoundingSphere() {
          null === this.boundingSphere && (this.boundingSphere = new Mn());
          const e = this.attributes.position,
            t = this.morphAttributes.position;
          if (e && e.isGLBufferAttribute)
            return (
              console.error(
                "THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",
                this
              ),
              void this.boundingSphere.set(new on(), 1 / 0)
            );
          if (e) {
            const n = this.boundingSphere.center;
            if ((Xi.setFromBufferAttribute(e), t))
              for (let e = 0, n = t.length; e < n; e++) {
                const n = t[e];
                Ki.setFromBufferAttribute(n),
                  this.morphTargetsRelative
                    ? (Ji.addVectors(Xi.min, Ki.min),
                      Xi.expandByPoint(Ji),
                      Ji.addVectors(Xi.max, Ki.max),
                      Xi.expandByPoint(Ji))
                    : (Xi.expandByPoint(Ki.min), Xi.expandByPoint(Ki.max));
              }
            Xi.getCenter(n);
            let i = 0;
            for (let t = 0, r = e.count; t < r; t++)
              Ji.fromBufferAttribute(e, t),
                (i = Math.max(i, n.distanceToSquared(Ji)));
            if (t)
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = this.morphTargetsRelative;
                for (let t = 0, r = s.count; t < r; t++)
                  Ji.fromBufferAttribute(s, t),
                    a && (Yi.fromBufferAttribute(e, t), Ji.add(Yi)),
                    (i = Math.max(i, n.distanceToSquared(Ji)));
              }
            (this.boundingSphere.radius = Math.sqrt(i)),
              isNaN(this.boundingSphere.radius) &&
                console.error(
                  'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
                  this
                );
          }
        }
        computeTangents() {
          const e = this.index,
            t = this.attributes;
          if (
            null === e ||
            void 0 === t.position ||
            void 0 === t.normal ||
            void 0 === t.uv
          )
            return void console.error(
              "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
            );
          const n = t.position,
            i = t.normal,
            r = t.uv;
          !1 === this.hasAttribute("tangent") &&
            this.setAttribute(
              "tangent",
              new Gi(new Float32Array(4 * n.count), 4)
            );
          const s = this.getAttribute("tangent"),
            a = [],
            o = [];
          for (let e = 0; e < n.count; e++)
            (a[e] = new on()), (o[e] = new on());
          const l = new on(),
            c = new on(),
            u = new on(),
            h = new Rt(),
            d = new Rt(),
            p = new Rt(),
            f = new on(),
            A = new on();
          function g(e, t, i) {
            l.fromBufferAttribute(n, e),
              c.fromBufferAttribute(n, t),
              u.fromBufferAttribute(n, i),
              h.fromBufferAttribute(r, e),
              d.fromBufferAttribute(r, t),
              p.fromBufferAttribute(r, i),
              c.sub(l),
              u.sub(l),
              d.sub(h),
              p.sub(h);
            const s = 1 / (d.x * p.y - p.x * d.y);
            isFinite(s) &&
              (f
                .copy(c)
                .multiplyScalar(p.y)
                .addScaledVector(u, -d.y)
                .multiplyScalar(s),
              A.copy(u)
                .multiplyScalar(d.x)
                .addScaledVector(c, -p.x)
                .multiplyScalar(s),
              a[e].add(f),
              a[t].add(f),
              a[i].add(f),
              o[e].add(A),
              o[t].add(A),
              o[i].add(A));
          }
          let m = this.groups;
          0 === m.length && (m = [{ start: 0, count: e.count }]);
          for (let t = 0, n = m.length; t < n; ++t) {
            const n = m[t],
              i = n.start;
            for (let t = i, r = i + n.count; t < r; t += 3)
              g(e.getX(t + 0), e.getX(t + 1), e.getX(t + 2));
          }
          const v = new on(),
            y = new on(),
            x = new on(),
            _ = new on();
          function b(e) {
            x.fromBufferAttribute(i, e), _.copy(x);
            const t = a[e];
            v.copy(t),
              v.sub(x.multiplyScalar(x.dot(t))).normalize(),
              y.crossVectors(_, t);
            const n = y.dot(o[e]) < 0 ? -1 : 1;
            s.setXYZW(e, v.x, v.y, v.z, n);
          }
          for (let t = 0, n = m.length; t < n; ++t) {
            const n = m[t],
              i = n.start;
            for (let t = i, r = i + n.count; t < r; t += 3)
              b(e.getX(t + 0)), b(e.getX(t + 1)), b(e.getX(t + 2));
          }
        }
        computeVertexNormals() {
          const e = this.index,
            t = this.getAttribute("position");
          if (void 0 !== t) {
            let n = this.getAttribute("normal");
            if (void 0 === n)
              (n = new Gi(new Float32Array(3 * t.count), 3)),
                this.setAttribute("normal", n);
            else for (let e = 0, t = n.count; e < t; e++) n.setXYZ(e, 0, 0, 0);
            const i = new on(),
              r = new on(),
              s = new on(),
              a = new on(),
              o = new on(),
              l = new on(),
              c = new on(),
              u = new on();
            if (e)
              for (let h = 0, d = e.count; h < d; h += 3) {
                const d = e.getX(h + 0),
                  p = e.getX(h + 1),
                  f = e.getX(h + 2);
                i.fromBufferAttribute(t, d),
                  r.fromBufferAttribute(t, p),
                  s.fromBufferAttribute(t, f),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  a.fromBufferAttribute(n, d),
                  o.fromBufferAttribute(n, p),
                  l.fromBufferAttribute(n, f),
                  a.add(c),
                  o.add(c),
                  l.add(c),
                  n.setXYZ(d, a.x, a.y, a.z),
                  n.setXYZ(p, o.x, o.y, o.z),
                  n.setXYZ(f, l.x, l.y, l.z);
              }
            else
              for (let e = 0, a = t.count; e < a; e += 3)
                i.fromBufferAttribute(t, e + 0),
                  r.fromBufferAttribute(t, e + 1),
                  s.fromBufferAttribute(t, e + 2),
                  c.subVectors(s, r),
                  u.subVectors(i, r),
                  c.cross(u),
                  n.setXYZ(e + 0, c.x, c.y, c.z),
                  n.setXYZ(e + 1, c.x, c.y, c.z),
                  n.setXYZ(e + 2, c.x, c.y, c.z);
            this.normalizeNormals(), (n.needsUpdate = !0);
          }
        }
        normalizeNormals() {
          const e = this.attributes.normal;
          for (let t = 0, n = e.count; t < n; t++)
            Ji.fromBufferAttribute(e, t),
              Ji.normalize(),
              e.setXYZ(t, Ji.x, Ji.y, Ji.z);
        }
        toNonIndexed() {
          function e(e, t) {
            const n = e.array,
              i = e.itemSize,
              r = e.normalized,
              s = new n.constructor(t.length * i);
            let a = 0,
              o = 0;
            for (let r = 0, l = t.length; r < l; r++) {
              a = e.isInterleavedBufferAttribute
                ? t[r] * e.data.stride + e.offset
                : t[r] * i;
              for (let e = 0; e < i; e++) s[o++] = n[a++];
            }
            return new Gi(s, i, r);
          }
          if (null === this.index)
            return (
              console.warn(
                "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
              ),
              this
            );
          const t = new Zi(),
            n = this.index.array,
            i = this.attributes;
          for (const r in i) {
            const s = e(i[r], n);
            t.setAttribute(r, s);
          }
          const r = this.morphAttributes;
          for (const i in r) {
            const s = [],
              a = r[i];
            for (let t = 0, i = a.length; t < i; t++) {
              const i = e(a[t], n);
              s.push(i);
            }
            t.morphAttributes[i] = s;
          }
          t.morphTargetsRelative = this.morphTargetsRelative;
          const s = this.groups;
          for (let e = 0, n = s.length; e < n; e++) {
            const n = s[e];
            t.addGroup(n.start, n.count, n.materialIndex);
          }
          return t;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "BufferGeometry",
              generator: "BufferGeometry.toJSON",
            },
          };
          if (
            ((e.uuid = this.uuid),
            (e.type = this.type),
            "" !== this.name && (e.name = this.name),
            Object.keys(this.userData).length > 0 &&
              (e.userData = this.userData),
            void 0 !== this.parameters)
          ) {
            const t = this.parameters;
            for (const n in t) void 0 !== t[n] && (e[n] = t[n]);
            return e;
          }
          e.data = { attributes: {} };
          const t = this.index;
          null !== t &&
            (e.data.index = {
              type: t.array.constructor.name,
              array: Array.prototype.slice.call(t.array),
            });
          const n = this.attributes;
          for (const t in n) {
            const i = n[t];
            e.data.attributes[t] = i.toJSON(e.data);
          }
          const i = {};
          let r = !1;
          for (const t in this.morphAttributes) {
            const n = this.morphAttributes[t],
              s = [];
            for (let t = 0, i = n.length; t < i; t++) {
              const i = n[t];
              s.push(i.toJSON(e.data));
            }
            s.length > 0 && ((i[t] = s), (r = !0));
          }
          r &&
            ((e.data.morphAttributes = i),
            (e.data.morphTargetsRelative = this.morphTargetsRelative));
          const s = this.groups;
          s.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(s)));
          const a = this.boundingSphere;
          return (
            null !== a &&
              (e.data.boundingSphere = {
                center: a.center.toArray(),
                radius: a.radius,
              }),
            e
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          (this.index = null),
            (this.attributes = {}),
            (this.morphAttributes = {}),
            (this.groups = []),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          const t = {};
          this.name = e.name;
          const n = e.index;
          null !== n && this.setIndex(n.clone(t));
          const i = e.attributes;
          for (const e in i) {
            const n = i[e];
            this.setAttribute(e, n.clone(t));
          }
          const r = e.morphAttributes;
          for (const e in r) {
            const n = [],
              i = r[e];
            for (let e = 0, r = i.length; e < r; e++) n.push(i[e].clone(t));
            this.morphAttributes[e] = n;
          }
          this.morphTargetsRelative = e.morphTargetsRelative;
          const s = e.groups;
          for (let e = 0, t = s.length; e < t; e++) {
            const t = s[e];
            this.addGroup(t.start, t.count, t.materialIndex);
          }
          const a = e.boundingBox;
          null !== a && (this.boundingBox = a.clone());
          const o = e.boundingSphere;
          return (
            null !== o && (this.boundingSphere = o.clone()),
            (this.drawRange.start = e.drawRange.start),
            (this.drawRange.count = e.drawRange.count),
            (this.userData = e.userData),
            this
          );
        }
        dispose() {
          this.dispatchEvent({ type: "dispose" });
        }
      }
      const $i = new Nn(),
        er = new Fn(),
        tr = new Mn(),
        nr = new on(),
        ir = new on(),
        rr = new on(),
        sr = new on(),
        ar = new on(),
        or = new on(),
        lr = new on(),
        cr = new on();
      class ur extends ui {
        constructor(e = new Zi(), t = new Pi()) {
          super(),
            (this.isMesh = !0),
            (this.type = "Mesh"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            void 0 !== e.morphTargetInfluences &&
              (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
            void 0 !== e.morphTargetDictionary &&
              (this.morphTargetDictionary = Object.assign(
                {},
                e.morphTargetDictionary
              )),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
        getVertexPosition(e, t) {
          const n = this.geometry,
            i = n.attributes.position,
            r = n.morphAttributes.position,
            s = n.morphTargetsRelative;
          t.fromBufferAttribute(i, e);
          const a = this.morphTargetInfluences;
          if (r && a) {
            or.set(0, 0, 0);
            for (let n = 0, i = r.length; n < i; n++) {
              const i = a[n],
                o = r[n];
              0 !== i &&
                (ar.fromBufferAttribute(o, e),
                s
                  ? or.addScaledVector(ar, i)
                  : or.addScaledVector(ar.sub(t), i));
            }
            t.add(or);
          }
          return t;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.material,
            r = this.matrixWorld;
          if (void 0 !== i) {
            if (
              (null === n.boundingSphere && n.computeBoundingSphere(),
              tr.copy(n.boundingSphere),
              tr.applyMatrix4(r),
              er.copy(e.ray).recast(e.near),
              !1 === tr.containsPoint(er.origin))
            ) {
              if (null === er.intersectSphere(tr, nr)) return;
              if (er.origin.distanceToSquared(nr) > (e.far - e.near) ** 2)
                return;
            }
            $i.copy(r).invert(),
              er.copy(e.ray).applyMatrix4($i),
              (null !== n.boundingBox &&
                !1 === er.intersectsBox(n.boundingBox)) ||
                this._computeIntersections(e, t, er);
          }
        }
        _computeIntersections(e, t, n) {
          let i;
          const r = this.geometry,
            s = this.material,
            a = r.index,
            o = r.attributes.position,
            l = r.attributes.uv,
            c = r.attributes.uv1,
            u = r.attributes.normal,
            h = r.groups,
            d = r.drawRange;
          if (null !== a)
            if (Array.isArray(s))
              for (let r = 0, o = h.length; r < o; r++) {
                const o = h[r],
                  p = s[o.materialIndex];
                for (
                  let r = Math.max(o.start, d.start),
                    s = Math.min(
                      a.count,
                      Math.min(o.start + o.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                ) {
                  (i = hr(
                    this,
                    p,
                    e,
                    n,
                    l,
                    c,
                    u,
                    a.getX(r),
                    a.getX(r + 1),
                    a.getX(r + 2)
                  )),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = o.materialIndex),
                      t.push(i));
                }
              }
            else {
              for (
                let r = Math.max(0, d.start),
                  o = Math.min(a.count, d.start + d.count);
                r < o;
                r += 3
              ) {
                (i = hr(
                  this,
                  s,
                  e,
                  n,
                  l,
                  c,
                  u,
                  a.getX(r),
                  a.getX(r + 1),
                  a.getX(r + 2)
                )),
                  i && ((i.faceIndex = Math.floor(r / 3)), t.push(i));
              }
            }
          else if (void 0 !== o)
            if (Array.isArray(s))
              for (let r = 0, a = h.length; r < a; r++) {
                const a = h[r],
                  p = s[a.materialIndex];
                for (
                  let r = Math.max(a.start, d.start),
                    s = Math.min(
                      o.count,
                      Math.min(a.start + a.count, d.start + d.count)
                    );
                  r < s;
                  r += 3
                ) {
                  (i = hr(this, p, e, n, l, c, u, r, r + 1, r + 2)),
                    i &&
                      ((i.faceIndex = Math.floor(r / 3)),
                      (i.face.materialIndex = a.materialIndex),
                      t.push(i));
                }
              }
            else {
              for (
                let r = Math.max(0, d.start),
                  a = Math.min(o.count, d.start + d.count);
                r < a;
                r += 3
              ) {
                (i = hr(this, s, e, n, l, c, u, r, r + 1, r + 2)),
                  i && ((i.faceIndex = Math.floor(r / 3)), t.push(i));
              }
            }
        }
      }
      function hr(e, t, n, i, r, s, a, c, u, h) {
        e.getVertexPosition(c, ir),
          e.getVertexPosition(u, rr),
          e.getVertexPosition(h, sr);
        const d = (function (e, t, n, i, r, s, a, c) {
          let u;
          if (
            ((u =
              t.side === l
                ? i.intersectTriangle(a, s, r, !0, c)
                : i.intersectTriangle(r, s, a, t.side === o, c)),
            null === u)
          )
            return null;
          cr.copy(c), cr.applyMatrix4(e.matrixWorld);
          const h = n.ray.origin.distanceTo(cr);
          return h < n.near || h > n.far
            ? null
            : { distance: h, point: cr.clone(), object: e };
        })(e, t, n, i, ir, rr, sr, lr);
        if (d) {
          const e = new on();
          wi.getBarycoord(lr, ir, rr, sr, e),
            r && (d.uv = wi.getInterpolatedAttribute(r, c, u, h, e, new Rt())),
            s && (d.uv1 = wi.getInterpolatedAttribute(s, c, u, h, e, new Rt())),
            a &&
              ((d.normal = wi.getInterpolatedAttribute(
                a,
                c,
                u,
                h,
                e,
                new on()
              )),
              d.normal.dot(i.direction) > 0 && d.normal.multiplyScalar(-1));
          const t = { a: c, b: u, c: h, normal: new on(), materialIndex: 0 };
          wi.getNormal(ir, rr, sr, t.normal), (d.face = t), (d.barycoord = e);
        }
        return d;
      }
      class dr extends Zi {
        constructor(e = 1, t = 1, n = 1, i = 1, r = 1, s = 1) {
          super(),
            (this.type = "BoxGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              depth: n,
              widthSegments: i,
              heightSegments: r,
              depthSegments: s,
            });
          const a = this;
          (i = Math.floor(i)), (r = Math.floor(r)), (s = Math.floor(s));
          const o = [],
            l = [],
            c = [],
            u = [];
          let h = 0,
            d = 0;
          function p(e, t, n, i, r, s, p, f, A, g, m) {
            const v = s / A,
              y = p / g,
              x = s / 2,
              _ = p / 2,
              b = f / 2,
              E = A + 1,
              w = g + 1;
            let C = 0,
              I = 0;
            const S = new on();
            for (let s = 0; s < w; s++) {
              const a = s * y - _;
              for (let o = 0; o < E; o++) {
                const h = o * v - x;
                (S[e] = h * i),
                  (S[t] = a * r),
                  (S[n] = b),
                  l.push(S.x, S.y, S.z),
                  (S[e] = 0),
                  (S[t] = 0),
                  (S[n] = f > 0 ? 1 : -1),
                  c.push(S.x, S.y, S.z),
                  u.push(o / A),
                  u.push(1 - s / g),
                  (C += 1);
              }
            }
            for (let e = 0; e < g; e++)
              for (let t = 0; t < A; t++) {
                const n = h + t + E * e,
                  i = h + t + E * (e + 1),
                  r = h + (t + 1) + E * (e + 1),
                  s = h + (t + 1) + E * e;
                o.push(n, i, s), o.push(i, r, s), (I += 6);
              }
            a.addGroup(d, I, m), (d += I), (h += C);
          }
          p("z", "y", "x", -1, -1, n, t, e, s, r, 0),
            p("z", "y", "x", 1, -1, n, t, -e, s, r, 1),
            p("x", "z", "y", 1, 1, e, n, t, i, s, 2),
            p("x", "z", "y", 1, -1, e, n, -t, i, s, 3),
            p("x", "y", "z", 1, -1, e, t, n, i, r, 4),
            p("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
            this.setIndex(o),
            this.setAttribute("position", new Vi(l, 3)),
            this.setAttribute("normal", new Vi(c, 3)),
            this.setAttribute("uv", new Vi(u, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new dr(
            e.width,
            e.height,
            e.depth,
            e.widthSegments,
            e.heightSegments,
            e.depthSegments
          );
        }
      }
      function pr(e) {
        const t = {};
        for (const n in e) {
          t[n] = {};
          for (const i in e[n]) {
            const r = e[n][i];
            r &&
            (r.isColor ||
              r.isMatrix3 ||
              r.isMatrix4 ||
              r.isVector2 ||
              r.isVector3 ||
              r.isVector4 ||
              r.isTexture ||
              r.isQuaternion)
              ? r.isRenderTargetTexture
                ? (console.warn(
                    "UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."
                  ),
                  (t[n][i] = null))
                : (t[n][i] = r.clone())
              : Array.isArray(r)
              ? (t[n][i] = r.slice())
              : (t[n][i] = r);
          }
        }
        return t;
      }
      function fr(e) {
        const t = {};
        for (let n = 0; n < e.length; n++) {
          const i = pr(e[n]);
          for (const e in i) t[e] = i[e];
        }
        return t;
      }
      function Ar(e) {
        const t = e.getRenderTarget();
        return null === t
          ? e.outputColorSpace
          : !0 === t.isXRRenderTarget
          ? t.texture.colorSpace
          : Qt.workingColorSpace;
      }
      const gr = { clone: pr, merge: fr };
      class mr extends Di {
        static get type() {
          return "ShaderMaterial";
        }
        constructor(e) {
          super(),
            (this.isShaderMaterial = !0),
            (this.defines = {}),
            (this.uniforms = {}),
            (this.uniformsGroups = []),
            (this.vertexShader =
              "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"),
            (this.fragmentShader =
              "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}"),
            (this.linewidth = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.fog = !1),
            (this.lights = !1),
            (this.clipping = !1),
            (this.forceSinglePass = !0),
            (this.extensions = { clipCullDistance: !1, multiDraw: !1 }),
            (this.defaultAttributeValues = {
              color: [1, 1, 1],
              uv: [0, 0],
              uv1: [0, 0],
            }),
            (this.index0AttributeName = void 0),
            (this.uniformsNeedUpdate = !1),
            (this.glslVersion = null),
            void 0 !== e && this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.fragmentShader = e.fragmentShader),
            (this.vertexShader = e.vertexShader),
            (this.uniforms = pr(e.uniforms)),
            (this.uniformsGroups = (function (e) {
              const t = [];
              for (let n = 0; n < e.length; n++) t.push(e[n].clone());
              return t;
            })(e.uniformsGroups)),
            (this.defines = Object.assign({}, e.defines)),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.fog = e.fog),
            (this.lights = e.lights),
            (this.clipping = e.clipping),
            (this.extensions = Object.assign({}, e.extensions)),
            (this.glslVersion = e.glslVersion),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          (t.glslVersion = this.glslVersion), (t.uniforms = {});
          for (const n in this.uniforms) {
            const i = this.uniforms[n].value;
            i && i.isTexture
              ? (t.uniforms[n] = { type: "t", value: i.toJSON(e).uuid })
              : i && i.isColor
              ? (t.uniforms[n] = { type: "c", value: i.getHex() })
              : i && i.isVector2
              ? (t.uniforms[n] = { type: "v2", value: i.toArray() })
              : i && i.isVector3
              ? (t.uniforms[n] = { type: "v3", value: i.toArray() })
              : i && i.isVector4
              ? (t.uniforms[n] = { type: "v4", value: i.toArray() })
              : i && i.isMatrix3
              ? (t.uniforms[n] = { type: "m3", value: i.toArray() })
              : i && i.isMatrix4
              ? (t.uniforms[n] = { type: "m4", value: i.toArray() })
              : (t.uniforms[n] = { value: i });
          }
          Object.keys(this.defines).length > 0 && (t.defines = this.defines),
            (t.vertexShader = this.vertexShader),
            (t.fragmentShader = this.fragmentShader),
            (t.lights = this.lights),
            (t.clipping = this.clipping);
          const n = {};
          for (const e in this.extensions)
            !0 === this.extensions[e] && (n[e] = !0);
          return Object.keys(n).length > 0 && (t.extensions = n), t;
        }
      }
      class vr extends ui {
        constructor() {
          super(),
            (this.isCamera = !0),
            (this.type = "Camera"),
            (this.matrixWorldInverse = new Nn()),
            (this.projectionMatrix = new Nn()),
            (this.projectionMatrixInverse = new Nn()),
            (this.coordinateSystem = mt);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.matrixWorldInverse.copy(e.matrixWorldInverse),
            this.projectionMatrix.copy(e.projectionMatrix),
            this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
            (this.coordinateSystem = e.coordinateSystem),
            this
          );
        }
        getWorldDirection(e) {
          return super.getWorldDirection(e).negate();
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        updateWorldMatrix(e, t) {
          super.updateWorldMatrix(e, t),
            this.matrixWorldInverse.copy(this.matrixWorld).invert();
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const yr = new on(),
        xr = new Rt(),
        _r = new Rt();
      class br extends vr {
        constructor(e = 50, t = 1, n = 0.1, i = 2e3) {
          super(),
            (this.isPerspectiveCamera = !0),
            (this.type = "PerspectiveCamera"),
            (this.fov = e),
            (this.zoom = 1),
            (this.near = n),
            (this.far = i),
            (this.focus = 10),
            (this.aspect = t),
            (this.view = null),
            (this.filmGauge = 35),
            (this.filmOffset = 0),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.fov = e.fov),
            (this.zoom = e.zoom),
            (this.near = e.near),
            (this.far = e.far),
            (this.focus = e.focus),
            (this.aspect = e.aspect),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            (this.filmGauge = e.filmGauge),
            (this.filmOffset = e.filmOffset),
            this
          );
        }
        setFocalLength(e) {
          const t = (0.5 * this.getFilmHeight()) / e;
          (this.fov = 2 * Et * Math.atan(t)), this.updateProjectionMatrix();
        }
        getFocalLength() {
          const e = Math.tan(0.5 * bt * this.fov);
          return (0.5 * this.getFilmHeight()) / e;
        }
        getEffectiveFOV() {
          return 2 * Et * Math.atan(Math.tan(0.5 * bt * this.fov) / this.zoom);
        }
        getFilmWidth() {
          return this.filmGauge * Math.min(this.aspect, 1);
        }
        getFilmHeight() {
          return this.filmGauge / Math.max(this.aspect, 1);
        }
        getViewBounds(e, t, n) {
          yr.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            t.set(yr.x, yr.y).multiplyScalar(-e / yr.z),
            yr.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse),
            n.set(yr.x, yr.y).multiplyScalar(-e / yr.z);
        }
        getViewSize(e, t) {
          return this.getViewBounds(e, xr, _r), t.subVectors(_r, xr);
        }
        setViewOffset(e, t, n, i, r, s) {
          (this.aspect = e / t),
            null === this.view &&
              (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1,
              }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = this.near;
          let t = (e * Math.tan(0.5 * bt * this.fov)) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            r = -0.5 * i;
          const s = this.view;
          if (null !== this.view && this.view.enabled) {
            const e = s.fullWidth,
              a = s.fullHeight;
            (r += (s.offsetX * i) / e),
              (t -= (s.offsetY * n) / a),
              (i *= s.width / e),
              (n *= s.height / a);
          }
          const a = this.filmOffset;
          0 !== a && (r += (e * a) / this.getFilmWidth()),
            this.projectionMatrix.makePerspective(
              r,
              r + i,
              t,
              t - n,
              e,
              this.far,
              this.coordinateSystem
            ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.fov = this.fov),
            (t.object.zoom = this.zoom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            (t.object.focus = this.focus),
            (t.object.aspect = this.aspect),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            (t.object.filmGauge = this.filmGauge),
            (t.object.filmOffset = this.filmOffset),
            t
          );
        }
      }
      const Er = -90;
      class wr extends ui {
        constructor(e, t, n) {
          super(),
            (this.type = "CubeCamera"),
            (this.renderTarget = n),
            (this.coordinateSystem = null),
            (this.activeMipmapLevel = 0);
          const i = new br(Er, 1, e, t);
          (i.layers = this.layers), this.add(i);
          const r = new br(Er, 1, e, t);
          (r.layers = this.layers), this.add(r);
          const s = new br(Er, 1, e, t);
          (s.layers = this.layers), this.add(s);
          const a = new br(Er, 1, e, t);
          (a.layers = this.layers), this.add(a);
          const o = new br(Er, 1, e, t);
          (o.layers = this.layers), this.add(o);
          const l = new br(Er, 1, e, t);
          (l.layers = this.layers), this.add(l);
        }
        updateCoordinateSystem() {
          const e = this.coordinateSystem,
            t = this.children.concat(),
            [n, i, r, s, a, o] = t;
          for (const e of t) this.remove(e);
          if (e === mt)
            n.up.set(0, 1, 0),
              n.lookAt(1, 0, 0),
              i.up.set(0, 1, 0),
              i.lookAt(-1, 0, 0),
              r.up.set(0, 0, -1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, 1),
              s.lookAt(0, -1, 0),
              a.up.set(0, 1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, 1, 0),
              o.lookAt(0, 0, -1);
          else {
            if (e !== vt)
              throw new Error(
                "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
                  e
              );
            n.up.set(0, -1, 0),
              n.lookAt(-1, 0, 0),
              i.up.set(0, -1, 0),
              i.lookAt(1, 0, 0),
              r.up.set(0, 0, 1),
              r.lookAt(0, 1, 0),
              s.up.set(0, 0, -1),
              s.lookAt(0, -1, 0),
              a.up.set(0, -1, 0),
              a.lookAt(0, 0, 1),
              o.up.set(0, -1, 0),
              o.lookAt(0, 0, -1);
          }
          for (const e of t) this.add(e), e.updateMatrixWorld();
        }
        update(e, t) {
          null === this.parent && this.updateMatrixWorld();
          const { renderTarget: n, activeMipmapLevel: i } = this;
          this.coordinateSystem !== e.coordinateSystem &&
            ((this.coordinateSystem = e.coordinateSystem),
            this.updateCoordinateSystem());
          const [r, s, a, o, l, c] = this.children,
            u = e.getRenderTarget(),
            h = e.getActiveCubeFace(),
            d = e.getActiveMipmapLevel(),
            p = e.xr.enabled;
          e.xr.enabled = !1;
          const f = n.texture.generateMipmaps;
          (n.texture.generateMipmaps = !1),
            e.setRenderTarget(n, 0, i),
            e.render(t, r),
            e.setRenderTarget(n, 1, i),
            e.render(t, s),
            e.setRenderTarget(n, 2, i),
            e.render(t, a),
            e.setRenderTarget(n, 3, i),
            e.render(t, o),
            e.setRenderTarget(n, 4, i),
            e.render(t, l),
            (n.texture.generateMipmaps = f),
            e.setRenderTarget(n, 5, i),
            e.render(t, c),
            e.setRenderTarget(u, h, d),
            (e.xr.enabled = p),
            (n.texture.needsPMREMUpdate = !0);
        }
      }
      class Cr extends $t {
        constructor(e, t, n, i, r, s, a, o, l, c) {
          super(
            (e = void 0 !== e ? e : []),
            (t = void 0 !== t ? t : D),
            n,
            i,
            r,
            s,
            a,
            o,
            l,
            c
          ),
            (this.isCubeTexture = !0),
            (this.flipY = !1);
        }
        get images() {
          return this.image;
        }
        set images(e) {
          this.image = e;
        }
      }
      class Ir extends nn {
        constructor(e = 1, t = {}) {
          super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
          const n = { width: e, height: e, depth: 1 },
            i = [n, n, n, n, n, n];
          (this.texture = new Cr(
            i,
            t.mapping,
            t.wrapS,
            t.wrapT,
            t.magFilter,
            t.minFilter,
            t.format,
            t.type,
            t.anisotropy,
            t.colorSpace
          )),
            (this.texture.isRenderTargetTexture = !0),
            (this.texture.generateMipmaps =
              void 0 !== t.generateMipmaps && t.generateMipmaps),
            (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : z);
        }
        fromEquirectangularTexture(e, t) {
          (this.texture.type = t.type),
            (this.texture.colorSpace = t.colorSpace),
            (this.texture.generateMipmaps = t.generateMipmaps),
            (this.texture.minFilter = t.minFilter),
            (this.texture.magFilter = t.magFilter);
          const n = {
              uniforms: { tEquirect: { value: null } },
              vertexShader:
                "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
              fragmentShader:
                "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
            },
            i = new dr(5, 5, 5),
            r = new mr({
              name: "CubemapFromEquirect",
              uniforms: pr(n.uniforms),
              vertexShader: n.vertexShader,
              fragmentShader: n.fragmentShader,
              side: l,
              blending: u,
            });
          r.uniforms.tEquirect.value = t;
          const s = new ur(i, r),
            a = t.minFilter;
          t.minFilter === W && (t.minFilter = z);
          return (
            new wr(1, 10, this).update(e, s),
            (t.minFilter = a),
            s.geometry.dispose(),
            s.material.dispose(),
            this
          );
        }
        clear(e, t, n, i) {
          const r = e.getRenderTarget();
          for (let r = 0; r < 6; r++)
            e.setRenderTarget(this, r), e.clear(t, n, i);
          e.setRenderTarget(r);
        }
      }
      const Sr = new on(),
        Mr = new on(),
        Tr = new Dt();
      class Br {
        constructor(e = new on(1, 0, 0), t = 0) {
          (this.isPlane = !0), (this.normal = e), (this.constant = t);
        }
        set(e, t) {
          return this.normal.copy(e), (this.constant = t), this;
        }
        setComponents(e, t, n, i) {
          return this.normal.set(e, t, n), (this.constant = i), this;
        }
        setFromNormalAndCoplanarPoint(e, t) {
          return (
            this.normal.copy(e), (this.constant = -t.dot(this.normal)), this
          );
        }
        setFromCoplanarPoints(e, t, n) {
          const i = Sr.subVectors(n, t).cross(Mr.subVectors(e, t)).normalize();
          return this.setFromNormalAndCoplanarPoint(i, e), this;
        }
        copy(e) {
          return this.normal.copy(e.normal), (this.constant = e.constant), this;
        }
        normalize() {
          const e = 1 / this.normal.length();
          return this.normal.multiplyScalar(e), (this.constant *= e), this;
        }
        negate() {
          return (this.constant *= -1), this.normal.negate(), this;
        }
        distanceToPoint(e) {
          return this.normal.dot(e) + this.constant;
        }
        distanceToSphere(e) {
          return this.distanceToPoint(e.center) - e.radius;
        }
        projectPoint(e, t) {
          return t
            .copy(e)
            .addScaledVector(this.normal, -this.distanceToPoint(e));
        }
        intersectLine(e, t) {
          const n = e.delta(Sr),
            i = this.normal.dot(n);
          if (0 === i)
            return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
          const r = -(e.start.dot(this.normal) + this.constant) / i;
          return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r);
        }
        intersectsLine(e) {
          const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
          return (t < 0 && n > 0) || (n < 0 && t > 0);
        }
        intersectsBox(e) {
          return e.intersectsPlane(this);
        }
        intersectsSphere(e) {
          return e.intersectsPlane(this);
        }
        coplanarPoint(e) {
          return e.copy(this.normal).multiplyScalar(-this.constant);
        }
        applyMatrix4(e, t) {
          const n = t || Tr.getNormalMatrix(e),
            i = this.coplanarPoint(Sr).applyMatrix4(e),
            r = this.normal.applyMatrix3(n).normalize();
          return (this.constant = -i.dot(r)), this;
        }
        translate(e) {
          return (this.constant -= e.dot(this.normal)), this;
        }
        equals(e) {
          return e.normal.equals(this.normal) && e.constant === this.constant;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      const Rr = new Mn(),
        Dr = new on();
      class Pr {
        constructor(
          e = new Br(),
          t = new Br(),
          n = new Br(),
          i = new Br(),
          r = new Br(),
          s = new Br()
        ) {
          this.planes = [e, t, n, i, r, s];
        }
        set(e, t, n, i, r, s) {
          const a = this.planes;
          return (
            a[0].copy(e),
            a[1].copy(t),
            a[2].copy(n),
            a[3].copy(i),
            a[4].copy(r),
            a[5].copy(s),
            this
          );
        }
        copy(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
          return this;
        }
        setFromProjectionMatrix(e, t = 2e3) {
          const n = this.planes,
            i = e.elements,
            r = i[0],
            s = i[1],
            a = i[2],
            o = i[3],
            l = i[4],
            c = i[5],
            u = i[6],
            h = i[7],
            d = i[8],
            p = i[9],
            f = i[10],
            A = i[11],
            g = i[12],
            m = i[13],
            v = i[14],
            y = i[15];
          if (
            (n[0].setComponents(o - r, h - l, A - d, y - g).normalize(),
            n[1].setComponents(o + r, h + l, A + d, y + g).normalize(),
            n[2].setComponents(o + s, h + c, A + p, y + m).normalize(),
            n[3].setComponents(o - s, h - c, A - p, y - m).normalize(),
            n[4].setComponents(o - a, h - u, A - f, y - v).normalize(),
            t === mt)
          )
            n[5].setComponents(o + a, h + u, A + f, y + v).normalize();
          else {
            if (t !== vt)
              throw new Error(
                "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
                  t
              );
            n[5].setComponents(a, u, f, v).normalize();
          }
          return this;
        }
        intersectsObject(e) {
          if (void 0 !== e.boundingSphere)
            null === e.boundingSphere && e.computeBoundingSphere(),
              Rr.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
          else {
            const t = e.geometry;
            null === t.boundingSphere && t.computeBoundingSphere(),
              Rr.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
          }
          return this.intersectsSphere(Rr);
        }
        intersectsSprite(e) {
          return (
            Rr.center.set(0, 0, 0),
            (Rr.radius = 0.7071067811865476),
            Rr.applyMatrix4(e.matrixWorld),
            this.intersectsSphere(Rr)
          );
        }
        intersectsSphere(e) {
          const t = this.planes,
            n = e.center,
            i = -e.radius;
          for (let e = 0; e < 6; e++) {
            if (t[e].distanceToPoint(n) < i) return !1;
          }
          return !0;
        }
        intersectsBox(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (
              ((Dr.x = i.normal.x > 0 ? e.max.x : e.min.x),
              (Dr.y = i.normal.y > 0 ? e.max.y : e.min.y),
              (Dr.z = i.normal.z > 0 ? e.max.z : e.min.z),
              i.distanceToPoint(Dr) < 0)
            )
              return !1;
          }
          return !0;
        }
        containsPoint(e) {
          const t = this.planes;
          for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
          return !0;
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      function Lr() {
        let e = null,
          t = !1,
          n = null,
          i = null;
        function r(t, s) {
          n(t, s), (i = e.requestAnimationFrame(r));
        }
        return {
          start: function () {
            !0 !== t &&
              null !== n &&
              ((i = e.requestAnimationFrame(r)), (t = !0));
          },
          stop: function () {
            e.cancelAnimationFrame(i), (t = !1);
          },
          setAnimationLoop: function (e) {
            n = e;
          },
          setContext: function (t) {
            e = t;
          },
        };
      }
      function Ur(e) {
        const t = new WeakMap();
        return {
          get: function (e) {
            return e.isInterleavedBufferAttribute && (e = e.data), t.get(e);
          },
          remove: function (n) {
            n.isInterleavedBufferAttribute && (n = n.data);
            const i = t.get(n);
            i && (e.deleteBuffer(i.buffer), t.delete(n));
          },
          update: function (n, i) {
            if (
              (n.isInterleavedBufferAttribute && (n = n.data),
              n.isGLBufferAttribute)
            ) {
              const e = t.get(n);
              return void (
                (!e || e.version < n.version) &&
                t.set(n, {
                  buffer: n.buffer,
                  type: n.type,
                  bytesPerElement: n.elementSize,
                  version: n.version,
                })
              );
            }
            const r = t.get(n);
            if (void 0 === r)
              t.set(
                n,
                (function (t, n) {
                  const i = t.array,
                    r = t.usage,
                    s = i.byteLength,
                    a = e.createBuffer();
                  let o;
                  if (
                    (e.bindBuffer(n, a),
                    e.bufferData(n, i, r),
                    t.onUploadCallback(),
                    i instanceof Float32Array)
                  )
                    o = e.FLOAT;
                  else if (i instanceof Uint16Array)
                    o = t.isFloat16BufferAttribute
                      ? e.HALF_FLOAT
                      : e.UNSIGNED_SHORT;
                  else if (i instanceof Int16Array) o = e.SHORT;
                  else if (i instanceof Uint32Array) o = e.UNSIGNED_INT;
                  else if (i instanceof Int32Array) o = e.INT;
                  else if (i instanceof Int8Array) o = e.BYTE;
                  else if (i instanceof Uint8Array) o = e.UNSIGNED_BYTE;
                  else {
                    if (!(i instanceof Uint8ClampedArray))
                      throw new Error(
                        "THREE.WebGLAttributes: Unsupported buffer data format: " +
                          i
                      );
                    o = e.UNSIGNED_BYTE;
                  }
                  return {
                    buffer: a,
                    type: o,
                    bytesPerElement: i.BYTES_PER_ELEMENT,
                    version: t.version,
                    size: s,
                  };
                })(n, i)
              );
            else if (r.version < n.version) {
              if (r.size !== n.array.byteLength)
                throw new Error(
                  "THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported."
                );
              !(function (t, n, i) {
                const r = n.array,
                  s = n.updateRanges;
                if ((e.bindBuffer(i, t), 0 === s.length))
                  e.bufferSubData(i, 0, r);
                else {
                  s.sort((e, t) => e.start - t.start);
                  let t = 0;
                  for (let e = 1; e < s.length; e++) {
                    const n = s[t],
                      i = s[e];
                    i.start <= n.start + n.count + 1
                      ? (n.count = Math.max(
                          n.count,
                          i.start + i.count - n.start
                        ))
                      : (++t, (s[t] = i));
                  }
                  s.length = t + 1;
                  for (let t = 0, n = s.length; t < n; t++) {
                    const n = s[t];
                    e.bufferSubData(
                      i,
                      n.start * r.BYTES_PER_ELEMENT,
                      r,
                      n.start,
                      n.count
                    );
                  }
                  n.clearUpdateRanges();
                }
                n.onUploadCallback();
              })(r.buffer, n, i),
                (r.version = n.version);
            }
          },
        };
      }
      class Fr extends Zi {
        constructor(e = 1, t = 1, n = 1, i = 1) {
          super(),
            (this.type = "PlaneGeometry"),
            (this.parameters = {
              width: e,
              height: t,
              widthSegments: n,
              heightSegments: i,
            });
          const r = e / 2,
            s = t / 2,
            a = Math.floor(n),
            o = Math.floor(i),
            l = a + 1,
            c = o + 1,
            u = e / a,
            h = t / o,
            d = [],
            p = [],
            f = [],
            A = [];
          for (let e = 0; e < c; e++) {
            const t = e * h - s;
            for (let n = 0; n < l; n++) {
              const i = n * u - r;
              p.push(i, -t, 0),
                f.push(0, 0, 1),
                A.push(n / a),
                A.push(1 - e / o);
            }
          }
          for (let e = 0; e < o; e++)
            for (let t = 0; t < a; t++) {
              const n = t + l * e,
                i = t + l * (e + 1),
                r = t + 1 + l * (e + 1),
                s = t + 1 + l * e;
              d.push(n, i, s), d.push(i, r, s);
            }
          this.setIndex(d),
            this.setAttribute("position", new Vi(p, 3)),
            this.setAttribute("normal", new Vi(f, 3)),
            this.setAttribute("uv", new Vi(A, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new Fr(e.width, e.height, e.widthSegments, e.heightSegments);
        }
      }
      const Nr = {
          alphahash_fragment:
            "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
          alphahash_pars_fragment:
            "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
          alphamap_fragment:
            "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
          alphamap_pars_fragment:
            "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          alphatest_fragment:
            "#ifdef USE_ALPHATEST\n\t#ifdef ALPHA_TO_COVERAGE\n\tdiffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\tif ( diffuseColor.a < alphaTest ) discard;\n\t#endif\n#endif",
          alphatest_pars_fragment:
            "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
          aomap_fragment:
            "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_CLEARCOAT ) \n\t\tclearcoatSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_SHEEN ) \n\t\tsheenSpecularIndirect *= ambientOcclusion;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
          aomap_pars_fragment:
            "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
          batching_pars_vertex:
            "#ifdef USE_BATCHING\n\t#if ! defined( GL_ANGLE_multi_draw )\n\t#define gl_DrawID _gl_DrawID\n\tuniform int _gl_DrawID;\n\t#endif\n\tuniform highp sampler2D batchingTexture;\n\tuniform highp usampler2D batchingIdTexture;\n\tmat4 getBatchingMatrix( const in float i ) {\n\t\tint size = textureSize( batchingTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n\tfloat getIndirectIndex( const in int i ) {\n\t\tint size = textureSize( batchingIdTexture, 0 ).x;\n\t\tint x = i % size;\n\t\tint y = i / size;\n\t\treturn float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n\t}\n#endif\n#ifdef USE_BATCHING_COLOR\n\tuniform sampler2D batchingColorTexture;\n\tvec3 getBatchingColor( const in float i ) {\n\t\tint size = textureSize( batchingColorTexture, 0 ).x;\n\t\tint j = int( i );\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\treturn texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n\t}\n#endif",
          batching_vertex:
            "#ifdef USE_BATCHING\n\tmat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif",
          begin_vertex:
            "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
          beginnormal_vertex:
            "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
          bsdfs:
            "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
          iridescence_fragment:
            "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
          bumpmap_pars_fragment:
            "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n\t\tvec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
          clipping_planes_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#ifdef ALPHA_TO_COVERAGE\n\t\tfloat distanceToPlane, distanceGradient;\n\t\tfloat clipOpacity = 1.0;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\tclipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\tif ( clipOpacity == 0.0 ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tfloat unionClipOpacity = 1.0;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tdistanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n\t\t\t\tdistanceGradient = fwidth( distanceToPlane ) / 2.0;\n\t\t\t\tunionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tclipOpacity *= 1.0 - unionClipOpacity;\n\t\t#endif\n\t\tdiffuseColor.a *= clipOpacity;\n\t\tif ( diffuseColor.a == 0.0 ) discard;\n\t#else\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\t\tbool clipped = true;\n\t\t\t#pragma unroll_loop_start\n\t\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\t\tplane = clippingPlanes[ i ];\n\t\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t\t}\n\t\t\t#pragma unroll_loop_end\n\t\t\tif ( clipped ) discard;\n\t\t#endif\n\t#endif\n#endif",
          clipping_planes_pars_fragment:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
          clipping_planes_pars_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
          clipping_planes_vertex:
            "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
          color_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
          color_pars_fragment:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_pars_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvarying vec3 vColor;\n#endif",
          color_vertex:
            "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n\tvec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n\tvColor.xyz *= batchingColor.xyz;\n#endif",
          common:
            "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
          cube_uv_reflection_fragment:
            "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
          defaultnormal_vertex:
            "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n\tmat3 bm = mat3( batchingMatrix );\n\ttransformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n\ttransformedNormal = bm * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = bm * transformedTangent;\n\t#endif\n#endif\n#ifdef USE_INSTANCING\n\tmat3 im = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n\ttransformedNormal = im * transformedNormal;\n\t#ifdef USE_TANGENT\n\t\ttransformedTangent = im * transformedTangent;\n\t#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\ttransformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
          displacementmap_pars_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
          displacementmap_vertex:
            "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
          emissivemap_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n\t\temissiveColor = sRGBTransferEOTF( emissiveColor );\n\t#endif\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
          emissivemap_pars_fragment:
            "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
          colorspace_fragment:
            "gl_FragColor = linearToOutputTexel( gl_FragColor );",
          colorspace_pars_fragment:
            "vec4 LinearTransferOETF( in vec4 value ) {\n\treturn value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
          envmap_fragment:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
          envmap_common_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform mat3 envMapRotation;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
          envmap_pars_fragment:
            "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
          envmap_pars_vertex:
            "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
          envmap_physical_pars_fragment:
            "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
          envmap_vertex:
            "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
          fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
          fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
          fog_fragment:
            "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
          fog_pars_fragment:
            "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
          gradientmap_pars_fragment:
            "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
          lightmap_pars_fragment:
            "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
          lights_lambert_fragment:
            "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
          lights_lambert_pars_fragment:
            "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
          lights_pars_begin:
            "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n\tuniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif ( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometryPosition;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
          lights_toon_fragment:
            "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
          lights_toon_pars_fragment:
            "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
          lights_phong_fragment:
            "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
          lights_phong_pars_fragment:
            "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
          lights_physical_fragment:
            "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n\tmaterial.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tif( material.anisotropy == 0.0 ) {\n\t\tanisotropyV = vec2( 1.0, 0.0 );\n\t} else {\n\t\tanisotropyV /= material.anisotropy;\n\t\tmaterial.anisotropy = saturate( material.anisotropy );\n\t}\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif",
          lights_physical_pars_fragment:
            "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\tfloat dispersion;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometryNormal;\n\t\tvec3 viewDir = geometryViewDir;\n\t\tvec3 position = geometryPosition;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
          lights_fragment_begin:
            "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n\tgeometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometryViewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometryPosition, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometryPosition, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if defined( USE_LIGHT_PROBES )\n\t\tirradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
          lights_fragment_maps:
            "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometryNormal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
          lights_fragment_end:
            "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif",
          logdepthbuf_fragment:
            "#if defined( USE_LOGDEPTHBUF )\n\tgl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
          logdepthbuf_pars_fragment:
            "#if defined( USE_LOGDEPTHBUF )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_pars_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
          logdepthbuf_vertex:
            "#ifdef USE_LOGDEPTHBUF\n\tvFragDepth = 1.0 + gl_Position.w;\n\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif",
          map_fragment:
            "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
          map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
          map_particle_fragment:
            "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
          map_particle_pars_fragment:
            "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
          metalnessmap_fragment:
            "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
          metalnessmap_pars_fragment:
            "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
          morphinstance_vertex:
            "#ifdef USE_INSTANCING_MORPH\n\tfloat morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\tfloat morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tmorphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n\t}\n#endif",
          morphcolor_vertex:
            "#if defined( USE_MORPHCOLORS )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
          morphnormal_vertex:
            "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
          morphtarget_pars_vertex:
            "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_INSTANCING_MORPH\n\t\tuniform float morphTargetBaseInfluence;\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t#endif\n\tuniform sampler2DArray morphTargetsTexture;\n\tuniform ivec2 morphTargetsTextureSize;\n\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t}\n#endif",
          morphtarget_vertex:
            "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t}\n#endif",
          normal_fragment_begin:
            "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 nonPerturbedNormal = normal;",
          normal_fragment_maps:
            "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
          normal_pars_fragment:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_pars_vertex:
            "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
          normal_vertex:
            "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
          normalmap_pars_fragment:
            "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
          clearcoat_normal_fragment_begin:
            "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = nonPerturbedNormal;\n#endif",
          clearcoat_normal_fragment_maps:
            "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
          clearcoat_pars_fragment:
            "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
          iridescence_pars_fragment:
            "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
          opaque_fragment:
            "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
          packing:
            "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec4( 0., 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec4( 1., 1., 1., 1. );\n\tfloat vuf;\n\tfloat af = modf( v * PackFactors.a, vuf );\n\tfloat bf = modf( vuf * ShiftRight8, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec3( 0., 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec3( 1., 1., 1. );\n\tfloat vuf;\n\tfloat bf = modf( v * PackFactors.b, vuf );\n\tfloat gf = modf( vuf * ShiftRight8, vuf );\n\treturn vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n\tif( v <= 0.0 )\n\t\treturn vec2( 0., 0. );\n\tif( v >= 1.0 )\n\t\treturn vec2( 1., 1. );\n\tfloat vuf;\n\tfloat gf = modf( v * 256., vuf );\n\treturn vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n\treturn dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n\treturn v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
          premultiplied_alpha_fragment:
            "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
          project_vertex:
            "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n\tmvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
          dithering_fragment:
            "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
          dithering_pars_fragment:
            "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
          roughnessmap_fragment:
            "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
          roughnessmap_pars_fragment:
            "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
          shadowmap_pars_fragment:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tfloat shadow = 1.0;\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\t\n\t\tfloat lightToPositionLength = length( lightToPosition );\n\t\tif ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {\n\t\t\tfloat dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\t\tdp += shadowBias;\n\t\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\t\tshadow = (\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t\t) * ( 1.0 / 9.0 );\n\t\t\t#else\n\t\t\t\tshadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t\t#endif\n\t\t}\n\t\treturn mix( 1.0, shadow, shadowIntensity );\n\t}\n#endif",
          shadowmap_pars_vertex:
            "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowIntensity;\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
          shadowmap_vertex:
            "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
          shadowmask_pars_fragment:
            "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
          skinbase_vertex:
            "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
          skinning_pars_vertex:
            "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tint size = textureSize( boneTexture, 0 ).x;\n\t\tint j = int( i ) * 4;\n\t\tint x = j % size;\n\t\tint y = j / size;\n\t\tvec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n\t\tvec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n\t\tvec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n\t\tvec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n\t\treturn mat4( v1, v2, v3, v4 );\n\t}\n#endif",
          skinning_vertex:
            "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
          skinnormal_vertex:
            "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
          specularmap_fragment:
            "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
          specularmap_pars_fragment:
            "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
          tonemapping_fragment:
            "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
          tonemapping_pars_fragment:
            "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n\tvec3( 1.6605, - 0.1246, - 0.0182 ),\n\tvec3( - 0.5876, 1.1329, - 0.1006 ),\n\tvec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n\tvec3( 0.6274, 0.0691, 0.0164 ),\n\tvec3( 0.3293, 0.9195, 0.0880 ),\n\tvec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n\tvec3 x2 = x * x;\n\tvec3 x4 = x2 * x2;\n\treturn + 15.5 * x4 * x2\n\t\t- 40.14 * x4 * x\n\t\t+ 31.96 * x4\n\t\t- 6.868 * x2 * x\n\t\t+ 0.4298 * x2\n\t\t+ 0.1191 * x\n\t\t- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n\tconst mat3 AgXInsetMatrix = mat3(\n\t\tvec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n\t\tvec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n\t\tvec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n\t);\n\tconst mat3 AgXOutsetMatrix = mat3(\n\t\tvec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n\t\tvec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n\t\tvec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n\t);\n\tconst float AgxMinEv = - 12.47393;\tconst float AgxMaxEv = 4.026069;\n\tcolor *= toneMappingExposure;\n\tcolor = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n\tcolor = AgXInsetMatrix * color;\n\tcolor = max( color, 1e-10 );\tcolor = log2( color );\n\tcolor = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n\tcolor = clamp( color, 0.0, 1.0 );\n\tcolor = agxDefaultContrastApprox( color );\n\tcolor = AgXOutsetMatrix * color;\n\tcolor = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n\tcolor = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n\tcolor = clamp( color, 0.0, 1.0 );\n\treturn color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n\tconst float StartCompression = 0.8 - 0.04;\n\tconst float Desaturation = 0.15;\n\tcolor *= toneMappingExposure;\n\tfloat x = min( color.r, min( color.g, color.b ) );\n\tfloat offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n\tcolor -= offset;\n\tfloat peak = max( color.r, max( color.g, color.b ) );\n\tif ( peak < StartCompression ) return color;\n\tfloat d = 1. - StartCompression;\n\tfloat newPeak = 1. - d * d / ( peak + d - StartCompression );\n\tcolor *= newPeak / peak;\n\tfloat g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n\treturn mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
          transmission_fragment:
            "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
          transmission_pars_fragment:
            "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec4 transmittedLight;\n\t\tvec3 transmittance;\n\t\t#ifdef USE_DISPERSION\n\t\t\tfloat halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n\t\t\tvec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n\t\t\tfor ( int i = 0; i < 3; i ++ ) {\n\t\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n\t\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\n\t\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\t\trefractionCoords += 1.0;\n\t\t\t\trefractionCoords /= 2.0;\n\t\t\n\t\t\t\tvec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n\t\t\t\ttransmittedLight[ i ] = transmissionSample[ i ];\n\t\t\t\ttransmittedLight.a += transmissionSample.a;\n\t\t\t\ttransmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n\t\t\t}\n\t\t\ttransmittedLight.a /= 3.0;\n\t\t\n\t\t#else\n\t\t\n\t\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\t\trefractionCoords += 1.0;\n\t\t\trefractionCoords /= 2.0;\n\t\t\ttransmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\t\ttransmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\t\n\t\t#endif\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
          uv_pars_fragment:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_pars_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
          uv_vertex:
            "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
          worldpos_vertex:
            "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_BATCHING\n\t\tworldPosition = batchingMatrix * worldPosition;\n\t#endif\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
          background_vert:
            "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
          background_frag:
            "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          backgroundCube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          backgroundCube_frag:
            "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          cube_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
          cube_frag:
            "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          depth_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
          depth_frag:
            "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#elif DEPTH_PACKING == 3202\n\t\tgl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n\t#elif DEPTH_PACKING == 3203\n\t\tgl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n\t#endif\n}",
          distanceRGBA_vert:
            "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <skinbase_vertex>\n\t#include <morphinstance_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
          distanceRGBA_frag:
            "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <clipping_planes_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
          equirect_vert:
            "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
          equirect_frag:
            "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
          linedashed_vert:
            "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          linedashed_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          meshbasic_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
          meshbasic_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshlambert_vert:
            "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshlambert_frag:
            "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshmatcap_vert:
            "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
          meshmatcap_frag:
            "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshnormal_vert:
            "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
          meshnormal_frag:
            "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
          meshphong_vert:
            "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshphong_frag:
            "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshphysical_vert:
            "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
          meshphysical_frag:
            "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n\tuniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          meshtoon_vert:
            "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          meshtoon_frag:
            "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
          points_vert:
            "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
          points_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
          shadow_vert:
            "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <batching_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphinstance_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
          shadow_frag:
            "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
          sprite_vert:
            "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix[ 3 ];\n\tvec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
          sprite_frag:
            "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
        },
        Or = {
          common: {
            diffuse: { value: new Ti(16777215) },
            opacity: { value: 1 },
            map: { value: null },
            mapTransform: { value: new Dt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
          },
          specularmap: {
            specularMap: { value: null },
            specularMapTransform: { value: new Dt() },
          },
          envmap: {
            envMap: { value: null },
            envMapRotation: { value: new Dt() },
            flipEnvMap: { value: -1 },
            reflectivity: { value: 1 },
            ior: { value: 1.5 },
            refractionRatio: { value: 0.98 },
          },
          aomap: {
            aoMap: { value: null },
            aoMapIntensity: { value: 1 },
            aoMapTransform: { value: new Dt() },
          },
          lightmap: {
            lightMap: { value: null },
            lightMapIntensity: { value: 1 },
            lightMapTransform: { value: new Dt() },
          },
          bumpmap: {
            bumpMap: { value: null },
            bumpMapTransform: { value: new Dt() },
            bumpScale: { value: 1 },
          },
          normalmap: {
            normalMap: { value: null },
            normalMapTransform: { value: new Dt() },
            normalScale: { value: new Rt(1, 1) },
          },
          displacementmap: {
            displacementMap: { value: null },
            displacementMapTransform: { value: new Dt() },
            displacementScale: { value: 1 },
            displacementBias: { value: 0 },
          },
          emissivemap: {
            emissiveMap: { value: null },
            emissiveMapTransform: { value: new Dt() },
          },
          metalnessmap: {
            metalnessMap: { value: null },
            metalnessMapTransform: { value: new Dt() },
          },
          roughnessmap: {
            roughnessMap: { value: null },
            roughnessMapTransform: { value: new Dt() },
          },
          gradientmap: { gradientMap: { value: null } },
          fog: {
            fogDensity: { value: 25e-5 },
            fogNear: { value: 1 },
            fogFar: { value: 2e3 },
            fogColor: { value: new Ti(16777215) },
          },
          lights: {
            ambientLightColor: { value: [] },
            lightProbe: { value: [] },
            directionalLights: {
              value: [],
              properties: { direction: {}, color: {} },
            },
            directionalLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            directionalShadowMap: { value: [] },
            directionalShadowMatrix: { value: [] },
            spotLights: {
              value: [],
              properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {},
              },
            },
            spotLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
              },
            },
            spotLightMap: { value: [] },
            spotShadowMap: { value: [] },
            spotLightMatrix: { value: [] },
            pointLights: {
              value: [],
              properties: { color: {}, position: {}, decay: {}, distance: {} },
            },
            pointLightShadows: {
              value: [],
              properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {},
              },
            },
            pointShadowMap: { value: [] },
            pointShadowMatrix: { value: [] },
            hemisphereLights: {
              value: [],
              properties: { direction: {}, skyColor: {}, groundColor: {} },
            },
            rectAreaLights: {
              value: [],
              properties: { color: {}, position: {}, width: {}, height: {} },
            },
            ltc_1: { value: null },
            ltc_2: { value: null },
          },
          points: {
            diffuse: { value: new Ti(16777215) },
            opacity: { value: 1 },
            size: { value: 1 },
            scale: { value: 1 },
            map: { value: null },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
            uvTransform: { value: new Dt() },
          },
          sprite: {
            diffuse: { value: new Ti(16777215) },
            opacity: { value: 1 },
            center: { value: new Rt(0.5, 0.5) },
            rotation: { value: 0 },
            map: { value: null },
            mapTransform: { value: new Dt() },
            alphaMap: { value: null },
            alphaMapTransform: { value: new Dt() },
            alphaTest: { value: 0 },
          },
        },
        Qr = {
          basic: {
            uniforms: fr([
              Or.common,
              Or.specularmap,
              Or.envmap,
              Or.aomap,
              Or.lightmap,
              Or.fog,
            ]),
            vertexShader: Nr.meshbasic_vert,
            fragmentShader: Nr.meshbasic_frag,
          },
          lambert: {
            uniforms: fr([
              Or.common,
              Or.specularmap,
              Or.envmap,
              Or.aomap,
              Or.lightmap,
              Or.emissivemap,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              Or.fog,
              Or.lights,
              { emissive: { value: new Ti(0) } },
            ]),
            vertexShader: Nr.meshlambert_vert,
            fragmentShader: Nr.meshlambert_frag,
          },
          phong: {
            uniforms: fr([
              Or.common,
              Or.specularmap,
              Or.envmap,
              Or.aomap,
              Or.lightmap,
              Or.emissivemap,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              Or.fog,
              Or.lights,
              {
                emissive: { value: new Ti(0) },
                specular: { value: new Ti(1118481) },
                shininess: { value: 30 },
              },
            ]),
            vertexShader: Nr.meshphong_vert,
            fragmentShader: Nr.meshphong_frag,
          },
          standard: {
            uniforms: fr([
              Or.common,
              Or.envmap,
              Or.aomap,
              Or.lightmap,
              Or.emissivemap,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              Or.roughnessmap,
              Or.metalnessmap,
              Or.fog,
              Or.lights,
              {
                emissive: { value: new Ti(0) },
                roughness: { value: 1 },
                metalness: { value: 0 },
                envMapIntensity: { value: 1 },
              },
            ]),
            vertexShader: Nr.meshphysical_vert,
            fragmentShader: Nr.meshphysical_frag,
          },
          toon: {
            uniforms: fr([
              Or.common,
              Or.aomap,
              Or.lightmap,
              Or.emissivemap,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              Or.gradientmap,
              Or.fog,
              Or.lights,
              { emissive: { value: new Ti(0) } },
            ]),
            vertexShader: Nr.meshtoon_vert,
            fragmentShader: Nr.meshtoon_frag,
          },
          matcap: {
            uniforms: fr([
              Or.common,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              Or.fog,
              { matcap: { value: null } },
            ]),
            vertexShader: Nr.meshmatcap_vert,
            fragmentShader: Nr.meshmatcap_frag,
          },
          points: {
            uniforms: fr([Or.points, Or.fog]),
            vertexShader: Nr.points_vert,
            fragmentShader: Nr.points_frag,
          },
          dashed: {
            uniforms: fr([
              Or.common,
              Or.fog,
              {
                scale: { value: 1 },
                dashSize: { value: 1 },
                totalSize: { value: 2 },
              },
            ]),
            vertexShader: Nr.linedashed_vert,
            fragmentShader: Nr.linedashed_frag,
          },
          depth: {
            uniforms: fr([Or.common, Or.displacementmap]),
            vertexShader: Nr.depth_vert,
            fragmentShader: Nr.depth_frag,
          },
          normal: {
            uniforms: fr([
              Or.common,
              Or.bumpmap,
              Or.normalmap,
              Or.displacementmap,
              { opacity: { value: 1 } },
            ]),
            vertexShader: Nr.meshnormal_vert,
            fragmentShader: Nr.meshnormal_frag,
          },
          sprite: {
            uniforms: fr([Or.sprite, Or.fog]),
            vertexShader: Nr.sprite_vert,
            fragmentShader: Nr.sprite_frag,
          },
          background: {
            uniforms: {
              uvTransform: { value: new Dt() },
              t2D: { value: null },
              backgroundIntensity: { value: 1 },
            },
            vertexShader: Nr.background_vert,
            fragmentShader: Nr.background_frag,
          },
          backgroundCube: {
            uniforms: {
              envMap: { value: null },
              flipEnvMap: { value: -1 },
              backgroundBlurriness: { value: 0 },
              backgroundIntensity: { value: 1 },
              backgroundRotation: { value: new Dt() },
            },
            vertexShader: Nr.backgroundCube_vert,
            fragmentShader: Nr.backgroundCube_frag,
          },
          cube: {
            uniforms: {
              tCube: { value: null },
              tFlip: { value: -1 },
              opacity: { value: 1 },
            },
            vertexShader: Nr.cube_vert,
            fragmentShader: Nr.cube_frag,
          },
          equirect: {
            uniforms: { tEquirect: { value: null } },
            vertexShader: Nr.equirect_vert,
            fragmentShader: Nr.equirect_frag,
          },
          distanceRGBA: {
            uniforms: fr([
              Or.common,
              Or.displacementmap,
              {
                referencePosition: { value: new on() },
                nearDistance: { value: 1 },
                farDistance: { value: 1e3 },
              },
            ]),
            vertexShader: Nr.distanceRGBA_vert,
            fragmentShader: Nr.distanceRGBA_frag,
          },
          shadow: {
            uniforms: fr([
              Or.lights,
              Or.fog,
              { color: { value: new Ti(0) }, opacity: { value: 1 } },
            ]),
            vertexShader: Nr.shadow_vert,
            fragmentShader: Nr.shadow_frag,
          },
        };
      Qr.physical = {
        uniforms: fr([
          Qr.standard.uniforms,
          {
            clearcoat: { value: 0 },
            clearcoatMap: { value: null },
            clearcoatMapTransform: { value: new Dt() },
            clearcoatNormalMap: { value: null },
            clearcoatNormalMapTransform: { value: new Dt() },
            clearcoatNormalScale: { value: new Rt(1, 1) },
            clearcoatRoughness: { value: 0 },
            clearcoatRoughnessMap: { value: null },
            clearcoatRoughnessMapTransform: { value: new Dt() },
            dispersion: { value: 0 },
            iridescence: { value: 0 },
            iridescenceMap: { value: null },
            iridescenceMapTransform: { value: new Dt() },
            iridescenceIOR: { value: 1.3 },
            iridescenceThicknessMinimum: { value: 100 },
            iridescenceThicknessMaximum: { value: 400 },
            iridescenceThicknessMap: { value: null },
            iridescenceThicknessMapTransform: { value: new Dt() },
            sheen: { value: 0 },
            sheenColor: { value: new Ti(0) },
            sheenColorMap: { value: null },
            sheenColorMapTransform: { value: new Dt() },
            sheenRoughness: { value: 1 },
            sheenRoughnessMap: { value: null },
            sheenRoughnessMapTransform: { value: new Dt() },
            transmission: { value: 0 },
            transmissionMap: { value: null },
            transmissionMapTransform: { value: new Dt() },
            transmissionSamplerSize: { value: new Rt() },
            transmissionSamplerMap: { value: null },
            thickness: { value: 0 },
            thicknessMap: { value: null },
            thicknessMapTransform: { value: new Dt() },
            attenuationDistance: { value: 0 },
            attenuationColor: { value: new Ti(0) },
            specularColor: { value: new Ti(1, 1, 1) },
            specularColorMap: { value: null },
            specularColorMapTransform: { value: new Dt() },
            specularIntensity: { value: 1 },
            specularIntensityMap: { value: null },
            specularIntensityMapTransform: { value: new Dt() },
            anisotropyVector: { value: new Rt() },
            anisotropyMap: { value: null },
            anisotropyMapTransform: { value: new Dt() },
          },
        ]),
        vertexShader: Nr.meshphysical_vert,
        fragmentShader: Nr.meshphysical_frag,
      };
      const kr = { r: 0, b: 0, g: 0 },
        Gr = new qn(),
        Hr = new Nn();
      function zr(e, t, n, i, r, s, a) {
        const c = new Ti(0);
        let u,
          h,
          d = !0 === s ? 0 : 1,
          p = null,
          f = 0,
          A = null;
        function g(e) {
          let i = !0 === e.isScene ? e.background : null;
          if (i && i.isTexture) {
            i = (e.backgroundBlurriness > 0 ? n : t).get(i);
          }
          return i;
        }
        function m(t, n) {
          t.getRGB(kr, Ar(e)), i.buffers.color.setClear(kr.r, kr.g, kr.b, n, a);
        }
        return {
          getClearColor: function () {
            return c;
          },
          setClearColor: function (e, t = 1) {
            c.set(e), (d = t), m(c, d);
          },
          getClearAlpha: function () {
            return d;
          },
          setClearAlpha: function (e) {
            (d = e), m(c, d);
          },
          render: function (t) {
            let n = !1;
            const r = g(t);
            null === r ? m(c, d) : r && r.isColor && (m(r, 1), (n = !0));
            const s = e.xr.getEnvironmentBlendMode();
            "additive" === s
              ? i.buffers.color.setClear(0, 0, 0, 1, a)
              : "alpha-blend" === s && i.buffers.color.setClear(0, 0, 0, 0, a),
              (e.autoClear || n) &&
                (i.buffers.depth.setTest(!0),
                i.buffers.depth.setMask(!0),
                i.buffers.color.setMask(!0),
                e.clear(
                  e.autoClearColor,
                  e.autoClearDepth,
                  e.autoClearStencil
                ));
          },
          addToRenderList: function (t, n) {
            const i = g(n);
            i && (i.isCubeTexture || i.mapping === F)
              ? (void 0 === h &&
                  ((h = new ur(
                    new dr(1, 1, 1),
                    new mr({
                      name: "BackgroundCubeMaterial",
                      uniforms: pr(Qr.backgroundCube.uniforms),
                      vertexShader: Qr.backgroundCube.vertexShader,
                      fragmentShader: Qr.backgroundCube.fragmentShader,
                      side: l,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  h.geometry.deleteAttribute("normal"),
                  h.geometry.deleteAttribute("uv"),
                  (h.onBeforeRender = function (e, t, n) {
                    this.matrixWorld.copyPosition(n.matrixWorld);
                  }),
                  Object.defineProperty(h.material, "envMap", {
                    get: function () {
                      return this.uniforms.envMap.value;
                    },
                  }),
                  r.update(h)),
                Gr.copy(n.backgroundRotation),
                (Gr.x *= -1),
                (Gr.y *= -1),
                (Gr.z *= -1),
                i.isCubeTexture &&
                  !1 === i.isRenderTargetTexture &&
                  ((Gr.y *= -1), (Gr.z *= -1)),
                (h.material.uniforms.envMap.value = i),
                (h.material.uniforms.flipEnvMap.value =
                  i.isCubeTexture && !1 === i.isRenderTargetTexture ? -1 : 1),
                (h.material.uniforms.backgroundBlurriness.value =
                  n.backgroundBlurriness),
                (h.material.uniforms.backgroundIntensity.value =
                  n.backgroundIntensity),
                h.material.uniforms.backgroundRotation.value.setFromMatrix4(
                  Hr.makeRotationFromEuler(Gr)
                ),
                (h.material.toneMapped = Qt.getTransfer(i.colorSpace) !== dt),
                (p === i && f === i.version && A === e.toneMapping) ||
                  ((h.material.needsUpdate = !0),
                  (p = i),
                  (f = i.version),
                  (A = e.toneMapping)),
                h.layers.enableAll(),
                t.unshift(h, h.geometry, h.material, 0, 0, null))
              : i &&
                i.isTexture &&
                (void 0 === u &&
                  ((u = new ur(
                    new Fr(2, 2),
                    new mr({
                      name: "BackgroundMaterial",
                      uniforms: pr(Qr.background.uniforms),
                      vertexShader: Qr.background.vertexShader,
                      fragmentShader: Qr.background.fragmentShader,
                      side: o,
                      depthTest: !1,
                      depthWrite: !1,
                      fog: !1,
                    })
                  )),
                  u.geometry.deleteAttribute("normal"),
                  Object.defineProperty(u.material, "map", {
                    get: function () {
                      return this.uniforms.t2D.value;
                    },
                  }),
                  r.update(u)),
                (u.material.uniforms.t2D.value = i),
                (u.material.uniforms.backgroundIntensity.value =
                  n.backgroundIntensity),
                (u.material.toneMapped = Qt.getTransfer(i.colorSpace) !== dt),
                !0 === i.matrixAutoUpdate && i.updateMatrix(),
                u.material.uniforms.uvTransform.value.copy(i.matrix),
                (p === i && f === i.version && A === e.toneMapping) ||
                  ((u.material.needsUpdate = !0),
                  (p = i),
                  (f = i.version),
                  (A = e.toneMapping)),
                u.layers.enableAll(),
                t.unshift(u, u.geometry, u.material, 0, 0, null));
          },
        };
      }
      function Vr(e, t) {
        const n = e.getParameter(e.MAX_VERTEX_ATTRIBS),
          i = {},
          r = c(null);
        let s = r,
          a = !1;
        function o(t) {
          return e.bindVertexArray(t);
        }
        function l(t) {
          return e.deleteVertexArray(t);
        }
        function c(e) {
          const t = [],
            i = [],
            r = [];
          for (let e = 0; e < n; e++) (t[e] = 0), (i[e] = 0), (r[e] = 0);
          return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: t,
            enabledAttributes: i,
            attributeDivisors: r,
            object: e,
            attributes: {},
            index: null,
          };
        }
        function u() {
          const e = s.newAttributes;
          for (let t = 0, n = e.length; t < n; t++) e[t] = 0;
        }
        function h(e) {
          d(e, 0);
        }
        function d(t, n) {
          const i = s.newAttributes,
            r = s.enabledAttributes,
            a = s.attributeDivisors;
          (i[t] = 1),
            0 === r[t] && (e.enableVertexAttribArray(t), (r[t] = 1)),
            a[t] !== n && (e.vertexAttribDivisor(t, n), (a[t] = n));
        }
        function p() {
          const t = s.newAttributes,
            n = s.enabledAttributes;
          for (let i = 0, r = n.length; i < r; i++)
            n[i] !== t[i] && (e.disableVertexAttribArray(i), (n[i] = 0));
        }
        function f(t, n, i, r, s, a, o) {
          !0 === o
            ? e.vertexAttribIPointer(t, n, i, s, a)
            : e.vertexAttribPointer(t, n, i, r, s, a);
        }
        function A() {
          g(), (a = !0), s !== r && ((s = r), o(s.object));
        }
        function g() {
          (r.geometry = null), (r.program = null), (r.wireframe = !1);
        }
        return {
          setup: function (n, r, l, A, g) {
            let m = !1;
            const v = (function (t, n, r) {
              const s = !0 === r.wireframe;
              let a = i[t.id];
              void 0 === a && ((a = {}), (i[t.id] = a));
              let o = a[n.id];
              void 0 === o && ((o = {}), (a[n.id] = o));
              let l = o[s];
              void 0 === l && ((l = c(e.createVertexArray())), (o[s] = l));
              return l;
            })(A, l, r);
            s !== v && ((s = v), o(s.object)),
              (m = (function (e, t, n, i) {
                const r = s.attributes,
                  a = t.attributes;
                let o = 0;
                const l = n.getAttributes();
                for (const t in l) {
                  if (l[t].location >= 0) {
                    const n = r[t];
                    let i = a[t];
                    if (
                      (void 0 === i &&
                        ("instanceMatrix" === t &&
                          e.instanceMatrix &&
                          (i = e.instanceMatrix),
                        "instanceColor" === t &&
                          e.instanceColor &&
                          (i = e.instanceColor)),
                      void 0 === n)
                    )
                      return !0;
                    if (n.attribute !== i) return !0;
                    if (i && n.data !== i.data) return !0;
                    o++;
                  }
                }
                return s.attributesNum !== o || s.index !== i;
              })(n, A, l, g)),
              m &&
                (function (e, t, n, i) {
                  const r = {},
                    a = t.attributes;
                  let o = 0;
                  const l = n.getAttributes();
                  for (const t in l) {
                    if (l[t].location >= 0) {
                      let n = a[t];
                      void 0 === n &&
                        ("instanceMatrix" === t &&
                          e.instanceMatrix &&
                          (n = e.instanceMatrix),
                        "instanceColor" === t &&
                          e.instanceColor &&
                          (n = e.instanceColor));
                      const i = {};
                      (i.attribute = n),
                        n && n.data && (i.data = n.data),
                        (r[t] = i),
                        o++;
                    }
                  }
                  (s.attributes = r), (s.attributesNum = o), (s.index = i);
                })(n, A, l, g),
              null !== g && t.update(g, e.ELEMENT_ARRAY_BUFFER),
              (m || a) &&
                ((a = !1),
                (function (n, i, r, s) {
                  u();
                  const a = s.attributes,
                    o = r.getAttributes(),
                    l = i.defaultAttributeValues;
                  for (const i in o) {
                    const r = o[i];
                    if (r.location >= 0) {
                      let o = a[i];
                      if (
                        (void 0 === o &&
                          ("instanceMatrix" === i &&
                            n.instanceMatrix &&
                            (o = n.instanceMatrix),
                          "instanceColor" === i &&
                            n.instanceColor &&
                            (o = n.instanceColor)),
                        void 0 !== o)
                      ) {
                        const i = o.normalized,
                          a = o.itemSize,
                          l = t.get(o);
                        if (void 0 === l) continue;
                        const c = l.buffer,
                          u = l.type,
                          p = l.bytesPerElement,
                          A =
                            u === e.INT ||
                            u === e.UNSIGNED_INT ||
                            o.gpuType === K;
                        if (o.isInterleavedBufferAttribute) {
                          const t = o.data,
                            l = t.stride,
                            g = o.offset;
                          if (t.isInstancedInterleavedBuffer) {
                            for (let e = 0; e < r.locationSize; e++)
                              d(r.location + e, t.meshPerAttribute);
                            !0 !== n.isInstancedMesh &&
                              void 0 === s._maxInstanceCount &&
                              (s._maxInstanceCount =
                                t.meshPerAttribute * t.count);
                          } else
                            for (let e = 0; e < r.locationSize; e++)
                              h(r.location + e);
                          e.bindBuffer(e.ARRAY_BUFFER, c);
                          for (let e = 0; e < r.locationSize; e++)
                            f(
                              r.location + e,
                              a / r.locationSize,
                              u,
                              i,
                              l * p,
                              (g + (a / r.locationSize) * e) * p,
                              A
                            );
                        } else {
                          if (o.isInstancedBufferAttribute) {
                            for (let e = 0; e < r.locationSize; e++)
                              d(r.location + e, o.meshPerAttribute);
                            !0 !== n.isInstancedMesh &&
                              void 0 === s._maxInstanceCount &&
                              (s._maxInstanceCount =
                                o.meshPerAttribute * o.count);
                          } else
                            for (let e = 0; e < r.locationSize; e++)
                              h(r.location + e);
                          e.bindBuffer(e.ARRAY_BUFFER, c);
                          for (let e = 0; e < r.locationSize; e++)
                            f(
                              r.location + e,
                              a / r.locationSize,
                              u,
                              i,
                              a * p,
                              (a / r.locationSize) * e * p,
                              A
                            );
                        }
                      } else if (void 0 !== l) {
                        const t = l[i];
                        if (void 0 !== t)
                          switch (t.length) {
                            case 2:
                              e.vertexAttrib2fv(r.location, t);
                              break;
                            case 3:
                              e.vertexAttrib3fv(r.location, t);
                              break;
                            case 4:
                              e.vertexAttrib4fv(r.location, t);
                              break;
                            default:
                              e.vertexAttrib1fv(r.location, t);
                          }
                      }
                    }
                  }
                  p();
                })(n, r, l, A),
                null !== g &&
                  e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t.get(g).buffer));
          },
          reset: A,
          resetDefaultState: g,
          dispose: function () {
            A();
            for (const e in i) {
              const t = i[e];
              for (const e in t) {
                const n = t[e];
                for (const e in n) l(n[e].object), delete n[e];
                delete t[e];
              }
              delete i[e];
            }
          },
          releaseStatesOfGeometry: function (e) {
            if (void 0 === i[e.id]) return;
            const t = i[e.id];
            for (const e in t) {
              const n = t[e];
              for (const e in n) l(n[e].object), delete n[e];
              delete t[e];
            }
            delete i[e.id];
          },
          releaseStatesOfProgram: function (e) {
            for (const t in i) {
              const n = i[t];
              if (void 0 === n[e.id]) continue;
              const r = n[e.id];
              for (const e in r) l(r[e].object), delete r[e];
              delete n[e.id];
            }
          },
          initAttributes: u,
          enableAttribute: h,
          disableUnusedAttributes: p,
        };
      }
      function Wr(e, t, n) {
        let i;
        function r(t, r, s) {
          0 !== s && (e.drawArraysInstanced(i, t, r, s), n.update(r, i, s));
        }
        (this.setMode = function (e) {
          i = e;
        }),
          (this.render = function (t, r) {
            e.drawArrays(i, t, r), n.update(r, i, 1);
          }),
          (this.renderInstances = r),
          (this.renderMultiDraw = function (e, r, s) {
            if (0 === s) return;
            t.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, e, 0, r, 0, s);
            let a = 0;
            for (let e = 0; e < s; e++) a += r[e];
            n.update(a, i, 1);
          }),
          (this.renderMultiDrawInstances = function (e, s, a, o) {
            if (0 === a) return;
            const l = t.get("WEBGL_multi_draw");
            if (null === l)
              for (let t = 0; t < e.length; t++) r(e[t], s[t], o[t]);
            else {
              l.multiDrawArraysInstancedWEBGL(i, e, 0, s, 0, o, 0, a);
              let t = 0;
              for (let e = 0; e < a; e++) t += s[e] * o[e];
              n.update(t, i, 1);
            }
          });
      }
      function jr(e, t, n, i) {
        let r;
        function s(t) {
          if ("highp" === t) {
            if (
              e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT)
                .precision > 0 &&
              e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT)
                .precision > 0
            )
              return "highp";
            t = "mediump";
          }
          return "mediump" === t &&
            e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT)
              .precision > 0 &&
            e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT)
              .precision > 0
            ? "mediump"
            : "lowp";
        }
        let a = void 0 !== n.precision ? n.precision : "highp";
        const o = s(a);
        o !== a &&
          (console.warn(
            "THREE.WebGLRenderer:",
            a,
            "not supported, using",
            o,
            "instead."
          ),
          (a = o));
        const l = !0 === n.logarithmicDepthBuffer,
          c = !0 === n.reverseDepthBuffer && t.has("EXT_clip_control"),
          u = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
          h = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        return {
          isWebGL2: !0,
          getMaxAnisotropy: function () {
            if (void 0 !== r) return r;
            if (!0 === t.has("EXT_texture_filter_anisotropic")) {
              const n = t.get("EXT_texture_filter_anisotropic");
              r = e.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
            } else r = 0;
            return r;
          },
          getMaxPrecision: s,
          textureFormatReadable: function (t) {
            return (
              t === ae ||
              i.convert(t) ===
                e.getParameter(e.IMPLEMENTATION_COLOR_READ_FORMAT)
            );
          },
          textureTypeReadable: function (n) {
            const r =
              n === $ &&
              (t.has("EXT_color_buffer_half_float") ||
                t.has("EXT_color_buffer_float"));
            return !(
              n !== j &&
              i.convert(n) !==
                e.getParameter(e.IMPLEMENTATION_COLOR_READ_TYPE) &&
              n !== Z &&
              !r
            );
          },
          precision: a,
          logarithmicDepthBuffer: l,
          reverseDepthBuffer: c,
          maxTextures: u,
          maxVertexTextures: h,
          maxTextureSize: e.getParameter(e.MAX_TEXTURE_SIZE),
          maxCubemapSize: e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
          maxAttributes: e.getParameter(e.MAX_VERTEX_ATTRIBS),
          maxVertexUniforms: e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
          maxVaryings: e.getParameter(e.MAX_VARYING_VECTORS),
          maxFragmentUniforms: e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
          vertexTextures: h > 0,
          maxSamples: e.getParameter(e.MAX_SAMPLES),
        };
      }
      function qr(e) {
        const t = this;
        let n = null,
          i = 0,
          r = !1,
          s = !1;
        const a = new Br(),
          o = new Dt(),
          l = { value: null, needsUpdate: !1 };
        function c(e, n, i, r) {
          const s = null !== e ? e.length : 0;
          let c = null;
          if (0 !== s) {
            if (((c = l.value), !0 !== r || null === c)) {
              const t = i + 4 * s,
                r = n.matrixWorldInverse;
              o.getNormalMatrix(r),
                (null === c || c.length < t) && (c = new Float32Array(t));
              for (let t = 0, n = i; t !== s; ++t, n += 4)
                a.copy(e[t]).applyMatrix4(r, o),
                  a.normal.toArray(c, n),
                  (c[n + 3] = a.constant);
            }
            (l.value = c), (l.needsUpdate = !0);
          }
          return (t.numPlanes = s), (t.numIntersection = 0), c;
        }
        (this.uniform = l),
          (this.numPlanes = 0),
          (this.numIntersection = 0),
          (this.init = function (e, t) {
            const n = 0 !== e.length || t || 0 !== i || r;
            return (r = t), (i = e.length), n;
          }),
          (this.beginShadows = function () {
            (s = !0), c(null);
          }),
          (this.endShadows = function () {
            s = !1;
          }),
          (this.setGlobalState = function (e, t) {
            n = c(e, t, 0);
          }),
          (this.setState = function (a, o, u) {
            const h = a.clippingPlanes,
              d = a.clipIntersection,
              p = a.clipShadows,
              f = e.get(a);
            if (!r || null === h || 0 === h.length || (s && !p))
              s
                ? c(null)
                : (function () {
                    l.value !== n && ((l.value = n), (l.needsUpdate = i > 0));
                    (t.numPlanes = i), (t.numIntersection = 0);
                  })();
            else {
              const e = s ? 0 : i,
                t = 4 * e;
              let r = f.clippingState || null;
              (l.value = r), (r = c(h, o, t, u));
              for (let e = 0; e !== t; ++e) r[e] = n[e];
              (f.clippingState = r),
                (this.numIntersection = d ? this.numPlanes : 0),
                (this.numPlanes += e);
            }
          });
      }
      function Yr(e) {
        let t = new WeakMap();
        function n(e, t) {
          return t === L ? (e.mapping = D) : t === U && (e.mapping = P), e;
        }
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping;
              if (s === L || s === U) {
                if (t.has(r)) {
                  return n(t.get(r).texture, r.mapping);
                }
                {
                  const s = r.image;
                  if (s && s.height > 0) {
                    const a = new Ir(s.height);
                    return (
                      a.fromEquirectangularTexture(e, r),
                      t.set(r, a),
                      r.addEventListener("dispose", i),
                      n(a.texture, r.mapping)
                    );
                  }
                  return null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      class Xr extends vr {
        constructor(e = -1, t = 1, n = 1, i = -1, r = 0.1, s = 2e3) {
          super(),
            (this.isOrthographicCamera = !0),
            (this.type = "OrthographicCamera"),
            (this.zoom = 1),
            (this.view = null),
            (this.left = e),
            (this.right = t),
            (this.top = n),
            (this.bottom = i),
            (this.near = r),
            (this.far = s),
            this.updateProjectionMatrix();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.left = e.left),
            (this.right = e.right),
            (this.top = e.top),
            (this.bottom = e.bottom),
            (this.near = e.near),
            (this.far = e.far),
            (this.zoom = e.zoom),
            (this.view = null === e.view ? null : Object.assign({}, e.view)),
            this
          );
        }
        setViewOffset(e, t, n, i, r, s) {
          null === this.view &&
            (this.view = {
              enabled: !0,
              fullWidth: 1,
              fullHeight: 1,
              offsetX: 0,
              offsetY: 0,
              width: 1,
              height: 1,
            }),
            (this.view.enabled = !0),
            (this.view.fullWidth = e),
            (this.view.fullHeight = t),
            (this.view.offsetX = n),
            (this.view.offsetY = i),
            (this.view.width = r),
            (this.view.height = s),
            this.updateProjectionMatrix();
        }
        clearViewOffset() {
          null !== this.view && (this.view.enabled = !1),
            this.updateProjectionMatrix();
        }
        updateProjectionMatrix() {
          const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
          let r = n - e,
            s = n + e,
            a = i + t,
            o = i - t;
          if (null !== this.view && this.view.enabled) {
            const e =
                (this.right - this.left) / this.view.fullWidth / this.zoom,
              t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            (r += e * this.view.offsetX),
              (s = r + e * this.view.width),
              (a -= t * this.view.offsetY),
              (o = a - t * this.view.height);
          }
          this.projectionMatrix.makeOrthographic(
            r,
            s,
            a,
            o,
            this.near,
            this.far,
            this.coordinateSystem
          ),
            this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.zoom = this.zoom),
            (t.object.left = this.left),
            (t.object.right = this.right),
            (t.object.top = this.top),
            (t.object.bottom = this.bottom),
            (t.object.near = this.near),
            (t.object.far = this.far),
            null !== this.view &&
              (t.object.view = Object.assign({}, this.view)),
            t
          );
        }
      }
      const Kr = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
        Jr = 20,
        Zr = new Xr(),
        $r = new Ti();
      let es = null,
        ts = 0,
        ns = 0,
        is = !1;
      const rs = (1 + Math.sqrt(5)) / 2,
        ss = 1 / rs,
        as = [
          new on(-rs, ss, 0),
          new on(rs, ss, 0),
          new on(-ss, 0, rs),
          new on(ss, 0, rs),
          new on(0, rs, -ss),
          new on(0, rs, ss),
          new on(-1, 1, -1),
          new on(1, 1, -1),
          new on(-1, 1, 1),
          new on(1, 1, 1),
        ];
      class os {
        constructor(e) {
          (this._renderer = e),
            (this._pingPongRenderTarget = null),
            (this._lodMax = 0),
            (this._cubeSize = 0),
            (this._lodPlanes = []),
            (this._sizeLods = []),
            (this._sigmas = []),
            (this._blurMaterial = null),
            (this._cubemapMaterial = null),
            (this._equirectMaterial = null),
            this._compileMaterial(this._blurMaterial);
        }
        fromScene(e, t = 0, n = 0.1, i = 100) {
          (es = this._renderer.getRenderTarget()),
            (ts = this._renderer.getActiveCubeFace()),
            (ns = this._renderer.getActiveMipmapLevel()),
            (is = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1),
            this._setSize(256);
          const r = this._allocateTargets();
          return (
            (r.depthBuffer = !0),
            this._sceneToCubeUV(e, n, i, r),
            t > 0 && this._blur(r, 0, 0, t),
            this._applyPMREM(r),
            this._cleanup(r),
            r
          );
        }
        fromEquirectangular(e, t = null) {
          return this._fromTexture(e, t);
        }
        fromCubemap(e, t = null) {
          return this._fromTexture(e, t);
        }
        compileCubemapShader() {
          null === this._cubemapMaterial &&
            ((this._cubemapMaterial = hs()),
            this._compileMaterial(this._cubemapMaterial));
        }
        compileEquirectangularShader() {
          null === this._equirectMaterial &&
            ((this._equirectMaterial = us()),
            this._compileMaterial(this._equirectMaterial));
        }
        dispose() {
          this._dispose(),
            null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
            null !== this._equirectMaterial && this._equirectMaterial.dispose();
        }
        _setSize(e) {
          (this._lodMax = Math.floor(Math.log2(e))),
            (this._cubeSize = Math.pow(2, this._lodMax));
        }
        _dispose() {
          null !== this._blurMaterial && this._blurMaterial.dispose(),
            null !== this._pingPongRenderTarget &&
              this._pingPongRenderTarget.dispose();
          for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose();
        }
        _cleanup(e) {
          this._renderer.setRenderTarget(es, ts, ns),
            (this._renderer.xr.enabled = is),
            (e.scissorTest = !1),
            cs(e, 0, 0, e.width, e.height);
        }
        _fromTexture(e, t) {
          e.mapping === D || e.mapping === P
            ? this._setSize(
                0 === e.image.length
                  ? 16
                  : e.image[0].width || e.image[0].image.width
              )
            : this._setSize(e.image.width / 4),
            (es = this._renderer.getRenderTarget()),
            (ts = this._renderer.getActiveCubeFace()),
            (ns = this._renderer.getActiveMipmapLevel()),
            (is = this._renderer.xr.enabled),
            (this._renderer.xr.enabled = !1);
          const n = t || this._allocateTargets();
          return (
            this._textureToCubeUV(e, n),
            this._applyPMREM(n),
            this._cleanup(n),
            n
          );
        }
        _allocateTargets() {
          const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
              magFilter: z,
              minFilter: z,
              generateMipmaps: !1,
              type: $,
              format: ae,
              colorSpace: ut,
              depthBuffer: !1,
            },
            i = ls(e, t, n);
          if (
            null === this._pingPongRenderTarget ||
            this._pingPongRenderTarget.width !== e ||
            this._pingPongRenderTarget.height !== t
          ) {
            null !== this._pingPongRenderTarget && this._dispose(),
              (this._pingPongRenderTarget = ls(e, t, n));
            const { _lodMax: i } = this;
            ({
              sizeLods: this._sizeLods,
              lodPlanes: this._lodPlanes,
              sigmas: this._sigmas,
            } = (function (e) {
              const t = [],
                n = [],
                i = [];
              let r = e;
              const s = e - 4 + 1 + Kr.length;
              for (let a = 0; a < s; a++) {
                const s = Math.pow(2, r);
                n.push(s);
                let o = 1 / s;
                a > e - 4 ? (o = Kr[a - e + 4 - 1]) : 0 === a && (o = 0),
                  i.push(o);
                const l = 1 / (s - 2),
                  c = -l,
                  u = 1 + l,
                  h = [c, c, u, c, u, u, c, c, u, u, c, u],
                  d = 6,
                  p = 6,
                  f = 3,
                  A = 2,
                  g = 1,
                  m = new Float32Array(f * p * d),
                  v = new Float32Array(A * p * d),
                  y = new Float32Array(g * p * d);
                for (let e = 0; e < d; e++) {
                  const t = ((e % 3) * 2) / 3 - 1,
                    n = e > 2 ? 0 : -1,
                    i = [
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n,
                      0,
                      t + 2 / 3,
                      n + 1,
                      0,
                      t,
                      n + 1,
                      0,
                    ];
                  m.set(i, f * p * e), v.set(h, A * p * e);
                  const r = [e, e, e, e, e, e];
                  y.set(r, g * p * e);
                }
                const x = new Zi();
                x.setAttribute("position", new Gi(m, f)),
                  x.setAttribute("uv", new Gi(v, A)),
                  x.setAttribute("faceIndex", new Gi(y, g)),
                  t.push(x),
                  r > 4 && r--;
              }
              return { lodPlanes: t, sizeLods: n, sigmas: i };
            })(i)),
              (this._blurMaterial = (function (e, t, n) {
                const i = new Float32Array(Jr),
                  r = new on(0, 1, 0),
                  s = new mr({
                    name: "SphericalGaussianBlur",
                    defines: {
                      n: Jr,
                      CUBEUV_TEXEL_WIDTH: 1 / t,
                      CUBEUV_TEXEL_HEIGHT: 1 / n,
                      CUBEUV_MAX_MIP: `${e}.0`,
                    },
                    uniforms: {
                      envMap: { value: null },
                      samples: { value: 1 },
                      weights: { value: i },
                      latitudinal: { value: !1 },
                      dTheta: { value: 0 },
                      mipInt: { value: 0 },
                      poleAxis: { value: r },
                    },
                    vertexShader: ds(),
                    fragmentShader:
                      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
                    blending: u,
                    depthTest: !1,
                    depthWrite: !1,
                  });
                return s;
              })(i, e, t));
          }
          return i;
        }
        _compileMaterial(e) {
          const t = new ur(this._lodPlanes[0], e);
          this._renderer.compile(t, Zr);
        }
        _sceneToCubeUV(e, t, n, i) {
          const r = new br(90, 1, t, n),
            s = [1, -1, 1, 1, 1, 1],
            a = [1, 1, 1, -1, -1, -1],
            o = this._renderer,
            c = o.autoClear,
            u = o.toneMapping;
          o.getClearColor($r), (o.toneMapping = E), (o.autoClear = !1);
          const h = new Pi({
              name: "PMREM.Background",
              side: l,
              depthWrite: !1,
              depthTest: !1,
            }),
            d = new ur(new dr(), h);
          let p = !1;
          const f = e.background;
          f
            ? f.isColor && (h.color.copy(f), (e.background = null), (p = !0))
            : (h.color.copy($r), (p = !0));
          for (let t = 0; t < 6; t++) {
            const n = t % 3;
            0 === n
              ? (r.up.set(0, s[t], 0), r.lookAt(a[t], 0, 0))
              : 1 === n
              ? (r.up.set(0, 0, s[t]), r.lookAt(0, a[t], 0))
              : (r.up.set(0, s[t], 0), r.lookAt(0, 0, a[t]));
            const l = this._cubeSize;
            cs(i, n * l, t > 2 ? l : 0, l, l),
              o.setRenderTarget(i),
              p && o.render(d, r),
              o.render(e, r);
          }
          d.geometry.dispose(),
            d.material.dispose(),
            (o.toneMapping = u),
            (o.autoClear = c),
            (e.background = f);
        }
        _textureToCubeUV(e, t) {
          const n = this._renderer,
            i = e.mapping === D || e.mapping === P;
          i
            ? (null === this._cubemapMaterial && (this._cubemapMaterial = hs()),
              (this._cubemapMaterial.uniforms.flipEnvMap.value =
                !1 === e.isRenderTargetTexture ? -1 : 1))
            : null === this._equirectMaterial &&
              (this._equirectMaterial = us());
          const r = i ? this._cubemapMaterial : this._equirectMaterial,
            s = new ur(this._lodPlanes[0], r);
          r.uniforms.envMap.value = e;
          const a = this._cubeSize;
          cs(t, 0, 0, 3 * a, 2 * a), n.setRenderTarget(t), n.render(s, Zr);
        }
        _applyPMREM(e) {
          const t = this._renderer,
            n = t.autoClear;
          t.autoClear = !1;
          const i = this._lodPlanes.length;
          for (let t = 1; t < i; t++) {
            const n = Math.sqrt(
                this._sigmas[t] * this._sigmas[t] -
                  this._sigmas[t - 1] * this._sigmas[t - 1]
              ),
              r = as[(i - t - 1) % as.length];
            this._blur(e, t - 1, t, n, r);
          }
          t.autoClear = n;
        }
        _blur(e, t, n, i, r) {
          const s = this._pingPongRenderTarget;
          this._halfBlur(e, s, t, n, i, "latitudinal", r),
            this._halfBlur(s, e, n, n, i, "longitudinal", r);
        }
        _halfBlur(e, t, n, i, r, s, a) {
          const o = this._renderer,
            l = this._blurMaterial;
          "latitudinal" !== s &&
            "longitudinal" !== s &&
            console.error(
              "blur direction must be either latitudinal or longitudinal!"
            );
          const c = new ur(this._lodPlanes[i], l),
            u = l.uniforms,
            h = this._sizeLods[n] - 1,
            d = isFinite(r) ? Math.PI / (2 * h) : (2 * Math.PI) / 39,
            p = r / d,
            f = isFinite(r) ? 1 + Math.floor(3 * p) : Jr;
          f > Jr &&
            console.warn(
              `sigmaRadians, ${r}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
            );
          const A = [];
          let g = 0;
          for (let e = 0; e < Jr; ++e) {
            const t = e / p,
              n = Math.exp((-t * t) / 2);
            A.push(n), 0 === e ? (g += n) : e < f && (g += 2 * n);
          }
          for (let e = 0; e < A.length; e++) A[e] = A[e] / g;
          (u.envMap.value = e.texture),
            (u.samples.value = f),
            (u.weights.value = A),
            (u.latitudinal.value = "latitudinal" === s),
            a && (u.poleAxis.value = a);
          const { _lodMax: m } = this;
          (u.dTheta.value = d), (u.mipInt.value = m - n);
          const v = this._sizeLods[i];
          cs(
            t,
            3 * v * (i > m - 4 ? i - m + 4 : 0),
            4 * (this._cubeSize - v),
            3 * v,
            2 * v
          ),
            o.setRenderTarget(t),
            o.render(c, Zr);
        }
      }
      function ls(e, t, n) {
        const i = new nn(e, t, n);
        return (
          (i.texture.mapping = F),
          (i.texture.name = "PMREM.cubeUv"),
          (i.scissorTest = !0),
          i
        );
      }
      function cs(e, t, n, i, r) {
        e.viewport.set(t, n, i, r), e.scissor.set(t, n, i, r);
      }
      function us() {
        return new mr({
          name: "EquirectangularToCubeUV",
          uniforms: { envMap: { value: null } },
          vertexShader: ds(),
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
          blending: u,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function hs() {
        return new mr({
          name: "CubemapToCubeUV",
          uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
          vertexShader: ds(),
          fragmentShader:
            "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
          blending: u,
          depthTest: !1,
          depthWrite: !1,
        });
      }
      function ds() {
        return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
      }
      function ps(e) {
        let t = new WeakMap(),
          n = null;
        function i(e) {
          const n = e.target;
          n.removeEventListener("dispose", i);
          const r = t.get(n);
          void 0 !== r && (t.delete(n), r.dispose());
        }
        return {
          get: function (r) {
            if (r && r.isTexture) {
              const s = r.mapping,
                a = s === L || s === U,
                o = s === D || s === P;
              if (a || o) {
                let s = t.get(r);
                const l = void 0 !== s ? s.texture.pmremVersion : 0;
                if (r.isRenderTargetTexture && r.pmremVersion !== l)
                  return (
                    null === n && (n = new os(e)),
                    (s = a ? n.fromEquirectangular(r, s) : n.fromCubemap(r, s)),
                    (s.texture.pmremVersion = r.pmremVersion),
                    t.set(r, s),
                    s.texture
                  );
                if (void 0 !== s) return s.texture;
                {
                  const l = r.image;
                  return (a && l && l.height > 0) ||
                    (o &&
                      l &&
                      (function (e) {
                        let t = 0;
                        const n = 6;
                        for (let i = 0; i < n; i++) void 0 !== e[i] && t++;
                        return t === n;
                      })(l))
                    ? (null === n && (n = new os(e)),
                      (s = a ? n.fromEquirectangular(r) : n.fromCubemap(r)),
                      (s.texture.pmremVersion = r.pmremVersion),
                      t.set(r, s),
                      r.addEventListener("dispose", i),
                      s.texture)
                    : null;
                }
              }
            }
            return r;
          },
          dispose: function () {
            (t = new WeakMap()), null !== n && (n.dispose(), (n = null));
          },
        };
      }
      function fs(e) {
        const t = {};
        function n(n) {
          if (void 0 !== t[n]) return t[n];
          let i;
          switch (n) {
            case "WEBGL_depth_texture":
              i =
                e.getExtension("WEBGL_depth_texture") ||
                e.getExtension("MOZ_WEBGL_depth_texture") ||
                e.getExtension("WEBKIT_WEBGL_depth_texture");
              break;
            case "EXT_texture_filter_anisotropic":
              i =
                e.getExtension("EXT_texture_filter_anisotropic") ||
                e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
                e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
              break;
            case "WEBGL_compressed_texture_s3tc":
              i =
                e.getExtension("WEBGL_compressed_texture_s3tc") ||
                e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
              break;
            case "WEBGL_compressed_texture_pvrtc":
              i =
                e.getExtension("WEBGL_compressed_texture_pvrtc") ||
                e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
              break;
            default:
              i = e.getExtension(n);
          }
          return (t[n] = i), i;
        }
        return {
          has: function (e) {
            return null !== n(e);
          },
          init: function () {
            n("EXT_color_buffer_float"),
              n("WEBGL_clip_cull_distance"),
              n("OES_texture_float_linear"),
              n("EXT_color_buffer_half_float"),
              n("WEBGL_multisampled_render_to_texture"),
              n("WEBGL_render_shared_exponent");
          },
          get: function (e) {
            const t = n(e);
            return (
              null === t &&
                Ot("THREE.WebGLRenderer: " + e + " extension not supported."),
              t
            );
          },
        };
      }
      function As(e, t, n, i) {
        const r = {},
          s = new WeakMap();
        function a(e) {
          const o = e.target;
          null !== o.index && t.remove(o.index);
          for (const e in o.attributes) t.remove(o.attributes[e]);
          for (const e in o.morphAttributes) {
            const n = o.morphAttributes[e];
            for (let e = 0, i = n.length; e < i; e++) t.remove(n[e]);
          }
          o.removeEventListener("dispose", a), delete r[o.id];
          const l = s.get(o);
          l && (t.remove(l), s.delete(o)),
            i.releaseStatesOfGeometry(o),
            !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
            n.memory.geometries--;
        }
        function o(e) {
          const n = [],
            i = e.index,
            r = e.attributes.position;
          let a = 0;
          if (null !== i) {
            const e = i.array;
            a = i.version;
            for (let t = 0, i = e.length; t < i; t += 3) {
              const i = e[t + 0],
                r = e[t + 1],
                s = e[t + 2];
              n.push(i, r, r, s, s, i);
            }
          } else {
            if (void 0 === r) return;
            {
              const e = r.array;
              a = r.version;
              for (let t = 0, i = e.length / 3 - 1; t < i; t += 3) {
                const e = t + 0,
                  i = t + 1,
                  r = t + 2;
                n.push(e, i, i, r, r, e);
              }
            }
          }
          const o = new (Lt(n) ? zi : Hi)(n, 1);
          o.version = a;
          const l = s.get(e);
          l && t.remove(l), s.set(e, o);
        }
        return {
          get: function (e, t) {
            return (
              !0 === r[t.id] ||
                (t.addEventListener("dispose", a),
                (r[t.id] = !0),
                n.memory.geometries++),
              t
            );
          },
          update: function (n) {
            const i = n.attributes;
            for (const n in i) t.update(i[n], e.ARRAY_BUFFER);
            const r = n.morphAttributes;
            for (const n in r) {
              const i = r[n];
              for (let n = 0, r = i.length; n < r; n++)
                t.update(i[n], e.ARRAY_BUFFER);
            }
          },
          getWireframeAttribute: function (e) {
            const t = s.get(e);
            if (t) {
              const n = e.index;
              null !== n && t.version < n.version && o(e);
            } else o(e);
            return s.get(e);
          },
        };
      }
      function gs(e, t, n) {
        let i, r, s;
        function a(t, a, o) {
          0 !== o &&
            (e.drawElementsInstanced(i, a, r, t * s, o), n.update(a, i, o));
        }
        (this.setMode = function (e) {
          i = e;
        }),
          (this.setIndex = function (e) {
            (r = e.type), (s = e.bytesPerElement);
          }),
          (this.render = function (t, a) {
            e.drawElements(i, a, r, t * s), n.update(a, i, 1);
          }),
          (this.renderInstances = a),
          (this.renderMultiDraw = function (e, s, a) {
            if (0 === a) return;
            t.get("WEBGL_multi_draw").multiDrawElementsWEBGL(
              i,
              s,
              0,
              r,
              e,
              0,
              a
            );
            let o = 0;
            for (let e = 0; e < a; e++) o += s[e];
            n.update(o, i, 1);
          }),
          (this.renderMultiDrawInstances = function (e, o, l, c) {
            if (0 === l) return;
            const u = t.get("WEBGL_multi_draw");
            if (null === u)
              for (let t = 0; t < e.length; t++) a(e[t] / s, o[t], c[t]);
            else {
              u.multiDrawElementsInstancedWEBGL(i, o, 0, r, e, 0, c, 0, l);
              let t = 0;
              for (let e = 0; e < l; e++) t += o[e] * c[e];
              n.update(t, i, 1);
            }
          });
      }
      function ms(e) {
        const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
        return {
          memory: { geometries: 0, textures: 0 },
          render: t,
          programs: null,
          autoReset: !0,
          reset: function () {
            (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
          },
          update: function (n, i, r) {
            switch ((t.calls++, i)) {
              case e.TRIANGLES:
                t.triangles += r * (n / 3);
                break;
              case e.LINES:
                t.lines += r * (n / 2);
                break;
              case e.LINE_STRIP:
                t.lines += r * (n - 1);
                break;
              case e.LINE_LOOP:
                t.lines += r * n;
                break;
              case e.POINTS:
                t.points += r * n;
                break;
              default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", i);
            }
          },
        };
      }
      function vs(e, t, n) {
        const i = new WeakMap(),
          r = new en();
        return {
          update: function (s, a, o) {
            const l = s.morphTargetInfluences,
              c =
                a.morphAttributes.position ||
                a.morphAttributes.normal ||
                a.morphAttributes.color,
              u = void 0 !== c ? c.length : 0;
            let h = i.get(a);
            if (void 0 === h || h.count !== u) {
              void 0 !== h && h.texture.dispose();
              const d = void 0 !== a.morphAttributes.position,
                p = void 0 !== a.morphAttributes.normal,
                f = void 0 !== a.morphAttributes.color,
                A = a.morphAttributes.position || [],
                g = a.morphAttributes.normal || [],
                m = a.morphAttributes.color || [];
              let v = 0;
              !0 === d && (v = 1), !0 === p && (v = 2), !0 === f && (v = 3);
              let y = a.attributes.position.count * v,
                x = 1;
              y > t.maxTextureSize &&
                ((x = Math.ceil(y / t.maxTextureSize)), (y = t.maxTextureSize));
              const _ = new Float32Array(y * x * 4 * u),
                b = new rn(_, y, x, u);
              (b.type = Z), (b.needsUpdate = !0);
              const E = 4 * v;
              for (let C = 0; C < u; C++) {
                const I = A[C],
                  S = g[C],
                  M = m[C],
                  T = y * x * 4 * C;
                for (let B = 0; B < I.count; B++) {
                  const R = B * E;
                  !0 === d &&
                    (r.fromBufferAttribute(I, B),
                    (_[T + R + 0] = r.x),
                    (_[T + R + 1] = r.y),
                    (_[T + R + 2] = r.z),
                    (_[T + R + 3] = 0)),
                    !0 === p &&
                      (r.fromBufferAttribute(S, B),
                      (_[T + R + 4] = r.x),
                      (_[T + R + 5] = r.y),
                      (_[T + R + 6] = r.z),
                      (_[T + R + 7] = 0)),
                    !0 === f &&
                      (r.fromBufferAttribute(M, B),
                      (_[T + R + 8] = r.x),
                      (_[T + R + 9] = r.y),
                      (_[T + R + 10] = r.z),
                      (_[T + R + 11] = 4 === M.itemSize ? r.w : 1));
                }
              }
              function w() {
                b.dispose(), i.delete(a), a.removeEventListener("dispose", w);
              }
              (h = { count: u, texture: b, size: new Rt(y, x) }),
                i.set(a, h),
                a.addEventListener("dispose", w);
            }
            if (!0 === s.isInstancedMesh && null !== s.morphTexture)
              o.getUniforms().setValue(e, "morphTexture", s.morphTexture, n);
            else {
              let D = 0;
              for (let L = 0; L < l.length; L++) D += l[L];
              const P = a.morphTargetsRelative ? 1 : 1 - D;
              o.getUniforms().setValue(e, "morphTargetBaseInfluence", P),
                o.getUniforms().setValue(e, "morphTargetInfluences", l);
            }
            o.getUniforms().setValue(e, "morphTargetsTexture", h.texture, n),
              o.getUniforms().setValue(e, "morphTargetsTextureSize", h.size);
          },
        };
      }
      function ys(e, t, n, i) {
        let r = new WeakMap();
        function s(e) {
          const t = e.target;
          t.removeEventListener("dispose", s),
            n.remove(t.instanceMatrix),
            null !== t.instanceColor && n.remove(t.instanceColor);
        }
        return {
          update: function (a) {
            const o = i.render.frame,
              l = a.geometry,
              c = t.get(a, l);
            if (
              (r.get(c) !== o && (t.update(c), r.set(c, o)),
              a.isInstancedMesh &&
                (!1 === a.hasEventListener("dispose", s) &&
                  a.addEventListener("dispose", s),
                r.get(a) !== o &&
                  (n.update(a.instanceMatrix, e.ARRAY_BUFFER),
                  null !== a.instanceColor &&
                    n.update(a.instanceColor, e.ARRAY_BUFFER),
                  r.set(a, o))),
              a.isSkinnedMesh)
            ) {
              const e = a.skeleton;
              r.get(e) !== o && (e.update(), r.set(e, o));
            }
            return c;
          },
          dispose: function () {
            r = new WeakMap();
          },
        };
      }
      class xs extends $t {
        constructor(e, t, n, i, r, s, a, o, l, c = 1026) {
          if (c !== ce && c !== ue)
            throw new Error(
              "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
            );
          void 0 === n && c === ce && (n = J),
            void 0 === n && c === ue && (n = ne),
            super(null, i, r, s, a, o, c, n, l),
            (this.isDepthTexture = !0),
            (this.image = { width: e, height: t }),
            (this.magFilter = void 0 !== a ? a : k),
            (this.minFilter = void 0 !== o ? o : k),
            (this.flipY = !1),
            (this.generateMipmaps = !1),
            (this.compareFunction = null);
        }
        copy(e) {
          return (
            super.copy(e), (this.compareFunction = e.compareFunction), this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.compareFunction &&
              (t.compareFunction = this.compareFunction),
            t
          );
        }
      }
      const _s = new $t(),
        bs = new xs(1, 1),
        Es = new rn(),
        ws = new sn(),
        Cs = new Cr(),
        Is = [],
        Ss = [],
        Ms = new Float32Array(16),
        Ts = new Float32Array(9),
        Bs = new Float32Array(4);
      function Rs(e, t, n) {
        const i = e[0];
        if (i <= 0 || i > 0) return e;
        const r = t * n;
        let s = Is[r];
        if (
          (void 0 === s && ((s = new Float32Array(r)), (Is[r] = s)), 0 !== t)
        ) {
          i.toArray(s, 0);
          for (let i = 1, r = 0; i !== t; ++i) (r += n), e[i].toArray(s, r);
        }
        return s;
      }
      function Ds(e, t) {
        if (e.length !== t.length) return !1;
        for (let n = 0, i = e.length; n < i; n++) if (e[n] !== t[n]) return !1;
        return !0;
      }
      function Ps(e, t) {
        for (let n = 0, i = t.length; n < i; n++) e[n] = t[n];
      }
      function Ls(e, t) {
        let n = Ss[t];
        void 0 === n && ((n = new Int32Array(t)), (Ss[t] = n));
        for (let i = 0; i !== t; ++i) n[i] = e.allocateTextureUnit();
        return n;
      }
      function Us(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1f(this.addr, t), (n[0] = t));
      }
      function Fs(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2f(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (Ds(n, t)) return;
          e.uniform2fv(this.addr, t), Ps(n, t);
        }
      }
      function Ns(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3f(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else if (void 0 !== t.r)
          (n[0] === t.r && n[1] === t.g && n[2] === t.b) ||
            (e.uniform3f(this.addr, t.r, t.g, t.b),
            (n[0] = t.r),
            (n[1] = t.g),
            (n[2] = t.b));
        else {
          if (Ds(n, t)) return;
          e.uniform3fv(this.addr, t), Ps(n, t);
        }
      }
      function Os(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (Ds(n, t)) return;
          e.uniform4fv(this.addr, t), Ps(n, t);
        }
      }
      function Qs(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ds(n, t)) return;
          e.uniformMatrix2fv(this.addr, !1, t), Ps(n, t);
        } else {
          if (Ds(n, i)) return;
          Bs.set(i), e.uniformMatrix2fv(this.addr, !1, Bs), Ps(n, i);
        }
      }
      function ks(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ds(n, t)) return;
          e.uniformMatrix3fv(this.addr, !1, t), Ps(n, t);
        } else {
          if (Ds(n, i)) return;
          Ts.set(i), e.uniformMatrix3fv(this.addr, !1, Ts), Ps(n, i);
        }
      }
      function Gs(e, t) {
        const n = this.cache,
          i = t.elements;
        if (void 0 === i) {
          if (Ds(n, t)) return;
          e.uniformMatrix4fv(this.addr, !1, t), Ps(n, t);
        } else {
          if (Ds(n, i)) return;
          Ms.set(i), e.uniformMatrix4fv(this.addr, !1, Ms), Ps(n, i);
        }
      }
      function Hs(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1i(this.addr, t), (n[0] = t));
      }
      function zs(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2i(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (Ds(n, t)) return;
          e.uniform2iv(this.addr, t), Ps(n, t);
        }
      }
      function Vs(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3i(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else {
          if (Ds(n, t)) return;
          e.uniform3iv(this.addr, t), Ps(n, t);
        }
      }
      function Ws(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (Ds(n, t)) return;
          e.uniform4iv(this.addr, t), Ps(n, t);
        }
      }
      function js(e, t) {
        const n = this.cache;
        n[0] !== t && (e.uniform1ui(this.addr, t), (n[0] = t));
      }
      function qs(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y) ||
            (e.uniform2ui(this.addr, t.x, t.y), (n[0] = t.x), (n[1] = t.y));
        else {
          if (Ds(n, t)) return;
          e.uniform2uiv(this.addr, t), Ps(n, t);
        }
      }
      function Ys(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z) ||
            (e.uniform3ui(this.addr, t.x, t.y, t.z),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z));
        else {
          if (Ds(n, t)) return;
          e.uniform3uiv(this.addr, t), Ps(n, t);
        }
      }
      function Xs(e, t) {
        const n = this.cache;
        if (void 0 !== t.x)
          (n[0] === t.x && n[1] === t.y && n[2] === t.z && n[3] === t.w) ||
            (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
            (n[0] = t.x),
            (n[1] = t.y),
            (n[2] = t.z),
            (n[3] = t.w));
        else {
          if (Ds(n, t)) return;
          e.uniform4uiv(this.addr, t), Ps(n, t);
        }
      }
      function Ks(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        let s;
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          this.type === e.SAMPLER_2D_SHADOW
            ? ((bs.compareFunction = ft), (s = bs))
            : (s = _s),
          n.setTexture2D(t || s, r);
      }
      function Js(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture3D(t || ws, r);
      }
      function Zs(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTextureCube(t || Cs, r);
      }
      function $s(e, t, n) {
        const i = this.cache,
          r = n.allocateTextureUnit();
        i[0] !== r && (e.uniform1i(this.addr, r), (i[0] = r)),
          n.setTexture2DArray(t || Es, r);
      }
      function ea(e, t) {
        e.uniform1fv(this.addr, t);
      }
      function ta(e, t) {
        const n = Rs(t, this.size, 2);
        e.uniform2fv(this.addr, n);
      }
      function na(e, t) {
        const n = Rs(t, this.size, 3);
        e.uniform3fv(this.addr, n);
      }
      function ia(e, t) {
        const n = Rs(t, this.size, 4);
        e.uniform4fv(this.addr, n);
      }
      function ra(e, t) {
        const n = Rs(t, this.size, 4);
        e.uniformMatrix2fv(this.addr, !1, n);
      }
      function sa(e, t) {
        const n = Rs(t, this.size, 9);
        e.uniformMatrix3fv(this.addr, !1, n);
      }
      function aa(e, t) {
        const n = Rs(t, this.size, 16);
        e.uniformMatrix4fv(this.addr, !1, n);
      }
      function oa(e, t) {
        e.uniform1iv(this.addr, t);
      }
      function la(e, t) {
        e.uniform2iv(this.addr, t);
      }
      function ca(e, t) {
        e.uniform3iv(this.addr, t);
      }
      function ua(e, t) {
        e.uniform4iv(this.addr, t);
      }
      function ha(e, t) {
        e.uniform1uiv(this.addr, t);
      }
      function da(e, t) {
        e.uniform2uiv(this.addr, t);
      }
      function pa(e, t) {
        e.uniform3uiv(this.addr, t);
      }
      function fa(e, t) {
        e.uniform4uiv(this.addr, t);
      }
      function Aa(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ls(n, r);
        Ds(i, s) || (e.uniform1iv(this.addr, s), Ps(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture2D(t[e] || _s, s[e]);
      }
      function ga(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ls(n, r);
        Ds(i, s) || (e.uniform1iv(this.addr, s), Ps(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture3D(t[e] || ws, s[e]);
      }
      function ma(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ls(n, r);
        Ds(i, s) || (e.uniform1iv(this.addr, s), Ps(i, s));
        for (let e = 0; e !== r; ++e) n.setTextureCube(t[e] || Cs, s[e]);
      }
      function va(e, t, n) {
        const i = this.cache,
          r = t.length,
          s = Ls(n, r);
        Ds(i, s) || (e.uniform1iv(this.addr, s), Ps(i, s));
        for (let e = 0; e !== r; ++e) n.setTexture2DArray(t[e] || Es, s[e]);
      }
      class ya {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return Us;
                case 35664:
                  return Fs;
                case 35665:
                  return Ns;
                case 35666:
                  return Os;
                case 35674:
                  return Qs;
                case 35675:
                  return ks;
                case 35676:
                  return Gs;
                case 5124:
                case 35670:
                  return Hs;
                case 35667:
                case 35671:
                  return zs;
                case 35668:
                case 35672:
                  return Vs;
                case 35669:
                case 35673:
                  return Ws;
                case 5125:
                  return js;
                case 36294:
                  return qs;
                case 36295:
                  return Ys;
                case 36296:
                  return Xs;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Ks;
                case 35679:
                case 36299:
                case 36307:
                  return Js;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return Zs;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return $s;
              }
            })(t.type));
        }
      }
      class xa {
        constructor(e, t, n) {
          (this.id = e),
            (this.addr = n),
            (this.cache = []),
            (this.type = t.type),
            (this.size = t.size),
            (this.setValue = (function (e) {
              switch (e) {
                case 5126:
                  return ea;
                case 35664:
                  return ta;
                case 35665:
                  return na;
                case 35666:
                  return ia;
                case 35674:
                  return ra;
                case 35675:
                  return sa;
                case 35676:
                  return aa;
                case 5124:
                case 35670:
                  return oa;
                case 35667:
                case 35671:
                  return la;
                case 35668:
                case 35672:
                  return ca;
                case 35669:
                case 35673:
                  return ua;
                case 5125:
                  return ha;
                case 36294:
                  return da;
                case 36295:
                  return pa;
                case 36296:
                  return fa;
                case 35678:
                case 36198:
                case 36298:
                case 36306:
                case 35682:
                  return Aa;
                case 35679:
                case 36299:
                case 36307:
                  return ga;
                case 35680:
                case 36300:
                case 36308:
                case 36293:
                  return ma;
                case 36289:
                case 36303:
                case 36311:
                case 36292:
                  return va;
              }
            })(t.type));
        }
      }
      class _a {
        constructor(e) {
          (this.id = e), (this.seq = []), (this.map = {});
        }
        setValue(e, t, n) {
          const i = this.seq;
          for (let r = 0, s = i.length; r !== s; ++r) {
            const s = i[r];
            s.setValue(e, t[s.id], n);
          }
        }
      }
      const ba = /(\w+)(\])?(\[|\.)?/g;
      function Ea(e, t) {
        e.seq.push(t), (e.map[t.id] = t);
      }
      function wa(e, t, n) {
        const i = e.name,
          r = i.length;
        for (ba.lastIndex = 0; ; ) {
          const s = ba.exec(i),
            a = ba.lastIndex;
          let o = s[1];
          const l = "]" === s[2],
            c = s[3];
          if ((l && (o |= 0), void 0 === c || ("[" === c && a + 2 === r))) {
            Ea(n, void 0 === c ? new ya(o, e, t) : new xa(o, e, t));
            break;
          }
          {
            let e = n.map[o];
            void 0 === e && ((e = new _a(o)), Ea(n, e)), (n = e);
          }
        }
      }
      class Ca {
        constructor(e, t) {
          (this.seq = []), (this.map = {});
          const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
          for (let i = 0; i < n; ++i) {
            const n = e.getActiveUniform(t, i);
            wa(n, e.getUniformLocation(t, n.name), this);
          }
        }
        setValue(e, t, n, i) {
          const r = this.map[t];
          void 0 !== r && r.setValue(e, n, i);
        }
        setOptional(e, t, n) {
          const i = t[n];
          void 0 !== i && this.setValue(e, n, i);
        }
        static upload(e, t, n, i) {
          for (let r = 0, s = t.length; r !== s; ++r) {
            const s = t[r],
              a = n[s.id];
            !1 !== a.needsUpdate && s.setValue(e, a.value, i);
          }
        }
        static seqWithValue(e, t) {
          const n = [];
          for (let i = 0, r = e.length; i !== r; ++i) {
            const r = e[i];
            r.id in t && n.push(r);
          }
          return n;
        }
      }
      function Ia(e, t, n) {
        const i = e.createShader(t);
        return e.shaderSource(i, n), e.compileShader(i), i;
      }
      const Sa = 37297;
      let Ma = 0;
      const Ta = new Dt();
      function Ba(e, t, n) {
        const i = e.getShaderParameter(t, e.COMPILE_STATUS),
          r = e.getShaderInfoLog(t).trim();
        if (i && "" === r) return "";
        const s = /ERROR: 0:(\d+)/.exec(r);
        if (s) {
          const i = parseInt(s[1]);
          return (
            n.toUpperCase() +
            "\n\n" +
            r +
            "\n\n" +
            (function (e, t) {
              const n = e.split("\n"),
                i = [],
                r = Math.max(t - 6, 0),
                s = Math.min(t + 6, n.length);
              for (let e = r; e < s; e++) {
                const r = e + 1;
                i.push(`${r === t ? ">" : " "} ${r}: ${n[e]}`);
              }
              return i.join("\n");
            })(e.getShaderSource(t), i)
          );
        }
        return r;
      }
      function Ra(e, t) {
        const n = (function (e) {
          Qt._getMatrix(Ta, Qt.workingColorSpace, e);
          const t = `mat3( ${Ta.elements.map((e) => e.toFixed(4))} )`;
          switch (Qt.getTransfer(e)) {
            case ht:
              return [t, "LinearTransferOETF"];
            case dt:
              return [t, "sRGBTransferOETF"];
            default:
              return (
                console.warn(
                  "THREE.WebGLProgram: Unsupported color space: ",
                  e
                ),
                [t, "LinearTransferOETF"]
              );
          }
        })(t);
        return [
          `vec4 ${e}( vec4 value ) {`,
          `\treturn ${n[1]}( vec4( value.rgb * ${n[0]}, value.a ) );`,
          "}",
        ].join("\n");
      }
      function Da(e, t) {
        let n;
        switch (t) {
          case w:
            n = "Linear";
            break;
          case C:
            n = "Reinhard";
            break;
          case I:
            n = "Cineon";
            break;
          case S:
            n = "ACESFilmic";
            break;
          case T:
            n = "AgX";
            break;
          case B:
            n = "Neutral";
            break;
          case M:
            n = "Custom";
            break;
          default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
              (n = "Linear");
        }
        return (
          "vec3 " +
          e +
          "( vec3 color ) { return " +
          n +
          "ToneMapping( color ); }"
        );
      }
      const Pa = new on();
      function La() {
        Qt.getLuminanceCoefficients(Pa);
        return [
          "float luminance( const in vec3 rgb ) {",
          `\tconst vec3 weights = vec3( ${Pa.x.toFixed(4)}, ${Pa.y.toFixed(
            4
          )}, ${Pa.z.toFixed(4)} );`,
          "\treturn dot( weights, rgb );",
          "}",
        ].join("\n");
      }
      function Ua(e) {
        return "" !== e;
      }
      function Fa(e, t) {
        const n =
          t.numSpotLightShadows +
          t.numSpotLightMaps -
          t.numSpotLightShadowsWithMaps;
        return e
          .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
          .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
          .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
          .replace(/NUM_SPOT_LIGHT_COORDS/g, n)
          .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
          .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
          .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
          .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
          .replace(
            /NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,
            t.numSpotLightShadowsWithMaps
          )
          .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
          .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
      }
      function Na(e, t) {
        return e
          .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
          .replace(
            /UNION_CLIPPING_PLANES/g,
            t.numClippingPlanes - t.numClipIntersection
          );
      }
      const Oa = /^[ \t]*#include +<([\w\d./]+)>/gm;
      function Qa(e) {
        return e.replace(Oa, Ga);
      }
      const ka = new Map();
      function Ga(e, t) {
        let n = Nr[t];
        if (void 0 === n) {
          const e = ka.get(t);
          if (void 0 === e)
            throw new Error("Can not resolve #include <" + t + ">");
          (n = Nr[e]),
            console.warn(
              'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
              t,
              e
            );
        }
        return Qa(n);
      }
      const Ha =
        /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
      function za(e) {
        return e.replace(Ha, Va);
      }
      function Va(e, t, n, i) {
        let r = "";
        for (let e = parseInt(t); e < parseInt(n); e++)
          r += i
            .replace(/\[\s*i\s*\]/g, "[ " + e + " ]")
            .replace(/UNROLLED_LOOP_INDEX/g, e);
        return r;
      }
      function Wa(e) {
        let t = `precision ${e.precision} float;\n\tprecision ${e.precision} int;\n\tprecision ${e.precision} sampler2D;\n\tprecision ${e.precision} samplerCube;\n\tprecision ${e.precision} sampler3D;\n\tprecision ${e.precision} sampler2DArray;\n\tprecision ${e.precision} sampler2DShadow;\n\tprecision ${e.precision} samplerCubeShadow;\n\tprecision ${e.precision} sampler2DArrayShadow;\n\tprecision ${e.precision} isampler2D;\n\tprecision ${e.precision} isampler3D;\n\tprecision ${e.precision} isamplerCube;\n\tprecision ${e.precision} isampler2DArray;\n\tprecision ${e.precision} usampler2D;\n\tprecision ${e.precision} usampler3D;\n\tprecision ${e.precision} usamplerCube;\n\tprecision ${e.precision} usampler2DArray;\n\t`;
        return (
          "highp" === e.precision
            ? (t += "\n#define HIGH_PRECISION")
            : "mediump" === e.precision
            ? (t += "\n#define MEDIUM_PRECISION")
            : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
          t
        );
      }
      function ja(e, t, n, i) {
        const o = e.getContext(),
          l = n.defines;
        let c = n.vertexShader,
          u = n.fragmentShader;
        const h = (function (e) {
            let t = "SHADOWMAP_TYPE_BASIC";
            return (
              e.shadowMapType === r
                ? (t = "SHADOWMAP_TYPE_PCF")
                : e.shadowMapType === s
                ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
                : e.shadowMapType === a && (t = "SHADOWMAP_TYPE_VSM"),
              t
            );
          })(n),
          d = (function (e) {
            let t = "ENVMAP_TYPE_CUBE";
            if (e.envMap)
              switch (e.envMapMode) {
                case D:
                case P:
                  t = "ENVMAP_TYPE_CUBE";
                  break;
                case F:
                  t = "ENVMAP_TYPE_CUBE_UV";
              }
            return t;
          })(n),
          p = (function (e) {
            let t = "ENVMAP_MODE_REFLECTION";
            e.envMap && e.envMapMode === P && (t = "ENVMAP_MODE_REFRACTION");
            return t;
          })(n),
          f = (function (e) {
            let t = "ENVMAP_BLENDING_NONE";
            if (e.envMap)
              switch (e.combine) {
                case x:
                  t = "ENVMAP_BLENDING_MULTIPLY";
                  break;
                case _:
                  t = "ENVMAP_BLENDING_MIX";
                  break;
                case b:
                  t = "ENVMAP_BLENDING_ADD";
              }
            return t;
          })(n),
          A = (function (e) {
            const t = e.envMapCubeUVHeight;
            if (null === t) return null;
            const n = Math.log2(t) - 2,
              i = 1 / t;
            return {
              texelWidth: 1 / (3 * Math.max(Math.pow(2, n), 112)),
              texelHeight: i,
              maxMip: n,
            };
          })(n),
          g = (function (e) {
            return [
              e.extensionClipCullDistance
                ? "#extension GL_ANGLE_clip_cull_distance : require"
                : "",
              e.extensionMultiDraw
                ? "#extension GL_ANGLE_multi_draw : require"
                : "",
            ]
              .filter(Ua)
              .join("\n");
          })(n),
          m = (function (e) {
            const t = [];
            for (const n in e) {
              const i = e[n];
              !1 !== i && t.push("#define " + n + " " + i);
            }
            return t.join("\n");
          })(l),
          v = o.createProgram();
        let y,
          w,
          C = n.glslVersion ? "#version " + n.glslVersion + "\n" : "";
        n.isRawShaderMaterial
          ? ((y = [
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              m,
            ]
              .filter(Ua)
              .join("\n")),
            y.length > 0 && (y += "\n"),
            (w = [
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              m,
            ]
              .filter(Ua)
              .join("\n")),
            w.length > 0 && (w += "\n"))
          : ((y = [
              Wa(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              m,
              n.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
              n.batching ? "#define USE_BATCHING" : "",
              n.batchingColor ? "#define USE_BATCHING_COLOR" : "",
              n.instancing ? "#define USE_INSTANCING" : "",
              n.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
              n.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.map ? "#define USE_MAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + p : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.mapUv ? "#define MAP_UV " + n.mapUv : "",
              n.alphaMapUv ? "#define ALPHAMAP_UV " + n.alphaMapUv : "",
              n.lightMapUv ? "#define LIGHTMAP_UV " + n.lightMapUv : "",
              n.aoMapUv ? "#define AOMAP_UV " + n.aoMapUv : "",
              n.emissiveMapUv
                ? "#define EMISSIVEMAP_UV " + n.emissiveMapUv
                : "",
              n.bumpMapUv ? "#define BUMPMAP_UV " + n.bumpMapUv : "",
              n.normalMapUv ? "#define NORMALMAP_UV " + n.normalMapUv : "",
              n.displacementMapUv
                ? "#define DISPLACEMENTMAP_UV " + n.displacementMapUv
                : "",
              n.metalnessMapUv
                ? "#define METALNESSMAP_UV " + n.metalnessMapUv
                : "",
              n.roughnessMapUv
                ? "#define ROUGHNESSMAP_UV " + n.roughnessMapUv
                : "",
              n.anisotropyMapUv
                ? "#define ANISOTROPYMAP_UV " + n.anisotropyMapUv
                : "",
              n.clearcoatMapUv
                ? "#define CLEARCOATMAP_UV " + n.clearcoatMapUv
                : "",
              n.clearcoatNormalMapUv
                ? "#define CLEARCOAT_NORMALMAP_UV " + n.clearcoatNormalMapUv
                : "",
              n.clearcoatRoughnessMapUv
                ? "#define CLEARCOAT_ROUGHNESSMAP_UV " +
                  n.clearcoatRoughnessMapUv
                : "",
              n.iridescenceMapUv
                ? "#define IRIDESCENCEMAP_UV " + n.iridescenceMapUv
                : "",
              n.iridescenceThicknessMapUv
                ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
                  n.iridescenceThicknessMapUv
                : "",
              n.sheenColorMapUv
                ? "#define SHEEN_COLORMAP_UV " + n.sheenColorMapUv
                : "",
              n.sheenRoughnessMapUv
                ? "#define SHEEN_ROUGHNESSMAP_UV " + n.sheenRoughnessMapUv
                : "",
              n.specularMapUv
                ? "#define SPECULARMAP_UV " + n.specularMapUv
                : "",
              n.specularColorMapUv
                ? "#define SPECULAR_COLORMAP_UV " + n.specularColorMapUv
                : "",
              n.specularIntensityMapUv
                ? "#define SPECULAR_INTENSITYMAP_UV " + n.specularIntensityMapUv
                : "",
              n.transmissionMapUv
                ? "#define TRANSMISSIONMAP_UV " + n.transmissionMapUv
                : "",
              n.thicknessMapUv
                ? "#define THICKNESSMAP_UV " + n.thicknessMapUv
                : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors ? "#define USE_COLOR" : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.skinning ? "#define USE_SKINNING" : "",
              n.morphTargets ? "#define USE_MORPHTARGETS" : "",
              n.morphNormals && !1 === n.flatShading
                ? "#define USE_MORPHNORMALS"
                : "",
              n.morphColors ? "#define USE_MORPHCOLORS" : "",
              n.morphTargetsCount > 0
                ? "#define MORPHTARGETS_TEXTURE_STRIDE " + n.morphTextureStride
                : "",
              n.morphTargetsCount > 0
                ? "#define MORPHTARGETS_COUNT " + n.morphTargetsCount
                : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + h : "",
              n.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 modelMatrix;",
              "uniform mat4 modelViewMatrix;",
              "uniform mat4 projectionMatrix;",
              "uniform mat4 viewMatrix;",
              "uniform mat3 normalMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              "#ifdef USE_INSTANCING",
              "\tattribute mat4 instanceMatrix;",
              "#endif",
              "#ifdef USE_INSTANCING_COLOR",
              "\tattribute vec3 instanceColor;",
              "#endif",
              "#ifdef USE_INSTANCING_MORPH",
              "\tuniform sampler2D morphTexture;",
              "#endif",
              "attribute vec3 position;",
              "attribute vec3 normal;",
              "attribute vec2 uv;",
              "#ifdef USE_UV1",
              "\tattribute vec2 uv1;",
              "#endif",
              "#ifdef USE_UV2",
              "\tattribute vec2 uv2;",
              "#endif",
              "#ifdef USE_UV3",
              "\tattribute vec2 uv3;",
              "#endif",
              "#ifdef USE_TANGENT",
              "\tattribute vec4 tangent;",
              "#endif",
              "#if defined( USE_COLOR_ALPHA )",
              "\tattribute vec4 color;",
              "#elif defined( USE_COLOR )",
              "\tattribute vec3 color;",
              "#endif",
              "#ifdef USE_SKINNING",
              "\tattribute vec4 skinIndex;",
              "\tattribute vec4 skinWeight;",
              "#endif",
              "\n",
            ]
              .filter(Ua)
              .join("\n")),
            (w = [
              Wa(n),
              "#define SHADER_TYPE " + n.shaderType,
              "#define SHADER_NAME " + n.shaderName,
              m,
              n.useFog && n.fog ? "#define USE_FOG" : "",
              n.useFog && n.fogExp2 ? "#define FOG_EXP2" : "",
              n.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
              n.map ? "#define USE_MAP" : "",
              n.matcap ? "#define USE_MATCAP" : "",
              n.envMap ? "#define USE_ENVMAP" : "",
              n.envMap ? "#define " + d : "",
              n.envMap ? "#define " + p : "",
              n.envMap ? "#define " + f : "",
              A ? "#define CUBEUV_TEXEL_WIDTH " + A.texelWidth : "",
              A ? "#define CUBEUV_TEXEL_HEIGHT " + A.texelHeight : "",
              A ? "#define CUBEUV_MAX_MIP " + A.maxMip + ".0" : "",
              n.lightMap ? "#define USE_LIGHTMAP" : "",
              n.aoMap ? "#define USE_AOMAP" : "",
              n.bumpMap ? "#define USE_BUMPMAP" : "",
              n.normalMap ? "#define USE_NORMALMAP" : "",
              n.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
              n.normalMapTangentSpace
                ? "#define USE_NORMALMAP_TANGENTSPACE"
                : "",
              n.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
              n.anisotropy ? "#define USE_ANISOTROPY" : "",
              n.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
              n.clearcoat ? "#define USE_CLEARCOAT" : "",
              n.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
              n.clearcoatRoughnessMap
                ? "#define USE_CLEARCOAT_ROUGHNESSMAP"
                : "",
              n.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
              n.dispersion ? "#define USE_DISPERSION" : "",
              n.iridescence ? "#define USE_IRIDESCENCE" : "",
              n.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
              n.iridescenceThicknessMap
                ? "#define USE_IRIDESCENCE_THICKNESSMAP"
                : "",
              n.specularMap ? "#define USE_SPECULARMAP" : "",
              n.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
              n.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
              n.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
              n.metalnessMap ? "#define USE_METALNESSMAP" : "",
              n.alphaMap ? "#define USE_ALPHAMAP" : "",
              n.alphaTest ? "#define USE_ALPHATEST" : "",
              n.alphaHash ? "#define USE_ALPHAHASH" : "",
              n.sheen ? "#define USE_SHEEN" : "",
              n.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
              n.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
              n.transmission ? "#define USE_TRANSMISSION" : "",
              n.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
              n.thicknessMap ? "#define USE_THICKNESSMAP" : "",
              n.vertexTangents && !1 === n.flatShading
                ? "#define USE_TANGENT"
                : "",
              n.vertexColors || n.instancingColor || n.batchingColor
                ? "#define USE_COLOR"
                : "",
              n.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
              n.vertexUv1s ? "#define USE_UV1" : "",
              n.vertexUv2s ? "#define USE_UV2" : "",
              n.vertexUv3s ? "#define USE_UV3" : "",
              n.pointsUvs ? "#define USE_POINTS_UV" : "",
              n.gradientMap ? "#define USE_GRADIENTMAP" : "",
              n.flatShading ? "#define FLAT_SHADED" : "",
              n.doubleSided ? "#define DOUBLE_SIDED" : "",
              n.flipSided ? "#define FLIP_SIDED" : "",
              n.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
              n.shadowMapEnabled ? "#define " + h : "",
              n.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
              n.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
              n.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
              n.decodeVideoTextureEmissive
                ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE"
                : "",
              n.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
              n.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "",
              "uniform mat4 viewMatrix;",
              "uniform vec3 cameraPosition;",
              "uniform bool isOrthographic;",
              n.toneMapping !== E ? "#define TONE_MAPPING" : "",
              n.toneMapping !== E ? Nr.tonemapping_pars_fragment : "",
              n.toneMapping !== E ? Da("toneMapping", n.toneMapping) : "",
              n.dithering ? "#define DITHERING" : "",
              n.opaque ? "#define OPAQUE" : "",
              Nr.colorspace_pars_fragment,
              Ra("linearToOutputTexel", n.outputColorSpace),
              La(),
              n.useDepthPacking
                ? "#define DEPTH_PACKING " + n.depthPacking
                : "",
              "\n",
            ]
              .filter(Ua)
              .join("\n"))),
          (c = Qa(c)),
          (c = Fa(c, n)),
          (c = Na(c, n)),
          (u = Qa(u)),
          (u = Fa(u, n)),
          (u = Na(u, n)),
          (c = za(c)),
          (u = za(u)),
          !0 !== n.isRawShaderMaterial &&
            ((C = "#version 300 es\n"),
            (y =
              [
                g,
                "#define attribute in",
                "#define varying out",
                "#define texture2D texture",
              ].join("\n") +
              "\n" +
              y),
            (w =
              [
                "#define varying in",
                n.glslVersion === gt
                  ? ""
                  : "layout(location = 0) out highp vec4 pc_fragColor;",
                n.glslVersion === gt ? "" : "#define gl_FragColor pc_fragColor",
                "#define gl_FragDepthEXT gl_FragDepth",
                "#define texture2D texture",
                "#define textureCube texture",
                "#define texture2DProj textureProj",
                "#define texture2DLodEXT textureLod",
                "#define texture2DProjLodEXT textureProjLod",
                "#define textureCubeLodEXT textureLod",
                "#define texture2DGradEXT textureGrad",
                "#define texture2DProjGradEXT textureProjGrad",
                "#define textureCubeGradEXT textureGrad",
              ].join("\n") +
              "\n" +
              w));
        const I = C + y + c,
          S = C + w + u,
          M = Ia(o, o.VERTEX_SHADER, I),
          T = Ia(o, o.FRAGMENT_SHADER, S);
        function B(t) {
          if (e.debug.checkShaderErrors) {
            const n = o.getProgramInfoLog(v).trim(),
              i = o.getShaderInfoLog(M).trim(),
              r = o.getShaderInfoLog(T).trim();
            let s = !0,
              a = !0;
            if (!1 === o.getProgramParameter(v, o.LINK_STATUS))
              if (((s = !1), "function" == typeof e.debug.onShaderError))
                e.debug.onShaderError(o, v, M, T);
              else {
                const e = Ba(o, M, "vertex"),
                  i = Ba(o, T, "fragment");
                console.error(
                  "THREE.WebGLProgram: Shader Error " +
                    o.getError() +
                    " - VALIDATE_STATUS " +
                    o.getProgramParameter(v, o.VALIDATE_STATUS) +
                    "\n\nMaterial Name: " +
                    t.name +
                    "\nMaterial Type: " +
                    t.type +
                    "\n\nProgram Info Log: " +
                    n +
                    "\n" +
                    e +
                    "\n" +
                    i
                );
              }
            else
              "" !== n
                ? console.warn("THREE.WebGLProgram: Program Info Log:", n)
                : ("" !== i && "" !== r) || (a = !1);
            a &&
              (t.diagnostics = {
                runnable: s,
                programLog: n,
                vertexShader: { log: i, prefix: y },
                fragmentShader: { log: r, prefix: w },
              });
          }
          o.deleteShader(M),
            o.deleteShader(T),
            (R = new Ca(o, v)),
            (L = (function (e, t) {
              const n = {},
                i = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
              for (let r = 0; r < i; r++) {
                const i = e.getActiveAttrib(t, r),
                  s = i.name;
                let a = 1;
                i.type === e.FLOAT_MAT2 && (a = 2),
                  i.type === e.FLOAT_MAT3 && (a = 3),
                  i.type === e.FLOAT_MAT4 && (a = 4),
                  (n[s] = {
                    type: i.type,
                    location: e.getAttribLocation(t, s),
                    locationSize: a,
                  });
              }
              return n;
            })(o, v));
        }
        let R, L;
        o.attachShader(v, M),
          o.attachShader(v, T),
          void 0 !== n.index0AttributeName
            ? o.bindAttribLocation(v, 0, n.index0AttributeName)
            : !0 === n.morphTargets && o.bindAttribLocation(v, 0, "position"),
          o.linkProgram(v),
          (this.getUniforms = function () {
            return void 0 === R && B(this), R;
          }),
          (this.getAttributes = function () {
            return void 0 === L && B(this), L;
          });
        let U = !1 === n.rendererExtensionParallelShaderCompile;
        return (
          (this.isReady = function () {
            return !1 === U && (U = o.getProgramParameter(v, Sa)), U;
          }),
          (this.destroy = function () {
            i.releaseStatesOfProgram(this),
              o.deleteProgram(v),
              (this.program = void 0);
          }),
          (this.type = n.shaderType),
          (this.name = n.shaderName),
          (this.id = Ma++),
          (this.cacheKey = t),
          (this.usedTimes = 1),
          (this.program = v),
          (this.vertexShader = M),
          (this.fragmentShader = T),
          this
        );
      }
      let qa = 0;
      class Ya {
        constructor() {
          (this.shaderCache = new Map()), (this.materialCache = new Map());
        }
        update(e) {
          const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            r = this._getShaderStage(n),
            s = this._getShaderCacheForMaterial(e);
          return (
            !1 === s.has(i) && (s.add(i), i.usedTimes++),
            !1 === s.has(r) && (s.add(r), r.usedTimes++),
            this
          );
        }
        remove(e) {
          const t = this.materialCache.get(e);
          for (const e of t)
            e.usedTimes--, 0 === e.usedTimes && this.shaderCache.delete(e.code);
          return this.materialCache.delete(e), this;
        }
        getVertexShaderID(e) {
          return this._getShaderStage(e.vertexShader).id;
        }
        getFragmentShaderID(e) {
          return this._getShaderStage(e.fragmentShader).id;
        }
        dispose() {
          this.shaderCache.clear(), this.materialCache.clear();
        }
        _getShaderCacheForMaterial(e) {
          const t = this.materialCache;
          let n = t.get(e);
          return void 0 === n && ((n = new Set()), t.set(e, n)), n;
        }
        _getShaderStage(e) {
          const t = this.shaderCache;
          let n = t.get(e);
          return void 0 === n && ((n = new Xa(e)), t.set(e, n)), n;
        }
      }
      class Xa {
        constructor(e) {
          (this.id = qa++), (this.code = e), (this.usedTimes = 0);
        }
      }
      function Ka(e, t, n, i, r, s, a) {
        const o = new Yn(),
          u = new Ya(),
          h = new Set(),
          d = [],
          p = r.logarithmicDepthBuffer,
          f = r.vertexTextures;
        let A = r.precision;
        const g = {
          MeshDepthMaterial: "depth",
          MeshDistanceMaterial: "distanceRGBA",
          MeshNormalMaterial: "normal",
          MeshBasicMaterial: "basic",
          MeshLambertMaterial: "lambert",
          MeshPhongMaterial: "phong",
          MeshToonMaterial: "toon",
          MeshStandardMaterial: "physical",
          MeshPhysicalMaterial: "physical",
          MeshMatcapMaterial: "matcap",
          LineBasicMaterial: "basic",
          LineDashedMaterial: "dashed",
          PointsMaterial: "points",
          ShadowMaterial: "shadow",
          SpriteMaterial: "sprite",
        };
        function m(e) {
          return h.add(e), 0 === e ? "uv" : `uv${e}`;
        }
        return {
          getParameters: function (s, o, d, v, y) {
            const x = v.fog,
              _ = y.geometry,
              b = s.isMeshStandardMaterial ? v.environment : null,
              w = (s.isMeshStandardMaterial ? n : t).get(s.envMap || b),
              C = w && w.mapping === F ? w.image.height : null,
              I = g[s.type];
            null !== s.precision &&
              ((A = r.getMaxPrecision(s.precision)),
              A !== s.precision &&
                console.warn(
                  "THREE.WebGLProgram.getParameters:",
                  s.precision,
                  "not supported, using",
                  A,
                  "instead."
                ));
            const S =
                _.morphAttributes.position ||
                _.morphAttributes.normal ||
                _.morphAttributes.color,
              M = void 0 !== S ? S.length : 0;
            let T,
              B,
              R,
              D,
              P = 0;
            if (
              (void 0 !== _.morphAttributes.position && (P = 1),
              void 0 !== _.morphAttributes.normal && (P = 2),
              void 0 !== _.morphAttributes.color && (P = 3),
              I)
            ) {
              const e = Qr[I];
              (T = e.vertexShader), (B = e.fragmentShader);
            } else
              (T = s.vertexShader),
                (B = s.fragmentShader),
                u.update(s),
                (R = u.getVertexShaderID(s)),
                (D = u.getFragmentShaderID(s));
            const L = e.getRenderTarget(),
              U = e.state.buffers.depth.getReversed(),
              N = !0 === y.isInstancedMesh,
              O = !0 === y.isBatchedMesh,
              Q = !!s.map,
              k = !!s.matcap,
              G = !!w,
              H = !!s.aoMap,
              z = !!s.lightMap,
              V = !!s.bumpMap,
              W = !!s.normalMap,
              j = !!s.displacementMap,
              q = !!s.emissiveMap,
              Y = !!s.metalnessMap,
              X = !!s.roughnessMap,
              K = s.anisotropy > 0,
              J = s.clearcoat > 0,
              Z = s.dispersion > 0,
              $ = s.iridescence > 0,
              ee = s.sheen > 0,
              te = s.transmission > 0,
              ne = K && !!s.anisotropyMap,
              ie = J && !!s.clearcoatMap,
              re = J && !!s.clearcoatNormalMap,
              se = J && !!s.clearcoatRoughnessMap,
              ae = $ && !!s.iridescenceMap,
              oe = $ && !!s.iridescenceThicknessMap,
              le = ee && !!s.sheenColorMap,
              ce = ee && !!s.sheenRoughnessMap,
              ue = !!s.specularMap,
              he = !!s.specularColorMap,
              de = !!s.specularIntensityMap,
              pe = te && !!s.transmissionMap,
              fe = te && !!s.thicknessMap,
              Ae = !!s.gradientMap,
              ge = !!s.alphaMap,
              me = s.alphaTest > 0,
              ve = !!s.alphaHash,
              ye = !!s.extensions;
            let xe = E;
            s.toneMapped &&
              ((null !== L && !0 !== L.isXRRenderTarget) ||
                (xe = e.toneMapping));
            const _e = {
              shaderID: I,
              shaderType: s.type,
              shaderName: s.name,
              vertexShader: T,
              fragmentShader: B,
              defines: s.defines,
              customVertexShaderID: R,
              customFragmentShaderID: D,
              isRawShaderMaterial: !0 === s.isRawShaderMaterial,
              glslVersion: s.glslVersion,
              precision: A,
              batching: O,
              batchingColor: O && null !== y._colorsTexture,
              instancing: N,
              instancingColor: N && null !== y.instanceColor,
              instancingMorph: N && null !== y.morphTexture,
              supportsVertexTextures: f,
              outputColorSpace:
                null === L
                  ? e.outputColorSpace
                  : !0 === L.isXRRenderTarget
                  ? L.texture.colorSpace
                  : ut,
              alphaToCoverage: !!s.alphaToCoverage,
              map: Q,
              matcap: k,
              envMap: G,
              envMapMode: G && w.mapping,
              envMapCubeUVHeight: C,
              aoMap: H,
              lightMap: z,
              bumpMap: V,
              normalMap: W,
              displacementMap: f && j,
              emissiveMap: q,
              normalMapObjectSpace: W && 1 === s.normalMapType,
              normalMapTangentSpace: W && 0 === s.normalMapType,
              metalnessMap: Y,
              roughnessMap: X,
              anisotropy: K,
              anisotropyMap: ne,
              clearcoat: J,
              clearcoatMap: ie,
              clearcoatNormalMap: re,
              clearcoatRoughnessMap: se,
              dispersion: Z,
              iridescence: $,
              iridescenceMap: ae,
              iridescenceThicknessMap: oe,
              sheen: ee,
              sheenColorMap: le,
              sheenRoughnessMap: ce,
              specularMap: ue,
              specularColorMap: he,
              specularIntensityMap: de,
              transmission: te,
              transmissionMap: pe,
              thicknessMap: fe,
              gradientMap: Ae,
              opaque:
                !1 === s.transparent &&
                1 === s.blending &&
                !1 === s.alphaToCoverage,
              alphaMap: ge,
              alphaTest: me,
              alphaHash: ve,
              combine: s.combine,
              mapUv: Q && m(s.map.channel),
              aoMapUv: H && m(s.aoMap.channel),
              lightMapUv: z && m(s.lightMap.channel),
              bumpMapUv: V && m(s.bumpMap.channel),
              normalMapUv: W && m(s.normalMap.channel),
              displacementMapUv: j && m(s.displacementMap.channel),
              emissiveMapUv: q && m(s.emissiveMap.channel),
              metalnessMapUv: Y && m(s.metalnessMap.channel),
              roughnessMapUv: X && m(s.roughnessMap.channel),
              anisotropyMapUv: ne && m(s.anisotropyMap.channel),
              clearcoatMapUv: ie && m(s.clearcoatMap.channel),
              clearcoatNormalMapUv: re && m(s.clearcoatNormalMap.channel),
              clearcoatRoughnessMapUv: se && m(s.clearcoatRoughnessMap.channel),
              iridescenceMapUv: ae && m(s.iridescenceMap.channel),
              iridescenceThicknessMapUv:
                oe && m(s.iridescenceThicknessMap.channel),
              sheenColorMapUv: le && m(s.sheenColorMap.channel),
              sheenRoughnessMapUv: ce && m(s.sheenRoughnessMap.channel),
              specularMapUv: ue && m(s.specularMap.channel),
              specularColorMapUv: he && m(s.specularColorMap.channel),
              specularIntensityMapUv: de && m(s.specularIntensityMap.channel),
              transmissionMapUv: pe && m(s.transmissionMap.channel),
              thicknessMapUv: fe && m(s.thicknessMap.channel),
              alphaMapUv: ge && m(s.alphaMap.channel),
              vertexTangents: !!_.attributes.tangent && (W || K),
              vertexColors: s.vertexColors,
              vertexAlphas:
                !0 === s.vertexColors &&
                !!_.attributes.color &&
                4 === _.attributes.color.itemSize,
              pointsUvs: !0 === y.isPoints && !!_.attributes.uv && (Q || ge),
              fog: !!x,
              useFog: !0 === s.fog,
              fogExp2: !!x && x.isFogExp2,
              flatShading: !0 === s.flatShading,
              sizeAttenuation: !0 === s.sizeAttenuation,
              logarithmicDepthBuffer: p,
              reverseDepthBuffer: U,
              skinning: !0 === y.isSkinnedMesh,
              morphTargets: void 0 !== _.morphAttributes.position,
              morphNormals: void 0 !== _.morphAttributes.normal,
              morphColors: void 0 !== _.morphAttributes.color,
              morphTargetsCount: M,
              morphTextureStride: P,
              numDirLights: o.directional.length,
              numPointLights: o.point.length,
              numSpotLights: o.spot.length,
              numSpotLightMaps: o.spotLightMap.length,
              numRectAreaLights: o.rectArea.length,
              numHemiLights: o.hemi.length,
              numDirLightShadows: o.directionalShadowMap.length,
              numPointLightShadows: o.pointShadowMap.length,
              numSpotLightShadows: o.spotShadowMap.length,
              numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
              numLightProbes: o.numLightProbes,
              numClippingPlanes: a.numPlanes,
              numClipIntersection: a.numIntersection,
              dithering: s.dithering,
              shadowMapEnabled: e.shadowMap.enabled && d.length > 0,
              shadowMapType: e.shadowMap.type,
              toneMapping: xe,
              decodeVideoTexture:
                Q &&
                !0 === s.map.isVideoTexture &&
                Qt.getTransfer(s.map.colorSpace) === dt,
              decodeVideoTextureEmissive:
                q &&
                !0 === s.emissiveMap.isVideoTexture &&
                Qt.getTransfer(s.emissiveMap.colorSpace) === dt,
              premultipliedAlpha: s.premultipliedAlpha,
              doubleSided: s.side === c,
              flipSided: s.side === l,
              useDepthPacking: s.depthPacking >= 0,
              depthPacking: s.depthPacking || 0,
              index0AttributeName: s.index0AttributeName,
              extensionClipCullDistance:
                ye &&
                !0 === s.extensions.clipCullDistance &&
                i.has("WEBGL_clip_cull_distance"),
              extensionMultiDraw:
                ((ye && !0 === s.extensions.multiDraw) || O) &&
                i.has("WEBGL_multi_draw"),
              rendererExtensionParallelShaderCompile: i.has(
                "KHR_parallel_shader_compile"
              ),
              customProgramCacheKey: s.customProgramCacheKey(),
            };
            return (
              (_e.vertexUv1s = h.has(1)),
              (_e.vertexUv2s = h.has(2)),
              (_e.vertexUv3s = h.has(3)),
              h.clear(),
              _e
            );
          },
          getProgramCacheKey: function (t) {
            const n = [];
            if (
              (t.shaderID
                ? n.push(t.shaderID)
                : (n.push(t.customVertexShaderID),
                  n.push(t.customFragmentShaderID)),
              void 0 !== t.defines)
            )
              for (const e in t.defines) n.push(e), n.push(t.defines[e]);
            return (
              !1 === t.isRawShaderMaterial &&
                (!(function (e, t) {
                  e.push(t.precision),
                    e.push(t.outputColorSpace),
                    e.push(t.envMapMode),
                    e.push(t.envMapCubeUVHeight),
                    e.push(t.mapUv),
                    e.push(t.alphaMapUv),
                    e.push(t.lightMapUv),
                    e.push(t.aoMapUv),
                    e.push(t.bumpMapUv),
                    e.push(t.normalMapUv),
                    e.push(t.displacementMapUv),
                    e.push(t.emissiveMapUv),
                    e.push(t.metalnessMapUv),
                    e.push(t.roughnessMapUv),
                    e.push(t.anisotropyMapUv),
                    e.push(t.clearcoatMapUv),
                    e.push(t.clearcoatNormalMapUv),
                    e.push(t.clearcoatRoughnessMapUv),
                    e.push(t.iridescenceMapUv),
                    e.push(t.iridescenceThicknessMapUv),
                    e.push(t.sheenColorMapUv),
                    e.push(t.sheenRoughnessMapUv),
                    e.push(t.specularMapUv),
                    e.push(t.specularColorMapUv),
                    e.push(t.specularIntensityMapUv),
                    e.push(t.transmissionMapUv),
                    e.push(t.thicknessMapUv),
                    e.push(t.combine),
                    e.push(t.fogExp2),
                    e.push(t.sizeAttenuation),
                    e.push(t.morphTargetsCount),
                    e.push(t.morphAttributeCount),
                    e.push(t.numDirLights),
                    e.push(t.numPointLights),
                    e.push(t.numSpotLights),
                    e.push(t.numSpotLightMaps),
                    e.push(t.numHemiLights),
                    e.push(t.numRectAreaLights),
                    e.push(t.numDirLightShadows),
                    e.push(t.numPointLightShadows),
                    e.push(t.numSpotLightShadows),
                    e.push(t.numSpotLightShadowsWithMaps),
                    e.push(t.numLightProbes),
                    e.push(t.shadowMapType),
                    e.push(t.toneMapping),
                    e.push(t.numClippingPlanes),
                    e.push(t.numClipIntersection),
                    e.push(t.depthPacking);
                })(n, t),
                (function (e, t) {
                  o.disableAll(), t.supportsVertexTextures && o.enable(0);
                  t.instancing && o.enable(1);
                  t.instancingColor && o.enable(2);
                  t.instancingMorph && o.enable(3);
                  t.matcap && o.enable(4);
                  t.envMap && o.enable(5);
                  t.normalMapObjectSpace && o.enable(6);
                  t.normalMapTangentSpace && o.enable(7);
                  t.clearcoat && o.enable(8);
                  t.iridescence && o.enable(9);
                  t.alphaTest && o.enable(10);
                  t.vertexColors && o.enable(11);
                  t.vertexAlphas && o.enable(12);
                  t.vertexUv1s && o.enable(13);
                  t.vertexUv2s && o.enable(14);
                  t.vertexUv3s && o.enable(15);
                  t.vertexTangents && o.enable(16);
                  t.anisotropy && o.enable(17);
                  t.alphaHash && o.enable(18);
                  t.batching && o.enable(19);
                  t.dispersion && o.enable(20);
                  t.batchingColor && o.enable(21);
                  e.push(o.mask), o.disableAll(), t.fog && o.enable(0);
                  t.useFog && o.enable(1);
                  t.flatShading && o.enable(2);
                  t.logarithmicDepthBuffer && o.enable(3);
                  t.reverseDepthBuffer && o.enable(4);
                  t.skinning && o.enable(5);
                  t.morphTargets && o.enable(6);
                  t.morphNormals && o.enable(7);
                  t.morphColors && o.enable(8);
                  t.premultipliedAlpha && o.enable(9);
                  t.shadowMapEnabled && o.enable(10);
                  t.doubleSided && o.enable(11);
                  t.flipSided && o.enable(12);
                  t.useDepthPacking && o.enable(13);
                  t.dithering && o.enable(14);
                  t.transmission && o.enable(15);
                  t.sheen && o.enable(16);
                  t.opaque && o.enable(17);
                  t.pointsUvs && o.enable(18);
                  t.decodeVideoTexture && o.enable(19);
                  t.decodeVideoTextureEmissive && o.enable(20);
                  t.alphaToCoverage && o.enable(21);
                  e.push(o.mask);
                })(n, t),
                n.push(e.outputColorSpace)),
              n.push(t.customProgramCacheKey),
              n.join()
            );
          },
          getUniforms: function (e) {
            const t = g[e.type];
            let n;
            if (t) {
              const e = Qr[t];
              n = gr.clone(e.uniforms);
            } else n = e.uniforms;
            return n;
          },
          acquireProgram: function (t, n) {
            let i;
            for (let e = 0, t = d.length; e < t; e++) {
              const t = d[e];
              if (t.cacheKey === n) {
                (i = t), ++i.usedTimes;
                break;
              }
            }
            return void 0 === i && ((i = new ja(e, n, t, s)), d.push(i)), i;
          },
          releaseProgram: function (e) {
            if (0 == --e.usedTimes) {
              const t = d.indexOf(e);
              (d[t] = d[d.length - 1]), d.pop(), e.destroy();
            }
          },
          releaseShaderCache: function (e) {
            u.remove(e);
          },
          programs: d,
          dispose: function () {
            u.dispose();
          },
        };
      }
      function Ja() {
        let e = new WeakMap();
        return {
          has: function (t) {
            return e.has(t);
          },
          get: function (t) {
            let n = e.get(t);
            return void 0 === n && ((n = {}), e.set(t, n)), n;
          },
          remove: function (t) {
            e.delete(t);
          },
          update: function (t, n, i) {
            e.get(t)[n] = i;
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function Za(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.material.id !== t.material.id
          ? e.material.id - t.material.id
          : e.z !== t.z
          ? e.z - t.z
          : e.id - t.id;
      }
      function $a(e, t) {
        return e.groupOrder !== t.groupOrder
          ? e.groupOrder - t.groupOrder
          : e.renderOrder !== t.renderOrder
          ? e.renderOrder - t.renderOrder
          : e.z !== t.z
          ? t.z - e.z
          : e.id - t.id;
      }
      function eo() {
        const e = [];
        let t = 0;
        const n = [],
          i = [],
          r = [];
        function s(n, i, r, s, a, o) {
          let l = e[t];
          return (
            void 0 === l
              ? ((l = {
                  id: n.id,
                  object: n,
                  geometry: i,
                  material: r,
                  groupOrder: s,
                  renderOrder: n.renderOrder,
                  z: a,
                  group: o,
                }),
                (e[t] = l))
              : ((l.id = n.id),
                (l.object = n),
                (l.geometry = i),
                (l.material = r),
                (l.groupOrder = s),
                (l.renderOrder = n.renderOrder),
                (l.z = a),
                (l.group = o)),
            t++,
            l
          );
        }
        return {
          opaque: n,
          transmissive: i,
          transparent: r,
          init: function () {
            (t = 0), (n.length = 0), (i.length = 0), (r.length = 0);
          },
          push: function (e, t, a, o, l, c) {
            const u = s(e, t, a, o, l, c);
            a.transmission > 0
              ? i.push(u)
              : !0 === a.transparent
              ? r.push(u)
              : n.push(u);
          },
          unshift: function (e, t, a, o, l, c) {
            const u = s(e, t, a, o, l, c);
            a.transmission > 0
              ? i.unshift(u)
              : !0 === a.transparent
              ? r.unshift(u)
              : n.unshift(u);
          },
          finish: function () {
            for (let n = t, i = e.length; n < i; n++) {
              const t = e[n];
              if (null === t.id) break;
              (t.id = null),
                (t.object = null),
                (t.geometry = null),
                (t.material = null),
                (t.group = null);
            }
          },
          sort: function (e, t) {
            n.length > 1 && n.sort(e || Za),
              i.length > 1 && i.sort(t || $a),
              r.length > 1 && r.sort(t || $a);
          },
        };
      }
      function to() {
        let e = new WeakMap();
        return {
          get: function (t, n) {
            const i = e.get(t);
            let r;
            return (
              void 0 === i
                ? ((r = new eo()), e.set(t, [r]))
                : n >= i.length
                ? ((r = new eo()), i.push(r))
                : (r = i[n]),
              r
            );
          },
          dispose: function () {
            e = new WeakMap();
          },
        };
      }
      function no() {
        const e = {};
        return {
          get: function (t) {
            if (void 0 !== e[t.id]) return e[t.id];
            let n;
            switch (t.type) {
              case "DirectionalLight":
                n = { direction: new on(), color: new Ti() };
                break;
              case "SpotLight":
                n = {
                  position: new on(),
                  direction: new on(),
                  color: new Ti(),
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0,
                };
                break;
              case "PointLight":
                n = {
                  position: new on(),
                  color: new Ti(),
                  distance: 0,
                  decay: 0,
                };
                break;
              case "HemisphereLight":
                n = {
                  direction: new on(),
                  skyColor: new Ti(),
                  groundColor: new Ti(),
                };
                break;
              case "RectAreaLight":
                n = {
                  color: new Ti(),
                  position: new on(),
                  halfWidth: new on(),
                  halfHeight: new on(),
                };
            }
            return (e[t.id] = n), n;
          },
        };
      }
      let io = 0;
      function ro(e, t) {
        return (
          (t.castShadow ? 2 : 0) -
          (e.castShadow ? 2 : 0) +
          (t.map ? 1 : 0) -
          (e.map ? 1 : 0)
        );
      }
      function so(e) {
        const t = new no(),
          n = (function () {
            const e = {};
            return {
              get: function (t) {
                if (void 0 !== e[t.id]) return e[t.id];
                let n;
                switch (t.type) {
                  case "DirectionalLight":
                  case "SpotLight":
                    n = {
                      shadowIntensity: 1,
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Rt(),
                    };
                    break;
                  case "PointLight":
                    n = {
                      shadowIntensity: 1,
                      shadowBias: 0,
                      shadowNormalBias: 0,
                      shadowRadius: 1,
                      shadowMapSize: new Rt(),
                      shadowCameraNear: 1,
                      shadowCameraFar: 1e3,
                    };
                }
                return (e[t.id] = n), n;
              },
            };
          })(),
          i = {
            version: 0,
            hash: {
              directionalLength: -1,
              pointLength: -1,
              spotLength: -1,
              rectAreaLength: -1,
              hemiLength: -1,
              numDirectionalShadows: -1,
              numPointShadows: -1,
              numSpotShadows: -1,
              numSpotMaps: -1,
              numLightProbes: -1,
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0,
          };
        for (let e = 0; e < 9; e++) i.probe.push(new on());
        const r = new on(),
          s = new Nn(),
          a = new Nn();
        return {
          setup: function (r) {
            let s = 0,
              a = 0,
              o = 0;
            for (let e = 0; e < 9; e++) i.probe[e].set(0, 0, 0);
            let l = 0,
              c = 0,
              u = 0,
              h = 0,
              d = 0,
              p = 0,
              f = 0,
              A = 0,
              g = 0,
              m = 0,
              v = 0;
            r.sort(ro);
            for (let e = 0, y = r.length; e < y; e++) {
              const y = r[e],
                x = y.color,
                _ = y.intensity,
                b = y.distance,
                E = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
              if (y.isAmbientLight)
                (s += x.r * _), (a += x.g * _), (o += x.b * _);
              else if (y.isLightProbe) {
                for (let e = 0; e < 9; e++)
                  i.probe[e].addScaledVector(y.sh.coefficients[e], _);
                v++;
              } else if (y.isDirectionalLight) {
                const e = t.get(y);
                if (
                  (e.color.copy(y.color).multiplyScalar(y.intensity),
                  y.castShadow)
                ) {
                  const e = y.shadow,
                    t = n.get(y);
                  (t.shadowIntensity = e.intensity),
                    (t.shadowBias = e.bias),
                    (t.shadowNormalBias = e.normalBias),
                    (t.shadowRadius = e.radius),
                    (t.shadowMapSize = e.mapSize),
                    (i.directionalShadow[l] = t),
                    (i.directionalShadowMap[l] = E),
                    (i.directionalShadowMatrix[l] = y.shadow.matrix),
                    p++;
                }
                (i.directional[l] = e), l++;
              } else if (y.isSpotLight) {
                const e = t.get(y);
                e.position.setFromMatrixPosition(y.matrixWorld),
                  e.color.copy(x).multiplyScalar(_),
                  (e.distance = b),
                  (e.coneCos = Math.cos(y.angle)),
                  (e.penumbraCos = Math.cos(y.angle * (1 - y.penumbra))),
                  (e.decay = y.decay),
                  (i.spot[u] = e);
                const r = y.shadow;
                if (
                  (y.map &&
                    ((i.spotLightMap[g] = y.map),
                    g++,
                    r.updateMatrices(y),
                    y.castShadow && m++),
                  (i.spotLightMatrix[u] = r.matrix),
                  y.castShadow)
                ) {
                  const e = n.get(y);
                  (e.shadowIntensity = r.intensity),
                    (e.shadowBias = r.bias),
                    (e.shadowNormalBias = r.normalBias),
                    (e.shadowRadius = r.radius),
                    (e.shadowMapSize = r.mapSize),
                    (i.spotShadow[u] = e),
                    (i.spotShadowMap[u] = E),
                    A++;
                }
                u++;
              } else if (y.isRectAreaLight) {
                const e = t.get(y);
                e.color.copy(x).multiplyScalar(_),
                  e.halfWidth.set(0.5 * y.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * y.height, 0),
                  (i.rectArea[h] = e),
                  h++;
              } else if (y.isPointLight) {
                const e = t.get(y);
                if (
                  (e.color.copy(y.color).multiplyScalar(y.intensity),
                  (e.distance = y.distance),
                  (e.decay = y.decay),
                  y.castShadow)
                ) {
                  const e = y.shadow,
                    t = n.get(y);
                  (t.shadowIntensity = e.intensity),
                    (t.shadowBias = e.bias),
                    (t.shadowNormalBias = e.normalBias),
                    (t.shadowRadius = e.radius),
                    (t.shadowMapSize = e.mapSize),
                    (t.shadowCameraNear = e.camera.near),
                    (t.shadowCameraFar = e.camera.far),
                    (i.pointShadow[c] = t),
                    (i.pointShadowMap[c] = E),
                    (i.pointShadowMatrix[c] = y.shadow.matrix),
                    f++;
                }
                (i.point[c] = e), c++;
              } else if (y.isHemisphereLight) {
                const e = t.get(y);
                e.skyColor.copy(y.color).multiplyScalar(_),
                  e.groundColor.copy(y.groundColor).multiplyScalar(_),
                  (i.hemi[d] = e),
                  d++;
              }
            }
            h > 0 &&
              (!0 === e.has("OES_texture_float_linear")
                ? ((i.rectAreaLTC1 = Or.LTC_FLOAT_1),
                  (i.rectAreaLTC2 = Or.LTC_FLOAT_2))
                : ((i.rectAreaLTC1 = Or.LTC_HALF_1),
                  (i.rectAreaLTC2 = Or.LTC_HALF_2))),
              (i.ambient[0] = s),
              (i.ambient[1] = a),
              (i.ambient[2] = o);
            const y = i.hash;
            (y.directionalLength === l &&
              y.pointLength === c &&
              y.spotLength === u &&
              y.rectAreaLength === h &&
              y.hemiLength === d &&
              y.numDirectionalShadows === p &&
              y.numPointShadows === f &&
              y.numSpotShadows === A &&
              y.numSpotMaps === g &&
              y.numLightProbes === v) ||
              ((i.directional.length = l),
              (i.spot.length = u),
              (i.rectArea.length = h),
              (i.point.length = c),
              (i.hemi.length = d),
              (i.directionalShadow.length = p),
              (i.directionalShadowMap.length = p),
              (i.pointShadow.length = f),
              (i.pointShadowMap.length = f),
              (i.spotShadow.length = A),
              (i.spotShadowMap.length = A),
              (i.directionalShadowMatrix.length = p),
              (i.pointShadowMatrix.length = f),
              (i.spotLightMatrix.length = A + g - m),
              (i.spotLightMap.length = g),
              (i.numSpotLightShadowsWithMaps = m),
              (i.numLightProbes = v),
              (y.directionalLength = l),
              (y.pointLength = c),
              (y.spotLength = u),
              (y.rectAreaLength = h),
              (y.hemiLength = d),
              (y.numDirectionalShadows = p),
              (y.numPointShadows = f),
              (y.numSpotShadows = A),
              (y.numSpotMaps = g),
              (y.numLightProbes = v),
              (i.version = io++));
          },
          setupView: function (e, t) {
            let n = 0,
              o = 0,
              l = 0,
              c = 0,
              u = 0;
            const h = t.matrixWorldInverse;
            for (let t = 0, d = e.length; t < d; t++) {
              const d = e[t];
              if (d.isDirectionalLight) {
                const e = i.directional[n];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  r.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(r),
                  e.direction.transformDirection(h),
                  n++;
              } else if (d.isSpotLight) {
                const e = i.spot[l];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  e.direction.setFromMatrixPosition(d.matrixWorld),
                  r.setFromMatrixPosition(d.target.matrixWorld),
                  e.direction.sub(r),
                  e.direction.transformDirection(h),
                  l++;
              } else if (d.isRectAreaLight) {
                const e = i.rectArea[c];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  a.identity(),
                  s.copy(d.matrixWorld),
                  s.premultiply(h),
                  a.extractRotation(s),
                  e.halfWidth.set(0.5 * d.width, 0, 0),
                  e.halfHeight.set(0, 0.5 * d.height, 0),
                  e.halfWidth.applyMatrix4(a),
                  e.halfHeight.applyMatrix4(a),
                  c++;
              } else if (d.isPointLight) {
                const e = i.point[o];
                e.position.setFromMatrixPosition(d.matrixWorld),
                  e.position.applyMatrix4(h),
                  o++;
              } else if (d.isHemisphereLight) {
                const e = i.hemi[u];
                e.direction.setFromMatrixPosition(d.matrixWorld),
                  e.direction.transformDirection(h),
                  u++;
              }
            }
          },
          state: i,
        };
      }
      function ao(e) {
        const t = new so(e),
          n = [],
          i = [];
        const r = {
          lightsArray: n,
          shadowsArray: i,
          camera: null,
          lights: t,
          transmissionRenderTarget: {},
        };
        return {
          init: function (e) {
            (r.camera = e), (n.length = 0), (i.length = 0);
          },
          state: r,
          setupLights: function () {
            t.setup(n);
          },
          setupLightsView: function (e) {
            t.setupView(n, e);
          },
          pushLight: function (e) {
            n.push(e);
          },
          pushShadow: function (e) {
            i.push(e);
          },
        };
      }
      function oo(e) {
        let t = new WeakMap();
        return {
          get: function (n, i = 0) {
            const r = t.get(n);
            let s;
            return (
              void 0 === r
                ? ((s = new ao(e)), t.set(n, [s]))
                : i >= r.length
                ? ((s = new ao(e)), r.push(s))
                : (s = r[i]),
              s
            );
          },
          dispose: function () {
            t = new WeakMap();
          },
        };
      }
      class lo extends Di {
        static get type() {
          return "MeshDepthMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshDepthMaterial = !0),
            (this.depthPacking = at),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.depthPacking = e.depthPacking),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            this
          );
        }
      }
      class co extends Di {
        static get type() {
          return "MeshDistanceMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshDistanceMaterial = !0),
            (this.map = null),
            (this.alphaMap = null),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            this
          );
        }
      }
      function uo(e, t, n) {
        let i = new Pr();
        const s = new Rt(),
          h = new Rt(),
          d = new en(),
          p = new lo({ depthPacking: ot }),
          f = new co(),
          A = {},
          g = n.maxTextureSize,
          m = { [o]: l, [l]: o, [c]: c },
          v = new mr({
            defines: { VSM_SAMPLES: 8 },
            uniforms: {
              shadow_pass: { value: null },
              resolution: { value: new Rt() },
              radius: { value: 4 },
            },
            vertexShader:
              "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
            fragmentShader:
              "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
          }),
          y = v.clone();
        y.defines.HORIZONTAL_PASS = 1;
        const x = new Zi();
        x.setAttribute(
          "position",
          new Gi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
        );
        const _ = new ur(x, v),
          b = this;
        (this.enabled = !1),
          (this.autoUpdate = !0),
          (this.needsUpdate = !1),
          (this.type = r);
        let E = this.type;
        function w(n, i) {
          const r = t.update(_);
          v.defines.VSM_SAMPLES !== n.blurSamples &&
            ((v.defines.VSM_SAMPLES = n.blurSamples),
            (y.defines.VSM_SAMPLES = n.blurSamples),
            (v.needsUpdate = !0),
            (y.needsUpdate = !0)),
            null === n.mapPass && (n.mapPass = new nn(s.x, s.y)),
            (v.uniforms.shadow_pass.value = n.map.texture),
            (v.uniforms.resolution.value = n.mapSize),
            (v.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.mapPass),
            e.clear(),
            e.renderBufferDirect(i, null, r, v, _, null),
            (y.uniforms.shadow_pass.value = n.mapPass.texture),
            (y.uniforms.resolution.value = n.mapSize),
            (y.uniforms.radius.value = n.radius),
            e.setRenderTarget(n.map),
            e.clear(),
            e.renderBufferDirect(i, null, r, y, _, null);
        }
        function C(t, n, i, r) {
          let s = null;
          const o =
            !0 === i.isPointLight
              ? t.customDistanceMaterial
              : t.customDepthMaterial;
          if (void 0 !== o) s = o;
          else if (
            ((s = !0 === i.isPointLight ? f : p),
            (e.localClippingEnabled &&
              !0 === n.clipShadows &&
              Array.isArray(n.clippingPlanes) &&
              0 !== n.clippingPlanes.length) ||
              (n.displacementMap && 0 !== n.displacementScale) ||
              (n.alphaMap && n.alphaTest > 0) ||
              (n.map && n.alphaTest > 0))
          ) {
            const e = s.uuid,
              t = n.uuid;
            let i = A[e];
            void 0 === i && ((i = {}), (A[e] = i));
            let r = i[t];
            void 0 === r &&
              ((r = s.clone()), (i[t] = r), n.addEventListener("dispose", S)),
              (s = r);
          }
          if (
            ((s.visible = n.visible),
            (s.wireframe = n.wireframe),
            (s.side =
              r === a
                ? null !== n.shadowSide
                  ? n.shadowSide
                  : n.side
                : null !== n.shadowSide
                ? n.shadowSide
                : m[n.side]),
            (s.alphaMap = n.alphaMap),
            (s.alphaTest = n.alphaTest),
            (s.map = n.map),
            (s.clipShadows = n.clipShadows),
            (s.clippingPlanes = n.clippingPlanes),
            (s.clipIntersection = n.clipIntersection),
            (s.displacementMap = n.displacementMap),
            (s.displacementScale = n.displacementScale),
            (s.displacementBias = n.displacementBias),
            (s.wireframeLinewidth = n.wireframeLinewidth),
            (s.linewidth = n.linewidth),
            !0 === i.isPointLight && !0 === s.isMeshDistanceMaterial)
          ) {
            e.properties.get(s).light = i;
          }
          return s;
        }
        function I(n, r, s, o, l) {
          if (!1 === n.visible) return;
          if (
            n.layers.test(r.layers) &&
            (n.isMesh || n.isLine || n.isPoints) &&
            (n.castShadow || (n.receiveShadow && l === a)) &&
            (!n.frustumCulled || i.intersectsObject(n))
          ) {
            n.modelViewMatrix.multiplyMatrices(
              s.matrixWorldInverse,
              n.matrixWorld
            );
            const i = t.update(n),
              a = n.material;
            if (Array.isArray(a)) {
              const t = i.groups;
              for (let c = 0, u = t.length; c < u; c++) {
                const u = t[c],
                  h = a[u.materialIndex];
                if (h && h.visible) {
                  const t = C(n, h, o, l);
                  n.onBeforeShadow(e, n, r, s, i, t, u),
                    e.renderBufferDirect(s, null, i, t, n, u),
                    n.onAfterShadow(e, n, r, s, i, t, u);
                }
              }
            } else if (a.visible) {
              const t = C(n, a, o, l);
              n.onBeforeShadow(e, n, r, s, i, t, null),
                e.renderBufferDirect(s, null, i, t, n, null),
                n.onAfterShadow(e, n, r, s, i, t, null);
            }
          }
          const c = n.children;
          for (let e = 0, t = c.length; e < t; e++) I(c[e], r, s, o, l);
        }
        function S(e) {
          e.target.removeEventListener("dispose", S);
          for (const t in A) {
            const n = A[t],
              i = e.target.uuid;
            if (i in n) {
              n[i].dispose(), delete n[i];
            }
          }
        }
        this.render = function (t, n, r) {
          if (!1 === b.enabled) return;
          if (!1 === b.autoUpdate && !1 === b.needsUpdate) return;
          if (0 === t.length) return;
          const o = e.getRenderTarget(),
            l = e.getActiveCubeFace(),
            c = e.getActiveMipmapLevel(),
            p = e.state;
          p.setBlending(u),
            p.buffers.color.setClear(1, 1, 1, 1),
            p.buffers.depth.setTest(!0),
            p.setScissorTest(!1);
          const f = E !== a && this.type === a,
            A = E === a && this.type !== a;
          for (let o = 0, l = t.length; o < l; o++) {
            const l = t[o],
              c = l.shadow;
            if (void 0 === c) {
              console.warn("THREE.WebGLShadowMap:", l, "has no shadow.");
              continue;
            }
            if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
            s.copy(c.mapSize);
            const u = c.getFrameExtents();
            if (
              (s.multiply(u),
              h.copy(c.mapSize),
              (s.x > g || s.y > g) &&
                (s.x > g &&
                  ((h.x = Math.floor(g / u.x)),
                  (s.x = h.x * u.x),
                  (c.mapSize.x = h.x)),
                s.y > g &&
                  ((h.y = Math.floor(g / u.y)),
                  (s.y = h.y * u.y),
                  (c.mapSize.y = h.y))),
              null === c.map || !0 === f || !0 === A)
            ) {
              const e = this.type !== a ? { minFilter: k, magFilter: k } : {};
              null !== c.map && c.map.dispose(),
                (c.map = new nn(s.x, s.y, e)),
                (c.map.texture.name = l.name + ".shadowMap"),
                c.camera.updateProjectionMatrix();
            }
            e.setRenderTarget(c.map), e.clear();
            const m = c.getViewportCount();
            for (let e = 0; e < m; e++) {
              const t = c.getViewport(e);
              d.set(h.x * t.x, h.y * t.y, h.x * t.z, h.y * t.w),
                p.viewport(d),
                c.updateMatrices(l, e),
                (i = c.getFrustum()),
                I(n, r, c.camera, l, this.type);
            }
            !0 !== c.isPointLightShadow && this.type === a && w(c, r),
              (c.needsUpdate = !1);
          }
          (E = this.type), (b.needsUpdate = !1), e.setRenderTarget(o, l, c);
        };
      }
      const ho = {
        [d]: p,
        [f]: v,
        [g]: y,
        [A]: m,
        [p]: d,
        [v]: f,
        [y]: g,
        [m]: A,
      };
      function po(e, t) {
        const n = new (function () {
            let t = !1;
            const n = new en();
            let i = null;
            const r = new en(0, 0, 0, 0);
            return {
              setMask: function (n) {
                i === n || t || (e.colorMask(n, n, n, n), (i = n));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t, i, s, a, o) {
                !0 === o && ((t *= a), (i *= a), (s *= a)),
                  n.set(t, i, s, a),
                  !1 === r.equals(n) && (e.clearColor(t, i, s, a), r.copy(n));
              },
              reset: function () {
                (t = !1), (i = null), r.set(-1, 0, 0, 0);
              },
            };
          })(),
          i = new (function () {
            let n = !1,
              i = !1,
              r = null,
              s = null,
              a = null;
            return {
              setReversed: function (e) {
                if (i !== e) {
                  const e = t.get("EXT_clip_control");
                  i
                    ? e.clipControlEXT(e.LOWER_LEFT_EXT, e.ZERO_TO_ONE_EXT)
                    : e.clipControlEXT(
                        e.LOWER_LEFT_EXT,
                        e.NEGATIVE_ONE_TO_ONE_EXT
                      );
                  const n = a;
                  (a = null), this.setClear(n);
                }
                i = e;
              },
              getReversed: function () {
                return i;
              },
              setTest: function (t) {
                t ? Z(e.DEPTH_TEST) : $(e.DEPTH_TEST);
              },
              setMask: function (t) {
                r === t || n || (e.depthMask(t), (r = t));
              },
              setFunc: function (t) {
                if ((i && (t = ho[t]), s !== t)) {
                  switch (t) {
                    case d:
                      e.depthFunc(e.NEVER);
                      break;
                    case p:
                      e.depthFunc(e.ALWAYS);
                      break;
                    case f:
                      e.depthFunc(e.LESS);
                      break;
                    case A:
                      e.depthFunc(e.LEQUAL);
                      break;
                    case g:
                      e.depthFunc(e.EQUAL);
                      break;
                    case m:
                      e.depthFunc(e.GEQUAL);
                      break;
                    case v:
                      e.depthFunc(e.GREATER);
                      break;
                    case y:
                      e.depthFunc(e.NOTEQUAL);
                      break;
                    default:
                      e.depthFunc(e.LEQUAL);
                  }
                  s = t;
                }
              },
              setLocked: function (e) {
                n = e;
              },
              setClear: function (t) {
                a !== t && (i && (t = 1 - t), e.clearDepth(t), (a = t));
              },
              reset: function () {
                (n = !1), (r = null), (s = null), (a = null), (i = !1);
              },
            };
          })(),
          r = new (function () {
            let t = !1,
              n = null,
              i = null,
              r = null,
              s = null,
              a = null,
              o = null,
              l = null,
              c = null;
            return {
              setTest: function (n) {
                t || (n ? Z(e.STENCIL_TEST) : $(e.STENCIL_TEST));
              },
              setMask: function (i) {
                n === i || t || (e.stencilMask(i), (n = i));
              },
              setFunc: function (t, n, a) {
                (i === t && r === n && s === a) ||
                  (e.stencilFunc(t, n, a), (i = t), (r = n), (s = a));
              },
              setOp: function (t, n, i) {
                (a === t && o === n && l === i) ||
                  (e.stencilOp(t, n, i), (a = t), (o = n), (l = i));
              },
              setLocked: function (e) {
                t = e;
              },
              setClear: function (t) {
                c !== t && (e.clearStencil(t), (c = t));
              },
              reset: function () {
                (t = !1),
                  (n = null),
                  (i = null),
                  (r = null),
                  (s = null),
                  (a = null),
                  (o = null),
                  (l = null),
                  (c = null);
              },
            };
          })(),
          s = new WeakMap(),
          a = new WeakMap();
        let o = {},
          x = {},
          _ = new WeakMap(),
          b = [],
          E = null,
          w = !1,
          C = null,
          I = null,
          S = null,
          M = null,
          T = null,
          B = null,
          R = null,
          D = new Ti(0, 0, 0),
          P = 0,
          L = !1,
          U = null,
          F = null,
          N = null,
          O = null,
          Q = null;
        const k = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
        let G = !1,
          H = 0;
        const z = e.getParameter(e.VERSION);
        -1 !== z.indexOf("WebGL")
          ? ((H = parseFloat(/^WebGL (\d)/.exec(z)[1])), (G = H >= 1))
          : -1 !== z.indexOf("OpenGL ES") &&
            ((H = parseFloat(/^OpenGL ES (\d)/.exec(z)[1])), (G = H >= 2));
        let V = null,
          W = {};
        const j = e.getParameter(e.SCISSOR_BOX),
          q = e.getParameter(e.VIEWPORT),
          Y = new en().fromArray(j),
          X = new en().fromArray(q);
        function K(t, n, i, r) {
          const s = new Uint8Array(4),
            a = e.createTexture();
          e.bindTexture(t, a),
            e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
            e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
          for (let a = 0; a < i; a++)
            t === e.TEXTURE_3D || t === e.TEXTURE_2D_ARRAY
              ? e.texImage3D(
                  n,
                  0,
                  e.RGBA,
                  1,
                  1,
                  r,
                  0,
                  e.RGBA,
                  e.UNSIGNED_BYTE,
                  s
                )
              : e.texImage2D(
                  n + a,
                  0,
                  e.RGBA,
                  1,
                  1,
                  0,
                  e.RGBA,
                  e.UNSIGNED_BYTE,
                  s
                );
          return a;
        }
        const J = {};
        function Z(t) {
          !0 !== o[t] && (e.enable(t), (o[t] = !0));
        }
        function $(t) {
          !1 !== o[t] && (e.disable(t), (o[t] = !1));
        }
        (J[e.TEXTURE_2D] = K(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
          (J[e.TEXTURE_CUBE_MAP] = K(
            e.TEXTURE_CUBE_MAP,
            e.TEXTURE_CUBE_MAP_POSITIVE_X,
            6
          )),
          (J[e.TEXTURE_2D_ARRAY] = K(
            e.TEXTURE_2D_ARRAY,
            e.TEXTURE_2D_ARRAY,
            1,
            1
          )),
          (J[e.TEXTURE_3D] = K(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1)),
          n.setClear(0, 0, 0, 1),
          i.setClear(1),
          r.setClear(0),
          Z(e.DEPTH_TEST),
          i.setFunc(A),
          ie(!1),
          re(1),
          Z(e.CULL_FACE),
          ne(u);
        const ee = {
          [h]: e.FUNC_ADD,
          101: e.FUNC_SUBTRACT,
          102: e.FUNC_REVERSE_SUBTRACT,
        };
        (ee[103] = e.MIN), (ee[104] = e.MAX);
        const te = {
          200: e.ZERO,
          201: e.ONE,
          202: e.SRC_COLOR,
          204: e.SRC_ALPHA,
          210: e.SRC_ALPHA_SATURATE,
          208: e.DST_COLOR,
          206: e.DST_ALPHA,
          203: e.ONE_MINUS_SRC_COLOR,
          205: e.ONE_MINUS_SRC_ALPHA,
          209: e.ONE_MINUS_DST_COLOR,
          207: e.ONE_MINUS_DST_ALPHA,
          211: e.CONSTANT_COLOR,
          212: e.ONE_MINUS_CONSTANT_COLOR,
          213: e.CONSTANT_ALPHA,
          214: e.ONE_MINUS_CONSTANT_ALPHA,
        };
        function ne(t, n, i, r, s, a, o, l, c, d) {
          if (t !== u) {
            if ((!1 === w && (Z(e.BLEND), (w = !0)), 5 === t))
              (s = s || n),
                (a = a || i),
                (o = o || r),
                (n === I && s === T) ||
                  (e.blendEquationSeparate(ee[n], ee[s]), (I = n), (T = s)),
                (i === S && r === M && a === B && o === R) ||
                  (e.blendFuncSeparate(te[i], te[r], te[a], te[o]),
                  (S = i),
                  (M = r),
                  (B = a),
                  (R = o)),
                (!1 !== l.equals(D) && c === P) ||
                  (e.blendColor(l.r, l.g, l.b, c), D.copy(l), (P = c)),
                (C = t),
                (L = !1);
            else if (t !== C || d !== L) {
              if (
                ((I === h && T === h) ||
                  (e.blendEquation(e.FUNC_ADD), (I = h), (T = h)),
                d)
              )
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA,
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    e.blendFunc(e.ONE, e.ONE);
                    break;
                  case 3:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.ONE_MINUS_SRC_COLOR,
                      e.ZERO,
                      e.ONE
                    );
                    break;
                  case 4:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.SRC_COLOR,
                      e.ZERO,
                      e.SRC_ALPHA
                    );
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              else
                switch (t) {
                  case 1:
                    e.blendFuncSeparate(
                      e.SRC_ALPHA,
                      e.ONE_MINUS_SRC_ALPHA,
                      e.ONE,
                      e.ONE_MINUS_SRC_ALPHA
                    );
                    break;
                  case 2:
                    e.blendFunc(e.SRC_ALPHA, e.ONE);
                    break;
                  case 3:
                    e.blendFuncSeparate(
                      e.ZERO,
                      e.ONE_MINUS_SRC_COLOR,
                      e.ZERO,
                      e.ONE
                    );
                    break;
                  case 4:
                    e.blendFunc(e.ZERO, e.SRC_COLOR);
                    break;
                  default:
                    console.error("THREE.WebGLState: Invalid blending: ", t);
                }
              (S = null),
                (M = null),
                (B = null),
                (R = null),
                D.set(0, 0, 0),
                (P = 0),
                (C = t),
                (L = d);
            }
          } else !0 === w && ($(e.BLEND), (w = !1));
        }
        function ie(t) {
          U !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), (U = t));
        }
        function re(t) {
          0 !== t
            ? (Z(e.CULL_FACE),
              t !== F &&
                (1 === t
                  ? e.cullFace(e.BACK)
                  : 2 === t
                  ? e.cullFace(e.FRONT)
                  : e.cullFace(e.FRONT_AND_BACK)))
            : $(e.CULL_FACE),
            (F = t);
        }
        function se(t, n, i) {
          t
            ? (Z(e.POLYGON_OFFSET_FILL),
              (O === n && Q === i) || (e.polygonOffset(n, i), (O = n), (Q = i)))
            : $(e.POLYGON_OFFSET_FILL);
        }
        return {
          buffers: { color: n, depth: i, stencil: r },
          enable: Z,
          disable: $,
          bindFramebuffer: function (t, n) {
            return (
              x[t] !== n &&
              (e.bindFramebuffer(t, n),
              (x[t] = n),
              t === e.DRAW_FRAMEBUFFER && (x[e.FRAMEBUFFER] = n),
              t === e.FRAMEBUFFER && (x[e.DRAW_FRAMEBUFFER] = n),
              !0)
            );
          },
          drawBuffers: function (t, n) {
            let i = b,
              r = !1;
            if (t) {
              (i = _.get(n)), void 0 === i && ((i = []), _.set(n, i));
              const s = t.textures;
              if (i.length !== s.length || i[0] !== e.COLOR_ATTACHMENT0) {
                for (let t = 0, n = s.length; t < n; t++)
                  i[t] = e.COLOR_ATTACHMENT0 + t;
                (i.length = s.length), (r = !0);
              }
            } else i[0] !== e.BACK && ((i[0] = e.BACK), (r = !0));
            r && e.drawBuffers(i);
          },
          useProgram: function (t) {
            return E !== t && (e.useProgram(t), (E = t), !0);
          },
          setBlending: ne,
          setMaterial: function (t, s) {
            t.side === c ? $(e.CULL_FACE) : Z(e.CULL_FACE);
            let a = t.side === l;
            s && (a = !a),
              ie(a),
              1 === t.blending && !1 === t.transparent
                ? ne(u)
                : ne(
                    t.blending,
                    t.blendEquation,
                    t.blendSrc,
                    t.blendDst,
                    t.blendEquationAlpha,
                    t.blendSrcAlpha,
                    t.blendDstAlpha,
                    t.blendColor,
                    t.blendAlpha,
                    t.premultipliedAlpha
                  ),
              i.setFunc(t.depthFunc),
              i.setTest(t.depthTest),
              i.setMask(t.depthWrite),
              n.setMask(t.colorWrite);
            const o = t.stencilWrite;
            r.setTest(o),
              o &&
                (r.setMask(t.stencilWriteMask),
                r.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
                r.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
              se(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
              !0 === t.alphaToCoverage
                ? Z(e.SAMPLE_ALPHA_TO_COVERAGE)
                : $(e.SAMPLE_ALPHA_TO_COVERAGE);
          },
          setFlipSided: ie,
          setCullFace: re,
          setLineWidth: function (t) {
            t !== N && (G && e.lineWidth(t), (N = t));
          },
          setPolygonOffset: se,
          setScissorTest: function (t) {
            t ? Z(e.SCISSOR_TEST) : $(e.SCISSOR_TEST);
          },
          activeTexture: function (t) {
            void 0 === t && (t = e.TEXTURE0 + k - 1),
              V !== t && (e.activeTexture(t), (V = t));
          },
          bindTexture: function (t, n, i) {
            void 0 === i && (i = null === V ? e.TEXTURE0 + k - 1 : V);
            let r = W[i];
            void 0 === r &&
              ((r = { type: void 0, texture: void 0 }), (W[i] = r)),
              (r.type === t && r.texture === n) ||
                (V !== i && (e.activeTexture(i), (V = i)),
                e.bindTexture(t, n || J[t]),
                (r.type = t),
                (r.texture = n));
          },
          unbindTexture: function () {
            const t = W[V];
            void 0 !== t &&
              void 0 !== t.type &&
              (e.bindTexture(t.type, null),
              (t.type = void 0),
              (t.texture = void 0));
          },
          compressedTexImage2D: function () {
            try {
              e.compressedTexImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexImage3D: function () {
            try {
              e.compressedTexImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage2D: function () {
            try {
              e.texImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texImage3D: function () {
            try {
              e.texImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          updateUBOMapping: function (t, n) {
            let i = a.get(n);
            void 0 === i && ((i = new WeakMap()), a.set(n, i));
            let r = i.get(t);
            void 0 === r &&
              ((r = e.getUniformBlockIndex(n, t.name)), i.set(t, r));
          },
          uniformBlockBinding: function (t, n) {
            const i = a.get(n).get(t);
            s.get(n) !== i &&
              (e.uniformBlockBinding(n, i, t.__bindingPointIndex), s.set(n, i));
          },
          texStorage2D: function () {
            try {
              e.texStorage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texStorage3D: function () {
            try {
              e.texStorage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage2D: function () {
            try {
              e.texSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          texSubImage3D: function () {
            try {
              e.texSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage2D: function () {
            try {
              e.compressedTexSubImage2D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          compressedTexSubImage3D: function () {
            try {
              e.compressedTexSubImage3D.apply(e, arguments);
            } catch (e) {
              console.error("THREE.WebGLState:", e);
            }
          },
          scissor: function (t) {
            !1 === Y.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), Y.copy(t));
          },
          viewport: function (t) {
            !1 === X.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), X.copy(t));
          },
          reset: function () {
            e.disable(e.BLEND),
              e.disable(e.CULL_FACE),
              e.disable(e.DEPTH_TEST),
              e.disable(e.POLYGON_OFFSET_FILL),
              e.disable(e.SCISSOR_TEST),
              e.disable(e.STENCIL_TEST),
              e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
              e.blendEquation(e.FUNC_ADD),
              e.blendFunc(e.ONE, e.ZERO),
              e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
              e.blendColor(0, 0, 0, 0),
              e.colorMask(!0, !0, !0, !0),
              e.clearColor(0, 0, 0, 0),
              e.depthMask(!0),
              e.depthFunc(e.LESS),
              i.setReversed(!1),
              e.clearDepth(1),
              e.stencilMask(4294967295),
              e.stencilFunc(e.ALWAYS, 0, 4294967295),
              e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
              e.clearStencil(0),
              e.cullFace(e.BACK),
              e.frontFace(e.CCW),
              e.polygonOffset(0, 0),
              e.activeTexture(e.TEXTURE0),
              e.bindFramebuffer(e.FRAMEBUFFER, null),
              e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
              e.bindFramebuffer(e.READ_FRAMEBUFFER, null),
              e.useProgram(null),
              e.lineWidth(1),
              e.scissor(0, 0, e.canvas.width, e.canvas.height),
              e.viewport(0, 0, e.canvas.width, e.canvas.height),
              (o = {}),
              (V = null),
              (W = {}),
              (x = {}),
              (_ = new WeakMap()),
              (b = []),
              (E = null),
              (w = !1),
              (C = null),
              (I = null),
              (S = null),
              (M = null),
              (T = null),
              (B = null),
              (R = null),
              (D = new Ti(0, 0, 0)),
              (P = 0),
              (L = !1),
              (U = null),
              (F = null),
              (N = null),
              (O = null),
              (Q = null),
              Y.set(0, 0, e.canvas.width, e.canvas.height),
              X.set(0, 0, e.canvas.width, e.canvas.height),
              n.reset(),
              i.reset(),
              r.reset();
          },
        };
      }
      function fo(e, t, n, i) {
        const r = (function (e) {
          switch (e) {
            case j:
            case q:
              return { byteLength: 1, components: 1 };
            case X:
            case Y:
            case $:
              return { byteLength: 2, components: 1 };
            case ee:
            case te:
              return { byteLength: 2, components: 4 };
            case J:
            case K:
            case Z:
              return { byteLength: 4, components: 1 };
            case ie:
              return { byteLength: 4, components: 3 };
          }
          throw new Error(`Unknown texture type ${e}.`);
        })(i);
        switch (n) {
          case re:
          case oe:
            return e * t;
          case le:
            return e * t * 2;
          case he:
          case de:
            return ((e * t) / r.components) * r.byteLength;
          case pe:
          case fe:
            return ((e * t * 2) / r.components) * r.byteLength;
          case se:
            return ((e * t * 3) / r.components) * r.byteLength;
          case ae:
          case Ae:
            return ((e * t * 4) / r.components) * r.byteLength;
          case ge:
          case me:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case ve:
          case ye:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case _e:
          case Ee:
            return (Math.max(e, 16) * Math.max(t, 8)) / 4;
          case xe:
          case be:
            return (Math.max(e, 8) * Math.max(t, 8)) / 2;
          case we:
          case Ce:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 8;
          case Ie:
          case Se:
            return Math.floor((e + 3) / 4) * Math.floor((t + 3) / 4) * 16;
          case Me:
            return Math.floor((e + 4) / 5) * Math.floor((t + 3) / 4) * 16;
          case Te:
            return Math.floor((e + 4) / 5) * Math.floor((t + 4) / 5) * 16;
          case Be:
            return Math.floor((e + 5) / 6) * Math.floor((t + 4) / 5) * 16;
          case Re:
            return Math.floor((e + 5) / 6) * Math.floor((t + 5) / 6) * 16;
          case De:
            return Math.floor((e + 7) / 8) * Math.floor((t + 4) / 5) * 16;
          case Pe:
            return Math.floor((e + 7) / 8) * Math.floor((t + 5) / 6) * 16;
          case Le:
            return Math.floor((e + 7) / 8) * Math.floor((t + 7) / 8) * 16;
          case Ue:
            return Math.floor((e + 9) / 10) * Math.floor((t + 4) / 5) * 16;
          case Fe:
            return Math.floor((e + 9) / 10) * Math.floor((t + 5) / 6) * 16;
          case Ne:
            return Math.floor((e + 9) / 10) * Math.floor((t + 7) / 8) * 16;
          case Oe:
            return Math.floor((e + 9) / 10) * Math.floor((t + 9) / 10) * 16;
          case Qe:
            return Math.floor((e + 11) / 12) * Math.floor((t + 9) / 10) * 16;
          case ke:
            return Math.floor((e + 11) / 12) * Math.floor((t + 11) / 12) * 16;
          case Ge:
          case He:
          case ze:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
          case Ve:
          case We:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 8;
          case je:
          case qe:
            return Math.ceil(e / 4) * Math.ceil(t / 4) * 16;
        }
        throw new Error(
          `Unable to determine texture byte length for ${n} format.`
        );
      }
      function Ao(e, t, n, i, r, s, a) {
        const o = t.has("WEBGL_multisampled_render_to_texture")
            ? t.get("WEBGL_multisampled_render_to_texture")
            : null,
          l =
            "undefined" != typeof navigator &&
            /OculusBrowser/g.test(navigator.userAgent),
          c = new Rt(),
          u = new WeakMap();
        let h;
        const d = new WeakMap();
        let p = !1;
        try {
          p =
            "undefined" != typeof OffscreenCanvas &&
            null !== new OffscreenCanvas(1, 1).getContext("2d");
        } catch (e) {}
        function f(e, t) {
          return p ? new OffscreenCanvas(e, t) : Ut("canvas");
        }
        function A(e, t, n) {
          let i = 1;
          const r = ee(e);
          if (
            ((r.width > n || r.height > n) &&
              (i = n / Math.max(r.width, r.height)),
            i < 1)
          ) {
            if (
              ("undefined" != typeof HTMLImageElement &&
                e instanceof HTMLImageElement) ||
              ("undefined" != typeof HTMLCanvasElement &&
                e instanceof HTMLCanvasElement) ||
              ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap) ||
              ("undefined" != typeof VideoFrame && e instanceof VideoFrame)
            ) {
              const n = Math.floor(i * r.width),
                s = Math.floor(i * r.height);
              void 0 === h && (h = f(n, s));
              const a = t ? f(n, s) : h;
              (a.width = n), (a.height = s);
              return (
                a.getContext("2d").drawImage(e, 0, 0, n, s),
                console.warn(
                  "THREE.WebGLRenderer: Texture has been resized from (" +
                    r.width +
                    "x" +
                    r.height +
                    ") to (" +
                    n +
                    "x" +
                    s +
                    ")."
                ),
                a
              );
            }
            return (
              "data" in e &&
                console.warn(
                  "THREE.WebGLRenderer: Image in DataTexture is too big (" +
                    r.width +
                    "x" +
                    r.height +
                    ")."
                ),
              e
            );
          }
          return e;
        }
        function g(e) {
          return e.generateMipmaps;
        }
        function m(t) {
          e.generateMipmap(t);
        }
        function v(t) {
          return t.isWebGLCubeRenderTarget
            ? e.TEXTURE_CUBE_MAP
            : t.isWebGL3DRenderTarget
            ? e.TEXTURE_3D
            : t.isWebGLArrayRenderTarget || t.isCompressedArrayTexture
            ? e.TEXTURE_2D_ARRAY
            : e.TEXTURE_2D;
        }
        function y(n, i, r, s, a = !1) {
          if (null !== n) {
            if (void 0 !== e[n]) return e[n];
            console.warn(
              "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
                n +
                "'"
            );
          }
          let o = i;
          if (
            (i === e.RED &&
              (r === e.FLOAT && (o = e.R32F),
              r === e.HALF_FLOAT && (o = e.R16F),
              r === e.UNSIGNED_BYTE && (o = e.R8)),
            i === e.RED_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.R8UI),
              r === e.UNSIGNED_SHORT && (o = e.R16UI),
              r === e.UNSIGNED_INT && (o = e.R32UI),
              r === e.BYTE && (o = e.R8I),
              r === e.SHORT && (o = e.R16I),
              r === e.INT && (o = e.R32I)),
            i === e.RG &&
              (r === e.FLOAT && (o = e.RG32F),
              r === e.HALF_FLOAT && (o = e.RG16F),
              r === e.UNSIGNED_BYTE && (o = e.RG8)),
            i === e.RG_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RG8UI),
              r === e.UNSIGNED_SHORT && (o = e.RG16UI),
              r === e.UNSIGNED_INT && (o = e.RG32UI),
              r === e.BYTE && (o = e.RG8I),
              r === e.SHORT && (o = e.RG16I),
              r === e.INT && (o = e.RG32I)),
            i === e.RGB_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RGB8UI),
              r === e.UNSIGNED_SHORT && (o = e.RGB16UI),
              r === e.UNSIGNED_INT && (o = e.RGB32UI),
              r === e.BYTE && (o = e.RGB8I),
              r === e.SHORT && (o = e.RGB16I),
              r === e.INT && (o = e.RGB32I)),
            i === e.RGBA_INTEGER &&
              (r === e.UNSIGNED_BYTE && (o = e.RGBA8UI),
              r === e.UNSIGNED_SHORT && (o = e.RGBA16UI),
              r === e.UNSIGNED_INT && (o = e.RGBA32UI),
              r === e.BYTE && (o = e.RGBA8I),
              r === e.SHORT && (o = e.RGBA16I),
              r === e.INT && (o = e.RGBA32I)),
            i === e.RGB && r === e.UNSIGNED_INT_5_9_9_9_REV && (o = e.RGB9_E5),
            i === e.RGBA)
          ) {
            const t = a ? ht : Qt.getTransfer(s);
            r === e.FLOAT && (o = e.RGBA32F),
              r === e.HALF_FLOAT && (o = e.RGBA16F),
              r === e.UNSIGNED_BYTE &&
                (o = t === dt ? e.SRGB8_ALPHA8 : e.RGBA8),
              r === e.UNSIGNED_SHORT_4_4_4_4 && (o = e.RGBA4),
              r === e.UNSIGNED_SHORT_5_5_5_1 && (o = e.RGB5_A1);
          }
          return (
            (o !== e.R16F &&
              o !== e.R32F &&
              o !== e.RG16F &&
              o !== e.RG32F &&
              o !== e.RGBA16F &&
              o !== e.RGBA32F) ||
              t.get("EXT_color_buffer_float"),
            o
          );
        }
        function x(t, n) {
          let i;
          return (
            t
              ? null === n || n === J || n === ne
                ? (i = e.DEPTH24_STENCIL8)
                : n === Z
                ? (i = e.DEPTH32F_STENCIL8)
                : n === X &&
                  ((i = e.DEPTH24_STENCIL8),
                  console.warn(
                    "DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment."
                  ))
              : null === n || n === J || n === ne
              ? (i = e.DEPTH_COMPONENT24)
              : n === Z
              ? (i = e.DEPTH_COMPONENT32F)
              : n === X && (i = e.DEPTH_COMPONENT16),
            i
          );
        }
        function _(e, t) {
          return !0 === g(e) ||
            (e.isFramebufferTexture && e.minFilter !== k && e.minFilter !== z)
            ? Math.log2(Math.max(t.width, t.height)) + 1
            : void 0 !== e.mipmaps && e.mipmaps.length > 0
            ? e.mipmaps.length
            : e.isCompressedTexture && Array.isArray(e.image)
            ? t.mipmaps.length
            : 1;
        }
        function b(e) {
          const t = e.target;
          t.removeEventListener("dispose", b),
            (function (e) {
              const t = i.get(e);
              if (void 0 === t.__webglInit) return;
              const n = e.source,
                r = d.get(n);
              if (r) {
                const i = r[t.__cacheKey];
                i.usedTimes--,
                  0 === i.usedTimes && w(e),
                  0 === Object.keys(r).length && d.delete(n);
              }
              i.remove(e);
            })(t),
            t.isVideoTexture && u.delete(t);
        }
        function E(t) {
          const n = t.target;
          n.removeEventListener("dispose", E),
            (function (t) {
              const n = i.get(t);
              t.depthTexture &&
                (t.depthTexture.dispose(), i.remove(t.depthTexture));
              if (t.isWebGLCubeRenderTarget)
                for (let t = 0; t < 6; t++) {
                  if (Array.isArray(n.__webglFramebuffer[t]))
                    for (let i = 0; i < n.__webglFramebuffer[t].length; i++)
                      e.deleteFramebuffer(n.__webglFramebuffer[t][i]);
                  else e.deleteFramebuffer(n.__webglFramebuffer[t]);
                  n.__webglDepthbuffer &&
                    e.deleteRenderbuffer(n.__webglDepthbuffer[t]);
                }
              else {
                if (Array.isArray(n.__webglFramebuffer))
                  for (let t = 0; t < n.__webglFramebuffer.length; t++)
                    e.deleteFramebuffer(n.__webglFramebuffer[t]);
                else e.deleteFramebuffer(n.__webglFramebuffer);
                if (
                  (n.__webglDepthbuffer &&
                    e.deleteRenderbuffer(n.__webglDepthbuffer),
                  n.__webglMultisampledFramebuffer &&
                    e.deleteFramebuffer(n.__webglMultisampledFramebuffer),
                  n.__webglColorRenderbuffer)
                )
                  for (let t = 0; t < n.__webglColorRenderbuffer.length; t++)
                    n.__webglColorRenderbuffer[t] &&
                      e.deleteRenderbuffer(n.__webglColorRenderbuffer[t]);
                n.__webglDepthRenderbuffer &&
                  e.deleteRenderbuffer(n.__webglDepthRenderbuffer);
              }
              const r = t.textures;
              for (let t = 0, n = r.length; t < n; t++) {
                const n = i.get(r[t]);
                n.__webglTexture &&
                  (e.deleteTexture(n.__webglTexture), a.memory.textures--),
                  i.remove(r[t]);
              }
              i.remove(t);
            })(n);
        }
        function w(t) {
          const n = i.get(t);
          e.deleteTexture(n.__webglTexture);
          const r = t.source;
          delete d.get(r)[n.__cacheKey], a.memory.textures--;
        }
        let C = 0;
        function I(t, r) {
          const s = i.get(t);
          if (
            (t.isVideoTexture &&
              (function (e) {
                const t = a.render.frame;
                u.get(e) !== t && (u.set(e, t), e.update());
              })(t),
            !1 === t.isRenderTargetTexture &&
              t.version > 0 &&
              s.__version !== t.version)
          ) {
            const e = t.image;
            if (null === e)
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but no image data found."
              );
            else {
              if (!1 !== e.complete) return void D(s, t, r);
              console.warn(
                "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
              );
            }
          }
          n.bindTexture(e.TEXTURE_2D, s.__webglTexture, e.TEXTURE0 + r);
        }
        const S = {
            [N]: e.REPEAT,
            [O]: e.CLAMP_TO_EDGE,
            [Q]: e.MIRRORED_REPEAT,
          },
          M = {
            [k]: e.NEAREST,
            [G]: e.NEAREST_MIPMAP_NEAREST,
            [H]: e.NEAREST_MIPMAP_LINEAR,
            [z]: e.LINEAR,
            [V]: e.LINEAR_MIPMAP_NEAREST,
            [W]: e.LINEAR_MIPMAP_LINEAR,
          },
          T = {
            512: e.NEVER,
            519: e.ALWAYS,
            513: e.LESS,
            [ft]: e.LEQUAL,
            514: e.EQUAL,
            518: e.GEQUAL,
            516: e.GREATER,
            517: e.NOTEQUAL,
          };
        function B(n, s) {
          if (
            (s.type !== Z ||
              !1 !== t.has("OES_texture_float_linear") ||
              (s.magFilter !== z &&
                s.magFilter !== V &&
                s.magFilter !== H &&
                s.magFilter !== W &&
                s.minFilter !== z &&
                s.minFilter !== V &&
                s.minFilter !== H &&
                s.minFilter !== W) ||
              console.warn(
                "THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."
              ),
            e.texParameteri(n, e.TEXTURE_WRAP_S, S[s.wrapS]),
            e.texParameteri(n, e.TEXTURE_WRAP_T, S[s.wrapT]),
            (n !== e.TEXTURE_3D && n !== e.TEXTURE_2D_ARRAY) ||
              e.texParameteri(n, e.TEXTURE_WRAP_R, S[s.wrapR]),
            e.texParameteri(n, e.TEXTURE_MAG_FILTER, M[s.magFilter]),
            e.texParameteri(n, e.TEXTURE_MIN_FILTER, M[s.minFilter]),
            s.compareFunction &&
              (e.texParameteri(
                n,
                e.TEXTURE_COMPARE_MODE,
                e.COMPARE_REF_TO_TEXTURE
              ),
              e.texParameteri(n, e.TEXTURE_COMPARE_FUNC, T[s.compareFunction])),
            !0 === t.has("EXT_texture_filter_anisotropic"))
          ) {
            if (s.magFilter === k) return;
            if (s.minFilter !== H && s.minFilter !== W) return;
            if (s.type === Z && !1 === t.has("OES_texture_float_linear"))
              return;
            if (s.anisotropy > 1 || i.get(s).__currentAnisotropy) {
              const a = t.get("EXT_texture_filter_anisotropic");
              e.texParameterf(
                n,
                a.TEXTURE_MAX_ANISOTROPY_EXT,
                Math.min(s.anisotropy, r.getMaxAnisotropy())
              ),
                (i.get(s).__currentAnisotropy = s.anisotropy);
            }
          }
        }
        function R(t, n) {
          let i = !1;
          void 0 === t.__webglInit &&
            ((t.__webglInit = !0), n.addEventListener("dispose", b));
          const r = n.source;
          let s = d.get(r);
          void 0 === s && ((s = {}), d.set(r, s));
          const o = (function (e) {
            const t = [];
            return (
              t.push(e.wrapS),
              t.push(e.wrapT),
              t.push(e.wrapR || 0),
              t.push(e.magFilter),
              t.push(e.minFilter),
              t.push(e.anisotropy),
              t.push(e.internalFormat),
              t.push(e.format),
              t.push(e.type),
              t.push(e.generateMipmaps),
              t.push(e.premultiplyAlpha),
              t.push(e.flipY),
              t.push(e.unpackAlignment),
              t.push(e.colorSpace),
              t.join()
            );
          })(n);
          if (o !== t.__cacheKey) {
            void 0 === s[o] &&
              ((s[o] = { texture: e.createTexture(), usedTimes: 0 }),
              a.memory.textures++,
              (i = !0)),
              s[o].usedTimes++;
            const r = s[t.__cacheKey];
            void 0 !== r &&
              (s[t.__cacheKey].usedTimes--, 0 === r.usedTimes && w(n)),
              (t.__cacheKey = o),
              (t.__webglTexture = s[o].texture);
          }
          return i;
        }
        function D(t, a, o) {
          let l = e.TEXTURE_2D;
          (a.isDataArrayTexture || a.isCompressedArrayTexture) &&
            (l = e.TEXTURE_2D_ARRAY),
            a.isData3DTexture && (l = e.TEXTURE_3D);
          const c = R(t, a),
            u = a.source;
          n.bindTexture(l, t.__webglTexture, e.TEXTURE0 + o);
          const h = i.get(u);
          if (u.version !== h.__version || !0 === c) {
            n.activeTexture(e.TEXTURE0 + o);
            const t = Qt.getPrimaries(Qt.workingColorSpace),
              i = a.colorSpace === lt ? null : Qt.getPrimaries(a.colorSpace),
              d =
                a.colorSpace === lt || t === i
                  ? e.NONE
                  : e.BROWSER_DEFAULT_WEBGL;
            e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
              e.pixelStorei(
                e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                a.premultiplyAlpha
              ),
              e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
              e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, d);
            let p = A(a.image, !1, r.maxTextureSize);
            p = $(a, p);
            const f = s.convert(a.format, a.colorSpace),
              v = s.convert(a.type);
            let b,
              E = y(a.internalFormat, f, v, a.colorSpace, a.isVideoTexture);
            B(l, a);
            const w = a.mipmaps,
              C = !0 !== a.isVideoTexture,
              I = void 0 === h.__version || !0 === c,
              S = u.dataReady,
              M = _(a, p);
            if (a.isDepthTexture)
              (E = x(a.format === ue, a.type)),
                I &&
                  (C
                    ? n.texStorage2D(e.TEXTURE_2D, 1, E, p.width, p.height)
                    : n.texImage2D(
                        e.TEXTURE_2D,
                        0,
                        E,
                        p.width,
                        p.height,
                        0,
                        f,
                        v,
                        null
                      ));
            else if (a.isDataTexture)
              if (w.length > 0) {
                C &&
                  I &&
                  n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                for (let t = 0, i = w.length; t < i; t++)
                  (b = w[t]),
                    C
                      ? S &&
                        n.texSubImage2D(
                          e.TEXTURE_2D,
                          t,
                          0,
                          0,
                          b.width,
                          b.height,
                          f,
                          v,
                          b.data
                        )
                      : n.texImage2D(
                          e.TEXTURE_2D,
                          t,
                          E,
                          b.width,
                          b.height,
                          0,
                          f,
                          v,
                          b.data
                        );
                a.generateMipmaps = !1;
              } else
                C
                  ? (I && n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height),
                    S &&
                      n.texSubImage2D(
                        e.TEXTURE_2D,
                        0,
                        0,
                        0,
                        p.width,
                        p.height,
                        f,
                        v,
                        p.data
                      ))
                  : n.texImage2D(
                      e.TEXTURE_2D,
                      0,
                      E,
                      p.width,
                      p.height,
                      0,
                      f,
                      v,
                      p.data
                    );
            else if (a.isCompressedTexture)
              if (a.isCompressedArrayTexture) {
                C &&
                  I &&
                  n.texStorage3D(
                    e.TEXTURE_2D_ARRAY,
                    M,
                    E,
                    w[0].width,
                    w[0].height,
                    p.depth
                  );
                for (let t = 0, i = w.length; t < i; t++)
                  if (((b = w[t]), a.format !== ae))
                    if (null !== f)
                      if (C) {
                        if (S)
                          if (a.layerUpdates.size > 0) {
                            const i = fo(b.width, b.height, a.format, a.type);
                            for (const r of a.layerUpdates) {
                              const s = b.data.subarray(
                                (r * i) / b.data.BYTES_PER_ELEMENT,
                                ((r + 1) * i) / b.data.BYTES_PER_ELEMENT
                              );
                              n.compressedTexSubImage3D(
                                e.TEXTURE_2D_ARRAY,
                                t,
                                0,
                                0,
                                r,
                                b.width,
                                b.height,
                                1,
                                f,
                                s
                              );
                            }
                            a.clearLayerUpdates();
                          } else
                            n.compressedTexSubImage3D(
                              e.TEXTURE_2D_ARRAY,
                              t,
                              0,
                              0,
                              0,
                              b.width,
                              b.height,
                              p.depth,
                              f,
                              b.data
                            );
                      } else
                        n.compressedTexImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          E,
                          b.width,
                          b.height,
                          p.depth,
                          0,
                          b.data,
                          0,
                          0
                        );
                    else
                      console.warn(
                        "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                      );
                  else
                    C
                      ? S &&
                        n.texSubImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          0,
                          0,
                          0,
                          b.width,
                          b.height,
                          p.depth,
                          f,
                          v,
                          b.data
                        )
                      : n.texImage3D(
                          e.TEXTURE_2D_ARRAY,
                          t,
                          E,
                          b.width,
                          b.height,
                          p.depth,
                          0,
                          f,
                          v,
                          b.data
                        );
              } else {
                C &&
                  I &&
                  n.texStorage2D(e.TEXTURE_2D, M, E, w[0].width, w[0].height);
                for (let t = 0, i = w.length; t < i; t++)
                  (b = w[t]),
                    a.format !== ae
                      ? null !== f
                        ? C
                          ? S &&
                            n.compressedTexSubImage2D(
                              e.TEXTURE_2D,
                              t,
                              0,
                              0,
                              b.width,
                              b.height,
                              f,
                              b.data
                            )
                          : n.compressedTexImage2D(
                              e.TEXTURE_2D,
                              t,
                              E,
                              b.width,
                              b.height,
                              0,
                              b.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                          )
                      : C
                      ? S &&
                        n.texSubImage2D(
                          e.TEXTURE_2D,
                          t,
                          0,
                          0,
                          b.width,
                          b.height,
                          f,
                          v,
                          b.data
                        )
                      : n.texImage2D(
                          e.TEXTURE_2D,
                          t,
                          E,
                          b.width,
                          b.height,
                          0,
                          f,
                          v,
                          b.data
                        );
              }
            else if (a.isDataArrayTexture)
              if (C) {
                if (
                  (I &&
                    n.texStorage3D(
                      e.TEXTURE_2D_ARRAY,
                      M,
                      E,
                      p.width,
                      p.height,
                      p.depth
                    ),
                  S)
                )
                  if (a.layerUpdates.size > 0) {
                    const t = fo(p.width, p.height, a.format, a.type);
                    for (const i of a.layerUpdates) {
                      const r = p.data.subarray(
                        (i * t) / p.data.BYTES_PER_ELEMENT,
                        ((i + 1) * t) / p.data.BYTES_PER_ELEMENT
                      );
                      n.texSubImage3D(
                        e.TEXTURE_2D_ARRAY,
                        0,
                        0,
                        0,
                        i,
                        p.width,
                        p.height,
                        1,
                        f,
                        v,
                        r
                      );
                    }
                    a.clearLayerUpdates();
                  } else
                    n.texSubImage3D(
                      e.TEXTURE_2D_ARRAY,
                      0,
                      0,
                      0,
                      0,
                      p.width,
                      p.height,
                      p.depth,
                      f,
                      v,
                      p.data
                    );
              } else
                n.texImage3D(
                  e.TEXTURE_2D_ARRAY,
                  0,
                  E,
                  p.width,
                  p.height,
                  p.depth,
                  0,
                  f,
                  v,
                  p.data
                );
            else if (a.isData3DTexture)
              C
                ? (I &&
                    n.texStorage3D(
                      e.TEXTURE_3D,
                      M,
                      E,
                      p.width,
                      p.height,
                      p.depth
                    ),
                  S &&
                    n.texSubImage3D(
                      e.TEXTURE_3D,
                      0,
                      0,
                      0,
                      0,
                      p.width,
                      p.height,
                      p.depth,
                      f,
                      v,
                      p.data
                    ))
                : n.texImage3D(
                    e.TEXTURE_3D,
                    0,
                    E,
                    p.width,
                    p.height,
                    p.depth,
                    0,
                    f,
                    v,
                    p.data
                  );
            else if (a.isFramebufferTexture) {
              if (I)
                if (C) n.texStorage2D(e.TEXTURE_2D, M, E, p.width, p.height);
                else {
                  let t = p.width,
                    i = p.height;
                  for (let r = 0; r < M; r++)
                    n.texImage2D(e.TEXTURE_2D, r, E, t, i, 0, f, v, null),
                      (t >>= 1),
                      (i >>= 1);
                }
            } else if (w.length > 0) {
              if (C && I) {
                const t = ee(w[0]);
                n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height);
              }
              for (let t = 0, i = w.length; t < i; t++)
                (b = w[t]),
                  C
                    ? S && n.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, v, b)
                    : n.texImage2D(e.TEXTURE_2D, t, E, f, v, b);
              a.generateMipmaps = !1;
            } else if (C) {
              if (I) {
                const t = ee(p);
                n.texStorage2D(e.TEXTURE_2D, M, E, t.width, t.height);
              }
              S && n.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, v, p);
            } else n.texImage2D(e.TEXTURE_2D, 0, E, f, v, p);
            g(a) && m(l),
              (h.__version = u.version),
              a.onUpdate && a.onUpdate(a);
          }
          t.__version = a.version;
        }
        function P(t, r, a, l, c, u) {
          const h = s.convert(a.format, a.colorSpace),
            d = s.convert(a.type),
            p = y(a.internalFormat, h, d, a.colorSpace),
            f = i.get(r),
            A = i.get(a);
          if (((A.__renderTarget = r), !f.__hasExternalTextures)) {
            const t = Math.max(1, r.width >> u),
              i = Math.max(1, r.height >> u);
            c === e.TEXTURE_3D || c === e.TEXTURE_2D_ARRAY
              ? n.texImage3D(c, u, p, t, i, r.depth, 0, h, d, null)
              : n.texImage2D(c, u, p, t, i, 0, h, d, null);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, t),
            K(r)
              ? o.framebufferTexture2DMultisampleEXT(
                  e.FRAMEBUFFER,
                  l,
                  c,
                  A.__webglTexture,
                  0,
                  Y(r)
                )
              : (c === e.TEXTURE_2D ||
                  (c >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
                    c <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
                e.framebufferTexture2D(
                  e.FRAMEBUFFER,
                  l,
                  c,
                  A.__webglTexture,
                  u
                ),
            n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        function L(t, n, i) {
          if ((e.bindRenderbuffer(e.RENDERBUFFER, t), n.depthBuffer)) {
            const r = n.depthTexture,
              s = r && r.isDepthTexture ? r.type : null,
              a = x(n.stencilBuffer, s),
              l = n.stencilBuffer
                ? e.DEPTH_STENCIL_ATTACHMENT
                : e.DEPTH_ATTACHMENT,
              c = Y(n);
            K(n)
              ? o.renderbufferStorageMultisampleEXT(
                  e.RENDERBUFFER,
                  c,
                  a,
                  n.width,
                  n.height
                )
              : i
              ? e.renderbufferStorageMultisample(
                  e.RENDERBUFFER,
                  c,
                  a,
                  n.width,
                  n.height
                )
              : e.renderbufferStorage(e.RENDERBUFFER, a, n.width, n.height),
              e.framebufferRenderbuffer(e.FRAMEBUFFER, l, e.RENDERBUFFER, t);
          } else {
            const t = n.textures;
            for (let r = 0; r < t.length; r++) {
              const a = t[r],
                l = s.convert(a.format, a.colorSpace),
                c = s.convert(a.type),
                u = y(a.internalFormat, l, c, a.colorSpace),
                h = Y(n);
              i && !1 === K(n)
                ? e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    h,
                    u,
                    n.width,
                    n.height
                  )
                : K(n)
                ? o.renderbufferStorageMultisampleEXT(
                    e.RENDERBUFFER,
                    h,
                    u,
                    n.width,
                    n.height
                  )
                : e.renderbufferStorage(e.RENDERBUFFER, u, n.width, n.height);
            }
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null);
        }
        function U(t) {
          const r = i.get(t),
            s = !0 === t.isWebGLCubeRenderTarget;
          if (r.__boundDepthTexture !== t.depthTexture) {
            const e = t.depthTexture;
            if ((r.__depthDisposeCallback && r.__depthDisposeCallback(), e)) {
              const t = () => {
                delete r.__boundDepthTexture,
                  delete r.__depthDisposeCallback,
                  e.removeEventListener("dispose", t);
              };
              e.addEventListener("dispose", t), (r.__depthDisposeCallback = t);
            }
            r.__boundDepthTexture = e;
          }
          if (t.depthTexture && !r.__autoAllocateDepthBuffer) {
            if (s)
              throw new Error(
                "target.depthTexture not supported in Cube render targets"
              );
            !(function (t, r) {
              if (r && r.isWebGLCubeRenderTarget)
                throw new Error(
                  "Depth Texture with cube render targets is not supported"
                );
              if (
                (n.bindFramebuffer(e.FRAMEBUFFER, t),
                !r.depthTexture || !r.depthTexture.isDepthTexture)
              )
                throw new Error(
                  "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
                );
              const s = i.get(r.depthTexture);
              (s.__renderTarget = r),
                (s.__webglTexture &&
                  r.depthTexture.image.width === r.width &&
                  r.depthTexture.image.height === r.height) ||
                  ((r.depthTexture.image.width = r.width),
                  (r.depthTexture.image.height = r.height),
                  (r.depthTexture.needsUpdate = !0)),
                I(r.depthTexture, 0);
              const a = s.__webglTexture,
                l = Y(r);
              if (r.depthTexture.format === ce)
                K(r)
                  ? o.framebufferTexture2DMultisampleEXT(
                      e.FRAMEBUFFER,
                      e.DEPTH_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0,
                      l
                    )
                  : e.framebufferTexture2D(
                      e.FRAMEBUFFER,
                      e.DEPTH_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0
                    );
              else {
                if (r.depthTexture.format !== ue)
                  throw new Error("Unknown depthTexture format");
                K(r)
                  ? o.framebufferTexture2DMultisampleEXT(
                      e.FRAMEBUFFER,
                      e.DEPTH_STENCIL_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0,
                      l
                    )
                  : e.framebufferTexture2D(
                      e.FRAMEBUFFER,
                      e.DEPTH_STENCIL_ATTACHMENT,
                      e.TEXTURE_2D,
                      a,
                      0
                    );
              }
            })(r.__webglFramebuffer, t);
          } else if (s) {
            r.__webglDepthbuffer = [];
            for (let i = 0; i < 6; i++)
              if (
                (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer[i]),
                void 0 === r.__webglDepthbuffer[i])
              )
                (r.__webglDepthbuffer[i] = e.createRenderbuffer()),
                  L(r.__webglDepthbuffer[i], t, !1);
              else {
                const n = t.stencilBuffer
                    ? e.DEPTH_STENCIL_ATTACHMENT
                    : e.DEPTH_ATTACHMENT,
                  s = r.__webglDepthbuffer[i];
                e.bindRenderbuffer(e.RENDERBUFFER, s),
                  e.framebufferRenderbuffer(
                    e.FRAMEBUFFER,
                    n,
                    e.RENDERBUFFER,
                    s
                  );
              }
          } else if (
            (n.bindFramebuffer(e.FRAMEBUFFER, r.__webglFramebuffer),
            void 0 === r.__webglDepthbuffer)
          )
            (r.__webglDepthbuffer = e.createRenderbuffer()),
              L(r.__webglDepthbuffer, t, !1);
          else {
            const n = t.stencilBuffer
                ? e.DEPTH_STENCIL_ATTACHMENT
                : e.DEPTH_ATTACHMENT,
              i = r.__webglDepthbuffer;
            e.bindRenderbuffer(e.RENDERBUFFER, i),
              e.framebufferRenderbuffer(e.FRAMEBUFFER, n, e.RENDERBUFFER, i);
          }
          n.bindFramebuffer(e.FRAMEBUFFER, null);
        }
        const F = [],
          q = [];
        function Y(e) {
          return Math.min(r.maxSamples, e.samples);
        }
        function K(e) {
          const n = i.get(e);
          return (
            e.samples > 0 &&
            !0 === t.has("WEBGL_multisampled_render_to_texture") &&
            !1 !== n.__useRenderToTexture
          );
        }
        function $(e, t) {
          const n = e.colorSpace,
            i = e.format,
            r = e.type;
          return (
            !0 === e.isCompressedTexture ||
              !0 === e.isVideoTexture ||
              (n !== ut &&
                n !== lt &&
                (Qt.getTransfer(n) === dt
                  ? (i === ae && r === j) ||
                    console.warn(
                      "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                    )
                  : console.error(
                      "THREE.WebGLTextures: Unsupported texture color space:",
                      n
                    ))),
            t
          );
        }
        function ee(e) {
          return (
            "undefined" != typeof HTMLImageElement &&
            e instanceof HTMLImageElement
              ? ((c.width = e.naturalWidth || e.width),
                (c.height = e.naturalHeight || e.height))
              : "undefined" != typeof VideoFrame && e instanceof VideoFrame
              ? ((c.width = e.displayWidth), (c.height = e.displayHeight))
              : ((c.width = e.width), (c.height = e.height)),
            c
          );
        }
        (this.allocateTextureUnit = function () {
          const e = C;
          return (
            e >= r.maxTextures &&
              console.warn(
                "THREE.WebGLTextures: Trying to use " +
                  e +
                  " texture units while this GPU supports only " +
                  r.maxTextures
              ),
            (C += 1),
            e
          );
        }),
          (this.resetTextureUnits = function () {
            C = 0;
          }),
          (this.setTexture2D = I),
          (this.setTexture2DArray = function (t, r) {
            const s = i.get(t);
            t.version > 0 && s.__version !== t.version
              ? D(s, t, r)
              : n.bindTexture(
                  e.TEXTURE_2D_ARRAY,
                  s.__webglTexture,
                  e.TEXTURE0 + r
                );
          }),
          (this.setTexture3D = function (t, r) {
            const s = i.get(t);
            t.version > 0 && s.__version !== t.version
              ? D(s, t, r)
              : n.bindTexture(e.TEXTURE_3D, s.__webglTexture, e.TEXTURE0 + r);
          }),
          (this.setTextureCube = function (t, a) {
            const o = i.get(t);
            t.version > 0 && o.__version !== t.version
              ? (function (t, a, o) {
                  if (6 !== a.image.length) return;
                  const l = R(t, a),
                    c = a.source;
                  n.bindTexture(
                    e.TEXTURE_CUBE_MAP,
                    t.__webglTexture,
                    e.TEXTURE0 + o
                  );
                  const u = i.get(c);
                  if (c.version !== u.__version || !0 === l) {
                    n.activeTexture(e.TEXTURE0 + o);
                    const t = Qt.getPrimaries(Qt.workingColorSpace),
                      i =
                        a.colorSpace === lt
                          ? null
                          : Qt.getPrimaries(a.colorSpace),
                      h =
                        a.colorSpace === lt || t === i
                          ? e.NONE
                          : e.BROWSER_DEFAULT_WEBGL;
                    e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, a.flipY),
                      e.pixelStorei(
                        e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                        a.premultiplyAlpha
                      ),
                      e.pixelStorei(e.UNPACK_ALIGNMENT, a.unpackAlignment),
                      e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, h);
                    const d =
                        a.isCompressedTexture || a.image[0].isCompressedTexture,
                      p = a.image[0] && a.image[0].isDataTexture,
                      f = [];
                    for (let e = 0; e < 6; e++)
                      (f[e] =
                        d || p
                          ? p
                            ? a.image[e].image
                            : a.image[e]
                          : A(a.image[e], !0, r.maxCubemapSize)),
                        (f[e] = $(a, f[e]));
                    const v = f[0],
                      x = s.convert(a.format, a.colorSpace),
                      b = s.convert(a.type),
                      E = y(a.internalFormat, x, b, a.colorSpace),
                      w = !0 !== a.isVideoTexture,
                      C = void 0 === u.__version || !0 === l,
                      I = c.dataReady;
                    let S,
                      M = _(a, v);
                    if ((B(e.TEXTURE_CUBE_MAP, a), d)) {
                      w &&
                        C &&
                        n.texStorage2D(
                          e.TEXTURE_CUBE_MAP,
                          M,
                          E,
                          v.width,
                          v.height
                        );
                      for (let t = 0; t < 6; t++) {
                        S = f[t].mipmaps;
                        for (let i = 0; i < S.length; i++) {
                          const r = S[i];
                          a.format !== ae
                            ? null !== x
                              ? w
                                ? I &&
                                  n.compressedTexSubImage2D(
                                    e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                    i,
                                    0,
                                    0,
                                    r.width,
                                    r.height,
                                    x,
                                    r.data
                                  )
                                : n.compressedTexImage2D(
                                    e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                    i,
                                    E,
                                    r.width,
                                    r.height,
                                    0,
                                    r.data
                                  )
                              : console.warn(
                                  "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                                )
                            : w
                            ? I &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                i,
                                0,
                                0,
                                r.width,
                                r.height,
                                x,
                                b,
                                r.data
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                i,
                                E,
                                r.width,
                                r.height,
                                0,
                                x,
                                b,
                                r.data
                              );
                        }
                      }
                    } else {
                      if (((S = a.mipmaps), w && C)) {
                        S.length > 0 && M++;
                        const t = ee(f[0]);
                        n.texStorage2D(
                          e.TEXTURE_CUBE_MAP,
                          M,
                          E,
                          t.width,
                          t.height
                        );
                      }
                      for (let t = 0; t < 6; t++)
                        if (p) {
                          w
                            ? I &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                0,
                                0,
                                f[t].width,
                                f[t].height,
                                x,
                                b,
                                f[t].data
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                E,
                                f[t].width,
                                f[t].height,
                                0,
                                x,
                                b,
                                f[t].data
                              );
                          for (let i = 0; i < S.length; i++) {
                            const r = S[i].image[t].image;
                            w
                              ? I &&
                                n.texSubImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  0,
                                  0,
                                  r.width,
                                  r.height,
                                  x,
                                  b,
                                  r.data
                                )
                              : n.texImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  E,
                                  r.width,
                                  r.height,
                                  0,
                                  x,
                                  b,
                                  r.data
                                );
                          }
                        } else {
                          w
                            ? I &&
                              n.texSubImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                0,
                                0,
                                x,
                                b,
                                f[t]
                              )
                            : n.texImage2D(
                                e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                0,
                                E,
                                x,
                                b,
                                f[t]
                              );
                          for (let i = 0; i < S.length; i++) {
                            const r = S[i];
                            w
                              ? I &&
                                n.texSubImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  0,
                                  0,
                                  x,
                                  b,
                                  r.image[t]
                                )
                              : n.texImage2D(
                                  e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                                  i + 1,
                                  E,
                                  x,
                                  b,
                                  r.image[t]
                                );
                          }
                        }
                    }
                    g(a) && m(e.TEXTURE_CUBE_MAP),
                      (u.__version = c.version),
                      a.onUpdate && a.onUpdate(a);
                  }
                  t.__version = a.version;
                })(o, t, a)
              : n.bindTexture(
                  e.TEXTURE_CUBE_MAP,
                  o.__webglTexture,
                  e.TEXTURE0 + a
                );
          }),
          (this.rebindTextures = function (t, n, r) {
            const s = i.get(t);
            void 0 !== n &&
              P(
                s.__webglFramebuffer,
                t,
                t.texture,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_2D,
                0
              ),
              void 0 !== r && U(t);
          }),
          (this.setupRenderTarget = function (t) {
            const r = t.texture,
              o = i.get(t),
              l = i.get(r);
            t.addEventListener("dispose", E);
            const c = t.textures,
              u = !0 === t.isWebGLCubeRenderTarget,
              h = c.length > 1;
            if (
              (h ||
                (void 0 === l.__webglTexture &&
                  (l.__webglTexture = e.createTexture()),
                (l.__version = r.version),
                a.memory.textures++),
              u)
            ) {
              o.__webglFramebuffer = [];
              for (let t = 0; t < 6; t++)
                if (r.mipmaps && r.mipmaps.length > 0) {
                  o.__webglFramebuffer[t] = [];
                  for (let n = 0; n < r.mipmaps.length; n++)
                    o.__webglFramebuffer[t][n] = e.createFramebuffer();
                } else o.__webglFramebuffer[t] = e.createFramebuffer();
            } else {
              if (r.mipmaps && r.mipmaps.length > 0) {
                o.__webglFramebuffer = [];
                for (let t = 0; t < r.mipmaps.length; t++)
                  o.__webglFramebuffer[t] = e.createFramebuffer();
              } else o.__webglFramebuffer = e.createFramebuffer();
              if (h)
                for (let t = 0, n = c.length; t < n; t++) {
                  const n = i.get(c[t]);
                  void 0 === n.__webglTexture &&
                    ((n.__webglTexture = e.createTexture()),
                    a.memory.textures++);
                }
              if (t.samples > 0 && !1 === K(t)) {
                (o.__webglMultisampledFramebuffer = e.createFramebuffer()),
                  (o.__webglColorRenderbuffer = []),
                  n.bindFramebuffer(
                    e.FRAMEBUFFER,
                    o.__webglMultisampledFramebuffer
                  );
                for (let n = 0; n < c.length; n++) {
                  const i = c[n];
                  (o.__webglColorRenderbuffer[n] = e.createRenderbuffer()),
                    e.bindRenderbuffer(
                      e.RENDERBUFFER,
                      o.__webglColorRenderbuffer[n]
                    );
                  const r = s.convert(i.format, i.colorSpace),
                    a = s.convert(i.type),
                    l = y(
                      i.internalFormat,
                      r,
                      a,
                      i.colorSpace,
                      !0 === t.isXRRenderTarget
                    ),
                    u = Y(t);
                  e.renderbufferStorageMultisample(
                    e.RENDERBUFFER,
                    u,
                    l,
                    t.width,
                    t.height
                  ),
                    e.framebufferRenderbuffer(
                      e.FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0 + n,
                      e.RENDERBUFFER,
                      o.__webglColorRenderbuffer[n]
                    );
                }
                e.bindRenderbuffer(e.RENDERBUFFER, null),
                  t.depthBuffer &&
                    ((o.__webglDepthRenderbuffer = e.createRenderbuffer()),
                    L(o.__webglDepthRenderbuffer, t, !0)),
                  n.bindFramebuffer(e.FRAMEBUFFER, null);
              }
            }
            if (u) {
              n.bindTexture(e.TEXTURE_CUBE_MAP, l.__webglTexture),
                B(e.TEXTURE_CUBE_MAP, r);
              for (let n = 0; n < 6; n++)
                if (r.mipmaps && r.mipmaps.length > 0)
                  for (let i = 0; i < r.mipmaps.length; i++)
                    P(
                      o.__webglFramebuffer[n][i],
                      t,
                      r,
                      e.COLOR_ATTACHMENT0,
                      e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                      i
                    );
                else
                  P(
                    o.__webglFramebuffer[n],
                    t,
                    r,
                    e.COLOR_ATTACHMENT0,
                    e.TEXTURE_CUBE_MAP_POSITIVE_X + n,
                    0
                  );
              g(r) && m(e.TEXTURE_CUBE_MAP), n.unbindTexture();
            } else if (h) {
              for (let r = 0, s = c.length; r < s; r++) {
                const s = c[r],
                  a = i.get(s);
                n.bindTexture(e.TEXTURE_2D, a.__webglTexture),
                  B(e.TEXTURE_2D, s),
                  P(
                    o.__webglFramebuffer,
                    t,
                    s,
                    e.COLOR_ATTACHMENT0 + r,
                    e.TEXTURE_2D,
                    0
                  ),
                  g(s) && m(e.TEXTURE_2D);
              }
              n.unbindTexture();
            } else {
              let i = e.TEXTURE_2D;
              if (
                ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
                  (i = t.isWebGL3DRenderTarget
                    ? e.TEXTURE_3D
                    : e.TEXTURE_2D_ARRAY),
                n.bindTexture(i, l.__webglTexture),
                B(i, r),
                r.mipmaps && r.mipmaps.length > 0)
              )
                for (let n = 0; n < r.mipmaps.length; n++)
                  P(o.__webglFramebuffer[n], t, r, e.COLOR_ATTACHMENT0, i, n);
              else P(o.__webglFramebuffer, t, r, e.COLOR_ATTACHMENT0, i, 0);
              g(r) && m(i), n.unbindTexture();
            }
            t.depthBuffer && U(t);
          }),
          (this.updateRenderTargetMipmap = function (e) {
            const t = e.textures;
            for (let r = 0, s = t.length; r < s; r++) {
              const s = t[r];
              if (g(s)) {
                const t = v(e),
                  r = i.get(s).__webglTexture;
                n.bindTexture(t, r), m(t), n.unbindTexture();
              }
            }
          }),
          (this.updateMultisampleRenderTarget = function (t) {
            if (t.samples > 0)
              if (!1 === K(t)) {
                const r = t.textures,
                  s = t.width,
                  a = t.height;
                let o = e.COLOR_BUFFER_BIT;
                const c = t.stencilBuffer
                    ? e.DEPTH_STENCIL_ATTACHMENT
                    : e.DEPTH_ATTACHMENT,
                  u = i.get(t),
                  h = r.length > 1;
                if (h)
                  for (let t = 0; t < r.length; t++)
                    n.bindFramebuffer(
                      e.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      e.framebufferRenderbuffer(
                        e.FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.RENDERBUFFER,
                        null
                      ),
                      n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                      e.framebufferTexture2D(
                        e.DRAW_FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.TEXTURE_2D,
                        null,
                        0
                      );
                n.bindFramebuffer(
                  e.READ_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                ),
                  n.bindFramebuffer(e.DRAW_FRAMEBUFFER, u.__webglFramebuffer);
                for (let n = 0; n < r.length; n++) {
                  if (
                    (t.resolveDepthBuffer &&
                      (t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
                      t.stencilBuffer &&
                        t.resolveStencilBuffer &&
                        (o |= e.STENCIL_BUFFER_BIT)),
                    h)
                  ) {
                    e.framebufferRenderbuffer(
                      e.READ_FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0,
                      e.RENDERBUFFER,
                      u.__webglColorRenderbuffer[n]
                    );
                    const t = i.get(r[n]).__webglTexture;
                    e.framebufferTexture2D(
                      e.DRAW_FRAMEBUFFER,
                      e.COLOR_ATTACHMENT0,
                      e.TEXTURE_2D,
                      t,
                      0
                    );
                  }
                  e.blitFramebuffer(0, 0, s, a, 0, 0, s, a, o, e.NEAREST),
                    !0 === l &&
                      ((F.length = 0),
                      (q.length = 0),
                      F.push(e.COLOR_ATTACHMENT0 + n),
                      t.depthBuffer &&
                        !1 === t.resolveDepthBuffer &&
                        (F.push(c),
                        q.push(c),
                        e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, q)),
                      e.invalidateFramebuffer(e.READ_FRAMEBUFFER, F));
                }
                if (
                  (n.bindFramebuffer(e.READ_FRAMEBUFFER, null),
                  n.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
                  h)
                )
                  for (let t = 0; t < r.length; t++) {
                    n.bindFramebuffer(
                      e.FRAMEBUFFER,
                      u.__webglMultisampledFramebuffer
                    ),
                      e.framebufferRenderbuffer(
                        e.FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.RENDERBUFFER,
                        u.__webglColorRenderbuffer[t]
                      );
                    const s = i.get(r[t]).__webglTexture;
                    n.bindFramebuffer(e.FRAMEBUFFER, u.__webglFramebuffer),
                      e.framebufferTexture2D(
                        e.DRAW_FRAMEBUFFER,
                        e.COLOR_ATTACHMENT0 + t,
                        e.TEXTURE_2D,
                        s,
                        0
                      );
                  }
                n.bindFramebuffer(
                  e.DRAW_FRAMEBUFFER,
                  u.__webglMultisampledFramebuffer
                );
              } else if (t.depthBuffer && !1 === t.resolveDepthBuffer && l) {
                const n = t.stencilBuffer
                  ? e.DEPTH_STENCIL_ATTACHMENT
                  : e.DEPTH_ATTACHMENT;
                e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [n]);
              }
          }),
          (this.setupDepthRenderbuffer = U),
          (this.setupFrameBufferTexture = P),
          (this.useMultisampledRTT = K);
      }
      function go(e, t) {
        return {
          convert: function (n, i = lt) {
            let r;
            const s = Qt.getTransfer(i);
            if (n === j) return e.UNSIGNED_BYTE;
            if (n === ee) return e.UNSIGNED_SHORT_4_4_4_4;
            if (n === te) return e.UNSIGNED_SHORT_5_5_5_1;
            if (n === ie) return e.UNSIGNED_INT_5_9_9_9_REV;
            if (n === q) return e.BYTE;
            if (n === Y) return e.SHORT;
            if (n === X) return e.UNSIGNED_SHORT;
            if (n === K) return e.INT;
            if (n === J) return e.UNSIGNED_INT;
            if (n === Z) return e.FLOAT;
            if (n === $) return e.HALF_FLOAT;
            if (n === re) return e.ALPHA;
            if (n === se) return e.RGB;
            if (n === ae) return e.RGBA;
            if (n === oe) return e.LUMINANCE;
            if (n === le) return e.LUMINANCE_ALPHA;
            if (n === ce) return e.DEPTH_COMPONENT;
            if (n === ue) return e.DEPTH_STENCIL;
            if (n === he) return e.RED;
            if (n === de) return e.RED_INTEGER;
            if (n === pe) return e.RG;
            if (n === fe) return e.RG_INTEGER;
            if (n === Ae) return e.RGBA_INTEGER;
            if (n === ge || n === me || n === ve || n === ye)
              if (s === dt) {
                if (
                  ((r = t.get("WEBGL_compressed_texture_s3tc_srgb")),
                  null === r)
                )
                  return null;
                if (n === ge) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                if (n === me) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                if (n === ve) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                if (n === ye) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                if (((r = t.get("WEBGL_compressed_texture_s3tc")), null === r))
                  return null;
                if (n === ge) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === me) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === ve) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === ye) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
              }
            if (n === xe || n === _e || n === be || n === Ee) {
              if (((r = t.get("WEBGL_compressed_texture_pvrtc")), null === r))
                return null;
              if (n === xe) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
              if (n === _e) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
              if (n === be) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
              if (n === Ee) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
            }
            if (n === we || n === Ce || n === Ie) {
              if (((r = t.get("WEBGL_compressed_texture_etc")), null === r))
                return null;
              if (n === we || n === Ce)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ETC2
                  : r.COMPRESSED_RGB8_ETC2;
              if (n === Ie)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
                  : r.COMPRESSED_RGBA8_ETC2_EAC;
            }
            if (
              n === Se ||
              n === Me ||
              n === Te ||
              n === Be ||
              n === Re ||
              n === De ||
              n === Pe ||
              n === Le ||
              n === Ue ||
              n === Fe ||
              n === Ne ||
              n === Oe ||
              n === Qe ||
              n === ke
            ) {
              if (((r = t.get("WEBGL_compressed_texture_astc")), null === r))
                return null;
              if (n === Se)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
              if (n === Me)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
              if (n === Te)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
              if (n === Be)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
              if (n === Re)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
              if (n === De)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
              if (n === Pe)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
              if (n === Le)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
              if (n === Ue)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
              if (n === Fe)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
              if (n === Ne)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
              if (n === Oe)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
              if (n === Qe)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
              if (n === ke)
                return s === dt
                  ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
                  : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
            }
            if (n === Ge || n === He || n === ze) {
              if (((r = t.get("EXT_texture_compression_bptc")), null === r))
                return null;
              if (n === Ge)
                return s === dt
                  ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
                  : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
              if (n === He) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
              if (n === ze) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
            }
            if (n === Ve || n === We || n === je || n === qe) {
              if (((r = t.get("EXT_texture_compression_rgtc")), null === r))
                return null;
              if (n === Ge) return r.COMPRESSED_RED_RGTC1_EXT;
              if (n === We) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
              if (n === je) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
              if (n === qe) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
            }
            return n === ne
              ? e.UNSIGNED_INT_24_8
              : void 0 !== e[n]
              ? e[n]
              : null;
          },
        };
      }
      class mo extends br {
        constructor(e = []) {
          super(), (this.isArrayCamera = !0), (this.cameras = e);
        }
      }
      class vo extends ui {
        constructor() {
          super(), (this.isGroup = !0), (this.type = "Group");
        }
      }
      const yo = { type: "move" };
      class xo {
        constructor() {
          (this._targetRay = null), (this._grip = null), (this._hand = null);
        }
        getHandSpace() {
          return (
            null === this._hand &&
              ((this._hand = new vo()),
              (this._hand.matrixAutoUpdate = !1),
              (this._hand.visible = !1),
              (this._hand.joints = {}),
              (this._hand.inputState = { pinching: !1 })),
            this._hand
          );
        }
        getTargetRaySpace() {
          return (
            null === this._targetRay &&
              ((this._targetRay = new vo()),
              (this._targetRay.matrixAutoUpdate = !1),
              (this._targetRay.visible = !1),
              (this._targetRay.hasLinearVelocity = !1),
              (this._targetRay.linearVelocity = new on()),
              (this._targetRay.hasAngularVelocity = !1),
              (this._targetRay.angularVelocity = new on())),
            this._targetRay
          );
        }
        getGripSpace() {
          return (
            null === this._grip &&
              ((this._grip = new vo()),
              (this._grip.matrixAutoUpdate = !1),
              (this._grip.visible = !1),
              (this._grip.hasLinearVelocity = !1),
              (this._grip.linearVelocity = new on()),
              (this._grip.hasAngularVelocity = !1),
              (this._grip.angularVelocity = new on())),
            this._grip
          );
        }
        dispatchEvent(e) {
          return (
            null !== this._targetRay && this._targetRay.dispatchEvent(e),
            null !== this._grip && this._grip.dispatchEvent(e),
            null !== this._hand && this._hand.dispatchEvent(e),
            this
          );
        }
        connect(e) {
          if (e && e.hand) {
            const t = this._hand;
            if (t) for (const n of e.hand.values()) this._getHandJoint(t, n);
          }
          return this.dispatchEvent({ type: "connected", data: e }), this;
        }
        disconnect(e) {
          return (
            this.dispatchEvent({ type: "disconnected", data: e }),
            null !== this._targetRay && (this._targetRay.visible = !1),
            null !== this._grip && (this._grip.visible = !1),
            null !== this._hand && (this._hand.visible = !1),
            this
          );
        }
        update(e, t, n) {
          let i = null,
            r = null,
            s = null;
          const a = this._targetRay,
            o = this._grip,
            l = this._hand;
          if (e && "visible-blurred" !== t.session.visibilityState) {
            if (l && e.hand) {
              s = !0;
              for (const i of e.hand.values()) {
                const e = t.getJointPose(i, n),
                  r = this._getHandJoint(l, i);
                null !== e &&
                  (r.matrix.fromArray(e.transform.matrix),
                  r.matrix.decompose(r.position, r.rotation, r.scale),
                  (r.matrixWorldNeedsUpdate = !0),
                  (r.jointRadius = e.radius)),
                  (r.visible = null !== e);
              }
              const i = l.joints["index-finger-tip"],
                r = l.joints["thumb-tip"],
                a = i.position.distanceTo(r.position),
                o = 0.02,
                c = 0.005;
              l.inputState.pinching && a > o + c
                ? ((l.inputState.pinching = !1),
                  this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this,
                  }))
                : !l.inputState.pinching &&
                  a <= o - c &&
                  ((l.inputState.pinching = !0),
                  this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this,
                  }));
            } else
              null !== o &&
                e.gripSpace &&
                ((r = t.getPose(e.gripSpace, n)),
                null !== r &&
                  (o.matrix.fromArray(r.transform.matrix),
                  o.matrix.decompose(o.position, o.rotation, o.scale),
                  (o.matrixWorldNeedsUpdate = !0),
                  r.linearVelocity
                    ? ((o.hasLinearVelocity = !0),
                      o.linearVelocity.copy(r.linearVelocity))
                    : (o.hasLinearVelocity = !1),
                  r.angularVelocity
                    ? ((o.hasAngularVelocity = !0),
                      o.angularVelocity.copy(r.angularVelocity))
                    : (o.hasAngularVelocity = !1)));
            null !== a &&
              ((i = t.getPose(e.targetRaySpace, n)),
              null === i && null !== r && (i = r),
              null !== i &&
                (a.matrix.fromArray(i.transform.matrix),
                a.matrix.decompose(a.position, a.rotation, a.scale),
                (a.matrixWorldNeedsUpdate = !0),
                i.linearVelocity
                  ? ((a.hasLinearVelocity = !0),
                    a.linearVelocity.copy(i.linearVelocity))
                  : (a.hasLinearVelocity = !1),
                i.angularVelocity
                  ? ((a.hasAngularVelocity = !0),
                    a.angularVelocity.copy(i.angularVelocity))
                  : (a.hasAngularVelocity = !1),
                this.dispatchEvent(yo)));
          }
          return (
            null !== a && (a.visible = null !== i),
            null !== o && (o.visible = null !== r),
            null !== l && (l.visible = null !== s),
            this
          );
        }
        _getHandJoint(e, t) {
          if (void 0 === e.joints[t.jointName]) {
            const n = new vo();
            (n.matrixAutoUpdate = !1),
              (n.visible = !1),
              (e.joints[t.jointName] = n),
              e.add(n);
          }
          return e.joints[t.jointName];
        }
      }
      class _o {
        constructor() {
          (this.texture = null),
            (this.mesh = null),
            (this.depthNear = 0),
            (this.depthFar = 0);
        }
        init(e, t, n) {
          if (null === this.texture) {
            const i = new $t();
            (e.properties.get(i).__webglTexture = t.texture),
              (t.depthNear == n.depthNear && t.depthFar == n.depthFar) ||
                ((this.depthNear = t.depthNear), (this.depthFar = t.depthFar)),
              (this.texture = i);
          }
        }
        getMesh(e) {
          if (null !== this.texture && null === this.mesh) {
            const t = e.cameras[0].viewport,
              n = new mr({
                vertexShader:
                  "\nvoid main() {\n\n\tgl_Position = vec4( position, 1.0 );\n\n}",
                fragmentShader:
                  "\nuniform sampler2DArray depthColor;\nuniform float depthWidth;\nuniform float depthHeight;\n\nvoid main() {\n\n\tvec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );\n\n\tif ( coord.x >= 1.0 ) {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;\n\n\t} else {\n\n\t\tgl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;\n\n\t}\n\n}",
                uniforms: {
                  depthColor: { value: this.texture },
                  depthWidth: { value: t.z },
                  depthHeight: { value: t.w },
                },
              });
            this.mesh = new ur(new Fr(20, 20), n);
          }
          return this.mesh;
        }
        reset() {
          (this.texture = null), (this.mesh = null);
        }
        getDepthTexture() {
          return this.texture;
        }
      }
      class bo extends yt {
        constructor(e, t) {
          super();
          const n = this;
          let i = null,
            r = 1,
            s = null,
            a = "local-floor",
            o = 1,
            l = null,
            c = null,
            u = null,
            h = null,
            d = null,
            p = null;
          const f = new _o(),
            A = t.getContextAttributes();
          let g = null,
            m = null;
          const v = [],
            y = [],
            x = new Rt();
          let _ = null;
          const b = new br();
          b.viewport = new en();
          const E = new br();
          E.viewport = new en();
          const w = [b, E],
            C = new mo();
          let I = null,
            S = null;
          function M(e) {
            const t = y.indexOf(e.inputSource);
            if (-1 === t) return;
            const n = v[t];
            void 0 !== n &&
              (n.update(e.inputSource, e.frame, l || s),
              n.dispatchEvent({ type: e.type, data: e.inputSource }));
          }
          function T() {
            i.removeEventListener("select", M),
              i.removeEventListener("selectstart", M),
              i.removeEventListener("selectend", M),
              i.removeEventListener("squeeze", M),
              i.removeEventListener("squeezestart", M),
              i.removeEventListener("squeezeend", M),
              i.removeEventListener("end", T),
              i.removeEventListener("inputsourceschange", B);
            for (let e = 0; e < v.length; e++) {
              const t = y[e];
              null !== t && ((y[e] = null), v[e].disconnect(t));
            }
            (I = null),
              (S = null),
              f.reset(),
              e.setRenderTarget(g),
              (d = null),
              (h = null),
              (u = null),
              (i = null),
              (m = null),
              U.stop(),
              (n.isPresenting = !1),
              e.setPixelRatio(_),
              e.setSize(x.width, x.height, !1),
              n.dispatchEvent({ type: "sessionend" });
          }
          function B(e) {
            for (let t = 0; t < e.removed.length; t++) {
              const n = e.removed[t],
                i = y.indexOf(n);
              i >= 0 && ((y[i] = null), v[i].disconnect(n));
            }
            for (let t = 0; t < e.added.length; t++) {
              const n = e.added[t];
              let i = y.indexOf(n);
              if (-1 === i) {
                for (let e = 0; e < v.length; e++) {
                  if (e >= y.length) {
                    y.push(n), (i = e);
                    break;
                  }
                  if (null === y[e]) {
                    (y[e] = n), (i = e);
                    break;
                  }
                }
                if (-1 === i) break;
              }
              const r = v[i];
              r && r.connect(n);
            }
          }
          (this.cameraAutoUpdate = !0),
            (this.enabled = !1),
            (this.isPresenting = !1),
            (this.getController = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new xo()), (v[e] = t)),
                t.getTargetRaySpace()
              );
            }),
            (this.getControllerGrip = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new xo()), (v[e] = t)), t.getGripSpace()
              );
            }),
            (this.getHand = function (e) {
              let t = v[e];
              return (
                void 0 === t && ((t = new xo()), (v[e] = t)), t.getHandSpace()
              );
            }),
            (this.setFramebufferScaleFactor = function (e) {
              (r = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
                  );
            }),
            (this.setReferenceSpaceType = function (e) {
              (a = e),
                !0 === n.isPresenting &&
                  console.warn(
                    "THREE.WebXRManager: Cannot change reference space type while presenting."
                  );
            }),
            (this.getReferenceSpace = function () {
              return l || s;
            }),
            (this.setReferenceSpace = function (e) {
              l = e;
            }),
            (this.getBaseLayer = function () {
              return null !== h ? h : d;
            }),
            (this.getBinding = function () {
              return u;
            }),
            (this.getFrame = function () {
              return p;
            }),
            (this.getSession = function () {
              return i;
            }),
            (this.setSession = async function (c) {
              if (((i = c), null !== i)) {
                if (
                  ((g = e.getRenderTarget()),
                  i.addEventListener("select", M),
                  i.addEventListener("selectstart", M),
                  i.addEventListener("selectend", M),
                  i.addEventListener("squeeze", M),
                  i.addEventListener("squeezestart", M),
                  i.addEventListener("squeezeend", M),
                  i.addEventListener("end", T),
                  i.addEventListener("inputsourceschange", B),
                  !0 !== A.xrCompatible && (await t.makeXRCompatible()),
                  (_ = e.getPixelRatio()),
                  e.getSize(x),
                  void 0 === i.renderState.layers)
                ) {
                  const n = {
                    antialias: A.antialias,
                    alpha: !0,
                    depth: A.depth,
                    stencil: A.stencil,
                    framebufferScaleFactor: r,
                  };
                  (d = new XRWebGLLayer(i, t, n)),
                    i.updateRenderState({ baseLayer: d }),
                    e.setPixelRatio(1),
                    e.setSize(d.framebufferWidth, d.framebufferHeight, !1),
                    (m = new nn(d.framebufferWidth, d.framebufferHeight, {
                      format: ae,
                      type: j,
                      colorSpace: e.outputColorSpace,
                      stencilBuffer: A.stencil,
                    }));
                } else {
                  let n = null,
                    s = null,
                    a = null;
                  A.depth &&
                    ((a = A.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
                    (n = A.stencil ? ue : ce),
                    (s = A.stencil ? ne : J));
                  const o = {
                    colorFormat: t.RGBA8,
                    depthFormat: a,
                    scaleFactor: r,
                  };
                  (u = new XRWebGLBinding(i, t)),
                    (h = u.createProjectionLayer(o)),
                    i.updateRenderState({ layers: [h] }),
                    e.setPixelRatio(1),
                    e.setSize(h.textureWidth, h.textureHeight, !1),
                    (m = new nn(h.textureWidth, h.textureHeight, {
                      format: ae,
                      type: j,
                      depthTexture: new xs(
                        h.textureWidth,
                        h.textureHeight,
                        s,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        void 0,
                        n
                      ),
                      stencilBuffer: A.stencil,
                      colorSpace: e.outputColorSpace,
                      samples: A.antialias ? 4 : 0,
                      resolveDepthBuffer: !1 === h.ignoreDepthValues,
                    }));
                }
                (m.isXRRenderTarget = !0),
                  this.setFoveation(o),
                  (l = null),
                  (s = await i.requestReferenceSpace(a)),
                  U.setContext(i),
                  U.start(),
                  (n.isPresenting = !0),
                  n.dispatchEvent({ type: "sessionstart" });
              }
            }),
            (this.getEnvironmentBlendMode = function () {
              if (null !== i) return i.environmentBlendMode;
            }),
            (this.getDepthTexture = function () {
              return f.getDepthTexture();
            });
          const R = new on(),
            D = new on();
          function P(e, t) {
            null === t
              ? e.matrixWorld.copy(e.matrix)
              : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
              e.matrixWorldInverse.copy(e.matrixWorld).invert();
          }
          (this.updateCamera = function (e) {
            if (null === i) return;
            let t = e.near,
              n = e.far;
            null !== f.texture &&
              (f.depthNear > 0 && (t = f.depthNear),
              f.depthFar > 0 && (n = f.depthFar)),
              (C.near = E.near = b.near = t),
              (C.far = E.far = b.far = n),
              (I === C.near && S === C.far) ||
                (i.updateRenderState({ depthNear: C.near, depthFar: C.far }),
                (I = C.near),
                (S = C.far)),
              (b.layers.mask = 2 | e.layers.mask),
              (E.layers.mask = 4 | e.layers.mask),
              (C.layers.mask = b.layers.mask | E.layers.mask);
            const r = e.parent,
              s = C.cameras;
            P(C, r);
            for (let e = 0; e < s.length; e++) P(s[e], r);
            2 === s.length
              ? (function (e, t, n) {
                  R.setFromMatrixPosition(t.matrixWorld),
                    D.setFromMatrixPosition(n.matrixWorld);
                  const i = R.distanceTo(D),
                    r = t.projectionMatrix.elements,
                    s = n.projectionMatrix.elements,
                    a = r[14] / (r[10] - 1),
                    o = r[14] / (r[10] + 1),
                    l = (r[9] + 1) / r[5],
                    c = (r[9] - 1) / r[5],
                    u = (r[8] - 1) / r[0],
                    h = (s[8] + 1) / s[0],
                    d = a * u,
                    p = a * h,
                    f = i / (-u + h),
                    A = f * -u;
                  if (
                    (t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
                    e.translateX(A),
                    e.translateZ(f),
                    e.matrixWorld.compose(e.position, e.quaternion, e.scale),
                    e.matrixWorldInverse.copy(e.matrixWorld).invert(),
                    -1 === r[10])
                  )
                    e.projectionMatrix.copy(t.projectionMatrix),
                      e.projectionMatrixInverse.copy(t.projectionMatrixInverse);
                  else {
                    const t = a + f,
                      n = o + f,
                      r = d - A,
                      s = p + (i - A),
                      u = ((l * o) / n) * t,
                      h = ((c * o) / n) * t;
                    e.projectionMatrix.makePerspective(r, s, u, h, t, n),
                      e.projectionMatrixInverse
                        .copy(e.projectionMatrix)
                        .invert();
                  }
                })(C, b, E)
              : C.projectionMatrix.copy(b.projectionMatrix),
              (function (e, t, n) {
                null === n
                  ? e.matrix.copy(t.matrixWorld)
                  : (e.matrix.copy(n.matrixWorld),
                    e.matrix.invert(),
                    e.matrix.multiply(t.matrixWorld));
                e.matrix.decompose(e.position, e.quaternion, e.scale),
                  e.updateMatrixWorld(!0),
                  e.projectionMatrix.copy(t.projectionMatrix),
                  e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
                  e.isPerspectiveCamera &&
                    ((e.fov =
                      2 * Et * Math.atan(1 / e.projectionMatrix.elements[5])),
                    (e.zoom = 1));
              })(e, C, r);
          }),
            (this.getCamera = function () {
              return C;
            }),
            (this.getFoveation = function () {
              if (null !== h || null !== d) return o;
            }),
            (this.setFoveation = function (e) {
              (o = e),
                null !== h && (h.fixedFoveation = e),
                null !== d &&
                  void 0 !== d.fixedFoveation &&
                  (d.fixedFoveation = e);
            }),
            (this.hasDepthSensing = function () {
              return null !== f.texture;
            }),
            (this.getDepthSensingMesh = function () {
              return f.getMesh(C);
            });
          let L = null;
          const U = new Lr();
          U.setAnimationLoop(function (t, r) {
            if (((c = r.getViewerPose(l || s)), (p = r), null !== c)) {
              const t = c.views;
              null !== d &&
                (e.setRenderTargetFramebuffer(m, d.framebuffer),
                e.setRenderTarget(m));
              let n = !1;
              t.length !== C.cameras.length &&
                ((C.cameras.length = 0), (n = !0));
              for (let i = 0; i < t.length; i++) {
                const r = t[i];
                let s = null;
                if (null !== d) s = d.getViewport(r);
                else {
                  const t = u.getViewSubImage(h, r);
                  (s = t.viewport),
                    0 === i &&
                      (e.setRenderTargetTextures(
                        m,
                        t.colorTexture,
                        h.ignoreDepthValues ? void 0 : t.depthStencilTexture
                      ),
                      e.setRenderTarget(m));
                }
                let a = w[i];
                void 0 === a &&
                  ((a = new br()),
                  a.layers.enable(i),
                  (a.viewport = new en()),
                  (w[i] = a)),
                  a.matrix.fromArray(r.transform.matrix),
                  a.matrix.decompose(a.position, a.quaternion, a.scale),
                  a.projectionMatrix.fromArray(r.projectionMatrix),
                  a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
                  a.viewport.set(s.x, s.y, s.width, s.height),
                  0 === i &&
                    (C.matrix.copy(a.matrix),
                    C.matrix.decompose(C.position, C.quaternion, C.scale)),
                  !0 === n && C.cameras.push(a);
              }
              const r = i.enabledFeatures;
              if (r && r.includes("depth-sensing")) {
                const n = u.getDepthInformation(t[0]);
                n && n.isValid && n.texture && f.init(e, n, i.renderState);
              }
            }
            for (let e = 0; e < v.length; e++) {
              const t = y[e],
                n = v[e];
              null !== t && void 0 !== n && n.update(t, r, l || s);
            }
            L && L(t, r),
              r.detectedPlanes &&
                n.dispatchEvent({ type: "planesdetected", data: r }),
              (p = null);
          }),
            (this.setAnimationLoop = function (e) {
              L = e;
            }),
            (this.dispose = function () {});
        }
      }
      const Eo = new qn(),
        wo = new Nn();
      function Co(e, t) {
        function n(e, t) {
          !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix);
        }
        function i(e, i) {
          (e.opacity.value = i.opacity),
            i.color && e.diffuse.value.copy(i.color),
            i.emissive &&
              e.emissive.value
                .copy(i.emissive)
                .multiplyScalar(i.emissiveIntensity),
            i.map && ((e.map.value = i.map), n(i.map, e.mapTransform)),
            i.alphaMap &&
              ((e.alphaMap.value = i.alphaMap),
              n(i.alphaMap, e.alphaMapTransform)),
            i.bumpMap &&
              ((e.bumpMap.value = i.bumpMap),
              n(i.bumpMap, e.bumpMapTransform),
              (e.bumpScale.value = i.bumpScale),
              i.side === l && (e.bumpScale.value *= -1)),
            i.normalMap &&
              ((e.normalMap.value = i.normalMap),
              n(i.normalMap, e.normalMapTransform),
              e.normalScale.value.copy(i.normalScale),
              i.side === l && e.normalScale.value.negate()),
            i.displacementMap &&
              ((e.displacementMap.value = i.displacementMap),
              n(i.displacementMap, e.displacementMapTransform),
              (e.displacementScale.value = i.displacementScale),
              (e.displacementBias.value = i.displacementBias)),
            i.emissiveMap &&
              ((e.emissiveMap.value = i.emissiveMap),
              n(i.emissiveMap, e.emissiveMapTransform)),
            i.specularMap &&
              ((e.specularMap.value = i.specularMap),
              n(i.specularMap, e.specularMapTransform)),
            i.alphaTest > 0 && (e.alphaTest.value = i.alphaTest);
          const r = t.get(i),
            s = r.envMap,
            a = r.envMapRotation;
          s &&
            ((e.envMap.value = s),
            Eo.copy(a),
            (Eo.x *= -1),
            (Eo.y *= -1),
            (Eo.z *= -1),
            s.isCubeTexture &&
              !1 === s.isRenderTargetTexture &&
              ((Eo.y *= -1), (Eo.z *= -1)),
            e.envMapRotation.value.setFromMatrix4(wo.makeRotationFromEuler(Eo)),
            (e.flipEnvMap.value =
              s.isCubeTexture && !1 === s.isRenderTargetTexture ? -1 : 1),
            (e.reflectivity.value = i.reflectivity),
            (e.ior.value = i.ior),
            (e.refractionRatio.value = i.refractionRatio)),
            i.lightMap &&
              ((e.lightMap.value = i.lightMap),
              (e.lightMapIntensity.value = i.lightMapIntensity),
              n(i.lightMap, e.lightMapTransform)),
            i.aoMap &&
              ((e.aoMap.value = i.aoMap),
              (e.aoMapIntensity.value = i.aoMapIntensity),
              n(i.aoMap, e.aoMapTransform));
        }
        return {
          refreshFogUniforms: function (t, n) {
            n.color.getRGB(t.fogColor.value, Ar(e)),
              n.isFog
                ? ((t.fogNear.value = n.near), (t.fogFar.value = n.far))
                : n.isFogExp2 && (t.fogDensity.value = n.density);
          },
          refreshMaterialUniforms: function (e, r, s, a, o) {
            r.isMeshBasicMaterial || r.isMeshLambertMaterial
              ? i(e, r)
              : r.isMeshToonMaterial
              ? (i(e, r),
                (function (e, t) {
                  t.gradientMap && (e.gradientMap.value = t.gradientMap);
                })(e, r))
              : r.isMeshPhongMaterial
              ? (i(e, r),
                (function (e, t) {
                  e.specular.value.copy(t.specular),
                    (e.shininess.value = Math.max(t.shininess, 1e-4));
                })(e, r))
              : r.isMeshStandardMaterial
              ? (i(e, r),
                (function (e, t) {
                  (e.metalness.value = t.metalness),
                    t.metalnessMap &&
                      ((e.metalnessMap.value = t.metalnessMap),
                      n(t.metalnessMap, e.metalnessMapTransform));
                  (e.roughness.value = t.roughness),
                    t.roughnessMap &&
                      ((e.roughnessMap.value = t.roughnessMap),
                      n(t.roughnessMap, e.roughnessMapTransform));
                  t.envMap && (e.envMapIntensity.value = t.envMapIntensity);
                })(e, r),
                r.isMeshPhysicalMaterial &&
                  (function (e, t, i) {
                    (e.ior.value = t.ior),
                      t.sheen > 0 &&
                        (e.sheenColor.value
                          .copy(t.sheenColor)
                          .multiplyScalar(t.sheen),
                        (e.sheenRoughness.value = t.sheenRoughness),
                        t.sheenColorMap &&
                          ((e.sheenColorMap.value = t.sheenColorMap),
                          n(t.sheenColorMap, e.sheenColorMapTransform)),
                        t.sheenRoughnessMap &&
                          ((e.sheenRoughnessMap.value = t.sheenRoughnessMap),
                          n(
                            t.sheenRoughnessMap,
                            e.sheenRoughnessMapTransform
                          )));
                    t.clearcoat > 0 &&
                      ((e.clearcoat.value = t.clearcoat),
                      (e.clearcoatRoughness.value = t.clearcoatRoughness),
                      t.clearcoatMap &&
                        ((e.clearcoatMap.value = t.clearcoatMap),
                        n(t.clearcoatMap, e.clearcoatMapTransform)),
                      t.clearcoatRoughnessMap &&
                        ((e.clearcoatRoughnessMap.value =
                          t.clearcoatRoughnessMap),
                        n(
                          t.clearcoatRoughnessMap,
                          e.clearcoatRoughnessMapTransform
                        )),
                      t.clearcoatNormalMap &&
                        ((e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                        n(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                        e.clearcoatNormalScale.value.copy(
                          t.clearcoatNormalScale
                        ),
                        t.side === l && e.clearcoatNormalScale.value.negate()));
                    t.dispersion > 0 && (e.dispersion.value = t.dispersion);
                    t.iridescence > 0 &&
                      ((e.iridescence.value = t.iridescence),
                      (e.iridescenceIOR.value = t.iridescenceIOR),
                      (e.iridescenceThicknessMinimum.value =
                        t.iridescenceThicknessRange[0]),
                      (e.iridescenceThicknessMaximum.value =
                        t.iridescenceThicknessRange[1]),
                      t.iridescenceMap &&
                        ((e.iridescenceMap.value = t.iridescenceMap),
                        n(t.iridescenceMap, e.iridescenceMapTransform)),
                      t.iridescenceThicknessMap &&
                        ((e.iridescenceThicknessMap.value =
                          t.iridescenceThicknessMap),
                        n(
                          t.iridescenceThicknessMap,
                          e.iridescenceThicknessMapTransform
                        )));
                    t.transmission > 0 &&
                      ((e.transmission.value = t.transmission),
                      (e.transmissionSamplerMap.value = i.texture),
                      e.transmissionSamplerSize.value.set(i.width, i.height),
                      t.transmissionMap &&
                        ((e.transmissionMap.value = t.transmissionMap),
                        n(t.transmissionMap, e.transmissionMapTransform)),
                      (e.thickness.value = t.thickness),
                      t.thicknessMap &&
                        ((e.thicknessMap.value = t.thicknessMap),
                        n(t.thicknessMap, e.thicknessMapTransform)),
                      (e.attenuationDistance.value = t.attenuationDistance),
                      e.attenuationColor.value.copy(t.attenuationColor));
                    t.anisotropy > 0 &&
                      (e.anisotropyVector.value.set(
                        t.anisotropy * Math.cos(t.anisotropyRotation),
                        t.anisotropy * Math.sin(t.anisotropyRotation)
                      ),
                      t.anisotropyMap &&
                        ((e.anisotropyMap.value = t.anisotropyMap),
                        n(t.anisotropyMap, e.anisotropyMapTransform)));
                    (e.specularIntensity.value = t.specularIntensity),
                      e.specularColor.value.copy(t.specularColor),
                      t.specularColorMap &&
                        ((e.specularColorMap.value = t.specularColorMap),
                        n(t.specularColorMap, e.specularColorMapTransform));
                    t.specularIntensityMap &&
                      ((e.specularIntensityMap.value = t.specularIntensityMap),
                      n(
                        t.specularIntensityMap,
                        e.specularIntensityMapTransform
                      ));
                  })(e, r, o))
              : r.isMeshMatcapMaterial
              ? (i(e, r),
                (function (e, t) {
                  t.matcap && (e.matcap.value = t.matcap);
                })(e, r))
              : r.isMeshDepthMaterial
              ? i(e, r)
              : r.isMeshDistanceMaterial
              ? (i(e, r),
                (function (e, n) {
                  const i = t.get(n).light;
                  e.referencePosition.value.setFromMatrixPosition(
                    i.matrixWorld
                  ),
                    (e.nearDistance.value = i.shadow.camera.near),
                    (e.farDistance.value = i.shadow.camera.far);
                })(e, r))
              : r.isMeshNormalMaterial
              ? i(e, r)
              : r.isLineBasicMaterial
              ? ((function (e, t) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    t.map && ((e.map.value = t.map), n(t.map, e.mapTransform));
                })(e, r),
                r.isLineDashedMaterial &&
                  (function (e, t) {
                    (e.dashSize.value = t.dashSize),
                      (e.totalSize.value = t.dashSize + t.gapSize),
                      (e.scale.value = t.scale);
                  })(e, r))
              : r.isPointsMaterial
              ? (function (e, t, i, r) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.size.value = t.size * i),
                    (e.scale.value = 0.5 * r),
                    t.map && ((e.map.value = t.map), n(t.map, e.uvTransform));
                  t.alphaMap &&
                    ((e.alphaMap.value = t.alphaMap),
                    n(t.alphaMap, e.alphaMapTransform));
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                })(e, r, s, a)
              : r.isSpriteMaterial
              ? (function (e, t) {
                  e.diffuse.value.copy(t.color),
                    (e.opacity.value = t.opacity),
                    (e.rotation.value = t.rotation),
                    t.map && ((e.map.value = t.map), n(t.map, e.mapTransform));
                  t.alphaMap &&
                    ((e.alphaMap.value = t.alphaMap),
                    n(t.alphaMap, e.alphaMapTransform));
                  t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
                })(e, r)
              : r.isShadowMaterial
              ? (e.color.value.copy(r.color), (e.opacity.value = r.opacity))
              : r.isShaderMaterial && (r.uniformsNeedUpdate = !1);
          },
        };
      }
      function Io(e, t, n, i) {
        let r = {},
          s = {},
          a = [];
        const o = e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS);
        function l(e, t, n, i) {
          const r = e.value,
            s = t + "_" + n;
          if (void 0 === i[s])
            return (
              (i[s] =
                "number" == typeof r || "boolean" == typeof r ? r : r.clone()),
              !0
            );
          {
            const e = i[s];
            if ("number" == typeof r || "boolean" == typeof r) {
              if (e !== r) return (i[s] = r), !0;
            } else if (!1 === e.equals(r)) return e.copy(r), !0;
          }
          return !1;
        }
        function c(e) {
          const t = { boundary: 0, storage: 0 };
          return (
            "number" == typeof e || "boolean" == typeof e
              ? ((t.boundary = 4), (t.storage = 4))
              : e.isVector2
              ? ((t.boundary = 8), (t.storage = 8))
              : e.isVector3 || e.isColor
              ? ((t.boundary = 16), (t.storage = 12))
              : e.isVector4
              ? ((t.boundary = 16), (t.storage = 16))
              : e.isMatrix3
              ? ((t.boundary = 48), (t.storage = 48))
              : e.isMatrix4
              ? ((t.boundary = 64), (t.storage = 64))
              : e.isTexture
              ? console.warn(
                  "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
                )
              : console.warn(
                  "THREE.WebGLRenderer: Unsupported uniform value type.",
                  e
                ),
            t
          );
        }
        function u(t) {
          const n = t.target;
          n.removeEventListener("dispose", u);
          const i = a.indexOf(n.__bindingPointIndex);
          a.splice(i, 1),
            e.deleteBuffer(r[n.id]),
            delete r[n.id],
            delete s[n.id];
        }
        return {
          bind: function (e, t) {
            const n = t.program;
            i.uniformBlockBinding(e, n);
          },
          update: function (n, h) {
            let d = r[n.id];
            void 0 === d &&
              (!(function (e) {
                const t = e.uniforms;
                let n = 0;
                const i = 16;
                for (let e = 0, r = t.length; e < r; e++) {
                  const r = Array.isArray(t[e]) ? t[e] : [t[e]];
                  for (let e = 0, t = r.length; e < t; e++) {
                    const t = r[e],
                      s = Array.isArray(t.value) ? t.value : [t.value];
                    for (let e = 0, r = s.length; e < r; e++) {
                      const r = c(s[e]),
                        a = n % i,
                        o = a % r.boundary,
                        l = a + o;
                      (n += o),
                        0 !== l && i - l < r.storage && (n += i - l),
                        (t.__data = new Float32Array(
                          r.storage / Float32Array.BYTES_PER_ELEMENT
                        )),
                        (t.__offset = n),
                        (n += r.storage);
                    }
                  }
                }
                const r = n % i;
                r > 0 && (n += i - r);
                (e.__size = n), (e.__cache = {});
              })(n),
              (d = (function (t) {
                const n = (function () {
                  for (let e = 0; e < o; e++)
                    if (-1 === a.indexOf(e)) return a.push(e), e;
                  return (
                    console.error(
                      "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
                    ),
                    0
                  );
                })();
                t.__bindingPointIndex = n;
                const i = e.createBuffer(),
                  r = t.__size,
                  s = t.usage;
                return (
                  e.bindBuffer(e.UNIFORM_BUFFER, i),
                  e.bufferData(e.UNIFORM_BUFFER, r, s),
                  e.bindBuffer(e.UNIFORM_BUFFER, null),
                  e.bindBufferBase(e.UNIFORM_BUFFER, n, i),
                  i
                );
              })(n)),
              (r[n.id] = d),
              n.addEventListener("dispose", u));
            const p = h.program;
            i.updateUBOMapping(n, p);
            const f = t.render.frame;
            s[n.id] !== f &&
              (!(function (t) {
                const n = r[t.id],
                  i = t.uniforms,
                  s = t.__cache;
                e.bindBuffer(e.UNIFORM_BUFFER, n);
                for (let t = 0, n = i.length; t < n; t++) {
                  const n = Array.isArray(i[t]) ? i[t] : [i[t]];
                  for (let i = 0, r = n.length; i < r; i++) {
                    const r = n[i];
                    if (!0 === l(r, t, i, s)) {
                      const t = r.__offset,
                        n = Array.isArray(r.value) ? r.value : [r.value];
                      let i = 0;
                      for (let s = 0; s < n.length; s++) {
                        const a = n[s],
                          o = c(a);
                        "number" == typeof a || "boolean" == typeof a
                          ? ((r.__data[0] = a),
                            e.bufferSubData(e.UNIFORM_BUFFER, t + i, r.__data))
                          : a.isMatrix3
                          ? ((r.__data[0] = a.elements[0]),
                            (r.__data[1] = a.elements[1]),
                            (r.__data[2] = a.elements[2]),
                            (r.__data[3] = 0),
                            (r.__data[4] = a.elements[3]),
                            (r.__data[5] = a.elements[4]),
                            (r.__data[6] = a.elements[5]),
                            (r.__data[7] = 0),
                            (r.__data[8] = a.elements[6]),
                            (r.__data[9] = a.elements[7]),
                            (r.__data[10] = a.elements[8]),
                            (r.__data[11] = 0))
                          : (a.toArray(r.__data, i),
                            (i += o.storage / Float32Array.BYTES_PER_ELEMENT));
                      }
                      e.bufferSubData(e.UNIFORM_BUFFER, t, r.__data);
                    }
                  }
                }
                e.bindBuffer(e.UNIFORM_BUFFER, null);
              })(n),
              (s[n.id] = f));
          },
          dispose: function () {
            for (const t in r) e.deleteBuffer(r[t]);
            (a = []), (r = {}), (s = {});
          },
        };
      }
      class So {
        constructor(e = {}) {
          const {
            canvas: t = Ft(),
            context: n = null,
            depth: r = !0,
            stencil: s = !1,
            alpha: a = !1,
            antialias: u = !1,
            premultipliedAlpha: h = !0,
            preserveDrawingBuffer: d = !1,
            powerPreference: p = "default",
            failIfMajorPerformanceCaveat: f = !1,
            reverseDepthBuffer: A = !1,
          } = e;
          let g;
          if (((this.isWebGLRenderer = !0), null !== n)) {
            if (
              "undefined" != typeof WebGLRenderingContext &&
              n instanceof WebGLRenderingContext
            )
              throw new Error(
                "THREE.WebGLRenderer: WebGL 1 is not supported since r163."
              );
            g = n.getContextAttributes().alpha;
          } else g = a;
          const m = new Uint32Array(4),
            v = new Int32Array(4);
          let y = null,
            x = null;
          const _ = [],
            b = [];
          (this.domElement = t),
            (this.debug = { checkShaderErrors: !0, onShaderError: null }),
            (this.autoClear = !0),
            (this.autoClearColor = !0),
            (this.autoClearDepth = !0),
            (this.autoClearStencil = !0),
            (this.sortObjects = !0),
            (this.clippingPlanes = []),
            (this.localClippingEnabled = !1),
            (this._outputColorSpace = ct),
            (this.toneMapping = E),
            (this.toneMappingExposure = 1);
          const w = this;
          let C = !1,
            I = 0,
            S = 0,
            M = null,
            T = -1,
            B = null;
          const R = new en(),
            D = new en();
          let P = null;
          const L = new Ti(0);
          let U = 0,
            F = t.width,
            N = t.height,
            O = 1,
            Q = null,
            k = null;
          const G = new en(0, 0, F, N),
            H = new en(0, 0, F, N);
          let z = !1;
          const V = new Pr();
          let q = !1,
            Y = !1;
          const K = new Nn(),
            Z = new Nn(),
            ie = new on(),
            re = new en(),
            se = {
              background: null,
              fog: null,
              environment: null,
              overrideMaterial: null,
              isScene: !0,
            };
          let ae = !1;
          function oe() {
            return null === M ? O : 1;
          }
          let le,
            ce,
            ue,
            he,
            pe,
            ge,
            me,
            ve,
            ye,
            xe,
            _e,
            be,
            Ee,
            we,
            Ce,
            Ie,
            Se,
            Me,
            Te,
            Be,
            Re,
            De,
            Pe,
            Le,
            Ue = n;
          function Fe(e, n) {
            return t.getContext(e, n);
          }
          try {
            const e = {
              alpha: !0,
              depth: r,
              stencil: s,
              antialias: u,
              premultipliedAlpha: h,
              preserveDrawingBuffer: d,
              powerPreference: p,
              failIfMajorPerformanceCaveat: f,
            };
            if (
              ("setAttribute" in t &&
                t.setAttribute("data-engine", `three.js r${i}`),
              t.addEventListener("webglcontextlost", Qe, !1),
              t.addEventListener("webglcontextrestored", ke, !1),
              t.addEventListener("webglcontextcreationerror", Ge, !1),
              null === Ue)
            ) {
              const t = "webgl2";
              if (((Ue = Fe(t, e)), null === Ue))
                throw Fe(t)
                  ? new Error(
                      "Error creating WebGL context with your selected attributes."
                    )
                  : new Error("Error creating WebGL context.");
            }
          } catch (e) {
            throw (console.error("THREE.WebGLRenderer: " + e.message), e);
          }
          function Ne() {
            (le = new fs(Ue)),
              le.init(),
              (De = new go(Ue, le)),
              (ce = new jr(Ue, le, e, De)),
              (ue = new po(Ue, le)),
              ce.reverseDepthBuffer && A && ue.buffers.depth.setReversed(!0),
              (he = new ms(Ue)),
              (pe = new Ja()),
              (ge = new Ao(Ue, le, ue, pe, ce, De, he)),
              (me = new Yr(w)),
              (ve = new ps(w)),
              (ye = new Ur(Ue)),
              (Pe = new Vr(Ue, ye)),
              (xe = new As(Ue, ye, he, Pe)),
              (_e = new ys(Ue, xe, ye, he)),
              (Te = new vs(Ue, ce, ge)),
              (Ie = new qr(pe)),
              (be = new Ka(w, me, ve, le, ce, Pe, Ie)),
              (Ee = new Co(w, pe)),
              (we = new to()),
              (Ce = new oo(le)),
              (Me = new zr(w, me, ve, ue, _e, g, h)),
              (Se = new uo(w, _e, ce)),
              (Le = new Io(Ue, he, ce, ue)),
              (Be = new Wr(Ue, le, he)),
              (Re = new gs(Ue, le, he)),
              (he.programs = be.programs),
              (w.capabilities = ce),
              (w.extensions = le),
              (w.properties = pe),
              (w.renderLists = we),
              (w.shadowMap = Se),
              (w.state = ue),
              (w.info = he);
          }
          Ne();
          const Oe = new bo(w, Ue);
          function Qe(e) {
            e.preventDefault(),
              console.log("THREE.WebGLRenderer: Context Lost."),
              (C = !0);
          }
          function ke() {
            console.log("THREE.WebGLRenderer: Context Restored."), (C = !1);
            const e = he.autoReset,
              t = Se.enabled,
              n = Se.autoUpdate,
              i = Se.needsUpdate,
              r = Se.type;
            Ne(),
              (he.autoReset = e),
              (Se.enabled = t),
              (Se.autoUpdate = n),
              (Se.needsUpdate = i),
              (Se.type = r);
          }
          function Ge(e) {
            console.error(
              "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
              e.statusMessage
            );
          }
          function He(e) {
            const t = e.target;
            t.removeEventListener("dispose", He),
              (function (e) {
                (function (e) {
                  const t = pe.get(e).programs;
                  void 0 !== t &&
                    (t.forEach(function (e) {
                      be.releaseProgram(e);
                    }),
                    e.isShaderMaterial && be.releaseShaderCache(e));
                })(e),
                  pe.remove(e);
              })(t);
          }
          function ze(e, t, n) {
            !0 === e.transparent && e.side === c && !1 === e.forceSinglePass
              ? ((e.side = l),
                (e.needsUpdate = !0),
                $e(e, t, n),
                (e.side = o),
                (e.needsUpdate = !0),
                $e(e, t, n),
                (e.side = c))
              : $e(e, t, n);
          }
          (this.xr = Oe),
            (this.getContext = function () {
              return Ue;
            }),
            (this.getContextAttributes = function () {
              return Ue.getContextAttributes();
            }),
            (this.forceContextLoss = function () {
              const e = le.get("WEBGL_lose_context");
              e && e.loseContext();
            }),
            (this.forceContextRestore = function () {
              const e = le.get("WEBGL_lose_context");
              e && e.restoreContext();
            }),
            (this.getPixelRatio = function () {
              return O;
            }),
            (this.setPixelRatio = function (e) {
              void 0 !== e && ((O = e), this.setSize(F, N, !1));
            }),
            (this.getSize = function (e) {
              return e.set(F, N);
            }),
            (this.setSize = function (e, n, i = !0) {
              Oe.isPresenting
                ? console.warn(
                    "THREE.WebGLRenderer: Can't change size while VR device is presenting."
                  )
                : ((F = e),
                  (N = n),
                  (t.width = Math.floor(e * O)),
                  (t.height = Math.floor(n * O)),
                  !0 === i &&
                    ((t.style.width = e + "px"), (t.style.height = n + "px")),
                  this.setViewport(0, 0, e, n));
            }),
            (this.getDrawingBufferSize = function (e) {
              return e.set(F * O, N * O).floor();
            }),
            (this.setDrawingBufferSize = function (e, n, i) {
              (F = e),
                (N = n),
                (O = i),
                (t.width = Math.floor(e * i)),
                (t.height = Math.floor(n * i)),
                this.setViewport(0, 0, e, n);
            }),
            (this.getCurrentViewport = function (e) {
              return e.copy(R);
            }),
            (this.getViewport = function (e) {
              return e.copy(G);
            }),
            (this.setViewport = function (e, t, n, i) {
              e.isVector4 ? G.set(e.x, e.y, e.z, e.w) : G.set(e, t, n, i),
                ue.viewport(R.copy(G).multiplyScalar(O).round());
            }),
            (this.getScissor = function (e) {
              return e.copy(H);
            }),
            (this.setScissor = function (e, t, n, i) {
              e.isVector4 ? H.set(e.x, e.y, e.z, e.w) : H.set(e, t, n, i),
                ue.scissor(D.copy(H).multiplyScalar(O).round());
            }),
            (this.getScissorTest = function () {
              return z;
            }),
            (this.setScissorTest = function (e) {
              ue.setScissorTest((z = e));
            }),
            (this.setOpaqueSort = function (e) {
              Q = e;
            }),
            (this.setTransparentSort = function (e) {
              k = e;
            }),
            (this.getClearColor = function (e) {
              return e.copy(Me.getClearColor());
            }),
            (this.setClearColor = function () {
              Me.setClearColor.apply(Me, arguments);
            }),
            (this.getClearAlpha = function () {
              return Me.getClearAlpha();
            }),
            (this.setClearAlpha = function () {
              Me.setClearAlpha.apply(Me, arguments);
            }),
            (this.clear = function (e = !0, t = !0, n = !0) {
              let i = 0;
              if (e) {
                let e = !1;
                if (null !== M) {
                  const t = M.texture.format;
                  e = t === Ae || t === fe || t === de;
                }
                if (e) {
                  const e = M.texture.type,
                    t =
                      e === j ||
                      e === J ||
                      e === X ||
                      e === ne ||
                      e === ee ||
                      e === te,
                    n = Me.getClearColor(),
                    i = Me.getClearAlpha(),
                    r = n.r,
                    s = n.g,
                    a = n.b;
                  t
                    ? ((m[0] = r),
                      (m[1] = s),
                      (m[2] = a),
                      (m[3] = i),
                      Ue.clearBufferuiv(Ue.COLOR, 0, m))
                    : ((v[0] = r),
                      (v[1] = s),
                      (v[2] = a),
                      (v[3] = i),
                      Ue.clearBufferiv(Ue.COLOR, 0, v));
                } else i |= Ue.COLOR_BUFFER_BIT;
              }
              t && (i |= Ue.DEPTH_BUFFER_BIT),
                n &&
                  ((i |= Ue.STENCIL_BUFFER_BIT),
                  this.state.buffers.stencil.setMask(4294967295)),
                Ue.clear(i);
            }),
            (this.clearColor = function () {
              this.clear(!0, !1, !1);
            }),
            (this.clearDepth = function () {
              this.clear(!1, !0, !1);
            }),
            (this.clearStencil = function () {
              this.clear(!1, !1, !0);
            }),
            (this.dispose = function () {
              t.removeEventListener("webglcontextlost", Qe, !1),
                t.removeEventListener("webglcontextrestored", ke, !1),
                t.removeEventListener("webglcontextcreationerror", Ge, !1),
                we.dispose(),
                Ce.dispose(),
                pe.dispose(),
                me.dispose(),
                ve.dispose(),
                _e.dispose(),
                Pe.dispose(),
                Le.dispose(),
                be.dispose(),
                Oe.dispose(),
                Oe.removeEventListener("sessionstart", We),
                Oe.removeEventListener("sessionend", je),
                qe.stop();
            }),
            (this.renderBufferDirect = function (e, t, n, i, r, s) {
              null === t && (t = se);
              const a = r.isMesh && r.matrixWorld.determinant() < 0,
                o = (function (e, t, n, i, r) {
                  !0 !== t.isScene && (t = se);
                  ge.resetTextureUnits();
                  const s = t.fog,
                    a = i.isMeshStandardMaterial ? t.environment : null,
                    o =
                      null === M
                        ? w.outputColorSpace
                        : !0 === M.isXRRenderTarget
                        ? M.texture.colorSpace
                        : ut,
                    l = (i.isMeshStandardMaterial ? ve : me).get(i.envMap || a),
                    c =
                      !0 === i.vertexColors &&
                      !!n.attributes.color &&
                      4 === n.attributes.color.itemSize,
                    u =
                      !!n.attributes.tangent &&
                      (!!i.normalMap || i.anisotropy > 0),
                    h = !!n.morphAttributes.position,
                    d = !!n.morphAttributes.normal,
                    p = !!n.morphAttributes.color;
                  let f = E;
                  i.toneMapped &&
                    ((null !== M && !0 !== M.isXRRenderTarget) ||
                      (f = w.toneMapping));
                  const A =
                      n.morphAttributes.position ||
                      n.morphAttributes.normal ||
                      n.morphAttributes.color,
                    g = void 0 !== A ? A.length : 0,
                    m = pe.get(i),
                    v = x.state.lights;
                  if (!0 === q && (!0 === Y || e !== B)) {
                    const t = e === B && i.id === T;
                    Ie.setState(i, e, t);
                  }
                  let y = !1;
                  i.version === m.__version
                    ? (m.needsLights &&
                        m.lightsStateVersion !== v.state.version) ||
                      m.outputColorSpace !== o ||
                      (r.isBatchedMesh && !1 === m.batching)
                      ? (y = !0)
                      : r.isBatchedMesh || !0 !== m.batching
                      ? (r.isBatchedMesh &&
                          !0 === m.batchingColor &&
                          null === r.colorTexture) ||
                        (r.isBatchedMesh &&
                          !1 === m.batchingColor &&
                          null !== r.colorTexture) ||
                        (r.isInstancedMesh && !1 === m.instancing)
                        ? (y = !0)
                        : r.isInstancedMesh || !0 !== m.instancing
                        ? r.isSkinnedMesh && !1 === m.skinning
                          ? (y = !0)
                          : r.isSkinnedMesh || !0 !== m.skinning
                          ? (r.isInstancedMesh &&
                              !0 === m.instancingColor &&
                              null === r.instanceColor) ||
                            (r.isInstancedMesh &&
                              !1 === m.instancingColor &&
                              null !== r.instanceColor) ||
                            (r.isInstancedMesh &&
                              !0 === m.instancingMorph &&
                              null === r.morphTexture) ||
                            (r.isInstancedMesh &&
                              !1 === m.instancingMorph &&
                              null !== r.morphTexture) ||
                            m.envMap !== l ||
                            (!0 === i.fog && m.fog !== s)
                            ? (y = !0)
                            : void 0 === m.numClippingPlanes ||
                              (m.numClippingPlanes === Ie.numPlanes &&
                                m.numIntersection === Ie.numIntersection)
                            ? (m.vertexAlphas !== c ||
                                m.vertexTangents !== u ||
                                m.morphTargets !== h ||
                                m.morphNormals !== d ||
                                m.morphColors !== p ||
                                m.toneMapping !== f ||
                                m.morphTargetsCount !== g) &&
                              (y = !0)
                            : (y = !0)
                          : (y = !0)
                        : (y = !0)
                      : (y = !0)
                    : ((y = !0), (m.__version = i.version));
                  let _ = m.currentProgram;
                  !0 === y && (_ = $e(i, t, r));
                  let b = !1,
                    C = !1,
                    I = !1;
                  const S = _.getUniforms(),
                    R = m.uniforms;
                  ue.useProgram(_.program) && ((b = !0), (C = !0), (I = !0));
                  i.id !== T && ((T = i.id), (C = !0));
                  if (b || B !== e) {
                    ue.buffers.depth.getReversed()
                      ? (K.copy(e.projectionMatrix),
                        (function (e) {
                          const t = e.elements;
                          (t[2] = 0.5 * t[2] + 0.5 * t[3]),
                            (t[6] = 0.5 * t[6] + 0.5 * t[7]),
                            (t[10] = 0.5 * t[10] + 0.5 * t[11]),
                            (t[14] = 0.5 * t[14] + 0.5 * t[15]);
                        })(K),
                        (function (e) {
                          const t = e.elements;
                          -1 === t[11]
                            ? ((t[10] = -t[10] - 1), (t[14] = -t[14]))
                            : ((t[10] = -t[10]), (t[14] = 1 - t[14]));
                        })(K),
                        S.setValue(Ue, "projectionMatrix", K))
                      : S.setValue(Ue, "projectionMatrix", e.projectionMatrix),
                      S.setValue(Ue, "viewMatrix", e.matrixWorldInverse);
                    const t = S.map.cameraPosition;
                    void 0 !== t &&
                      t.setValue(Ue, ie.setFromMatrixPosition(e.matrixWorld)),
                      ce.logarithmicDepthBuffer &&
                        S.setValue(
                          Ue,
                          "logDepthBufFC",
                          2 / (Math.log(e.far + 1) / Math.LN2)
                        ),
                      (i.isMeshPhongMaterial ||
                        i.isMeshToonMaterial ||
                        i.isMeshLambertMaterial ||
                        i.isMeshBasicMaterial ||
                        i.isMeshStandardMaterial ||
                        i.isShaderMaterial) &&
                        S.setValue(
                          Ue,
                          "isOrthographic",
                          !0 === e.isOrthographicCamera
                        ),
                      B !== e && ((B = e), (C = !0), (I = !0));
                  }
                  if (r.isSkinnedMesh) {
                    S.setOptional(Ue, r, "bindMatrix"),
                      S.setOptional(Ue, r, "bindMatrixInverse");
                    const e = r.skeleton;
                    e &&
                      (null === e.boneTexture && e.computeBoneTexture(),
                      S.setValue(Ue, "boneTexture", e.boneTexture, ge));
                  }
                  r.isBatchedMesh &&
                    (S.setOptional(Ue, r, "batchingTexture"),
                    S.setValue(Ue, "batchingTexture", r._matricesTexture, ge),
                    S.setOptional(Ue, r, "batchingIdTexture"),
                    S.setValue(Ue, "batchingIdTexture", r._indirectTexture, ge),
                    S.setOptional(Ue, r, "batchingColorTexture"),
                    null !== r._colorsTexture &&
                      S.setValue(
                        Ue,
                        "batchingColorTexture",
                        r._colorsTexture,
                        ge
                      ));
                  const D = n.morphAttributes;
                  (void 0 === D.position &&
                    void 0 === D.normal &&
                    void 0 === D.color) ||
                    Te.update(r, n, _);
                  (C || m.receiveShadow !== r.receiveShadow) &&
                    ((m.receiveShadow = r.receiveShadow),
                    S.setValue(Ue, "receiveShadow", r.receiveShadow));
                  i.isMeshGouraudMaterial &&
                    null !== i.envMap &&
                    ((R.envMap.value = l),
                    (R.flipEnvMap.value =
                      l.isCubeTexture && !1 === l.isRenderTargetTexture
                        ? -1
                        : 1));
                  i.isMeshStandardMaterial &&
                    null === i.envMap &&
                    null !== t.environment &&
                    (R.envMapIntensity.value = t.environmentIntensity);
                  C &&
                    (S.setValue(
                      Ue,
                      "toneMappingExposure",
                      w.toneMappingExposure
                    ),
                    m.needsLights &&
                      ((L = I),
                      ((P = R).ambientLightColor.needsUpdate = L),
                      (P.lightProbe.needsUpdate = L),
                      (P.directionalLights.needsUpdate = L),
                      (P.directionalLightShadows.needsUpdate = L),
                      (P.pointLights.needsUpdate = L),
                      (P.pointLightShadows.needsUpdate = L),
                      (P.spotLights.needsUpdate = L),
                      (P.spotLightShadows.needsUpdate = L),
                      (P.rectAreaLights.needsUpdate = L),
                      (P.hemisphereLights.needsUpdate = L)),
                    s && !0 === i.fog && Ee.refreshFogUniforms(R, s),
                    Ee.refreshMaterialUniforms(
                      R,
                      i,
                      O,
                      N,
                      x.state.transmissionRenderTarget[e.id]
                    ),
                    Ca.upload(Ue, et(m), R, ge));
                  var P, L;
                  i.isShaderMaterial &&
                    !0 === i.uniformsNeedUpdate &&
                    (Ca.upload(Ue, et(m), R, ge), (i.uniformsNeedUpdate = !1));
                  i.isSpriteMaterial && S.setValue(Ue, "center", r.center);
                  if (
                    (S.setValue(Ue, "modelViewMatrix", r.modelViewMatrix),
                    S.setValue(Ue, "normalMatrix", r.normalMatrix),
                    S.setValue(Ue, "modelMatrix", r.matrixWorld),
                    i.isShaderMaterial || i.isRawShaderMaterial)
                  ) {
                    const e = i.uniformsGroups;
                    for (let t = 0, n = e.length; t < n; t++) {
                      const n = e[t];
                      Le.update(n, _), Le.bind(n, _);
                    }
                  }
                  return _;
                })(e, t, n, i, r);
              ue.setMaterial(i, a);
              let l = n.index,
                c = 1;
              if (!0 === i.wireframe) {
                if (((l = xe.getWireframeAttribute(n)), void 0 === l)) return;
                c = 2;
              }
              const u = n.drawRange,
                h = n.attributes.position;
              let d = u.start * c,
                p = (u.start + u.count) * c;
              null !== s &&
                ((d = Math.max(d, s.start * c)),
                (p = Math.min(p, (s.start + s.count) * c))),
                null !== l
                  ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
                  : null != h &&
                    ((d = Math.max(d, 0)), (p = Math.min(p, h.count)));
              const f = p - d;
              if (f < 0 || f === 1 / 0) return;
              let A;
              Pe.setup(r, i, o, n, l);
              let g = Be;
              if (
                (null !== l && ((A = ye.get(l)), (g = Re), g.setIndex(A)),
                r.isMesh)
              )
                !0 === i.wireframe
                  ? (ue.setLineWidth(i.wireframeLinewidth * oe()),
                    g.setMode(Ue.LINES))
                  : g.setMode(Ue.TRIANGLES);
              else if (r.isLine) {
                let e = i.linewidth;
                void 0 === e && (e = 1),
                  ue.setLineWidth(e * oe()),
                  r.isLineSegments
                    ? g.setMode(Ue.LINES)
                    : r.isLineLoop
                    ? g.setMode(Ue.LINE_LOOP)
                    : g.setMode(Ue.LINE_STRIP);
              } else
                r.isPoints
                  ? g.setMode(Ue.POINTS)
                  : r.isSprite && g.setMode(Ue.TRIANGLES);
              if (r.isBatchedMesh)
                if (null !== r._multiDrawInstances)
                  g.renderMultiDrawInstances(
                    r._multiDrawStarts,
                    r._multiDrawCounts,
                    r._multiDrawCount,
                    r._multiDrawInstances
                  );
                else if (le.get("WEBGL_multi_draw"))
                  g.renderMultiDraw(
                    r._multiDrawStarts,
                    r._multiDrawCounts,
                    r._multiDrawCount
                  );
                else {
                  const e = r._multiDrawStarts,
                    t = r._multiDrawCounts,
                    n = r._multiDrawCount,
                    s = l ? ye.get(l).bytesPerElement : 1,
                    a = pe.get(i).currentProgram.getUniforms();
                  for (let i = 0; i < n; i++)
                    a.setValue(Ue, "_gl_DrawID", i), g.render(e[i] / s, t[i]);
                }
              else if (r.isInstancedMesh) g.renderInstances(d, f, r.count);
              else if (n.isInstancedBufferGeometry) {
                const e =
                    void 0 !== n._maxInstanceCount
                      ? n._maxInstanceCount
                      : 1 / 0,
                  t = Math.min(n.instanceCount, e);
                g.renderInstances(d, f, t);
              } else g.render(d, f);
            }),
            (this.compile = function (e, t, n = null) {
              null === n && (n = e),
                (x = Ce.get(n)),
                x.init(t),
                b.push(x),
                n.traverseVisible(function (e) {
                  e.isLight &&
                    e.layers.test(t.layers) &&
                    (x.pushLight(e), e.castShadow && x.pushShadow(e));
                }),
                e !== n &&
                  e.traverseVisible(function (e) {
                    e.isLight &&
                      e.layers.test(t.layers) &&
                      (x.pushLight(e), e.castShadow && x.pushShadow(e));
                  }),
                x.setupLights();
              const i = new Set();
              return (
                e.traverse(function (e) {
                  if (!(e.isMesh || e.isPoints || e.isLine || e.isSprite))
                    return;
                  const t = e.material;
                  if (t)
                    if (Array.isArray(t))
                      for (let r = 0; r < t.length; r++) {
                        const s = t[r];
                        ze(s, n, e), i.add(s);
                      }
                    else ze(t, n, e), i.add(t);
                }),
                b.pop(),
                (x = null),
                i
              );
            }),
            (this.compileAsync = function (e, t, n = null) {
              const i = this.compile(e, t, n);
              return new Promise((t) => {
                function n() {
                  i.forEach(function (e) {
                    pe.get(e).currentProgram.isReady() && i.delete(e);
                  }),
                    0 !== i.size ? setTimeout(n, 10) : t(e);
                }
                null !== le.get("KHR_parallel_shader_compile")
                  ? n()
                  : setTimeout(n, 10);
              });
            });
          let Ve = null;
          function We() {
            qe.stop();
          }
          function je() {
            qe.start();
          }
          const qe = new Lr();
          function Ye(e, t, n, i) {
            if (!1 === e.visible) return;
            if (e.layers.test(t.layers))
              if (e.isGroup) n = e.renderOrder;
              else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
              else if (e.isLight)
                x.pushLight(e), e.castShadow && x.pushShadow(e);
              else if (e.isSprite) {
                if (!e.frustumCulled || V.intersectsSprite(e)) {
                  i && re.setFromMatrixPosition(e.matrixWorld).applyMatrix4(Z);
                  const t = _e.update(e),
                    r = e.material;
                  r.visible && y.push(e, t, r, n, re.z, null);
                }
              } else if (
                (e.isMesh || e.isLine || e.isPoints) &&
                (!e.frustumCulled || V.intersectsObject(e))
              ) {
                const t = _e.update(e),
                  r = e.material;
                if (
                  (i &&
                    (void 0 !== e.boundingSphere
                      ? (null === e.boundingSphere && e.computeBoundingSphere(),
                        re.copy(e.boundingSphere.center))
                      : (null === t.boundingSphere && t.computeBoundingSphere(),
                        re.copy(t.boundingSphere.center)),
                    re.applyMatrix4(e.matrixWorld).applyMatrix4(Z)),
                  Array.isArray(r))
                ) {
                  const i = t.groups;
                  for (let s = 0, a = i.length; s < a; s++) {
                    const a = i[s],
                      o = r[a.materialIndex];
                    o && o.visible && y.push(e, t, o, n, re.z, a);
                  }
                } else r.visible && y.push(e, t, r, n, re.z, null);
              }
            const r = e.children;
            for (let e = 0, s = r.length; e < s; e++) Ye(r[e], t, n, i);
          }
          function Xe(e, t, n, i) {
            const r = e.opaque,
              s = e.transmissive,
              a = e.transparent;
            x.setupLightsView(n),
              !0 === q && Ie.setGlobalState(w.clippingPlanes, n),
              i && ue.viewport(R.copy(i)),
              r.length > 0 && Je(r, t, n),
              s.length > 0 && Je(s, t, n),
              a.length > 0 && Je(a, t, n),
              ue.buffers.depth.setTest(!0),
              ue.buffers.depth.setMask(!0),
              ue.buffers.color.setMask(!0),
              ue.setPolygonOffset(!1);
          }
          function Ke(e, t, n, i) {
            if (null !== (!0 === n.isScene ? n.overrideMaterial : null)) return;
            void 0 === x.state.transmissionRenderTarget[i.id] &&
              (x.state.transmissionRenderTarget[i.id] = new nn(1, 1, {
                generateMipmaps: !0,
                type:
                  le.has("EXT_color_buffer_half_float") ||
                  le.has("EXT_color_buffer_float")
                    ? $
                    : j,
                minFilter: W,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: Qt.workingColorSpace,
              }));
            const r = x.state.transmissionRenderTarget[i.id],
              a = i.viewport || R;
            r.setSize(a.z, a.w);
            const o = w.getRenderTarget();
            w.setRenderTarget(r),
              w.getClearColor(L),
              (U = w.getClearAlpha()),
              U < 1 && w.setClearColor(16777215, 0.5),
              w.clear(),
              ae && Me.render(n);
            const u = w.toneMapping;
            w.toneMapping = E;
            const h = i.viewport;
            if (
              (void 0 !== i.viewport && (i.viewport = void 0),
              x.setupLightsView(i),
              !0 === q && Ie.setGlobalState(w.clippingPlanes, i),
              Je(e, n, i),
              ge.updateMultisampleRenderTarget(r),
              ge.updateRenderTargetMipmap(r),
              !1 === le.has("WEBGL_multisampled_render_to_texture"))
            ) {
              let e = !1;
              for (let r = 0, s = t.length; r < s; r++) {
                const s = t[r],
                  a = s.object,
                  o = s.geometry,
                  u = s.material,
                  h = s.group;
                if (u.side === c && a.layers.test(i.layers)) {
                  const t = u.side;
                  (u.side = l),
                    (u.needsUpdate = !0),
                    Ze(a, n, i, o, u, h),
                    (u.side = t),
                    (u.needsUpdate = !0),
                    (e = !0);
                }
              }
              !0 === e &&
                (ge.updateMultisampleRenderTarget(r),
                ge.updateRenderTargetMipmap(r));
            }
            w.setRenderTarget(o),
              w.setClearColor(L, U),
              void 0 !== h && (i.viewport = h),
              (w.toneMapping = u);
          }
          function Je(e, t, n) {
            const i = !0 === t.isScene ? t.overrideMaterial : null;
            for (let r = 0, s = e.length; r < s; r++) {
              const s = e[r],
                a = s.object,
                o = s.geometry,
                l = null === i ? s.material : i,
                c = s.group;
              a.layers.test(n.layers) && Ze(a, t, n, o, l, c);
            }
          }
          function Ze(e, t, n, i, r, s) {
            e.onBeforeRender(w, t, n, i, r, s),
              e.modelViewMatrix.multiplyMatrices(
                n.matrixWorldInverse,
                e.matrixWorld
              ),
              e.normalMatrix.getNormalMatrix(e.modelViewMatrix),
              r.onBeforeRender(w, t, n, i, e, s),
              !0 === r.transparent && r.side === c && !1 === r.forceSinglePass
                ? ((r.side = l),
                  (r.needsUpdate = !0),
                  w.renderBufferDirect(n, t, i, r, e, s),
                  (r.side = o),
                  (r.needsUpdate = !0),
                  w.renderBufferDirect(n, t, i, r, e, s),
                  (r.side = c))
                : w.renderBufferDirect(n, t, i, r, e, s),
              e.onAfterRender(w, t, n, i, r, s);
          }
          function $e(e, t, n) {
            !0 !== t.isScene && (t = se);
            const i = pe.get(e),
              r = x.state.lights,
              s = x.state.shadowsArray,
              a = r.state.version,
              o = be.getParameters(e, r.state, s, t, n),
              l = be.getProgramCacheKey(o);
            let c = i.programs;
            (i.environment = e.isMeshStandardMaterial ? t.environment : null),
              (i.fog = t.fog),
              (i.envMap = (e.isMeshStandardMaterial ? ve : me).get(
                e.envMap || i.environment
              )),
              (i.envMapRotation =
                null !== i.environment && null === e.envMap
                  ? t.environmentRotation
                  : e.envMapRotation),
              void 0 === c &&
                (e.addEventListener("dispose", He),
                (c = new Map()),
                (i.programs = c));
            let u = c.get(l);
            if (void 0 !== u) {
              if (i.currentProgram === u && i.lightsStateVersion === a)
                return tt(e, o), u;
            } else
              (o.uniforms = be.getUniforms(e)),
                e.onBeforeCompile(o, w),
                (u = be.acquireProgram(o, l)),
                c.set(l, u),
                (i.uniforms = o.uniforms);
            const h = i.uniforms;
            return (
              ((e.isShaderMaterial || e.isRawShaderMaterial) &&
                !0 !== e.clipping) ||
                (h.clippingPlanes = Ie.uniform),
              tt(e, o),
              (i.needsLights = (function (e) {
                return (
                  e.isMeshLambertMaterial ||
                  e.isMeshToonMaterial ||
                  e.isMeshPhongMaterial ||
                  e.isMeshStandardMaterial ||
                  e.isShadowMaterial ||
                  (e.isShaderMaterial && !0 === e.lights)
                );
              })(e)),
              (i.lightsStateVersion = a),
              i.needsLights &&
                ((h.ambientLightColor.value = r.state.ambient),
                (h.lightProbe.value = r.state.probe),
                (h.directionalLights.value = r.state.directional),
                (h.directionalLightShadows.value = r.state.directionalShadow),
                (h.spotLights.value = r.state.spot),
                (h.spotLightShadows.value = r.state.spotShadow),
                (h.rectAreaLights.value = r.state.rectArea),
                (h.ltc_1.value = r.state.rectAreaLTC1),
                (h.ltc_2.value = r.state.rectAreaLTC2),
                (h.pointLights.value = r.state.point),
                (h.pointLightShadows.value = r.state.pointShadow),
                (h.hemisphereLights.value = r.state.hemi),
                (h.directionalShadowMap.value = r.state.directionalShadowMap),
                (h.directionalShadowMatrix.value =
                  r.state.directionalShadowMatrix),
                (h.spotShadowMap.value = r.state.spotShadowMap),
                (h.spotLightMatrix.value = r.state.spotLightMatrix),
                (h.spotLightMap.value = r.state.spotLightMap),
                (h.pointShadowMap.value = r.state.pointShadowMap),
                (h.pointShadowMatrix.value = r.state.pointShadowMatrix)),
              (i.currentProgram = u),
              (i.uniformsList = null),
              u
            );
          }
          function et(e) {
            if (null === e.uniformsList) {
              const t = e.currentProgram.getUniforms();
              e.uniformsList = Ca.seqWithValue(t.seq, e.uniforms);
            }
            return e.uniformsList;
          }
          function tt(e, t) {
            const n = pe.get(e);
            (n.outputColorSpace = t.outputColorSpace),
              (n.batching = t.batching),
              (n.batchingColor = t.batchingColor),
              (n.instancing = t.instancing),
              (n.instancingColor = t.instancingColor),
              (n.instancingMorph = t.instancingMorph),
              (n.skinning = t.skinning),
              (n.morphTargets = t.morphTargets),
              (n.morphNormals = t.morphNormals),
              (n.morphColors = t.morphColors),
              (n.morphTargetsCount = t.morphTargetsCount),
              (n.numClippingPlanes = t.numClippingPlanes),
              (n.numIntersection = t.numClipIntersection),
              (n.vertexAlphas = t.vertexAlphas),
              (n.vertexTangents = t.vertexTangents),
              (n.toneMapping = t.toneMapping);
          }
          qe.setAnimationLoop(function (e) {
            Ve && Ve(e);
          }),
            "undefined" != typeof self && qe.setContext(self),
            (this.setAnimationLoop = function (e) {
              (Ve = e),
                Oe.setAnimationLoop(e),
                null === e ? qe.stop() : qe.start();
            }),
            Oe.addEventListener("sessionstart", We),
            Oe.addEventListener("sessionend", je),
            (this.render = function (e, t) {
              if (void 0 !== t && !0 !== t.isCamera)
                return void console.error(
                  "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
                );
              if (!0 === C) return;
              if (
                (!0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
                null === t.parent &&
                  !0 === t.matrixWorldAutoUpdate &&
                  t.updateMatrixWorld(),
                !0 === Oe.enabled &&
                  !0 === Oe.isPresenting &&
                  (!0 === Oe.cameraAutoUpdate && Oe.updateCamera(t),
                  (t = Oe.getCamera())),
                !0 === e.isScene && e.onBeforeRender(w, e, t, M),
                (x = Ce.get(e, b.length)),
                x.init(t),
                b.push(x),
                Z.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
                V.setFromProjectionMatrix(Z),
                (Y = this.localClippingEnabled),
                (q = Ie.init(this.clippingPlanes, Y)),
                (y = we.get(e, _.length)),
                y.init(),
                _.push(y),
                !0 === Oe.enabled && !0 === Oe.isPresenting)
              ) {
                const e = w.xr.getDepthSensingMesh();
                null !== e && Ye(e, t, -1 / 0, w.sortObjects);
              }
              Ye(e, t, 0, w.sortObjects),
                y.finish(),
                !0 === w.sortObjects && y.sort(Q, k),
                (ae =
                  !1 === Oe.enabled ||
                  !1 === Oe.isPresenting ||
                  !1 === Oe.hasDepthSensing()),
                ae && Me.addToRenderList(y, e),
                this.info.render.frame++,
                !0 === q && Ie.beginShadows();
              const n = x.state.shadowsArray;
              Se.render(n, e, t),
                !0 === q && Ie.endShadows(),
                !0 === this.info.autoReset && this.info.reset();
              const i = y.opaque,
                r = y.transmissive;
              if ((x.setupLights(), t.isArrayCamera)) {
                const n = t.cameras;
                if (r.length > 0)
                  for (let t = 0, s = n.length; t < s; t++) {
                    Ke(i, r, e, n[t]);
                  }
                ae && Me.render(e);
                for (let t = 0, i = n.length; t < i; t++) {
                  const i = n[t];
                  Xe(y, e, i, i.viewport);
                }
              } else
                r.length > 0 && Ke(i, r, e, t), ae && Me.render(e), Xe(y, e, t);
              null !== M &&
                (ge.updateMultisampleRenderTarget(M),
                ge.updateRenderTargetMipmap(M)),
                !0 === e.isScene && e.onAfterRender(w, e, t),
                Pe.resetDefaultState(),
                (T = -1),
                (B = null),
                b.pop(),
                b.length > 0
                  ? ((x = b[b.length - 1]),
                    !0 === q &&
                      Ie.setGlobalState(w.clippingPlanes, x.state.camera))
                  : (x = null),
                _.pop(),
                (y = _.length > 0 ? _[_.length - 1] : null);
            }),
            (this.getActiveCubeFace = function () {
              return I;
            }),
            (this.getActiveMipmapLevel = function () {
              return S;
            }),
            (this.getRenderTarget = function () {
              return M;
            }),
            (this.setRenderTargetTextures = function (e, t, n) {
              (pe.get(e.texture).__webglTexture = t),
                (pe.get(e.depthTexture).__webglTexture = n);
              const i = pe.get(e);
              (i.__hasExternalTextures = !0),
                (i.__autoAllocateDepthBuffer = void 0 === n),
                i.__autoAllocateDepthBuffer ||
                  (!0 === le.has("WEBGL_multisampled_render_to_texture") &&
                    (console.warn(
                      "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                    ),
                    (i.__useRenderToTexture = !1)));
            }),
            (this.setRenderTargetFramebuffer = function (e, t) {
              const n = pe.get(e);
              (n.__webglFramebuffer = t),
                (n.__useDefaultFramebuffer = void 0 === t);
            }),
            (this.setRenderTarget = function (e, t = 0, n = 0) {
              (M = e), (I = t), (S = n);
              let i = !0,
                r = null,
                s = !1,
                a = !1;
              if (e) {
                const o = pe.get(e);
                if (void 0 !== o.__useDefaultFramebuffer)
                  ue.bindFramebuffer(Ue.FRAMEBUFFER, null), (i = !1);
                else if (void 0 === o.__webglFramebuffer)
                  ge.setupRenderTarget(e);
                else if (o.__hasExternalTextures)
                  ge.rebindTextures(
                    e,
                    pe.get(e.texture).__webglTexture,
                    pe.get(e.depthTexture).__webglTexture
                  );
                else if (e.depthBuffer) {
                  const t = e.depthTexture;
                  if (o.__boundDepthTexture !== t) {
                    if (
                      null !== t &&
                      pe.has(t) &&
                      (e.width !== t.image.width || e.height !== t.image.height)
                    )
                      throw new Error(
                        "WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size."
                      );
                    ge.setupDepthRenderbuffer(e);
                  }
                }
                const l = e.texture;
                (l.isData3DTexture ||
                  l.isDataArrayTexture ||
                  l.isCompressedArrayTexture) &&
                  (a = !0);
                const c = pe.get(e).__webglFramebuffer;
                e.isWebGLCubeRenderTarget
                  ? ((r = Array.isArray(c[t]) ? c[t][n] : c[t]), (s = !0))
                  : (r =
                      e.samples > 0 && !1 === ge.useMultisampledRTT(e)
                        ? pe.get(e).__webglMultisampledFramebuffer
                        : Array.isArray(c)
                        ? c[n]
                        : c),
                  R.copy(e.viewport),
                  D.copy(e.scissor),
                  (P = e.scissorTest);
              } else
                R.copy(G).multiplyScalar(O).floor(),
                  D.copy(H).multiplyScalar(O).floor(),
                  (P = z);
              if (
                (ue.bindFramebuffer(Ue.FRAMEBUFFER, r) &&
                  i &&
                  ue.drawBuffers(e, r),
                ue.viewport(R),
                ue.scissor(D),
                ue.setScissorTest(P),
                s)
              ) {
                const i = pe.get(e.texture);
                Ue.framebufferTexture2D(
                  Ue.FRAMEBUFFER,
                  Ue.COLOR_ATTACHMENT0,
                  Ue.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                  i.__webglTexture,
                  n
                );
              } else if (a) {
                const i = pe.get(e.texture),
                  r = t || 0;
                Ue.framebufferTextureLayer(
                  Ue.FRAMEBUFFER,
                  Ue.COLOR_ATTACHMENT0,
                  i.__webglTexture,
                  n || 0,
                  r
                );
              }
              T = -1;
            }),
            (this.readRenderTargetPixels = function (e, t, n, i, r, s, a) {
              if (!e || !e.isWebGLRenderTarget)
                return void console.error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let o = pe.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)
              ) {
                ue.bindFramebuffer(Ue.FRAMEBUFFER, o);
                try {
                  const a = e.texture,
                    o = a.format,
                    l = a.type;
                  if (!ce.textureFormatReadable(o))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
                    );
                  if (!ce.textureTypeReadable(l))
                    return void console.error(
                      "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
                    );
                  t >= 0 &&
                    t <= e.width - i &&
                    n >= 0 &&
                    n <= e.height - r &&
                    Ue.readPixels(t, n, i, r, De.convert(o), De.convert(l), s);
                } finally {
                  const e = null !== M ? pe.get(M).__webglFramebuffer : null;
                  ue.bindFramebuffer(Ue.FRAMEBUFFER, e);
                }
              }
            }),
            (this.readRenderTargetPixelsAsync = async function (
              e,
              t,
              n,
              i,
              r,
              s,
              a
            ) {
              if (!e || !e.isWebGLRenderTarget)
                throw new Error(
                  "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
                );
              let o = pe.get(e).__webglFramebuffer;
              if (
                (e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)
              ) {
                const a = e.texture,
                  l = a.format,
                  c = a.type;
                if (!ce.textureFormatReadable(l))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format."
                  );
                if (!ce.textureTypeReadable(c))
                  throw new Error(
                    "THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type."
                  );
                if (t >= 0 && t <= e.width - i && n >= 0 && n <= e.height - r) {
                  ue.bindFramebuffer(Ue.FRAMEBUFFER, o);
                  const e = Ue.createBuffer();
                  Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e),
                    Ue.bufferData(
                      Ue.PIXEL_PACK_BUFFER,
                      s.byteLength,
                      Ue.STREAM_READ
                    ),
                    Ue.readPixels(t, n, i, r, De.convert(l), De.convert(c), 0);
                  const a = null !== M ? pe.get(M).__webglFramebuffer : null;
                  ue.bindFramebuffer(Ue.FRAMEBUFFER, a);
                  const u = Ue.fenceSync(Ue.SYNC_GPU_COMMANDS_COMPLETE, 0);
                  return (
                    Ue.flush(),
                    await (function (e, t, n) {
                      return new Promise(function (i, r) {
                        setTimeout(function s() {
                          switch (
                            e.clientWaitSync(t, e.SYNC_FLUSH_COMMANDS_BIT, 0)
                          ) {
                            case e.WAIT_FAILED:
                              r();
                              break;
                            case e.TIMEOUT_EXPIRED:
                              setTimeout(s, n);
                              break;
                            default:
                              i();
                          }
                        }, n);
                      });
                    })(Ue, u, 4),
                    Ue.bindBuffer(Ue.PIXEL_PACK_BUFFER, e),
                    Ue.getBufferSubData(Ue.PIXEL_PACK_BUFFER, 0, s),
                    Ue.deleteBuffer(e),
                    Ue.deleteSync(u),
                    s
                  );
                }
                throw new Error(
                  "THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range."
                );
              }
            }),
            (this.copyFramebufferToTexture = function (e, t = null, n = 0) {
              !0 !== e.isTexture &&
                (Ot(
                  "WebGLRenderer: copyFramebufferToTexture function signature has changed."
                ),
                (t = arguments[0] || null),
                (e = arguments[1]));
              const i = Math.pow(2, -n),
                r = Math.floor(e.image.width * i),
                s = Math.floor(e.image.height * i),
                a = null !== t ? t.x : 0,
                o = null !== t ? t.y : 0;
              ge.setTexture2D(e, 0),
                Ue.copyTexSubImage2D(Ue.TEXTURE_2D, n, 0, 0, a, o, r, s),
                ue.unbindTexture();
            }),
            (this.copyTextureToTexture = function (
              e,
              t,
              n = null,
              i = null,
              r = 0
            ) {
              let s, a, o, l, c, u, h, d, p;
              !0 !== e.isTexture &&
                (Ot(
                  "WebGLRenderer: copyTextureToTexture function signature has changed."
                ),
                (i = arguments[0] || null),
                (e = arguments[1]),
                (t = arguments[2]),
                (r = arguments[3] || 0),
                (n = null));
              const f = e.isCompressedTexture ? e.mipmaps[r] : e.image;
              null !== n
                ? ((s = n.max.x - n.min.x),
                  (a = n.max.y - n.min.y),
                  (o = n.isBox3 ? n.max.z - n.min.z : 1),
                  (l = n.min.x),
                  (c = n.min.y),
                  (u = n.isBox3 ? n.min.z : 0))
                : ((s = f.width),
                  (a = f.height),
                  (o = f.depth || 1),
                  (l = 0),
                  (c = 0),
                  (u = 0)),
                null !== i
                  ? ((h = i.x), (d = i.y), (p = i.z))
                  : ((h = 0), (d = 0), (p = 0));
              const A = De.convert(t.format),
                g = De.convert(t.type);
              let m;
              t.isData3DTexture
                ? (ge.setTexture3D(t, 0), (m = Ue.TEXTURE_3D))
                : t.isDataArrayTexture || t.isCompressedArrayTexture
                ? (ge.setTexture2DArray(t, 0), (m = Ue.TEXTURE_2D_ARRAY))
                : (ge.setTexture2D(t, 0), (m = Ue.TEXTURE_2D)),
                Ue.pixelStorei(Ue.UNPACK_FLIP_Y_WEBGL, t.flipY),
                Ue.pixelStorei(
                  Ue.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  t.premultiplyAlpha
                ),
                Ue.pixelStorei(Ue.UNPACK_ALIGNMENT, t.unpackAlignment);
              const v = Ue.getParameter(Ue.UNPACK_ROW_LENGTH),
                y = Ue.getParameter(Ue.UNPACK_IMAGE_HEIGHT),
                x = Ue.getParameter(Ue.UNPACK_SKIP_PIXELS),
                _ = Ue.getParameter(Ue.UNPACK_SKIP_ROWS),
                b = Ue.getParameter(Ue.UNPACK_SKIP_IMAGES);
              Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, f.width),
                Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, f.height),
                Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, l),
                Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, c),
                Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, u);
              const E = e.isDataArrayTexture || e.isData3DTexture,
                w = t.isDataArrayTexture || t.isData3DTexture;
              if (e.isRenderTargetTexture || e.isDepthTexture) {
                const n = pe.get(e),
                  i = pe.get(t),
                  f = pe.get(n.__renderTarget),
                  A = pe.get(i.__renderTarget);
                ue.bindFramebuffer(Ue.READ_FRAMEBUFFER, f.__webglFramebuffer),
                  ue.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, A.__webglFramebuffer);
                for (let n = 0; n < o; n++)
                  E &&
                    Ue.framebufferTextureLayer(
                      Ue.READ_FRAMEBUFFER,
                      Ue.COLOR_ATTACHMENT0,
                      pe.get(e).__webglTexture,
                      r,
                      u + n
                    ),
                    e.isDepthTexture
                      ? (w &&
                          Ue.framebufferTextureLayer(
                            Ue.DRAW_FRAMEBUFFER,
                            Ue.COLOR_ATTACHMENT0,
                            pe.get(t).__webglTexture,
                            r,
                            p + n
                          ),
                        Ue.blitFramebuffer(
                          l,
                          c,
                          s,
                          a,
                          h,
                          d,
                          s,
                          a,
                          Ue.DEPTH_BUFFER_BIT,
                          Ue.NEAREST
                        ))
                      : w
                      ? Ue.copyTexSubImage3D(m, r, h, d, p + n, l, c, s, a)
                      : Ue.copyTexSubImage2D(m, r, h, d, p + n, l, c, s, a);
                ue.bindFramebuffer(Ue.READ_FRAMEBUFFER, null),
                  ue.bindFramebuffer(Ue.DRAW_FRAMEBUFFER, null);
              } else
                w
                  ? e.isDataTexture || e.isData3DTexture
                    ? Ue.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f.data)
                    : t.isCompressedArrayTexture
                    ? Ue.compressedTexSubImage3D(
                        m,
                        r,
                        h,
                        d,
                        p,
                        s,
                        a,
                        o,
                        A,
                        f.data
                      )
                    : Ue.texSubImage3D(m, r, h, d, p, s, a, o, A, g, f)
                  : e.isDataTexture
                  ? Ue.texSubImage2D(Ue.TEXTURE_2D, r, h, d, s, a, A, g, f.data)
                  : e.isCompressedTexture
                  ? Ue.compressedTexSubImage2D(
                      Ue.TEXTURE_2D,
                      r,
                      h,
                      d,
                      f.width,
                      f.height,
                      A,
                      f.data
                    )
                  : Ue.texSubImage2D(Ue.TEXTURE_2D, r, h, d, s, a, A, g, f);
              Ue.pixelStorei(Ue.UNPACK_ROW_LENGTH, v),
                Ue.pixelStorei(Ue.UNPACK_IMAGE_HEIGHT, y),
                Ue.pixelStorei(Ue.UNPACK_SKIP_PIXELS, x),
                Ue.pixelStorei(Ue.UNPACK_SKIP_ROWS, _),
                Ue.pixelStorei(Ue.UNPACK_SKIP_IMAGES, b),
                0 === r && t.generateMipmaps && Ue.generateMipmap(m),
                ue.unbindTexture();
            }),
            (this.copyTextureToTexture3D = function (
              e,
              t,
              n = null,
              i = null,
              r = 0
            ) {
              return (
                !0 !== e.isTexture &&
                  (Ot(
                    "WebGLRenderer: copyTextureToTexture3D function signature has changed."
                  ),
                  (n = arguments[0] || null),
                  (i = arguments[1] || null),
                  (e = arguments[2]),
                  (t = arguments[3]),
                  (r = arguments[4] || 0)),
                Ot(
                  'WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'
                ),
                this.copyTextureToTexture(e, t, n, i, r)
              );
            }),
            (this.initRenderTarget = function (e) {
              void 0 === pe.get(e).__webglFramebuffer &&
                ge.setupRenderTarget(e);
            }),
            (this.initTexture = function (e) {
              e.isCubeTexture
                ? ge.setTextureCube(e, 0)
                : e.isData3DTexture
                ? ge.setTexture3D(e, 0)
                : e.isDataArrayTexture || e.isCompressedArrayTexture
                ? ge.setTexture2DArray(e, 0)
                : ge.setTexture2D(e, 0),
                ue.unbindTexture();
            }),
            (this.resetState = function () {
              (I = 0), (S = 0), (M = null), ue.reset(), Pe.reset();
            }),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        get coordinateSystem() {
          return mt;
        }
        get outputColorSpace() {
          return this._outputColorSpace;
        }
        set outputColorSpace(e) {
          this._outputColorSpace = e;
          const t = this.getContext();
          (t.drawingBufferColorspace = Qt._getDrawingBufferColorSpace(e)),
            (t.unpackColorSpace = Qt._getUnpackColorSpace());
        }
      }
      class Mo {
        constructor(e, t = 1, n = 1e3) {
          (this.isFog = !0),
            (this.name = ""),
            (this.color = new Ti(e)),
            (this.near = t),
            (this.far = n);
        }
        clone() {
          return new Mo(this.color, this.near, this.far);
        }
        toJSON() {
          return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far,
          };
        }
      }
      class To extends ui {
        constructor() {
          super(),
            (this.isScene = !0),
            (this.type = "Scene"),
            (this.background = null),
            (this.environment = null),
            (this.fog = null),
            (this.backgroundBlurriness = 0),
            (this.backgroundIntensity = 1),
            (this.backgroundRotation = new qn()),
            (this.environmentIntensity = 1),
            (this.environmentRotation = new qn()),
            (this.overrideMaterial = null),
            "undefined" != typeof __THREE_DEVTOOLS__ &&
              __THREE_DEVTOOLS__.dispatchEvent(
                new CustomEvent("observe", { detail: this })
              );
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            null !== e.background && (this.background = e.background.clone()),
            null !== e.environment &&
              (this.environment = e.environment.clone()),
            null !== e.fog && (this.fog = e.fog.clone()),
            (this.backgroundBlurriness = e.backgroundBlurriness),
            (this.backgroundIntensity = e.backgroundIntensity),
            this.backgroundRotation.copy(e.backgroundRotation),
            (this.environmentIntensity = e.environmentIntensity),
            this.environmentRotation.copy(e.environmentRotation),
            null !== e.overrideMaterial &&
              (this.overrideMaterial = e.overrideMaterial.clone()),
            (this.matrixAutoUpdate = e.matrixAutoUpdate),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            null !== this.fog && (t.object.fog = this.fog.toJSON()),
            this.backgroundBlurriness > 0 &&
              (t.object.backgroundBlurriness = this.backgroundBlurriness),
            1 !== this.backgroundIntensity &&
              (t.object.backgroundIntensity = this.backgroundIntensity),
            (t.object.backgroundRotation = this.backgroundRotation.toArray()),
            1 !== this.environmentIntensity &&
              (t.object.environmentIntensity = this.environmentIntensity),
            (t.object.environmentRotation = this.environmentRotation.toArray()),
            t
          );
        }
      }
      class Bo {
        constructor(e, t) {
          (this.isInterleavedBuffer = !0),
            (this.array = e),
            (this.stride = t),
            (this.count = void 0 !== e ? e.length / t : 0),
            (this.usage = At),
            (this.updateRanges = []),
            (this.version = 0),
            (this.uuid = wt());
        }
        onUploadCallback() {}
        set needsUpdate(e) {
          !0 === e && this.version++;
        }
        setUsage(e) {
          return (this.usage = e), this;
        }
        addUpdateRange(e, t) {
          this.updateRanges.push({ start: e, count: t });
        }
        clearUpdateRanges() {
          this.updateRanges.length = 0;
        }
        copy(e) {
          return (
            (this.array = new e.array.constructor(e.array)),
            (this.count = e.count),
            (this.stride = e.stride),
            (this.usage = e.usage),
            this
          );
        }
        copyAt(e, t, n) {
          (e *= this.stride), (n *= t.stride);
          for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
          return this;
        }
        set(e, t = 0) {
          return this.array.set(e, t), this;
        }
        clone(e) {
          void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = wt()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] =
                this.array.slice(0).buffer);
          const t = new this.array.constructor(
              e.arrayBuffers[this.array.buffer._uuid]
            ),
            n = new this.constructor(t, this.stride);
          return n.setUsage(this.usage), n;
        }
        onUpload(e) {
          return (this.onUploadCallback = e), this;
        }
        toJSON(e) {
          return (
            void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
            void 0 === this.array.buffer._uuid &&
              (this.array.buffer._uuid = wt()),
            void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
              (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
                new Uint32Array(this.array.buffer)
              )),
            {
              uuid: this.uuid,
              buffer: this.array.buffer._uuid,
              type: this.array.constructor.name,
              stride: this.stride,
            }
          );
        }
      }
      const Ro = new on();
      class Do {
        constructor(e, t, n, i = !1) {
          (this.isInterleavedBufferAttribute = !0),
            (this.name = ""),
            (this.data = e),
            (this.itemSize = t),
            (this.offset = n),
            (this.normalized = i);
        }
        get count() {
          return this.data.count;
        }
        get array() {
          return this.data.array;
        }
        set needsUpdate(e) {
          this.data.needsUpdate = e;
        }
        applyMatrix4(e) {
          for (let t = 0, n = this.data.count; t < n; t++)
            Ro.fromBufferAttribute(this, t),
              Ro.applyMatrix4(e),
              this.setXYZ(t, Ro.x, Ro.y, Ro.z);
          return this;
        }
        applyNormalMatrix(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ro.fromBufferAttribute(this, t),
              Ro.applyNormalMatrix(e),
              this.setXYZ(t, Ro.x, Ro.y, Ro.z);
          return this;
        }
        transformDirection(e) {
          for (let t = 0, n = this.count; t < n; t++)
            Ro.fromBufferAttribute(this, t),
              Ro.transformDirection(e),
              this.setXYZ(t, Ro.x, Ro.y, Ro.z);
          return this;
        }
        getComponent(e, t) {
          let n = this.array[e * this.data.stride + this.offset + t];
          return this.normalized && (n = Mt(n, this.array)), n;
        }
        setComponent(e, t, n) {
          return (
            this.normalized && (n = Tt(n, this.array)),
            (this.data.array[e * this.data.stride + this.offset + t] = n),
            this
          );
        }
        setX(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset] = t),
            this
          );
        }
        setY(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 1] = t),
            this
          );
        }
        setZ(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 2] = t),
            this
          );
        }
        setW(e, t) {
          return (
            this.normalized && (t = Tt(t, this.array)),
            (this.data.array[e * this.data.stride + this.offset + 3] = t),
            this
          );
        }
        getX(e) {
          let t = this.data.array[e * this.data.stride + this.offset];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        getY(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 1];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        getZ(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 2];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        getW(e) {
          let t = this.data.array[e * this.data.stride + this.offset + 3];
          return this.normalized && (t = Mt(t, this.array)), t;
        }
        setXY(e, t, n) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = Tt(t, this.array)), (n = Tt(n, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            this
          );
        }
        setXYZ(e, t, n, i) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = Tt(t, this.array)),
              (n = Tt(n, this.array)),
              (i = Tt(i, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            this
          );
        }
        setXYZW(e, t, n, i, r) {
          return (
            (e = e * this.data.stride + this.offset),
            this.normalized &&
              ((t = Tt(t, this.array)),
              (n = Tt(n, this.array)),
              (i = Tt(i, this.array)),
              (r = Tt(r, this.array))),
            (this.data.array[e + 0] = t),
            (this.data.array[e + 1] = n),
            (this.data.array[e + 2] = i),
            (this.data.array[e + 3] = r),
            this
          );
        }
        clone(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
            );
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const n = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++)
                e.push(this.data.array[n + t]);
            }
            return new Gi(
              new this.array.constructor(e),
              this.itemSize,
              this.normalized
            );
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Do(
              e.interleavedBuffers[this.data.uuid],
              this.itemSize,
              this.offset,
              this.normalized
            )
          );
        }
        toJSON(e) {
          if (void 0 === e) {
            console.log(
              "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
            );
            const e = [];
            for (let t = 0; t < this.count; t++) {
              const n = t * this.data.stride + this.offset;
              for (let t = 0; t < this.itemSize; t++)
                e.push(this.data.array[n + t]);
            }
            return {
              itemSize: this.itemSize,
              type: this.array.constructor.name,
              array: e,
              normalized: this.normalized,
            };
          }
          return (
            void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
            void 0 === e.interleavedBuffers[this.data.uuid] &&
              (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
              isInterleavedBufferAttribute: !0,
              itemSize: this.itemSize,
              data: this.data.uuid,
              offset: this.offset,
              normalized: this.normalized,
            }
          );
        }
      }
      const Po = new on(),
        Lo = new en(),
        Uo = new en(),
        Fo = new on(),
        No = new Nn(),
        Oo = new on(),
        Qo = new Mn(),
        ko = new Nn(),
        Go = new Fn();
      class Ho extends ur {
        constructor(e, t) {
          super(e, t),
            (this.isSkinnedMesh = !0),
            (this.type = "SkinnedMesh"),
            (this.bindMode = R),
            (this.bindMatrix = new Nn()),
            (this.bindMatrixInverse = new Nn()),
            (this.boundingBox = null),
            (this.boundingSphere = null);
        }
        computeBoundingBox() {
          const e = this.geometry;
          null === this.boundingBox && (this.boundingBox = new un()),
            this.boundingBox.makeEmpty();
          const t = e.getAttribute("position");
          for (let e = 0; e < t.count; e++)
            this.getVertexPosition(e, Oo), this.boundingBox.expandByPoint(Oo);
        }
        computeBoundingSphere() {
          const e = this.geometry;
          null === this.boundingSphere && (this.boundingSphere = new Mn()),
            this.boundingSphere.makeEmpty();
          const t = e.getAttribute("position");
          for (let e = 0; e < t.count; e++)
            this.getVertexPosition(e, Oo),
              this.boundingSphere.expandByPoint(Oo);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.bindMode = e.bindMode),
            this.bindMatrix.copy(e.bindMatrix),
            this.bindMatrixInverse.copy(e.bindMatrixInverse),
            (this.skeleton = e.skeleton),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        raycast(e, t) {
          const n = this.material,
            i = this.matrixWorld;
          void 0 !== n &&
            (null === this.boundingSphere && this.computeBoundingSphere(),
            Qo.copy(this.boundingSphere),
            Qo.applyMatrix4(i),
            !1 !== e.ray.intersectsSphere(Qo) &&
              (ko.copy(i).invert(),
              Go.copy(e.ray).applyMatrix4(ko),
              (null !== this.boundingBox &&
                !1 === Go.intersectsBox(this.boundingBox)) ||
                this._computeIntersections(e, t, Go)));
        }
        getVertexPosition(e, t) {
          return (
            super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
          );
        }
        bind(e, t) {
          (this.skeleton = e),
            void 0 === t &&
              (this.updateMatrixWorld(!0),
              this.skeleton.calculateInverses(),
              (t = this.matrixWorld)),
            this.bindMatrix.copy(t),
            this.bindMatrixInverse.copy(t).invert();
        }
        pose() {
          this.skeleton.pose();
        }
        normalizeSkinWeights() {
          const e = new en(),
            t = this.geometry.attributes.skinWeight;
          for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const i = 1 / e.manhattanLength();
            i !== 1 / 0 ? e.multiplyScalar(i) : e.set(1, 0, 0, 0),
              t.setXYZW(n, e.x, e.y, e.z, e.w);
          }
        }
        updateMatrixWorld(e) {
          super.updateMatrixWorld(e),
            this.bindMode === R
              ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
              : "detached" === this.bindMode
              ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
              : console.warn(
                  "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
                );
        }
        applyBoneTransform(e, t) {
          const n = this.skeleton,
            i = this.geometry;
          Lo.fromBufferAttribute(i.attributes.skinIndex, e),
            Uo.fromBufferAttribute(i.attributes.skinWeight, e),
            Po.copy(t).applyMatrix4(this.bindMatrix),
            t.set(0, 0, 0);
          for (let e = 0; e < 4; e++) {
            const i = Uo.getComponent(e);
            if (0 !== i) {
              const r = Lo.getComponent(e);
              No.multiplyMatrices(n.bones[r].matrixWorld, n.boneInverses[r]),
                t.addScaledVector(Fo.copy(Po).applyMatrix4(No), i);
            }
          }
          return t.applyMatrix4(this.bindMatrixInverse);
        }
      }
      class zo extends ui {
        constructor() {
          super(), (this.isBone = !0), (this.type = "Bone");
        }
      }
      class Vo extends $t {
        constructor(e = null, t = 1, n = 1, i, r, s, a, o, l = k, c = k, u, h) {
          super(null, s, a, o, l, c, i, r, u, h),
            (this.isDataTexture = !0),
            (this.image = { data: e, width: t, height: n }),
            (this.generateMipmaps = !1),
            (this.flipY = !1),
            (this.unpackAlignment = 1);
        }
      }
      const Wo = new Nn(),
        jo = new Nn();
      class qo {
        constructor(e = [], t = []) {
          (this.uuid = wt()),
            (this.bones = e.slice(0)),
            (this.boneInverses = t),
            (this.boneMatrices = null),
            (this.boneTexture = null),
            this.init();
        }
        init() {
          const e = this.bones,
            t = this.boneInverses;
          if (
            ((this.boneMatrices = new Float32Array(16 * e.length)),
            0 === t.length)
          )
            this.calculateInverses();
          else if (e.length !== t.length) {
            console.warn(
              "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
            ),
              (this.boneInverses = []);
            for (let e = 0, t = this.bones.length; e < t; e++)
              this.boneInverses.push(new Nn());
          }
        }
        calculateInverses() {
          this.boneInverses.length = 0;
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = new Nn();
            this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
              this.boneInverses.push(t);
          }
        }
        pose() {
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t && t.matrixWorld.copy(this.boneInverses[e]).invert();
          }
          for (let e = 0, t = this.bones.length; e < t; e++) {
            const t = this.bones[e];
            t &&
              (t.parent && t.parent.isBone
                ? (t.matrix.copy(t.parent.matrixWorld).invert(),
                  t.matrix.multiply(t.matrixWorld))
                : t.matrix.copy(t.matrixWorld),
              t.matrix.decompose(t.position, t.quaternion, t.scale));
          }
        }
        update() {
          const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
          for (let i = 0, r = e.length; i < r; i++) {
            const r = e[i] ? e[i].matrixWorld : jo;
            Wo.multiplyMatrices(r, t[i]), Wo.toArray(n, 16 * i);
          }
          null !== i && (i.needsUpdate = !0);
        }
        clone() {
          return new qo(this.bones, this.boneInverses);
        }
        computeBoneTexture() {
          let e = Math.sqrt(4 * this.bones.length);
          (e = 4 * Math.ceil(e / 4)), (e = Math.max(e, 4));
          const t = new Float32Array(e * e * 4);
          t.set(this.boneMatrices);
          const n = new Vo(t, e, e, ae, Z);
          return (
            (n.needsUpdate = !0),
            (this.boneMatrices = t),
            (this.boneTexture = n),
            this
          );
        }
        getBoneByName(e) {
          for (let t = 0, n = this.bones.length; t < n; t++) {
            const n = this.bones[t];
            if (n.name === e) return n;
          }
        }
        dispose() {
          null !== this.boneTexture &&
            (this.boneTexture.dispose(), (this.boneTexture = null));
        }
        fromJSON(e, t) {
          this.uuid = e.uuid;
          for (let n = 0, i = e.bones.length; n < i; n++) {
            const i = e.bones[n];
            let r = t[i];
            void 0 === r &&
              (console.warn("THREE.Skeleton: No bone found with UUID:", i),
              (r = new zo())),
              this.bones.push(r),
              this.boneInverses.push(new Nn().fromArray(e.boneInverses[n]));
          }
          return this.init(), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Skeleton",
              generator: "Skeleton.toJSON",
            },
            bones: [],
            boneInverses: [],
          };
          e.uuid = this.uuid;
          const t = this.bones,
            n = this.boneInverses;
          for (let i = 0, r = t.length; i < r; i++) {
            const r = t[i];
            e.bones.push(r.uuid);
            const s = n[i];
            e.boneInverses.push(s.toArray());
          }
          return e;
        }
      }
      class Yo extends Gi {
        constructor(e, t, n, i = 1) {
          super(e, t, n),
            (this.isInstancedBufferAttribute = !0),
            (this.meshPerAttribute = i);
        }
        copy(e) {
          return (
            super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this
          );
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.meshPerAttribute = this.meshPerAttribute),
            (e.isInstancedBufferAttribute = !0),
            e
          );
        }
      }
      const Xo = new Nn(),
        Ko = new Nn(),
        Jo = [],
        Zo = new un(),
        $o = new Nn(),
        el = new ur(),
        tl = new Mn();
      class nl extends ur {
        constructor(e, t, n) {
          super(e, t),
            (this.isInstancedMesh = !0),
            (this.instanceMatrix = new Yo(new Float32Array(16 * n), 16)),
            (this.instanceColor = null),
            (this.morphTexture = null),
            (this.count = n),
            (this.boundingBox = null),
            (this.boundingSphere = null);
          for (let e = 0; e < n; e++) this.setMatrixAt(e, $o);
        }
        computeBoundingBox() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingBox && (this.boundingBox = new un()),
            null === e.boundingBox && e.computeBoundingBox(),
            this.boundingBox.makeEmpty();
          for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Xo),
              Zo.copy(e.boundingBox).applyMatrix4(Xo),
              this.boundingBox.union(Zo);
        }
        computeBoundingSphere() {
          const e = this.geometry,
            t = this.count;
          null === this.boundingSphere && (this.boundingSphere = new Mn()),
            null === e.boundingSphere && e.computeBoundingSphere(),
            this.boundingSphere.makeEmpty();
          for (let n = 0; n < t; n++)
            this.getMatrixAt(n, Xo),
              tl.copy(e.boundingSphere).applyMatrix4(Xo),
              this.boundingSphere.union(tl);
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            this.instanceMatrix.copy(e.instanceMatrix),
            null !== e.morphTexture &&
              (this.morphTexture = e.morphTexture.clone()),
            null !== e.instanceColor &&
              (this.instanceColor = e.instanceColor.clone()),
            (this.count = e.count),
            null !== e.boundingBox &&
              (this.boundingBox = e.boundingBox.clone()),
            null !== e.boundingSphere &&
              (this.boundingSphere = e.boundingSphere.clone()),
            this
          );
        }
        getColorAt(e, t) {
          t.fromArray(this.instanceColor.array, 3 * e);
        }
        getMatrixAt(e, t) {
          t.fromArray(this.instanceMatrix.array, 16 * e);
        }
        getMorphAt(e, t) {
          const n = t.morphTargetInfluences,
            i = this.morphTexture.source.data.data,
            r = e * (n.length + 1) + 1;
          for (let e = 0; e < n.length; e++) n[e] = i[r + e];
        }
        raycast(e, t) {
          const n = this.matrixWorld,
            i = this.count;
          if (
            ((el.geometry = this.geometry),
            (el.material = this.material),
            void 0 !== el.material &&
              (null === this.boundingSphere && this.computeBoundingSphere(),
              tl.copy(this.boundingSphere),
              tl.applyMatrix4(n),
              !1 !== e.ray.intersectsSphere(tl)))
          )
            for (let r = 0; r < i; r++) {
              this.getMatrixAt(r, Xo),
                Ko.multiplyMatrices(n, Xo),
                (el.matrixWorld = Ko),
                el.raycast(e, Jo);
              for (let e = 0, n = Jo.length; e < n; e++) {
                const n = Jo[e];
                (n.instanceId = r), (n.object = this), t.push(n);
              }
              Jo.length = 0;
            }
        }
        setColorAt(e, t) {
          null === this.instanceColor &&
            (this.instanceColor = new Yo(
              new Float32Array(3 * this.instanceMatrix.count).fill(1),
              3
            )),
            t.toArray(this.instanceColor.array, 3 * e);
        }
        setMatrixAt(e, t) {
          t.toArray(this.instanceMatrix.array, 16 * e);
        }
        setMorphAt(e, t) {
          const n = t.morphTargetInfluences,
            i = n.length + 1;
          null === this.morphTexture &&
            (this.morphTexture = new Vo(
              new Float32Array(i * this.count),
              i,
              this.count,
              he,
              Z
            ));
          const r = this.morphTexture.source.data.data;
          let s = 0;
          for (let e = 0; e < n.length; e++) s += n[e];
          const a = this.geometry.morphTargetsRelative ? 1 : 1 - s,
            o = i * e;
          (r[o] = a), r.set(n, o + 1);
        }
        updateMorphTargets() {}
        dispose() {
          return (
            this.dispatchEvent({ type: "dispose" }),
            null !== this.morphTexture &&
              (this.morphTexture.dispose(), (this.morphTexture = null)),
            this
          );
        }
      }
      class il extends Di {
        static get type() {
          return "LineBasicMaterial";
        }
        constructor(e) {
          super(),
            (this.isLineBasicMaterial = !0),
            (this.color = new Ti(16777215)),
            (this.map = null),
            (this.linewidth = 1),
            (this.linecap = "round"),
            (this.linejoin = "round"),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.linewidth = e.linewidth),
            (this.linecap = e.linecap),
            (this.linejoin = e.linejoin),
            (this.fog = e.fog),
            this
          );
        }
      }
      const rl = new on(),
        sl = new on(),
        al = new Nn(),
        ol = new Fn(),
        ll = new Mn(),
        cl = new on(),
        ul = new on();
      class hl extends ui {
        constructor(e = new Zi(), t = new il()) {
          super(),
            (this.isLine = !0),
            (this.type = "Line"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              n = [0];
            for (let e = 1, i = t.count; e < i; e++)
              rl.fromBufferAttribute(t, e - 1),
                sl.fromBufferAttribute(t, e),
                (n[e] = n[e - 1]),
                (n[e] += rl.distanceTo(sl));
            e.setAttribute("lineDistance", new Vi(n, 1));
          } else
            console.warn(
              "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Line.threshold,
            s = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            ll.copy(n.boundingSphere),
            ll.applyMatrix4(i),
            (ll.radius += r),
            !1 === e.ray.intersectsSphere(ll))
          )
            return;
          al.copy(i).invert(), ol.copy(e.ray).applyMatrix4(al);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            l = this.isLineSegments ? 2 : 1,
            c = n.index,
            u = n.attributes.position;
          if (null !== c) {
            const n = Math.max(0, s.start),
              i = Math.min(c.count, s.start + s.count);
            for (let r = n, s = i - 1; r < s; r += l) {
              const n = c.getX(r),
                i = c.getX(r + 1),
                s = dl(this, e, ol, o, n, i);
              s && t.push(s);
            }
            if (this.isLineLoop) {
              const r = c.getX(i - 1),
                s = c.getX(n),
                a = dl(this, e, ol, o, r, s);
              a && t.push(a);
            }
          } else {
            const n = Math.max(0, s.start),
              i = Math.min(u.count, s.start + s.count);
            for (let r = n, s = i - 1; r < s; r += l) {
              const n = dl(this, e, ol, o, r, r + 1);
              n && t.push(n);
            }
            if (this.isLineLoop) {
              const r = dl(this, e, ol, o, i - 1, n);
              r && t.push(r);
            }
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
      }
      function dl(e, t, n, i, r, s) {
        const a = e.geometry.attributes.position;
        rl.fromBufferAttribute(a, r), sl.fromBufferAttribute(a, s);
        if (n.distanceSqToSegment(rl, sl, cl, ul) > i) return;
        cl.applyMatrix4(e.matrixWorld);
        const o = t.ray.origin.distanceTo(cl);
        return o < t.near || o > t.far
          ? void 0
          : {
              distance: o,
              point: ul.clone().applyMatrix4(e.matrixWorld),
              index: r,
              face: null,
              faceIndex: null,
              barycoord: null,
              object: e,
            };
      }
      const pl = new on(),
        fl = new on();
      class Al extends hl {
        constructor(e, t) {
          super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
        }
        computeLineDistances() {
          const e = this.geometry;
          if (null === e.index) {
            const t = e.attributes.position,
              n = [];
            for (let e = 0, i = t.count; e < i; e += 2)
              pl.fromBufferAttribute(t, e),
                fl.fromBufferAttribute(t, e + 1),
                (n[e] = 0 === e ? 0 : n[e - 1]),
                (n[e + 1] = n[e] + pl.distanceTo(fl));
            e.setAttribute("lineDistance", new Vi(n, 1));
          } else
            console.warn(
              "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
            );
          return this;
        }
      }
      class gl extends hl {
        constructor(e, t) {
          super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
        }
      }
      class ml extends Di {
        static get type() {
          return "PointsMaterial";
        }
        constructor(e) {
          super(),
            (this.isPointsMaterial = !0),
            (this.color = new Ti(16777215)),
            (this.map = null),
            (this.alphaMap = null),
            (this.size = 1),
            (this.sizeAttenuation = !0),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.alphaMap = e.alphaMap),
            (this.size = e.size),
            (this.sizeAttenuation = e.sizeAttenuation),
            (this.fog = e.fog),
            this
          );
        }
      }
      const vl = new Nn(),
        yl = new Fn(),
        xl = new Mn(),
        _l = new on();
      class bl extends ui {
        constructor(e = new Zi(), t = new ml()) {
          super(),
            (this.isPoints = !0),
            (this.type = "Points"),
            (this.geometry = e),
            (this.material = t),
            this.updateMorphTargets();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.material = Array.isArray(e.material)
              ? e.material.slice()
              : e.material),
            (this.geometry = e.geometry),
            this
          );
        }
        raycast(e, t) {
          const n = this.geometry,
            i = this.matrixWorld,
            r = e.params.Points.threshold,
            s = n.drawRange;
          if (
            (null === n.boundingSphere && n.computeBoundingSphere(),
            xl.copy(n.boundingSphere),
            xl.applyMatrix4(i),
            (xl.radius += r),
            !1 === e.ray.intersectsSphere(xl))
          )
            return;
          vl.copy(i).invert(), yl.copy(e.ray).applyMatrix4(vl);
          const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            o = a * a,
            l = n.index,
            c = n.attributes.position;
          if (null !== l) {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(l.count, s.start + s.count);
              n < r;
              n++
            ) {
              const r = l.getX(n);
              _l.fromBufferAttribute(c, r), El(_l, r, o, i, e, t, this);
            }
          } else {
            for (
              let n = Math.max(0, s.start),
                r = Math.min(c.count, s.start + s.count);
              n < r;
              n++
            )
              _l.fromBufferAttribute(c, n), El(_l, n, o, i, e, t, this);
          }
        }
        updateMorphTargets() {
          const e = this.geometry.morphAttributes,
            t = Object.keys(e);
          if (t.length > 0) {
            const n = e[t[0]];
            if (void 0 !== n) {
              (this.morphTargetInfluences = []),
                (this.morphTargetDictionary = {});
              for (let e = 0, t = n.length; e < t; e++) {
                const t = n[e].name || String(e);
                this.morphTargetInfluences.push(0),
                  (this.morphTargetDictionary[t] = e);
              }
            }
          }
        }
      }
      function El(e, t, n, i, r, s, a) {
        const o = yl.distanceSqToPoint(e);
        if (o < n) {
          const n = new on();
          yl.closestPointToPoint(e, n), n.applyMatrix4(i);
          const l = r.ray.origin.distanceTo(n);
          if (l < r.near || l > r.far) return;
          s.push({
            distance: l,
            distanceToRay: Math.sqrt(o),
            point: n,
            index: t,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: a,
          });
        }
      }
      class wl extends $t {
        constructor(e, t, n, i, r, s, a, o, l) {
          super(e, t, n, i, r, s, a, o, l),
            (this.isVideoTexture = !0),
            (this.minFilter = void 0 !== s ? s : z),
            (this.magFilter = void 0 !== r ? r : z),
            (this.generateMipmaps = !1);
          const c = this;
          "requestVideoFrameCallback" in e &&
            e.requestVideoFrameCallback(function t() {
              (c.needsUpdate = !0), e.requestVideoFrameCallback(t);
            });
        }
        clone() {
          return new this.constructor(this.image).copy(this);
        }
        update() {
          const e = this.image;
          !1 === "requestVideoFrameCallback" in e &&
            e.readyState >= e.HAVE_CURRENT_DATA &&
            (this.needsUpdate = !0);
        }
      }
      class Cl extends $t {
        constructor(e, t, n, i, r, s, a, o, l, c, u, h) {
          super(null, s, a, o, l, c, i, r, u, h),
            (this.isCompressedTexture = !0),
            (this.image = { width: t, height: n }),
            (this.mipmaps = e),
            (this.flipY = !1),
            (this.generateMipmaps = !1);
        }
      }
      class Il extends Cl {
        constructor(e, t, n, i, r, s) {
          super(e, t, n, r, s),
            (this.isCompressedArrayTexture = !0),
            (this.image.depth = i),
            (this.wrapR = O),
            (this.layerUpdates = new Set());
        }
        addLayerUpdate(e) {
          this.layerUpdates.add(e);
        }
        clearLayerUpdates() {
          this.layerUpdates.clear();
        }
      }
      class Sl extends Cl {
        constructor(e, t, n) {
          super(void 0, e[0].width, e[0].height, t, n, D),
            (this.isCompressedCubeTexture = !0),
            (this.isCubeTexture = !0),
            (this.image = e);
        }
      }
      class Ml {
        constructor() {
          (this.type = "Curve"), (this.arcLengthDivisions = 200);
        }
        getPoint() {
          return (
            console.warn("THREE.Curve: .getPoint() not implemented."), null
          );
        }
        getPointAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getPoint(n, t);
        }
        getPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
          return t;
        }
        getSpacedPoints(e = 5) {
          const t = [];
          for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
          return t;
        }
        getLength() {
          const e = this.getLengths();
          return e[e.length - 1];
        }
        getLengths(e = this.arcLengthDivisions) {
          if (
            this.cacheArcLengths &&
            this.cacheArcLengths.length === e + 1 &&
            !this.needsUpdate
          )
            return this.cacheArcLengths;
          this.needsUpdate = !1;
          const t = [];
          let n,
            i = this.getPoint(0),
            r = 0;
          t.push(0);
          for (let s = 1; s <= e; s++)
            (n = this.getPoint(s / e)),
              (r += n.distanceTo(i)),
              t.push(r),
              (i = n);
          return (this.cacheArcLengths = t), t;
        }
        updateArcLengths() {
          (this.needsUpdate = !0), this.getLengths();
        }
        getUtoTmapping(e, t) {
          const n = this.getLengths();
          let i = 0;
          const r = n.length;
          let s;
          s = t || e * n[r - 1];
          let a,
            o = 0,
            l = r - 1;
          for (; o <= l; )
            if (((i = Math.floor(o + (l - o) / 2)), (a = n[i] - s), a < 0))
              o = i + 1;
            else {
              if (!(a > 0)) {
                l = i;
                break;
              }
              l = i - 1;
            }
          if (((i = l), n[i] === s)) return i / (r - 1);
          const c = n[i];
          return (i + (s - c) / (n[i + 1] - c)) / (r - 1);
        }
        getTangent(e, t) {
          const n = 1e-4;
          let i = e - n,
            r = e + n;
          i < 0 && (i = 0), r > 1 && (r = 1);
          const s = this.getPoint(i),
            a = this.getPoint(r),
            o = t || (s.isVector2 ? new Rt() : new on());
          return o.copy(a).sub(s).normalize(), o;
        }
        getTangentAt(e, t) {
          const n = this.getUtoTmapping(e);
          return this.getTangent(n, t);
        }
        computeFrenetFrames(e, t) {
          const n = new on(),
            i = [],
            r = [],
            s = [],
            a = new on(),
            o = new Nn();
          for (let t = 0; t <= e; t++) {
            const n = t / e;
            i[t] = this.getTangentAt(n, new on());
          }
          (r[0] = new on()), (s[0] = new on());
          let l = Number.MAX_VALUE;
          const c = Math.abs(i[0].x),
            u = Math.abs(i[0].y),
            h = Math.abs(i[0].z);
          c <= l && ((l = c), n.set(1, 0, 0)),
            u <= l && ((l = u), n.set(0, 1, 0)),
            h <= l && n.set(0, 0, 1),
            a.crossVectors(i[0], n).normalize(),
            r[0].crossVectors(i[0], a),
            s[0].crossVectors(i[0], r[0]);
          for (let t = 1; t <= e; t++) {
            if (
              ((r[t] = r[t - 1].clone()),
              (s[t] = s[t - 1].clone()),
              a.crossVectors(i[t - 1], i[t]),
              a.length() > Number.EPSILON)
            ) {
              a.normalize();
              const e = Math.acos(Ct(i[t - 1].dot(i[t]), -1, 1));
              r[t].applyMatrix4(o.makeRotationAxis(a, e));
            }
            s[t].crossVectors(i[t], r[t]);
          }
          if (!0 === t) {
            let t = Math.acos(Ct(r[0].dot(r[e]), -1, 1));
            (t /= e), i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (t = -t);
            for (let n = 1; n <= e; n++)
              r[n].applyMatrix4(o.makeRotationAxis(i[n], t * n)),
                s[n].crossVectors(i[n], r[n]);
          }
          return { tangents: i, normals: r, binormals: s };
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
        toJSON() {
          const e = {
            metadata: {
              version: 4.6,
              type: "Curve",
              generator: "Curve.toJSON",
            },
          };
          return (
            (e.arcLengthDivisions = this.arcLengthDivisions),
            (e.type = this.type),
            e
          );
        }
        fromJSON(e) {
          return (this.arcLengthDivisions = e.arcLengthDivisions), this;
        }
      }
      class Tl extends Zi {
        constructor(
          e = 1,
          t = 1,
          n = 1,
          i = 32,
          r = 1,
          s = !1,
          a = 0,
          o = 2 * Math.PI
        ) {
          super(),
            (this.type = "CylinderGeometry"),
            (this.parameters = {
              radiusTop: e,
              radiusBottom: t,
              height: n,
              radialSegments: i,
              heightSegments: r,
              openEnded: s,
              thetaStart: a,
              thetaLength: o,
            });
          const l = this;
          (i = Math.floor(i)), (r = Math.floor(r));
          const c = [],
            u = [],
            h = [],
            d = [];
          let p = 0;
          const f = [],
            A = n / 2;
          let g = 0;
          function m(n) {
            const r = p,
              s = new Rt(),
              f = new on();
            let m = 0;
            const v = !0 === n ? e : t,
              y = !0 === n ? 1 : -1;
            for (let e = 1; e <= i; e++)
              u.push(0, A * y, 0), h.push(0, y, 0), d.push(0.5, 0.5), p++;
            const x = p;
            for (let e = 0; e <= i; e++) {
              const t = (e / i) * o + a,
                n = Math.cos(t),
                r = Math.sin(t);
              (f.x = v * r),
                (f.y = A * y),
                (f.z = v * n),
                u.push(f.x, f.y, f.z),
                h.push(0, y, 0),
                (s.x = 0.5 * n + 0.5),
                (s.y = 0.5 * r * y + 0.5),
                d.push(s.x, s.y),
                p++;
            }
            for (let e = 0; e < i; e++) {
              const t = r + e,
                i = x + e;
              !0 === n ? c.push(i, i + 1, t) : c.push(i + 1, i, t), (m += 3);
            }
            l.addGroup(g, m, !0 === n ? 1 : 2), (g += m);
          }
          !(function () {
            const s = new on(),
              m = new on();
            let v = 0;
            const y = (t - e) / n;
            for (let l = 0; l <= r; l++) {
              const c = [],
                g = l / r,
                v = g * (t - e) + e;
              for (let e = 0; e <= i; e++) {
                const t = e / i,
                  r = t * o + a,
                  l = Math.sin(r),
                  f = Math.cos(r);
                (m.x = v * l),
                  (m.y = -g * n + A),
                  (m.z = v * f),
                  u.push(m.x, m.y, m.z),
                  s.set(l, y, f).normalize(),
                  h.push(s.x, s.y, s.z),
                  d.push(t, 1 - g),
                  c.push(p++);
              }
              f.push(c);
            }
            for (let n = 0; n < i; n++)
              for (let i = 0; i < r; i++) {
                const s = f[i][n],
                  a = f[i + 1][n],
                  o = f[i + 1][n + 1],
                  l = f[i][n + 1];
                (e > 0 || 0 !== i) && (c.push(s, a, l), (v += 3)),
                  (t > 0 || i !== r - 1) && (c.push(a, o, l), (v += 3));
              }
            l.addGroup(g, v, 0), (g += v);
          })(),
            !1 === s && (e > 0 && m(!0), t > 0 && m(!1)),
            this.setIndex(c),
            this.setAttribute("position", new Vi(u, 3)),
            this.setAttribute("normal", new Vi(h, 3)),
            this.setAttribute("uv", new Vi(d, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new Tl(
            e.radiusTop,
            e.radiusBottom,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class Bl extends Tl {
        constructor(
          e = 1,
          t = 1,
          n = 32,
          i = 1,
          r = !1,
          s = 0,
          a = 2 * Math.PI
        ) {
          super(0, e, t, n, i, r, s, a),
            (this.type = "ConeGeometry"),
            (this.parameters = {
              radius: e,
              height: t,
              radialSegments: n,
              heightSegments: i,
              openEnded: r,
              thetaStart: s,
              thetaLength: a,
            });
        }
        static fromJSON(e) {
          return new Bl(
            e.radius,
            e.height,
            e.radialSegments,
            e.heightSegments,
            e.openEnded,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      const Rl = function (e, t, n = 2) {
        const i = t && t.length,
          r = i ? t[0] * n : e.length;
        let s = Dl(e, 0, r, n, !0);
        const a = [];
        if (!s || s.next === s.prev) return a;
        let o, l, c, u, h, d, p;
        if (
          (i &&
            (s = (function (e, t, n, i) {
              const r = [];
              let s, a, o, l, c;
              for (s = 0, a = t.length; s < a; s++)
                (o = t[s] * i),
                  (l = s < a - 1 ? t[s + 1] * i : e.length),
                  (c = Dl(e, o, l, i, !1)),
                  c === c.next && (c.steiner = !0),
                  r.push(zl(c));
              for (r.sort(Ql), s = 0; s < r.length; s++) n = kl(r[s], n);
              return n;
            })(e, t, s, n)),
          e.length > 80 * n)
        ) {
          (o = c = e[0]), (l = u = e[1]);
          for (let t = n; t < r; t += n)
            (h = e[t]),
              (d = e[t + 1]),
              h < o && (o = h),
              d < l && (l = d),
              h > c && (c = h),
              d > u && (u = d);
          (p = Math.max(c - o, u - l)), (p = 0 !== p ? 32767 / p : 0);
        }
        return Ll(s, a, n, o, l, p, 0), a;
      };
      function Dl(e, t, n, i, r) {
        let s, a;
        if (
          r ===
          (function (e, t, n, i) {
            let r = 0;
            for (let s = t, a = n - i; s < n; s += i)
              (r += (e[a] - e[s]) * (e[s + 1] + e[a + 1])), (a = s);
            return r;
          })(e, t, n, i) >
            0
        )
          for (s = t; s < n; s += i) a = $l(s, e[s], e[s + 1], a);
        else for (s = n - i; s >= t; s -= i) a = $l(s, e[s], e[s + 1], a);
        return a && ql(a, a.next) && (ec(a), (a = a.next)), a;
      }
      function Pl(e, t) {
        if (!e) return e;
        t || (t = e);
        let n,
          i = e;
        do {
          if (
            ((n = !1),
            i.steiner || (!ql(i, i.next) && 0 !== jl(i.prev, i, i.next)))
          )
            i = i.next;
          else {
            if ((ec(i), (i = t = i.prev), i === i.next)) break;
            n = !0;
          }
        } while (n || i !== t);
        return t;
      }
      function Ll(e, t, n, i, r, s, a) {
        if (!e) return;
        !a &&
          s &&
          (function (e, t, n, i) {
            let r = e;
            do {
              0 === r.z && (r.z = Hl(r.x, r.y, t, n, i)),
                (r.prevZ = r.prev),
                (r.nextZ = r.next),
                (r = r.next);
            } while (r !== e);
            (r.prevZ.nextZ = null),
              (r.prevZ = null),
              (function (e) {
                let t,
                  n,
                  i,
                  r,
                  s,
                  a,
                  o,
                  l,
                  c = 1;
                do {
                  for (n = e, e = null, s = null, a = 0; n; ) {
                    for (
                      a++, i = n, o = 0, t = 0;
                      t < c && (o++, (i = i.nextZ), i);
                      t++
                    );
                    for (l = c; o > 0 || (l > 0 && i); )
                      0 !== o && (0 === l || !i || n.z <= i.z)
                        ? ((r = n), (n = n.nextZ), o--)
                        : ((r = i), (i = i.nextZ), l--),
                        s ? (s.nextZ = r) : (e = r),
                        (r.prevZ = s),
                        (s = r);
                    n = i;
                  }
                  (s.nextZ = null), (c *= 2);
                } while (a > 1);
              })(r);
          })(e, i, r, s);
        let o,
          l,
          c = e;
        for (; e.prev !== e.next; )
          if (((o = e.prev), (l = e.next), s ? Fl(e, i, r, s) : Ul(e)))
            t.push((o.i / n) | 0),
              t.push((e.i / n) | 0),
              t.push((l.i / n) | 0),
              ec(e),
              (e = l.next),
              (c = l.next);
          else if ((e = l) === c) {
            a
              ? 1 === a
                ? Ll((e = Nl(Pl(e), t, n)), t, n, i, r, s, 2)
                : 2 === a && Ol(e, t, n, i, r, s)
              : Ll(Pl(e), t, n, i, r, s, 1);
            break;
          }
      }
      function Ul(e) {
        const t = e.prev,
          n = e,
          i = e.next;
        if (jl(t, n, i) >= 0) return !1;
        const r = t.x,
          s = n.x,
          a = i.x,
          o = t.y,
          l = n.y,
          c = i.y,
          u = r < s ? (r < a ? r : a) : s < a ? s : a,
          h = o < l ? (o < c ? o : c) : l < c ? l : c,
          d = r > s ? (r > a ? r : a) : s > a ? s : a,
          p = o > l ? (o > c ? o : c) : l > c ? l : c;
        let f = i.next;
        for (; f !== t; ) {
          if (
            f.x >= u &&
            f.x <= d &&
            f.y >= h &&
            f.y <= p &&
            Vl(r, o, s, l, a, c, f.x, f.y) &&
            jl(f.prev, f, f.next) >= 0
          )
            return !1;
          f = f.next;
        }
        return !0;
      }
      function Fl(e, t, n, i) {
        const r = e.prev,
          s = e,
          a = e.next;
        if (jl(r, s, a) >= 0) return !1;
        const o = r.x,
          l = s.x,
          c = a.x,
          u = r.y,
          h = s.y,
          d = a.y,
          p = o < l ? (o < c ? o : c) : l < c ? l : c,
          f = u < h ? (u < d ? u : d) : h < d ? h : d,
          A = o > l ? (o > c ? o : c) : l > c ? l : c,
          g = u > h ? (u > d ? u : d) : h > d ? h : d,
          m = Hl(p, f, t, n, i),
          v = Hl(A, g, t, n, i);
        let y = e.prevZ,
          x = e.nextZ;
        for (; y && y.z >= m && x && x.z <= v; ) {
          if (
            y.x >= p &&
            y.x <= A &&
            y.y >= f &&
            y.y <= g &&
            y !== r &&
            y !== a &&
            Vl(o, u, l, h, c, d, y.x, y.y) &&
            jl(y.prev, y, y.next) >= 0
          )
            return !1;
          if (
            ((y = y.prevZ),
            x.x >= p &&
              x.x <= A &&
              x.y >= f &&
              x.y <= g &&
              x !== r &&
              x !== a &&
              Vl(o, u, l, h, c, d, x.x, x.y) &&
              jl(x.prev, x, x.next) >= 0)
          )
            return !1;
          x = x.nextZ;
        }
        for (; y && y.z >= m; ) {
          if (
            y.x >= p &&
            y.x <= A &&
            y.y >= f &&
            y.y <= g &&
            y !== r &&
            y !== a &&
            Vl(o, u, l, h, c, d, y.x, y.y) &&
            jl(y.prev, y, y.next) >= 0
          )
            return !1;
          y = y.prevZ;
        }
        for (; x && x.z <= v; ) {
          if (
            x.x >= p &&
            x.x <= A &&
            x.y >= f &&
            x.y <= g &&
            x !== r &&
            x !== a &&
            Vl(o, u, l, h, c, d, x.x, x.y) &&
            jl(x.prev, x, x.next) >= 0
          )
            return !1;
          x = x.nextZ;
        }
        return !0;
      }
      function Nl(e, t, n) {
        let i = e;
        do {
          const r = i.prev,
            s = i.next.next;
          !ql(r, s) &&
            Yl(r, i, i.next, s) &&
            Jl(r, s) &&
            Jl(s, r) &&
            (t.push((r.i / n) | 0),
            t.push((i.i / n) | 0),
            t.push((s.i / n) | 0),
            ec(i),
            ec(i.next),
            (i = e = s)),
            (i = i.next);
        } while (i !== e);
        return Pl(i);
      }
      function Ol(e, t, n, i, r, s) {
        let a = e;
        do {
          let e = a.next.next;
          for (; e !== a.prev; ) {
            if (a.i !== e.i && Wl(a, e)) {
              let o = Zl(a, e);
              return (
                (a = Pl(a, a.next)),
                (o = Pl(o, o.next)),
                Ll(a, t, n, i, r, s, 0),
                void Ll(o, t, n, i, r, s, 0)
              );
            }
            e = e.next;
          }
          a = a.next;
        } while (a !== e);
      }
      function Ql(e, t) {
        return e.x - t.x;
      }
      function kl(e, t) {
        const n = (function (e, t) {
          let n,
            i = t,
            r = -1 / 0;
          const s = e.x,
            a = e.y;
          do {
            if (a <= i.y && a >= i.next.y && i.next.y !== i.y) {
              const e = i.x + ((a - i.y) * (i.next.x - i.x)) / (i.next.y - i.y);
              if (
                e <= s &&
                e > r &&
                ((r = e), (n = i.x < i.next.x ? i : i.next), e === s)
              )
                return n;
            }
            i = i.next;
          } while (i !== t);
          if (!n) return null;
          const o = n,
            l = n.x,
            c = n.y;
          let u,
            h = 1 / 0;
          i = n;
          do {
            s >= i.x &&
              i.x >= l &&
              s !== i.x &&
              Vl(a < c ? s : r, a, l, c, a < c ? r : s, a, i.x, i.y) &&
              ((u = Math.abs(a - i.y) / (s - i.x)),
              Jl(i, e) &&
                (u < h ||
                  (u === h && (i.x > n.x || (i.x === n.x && Gl(n, i))))) &&
                ((n = i), (h = u))),
              (i = i.next);
          } while (i !== o);
          return n;
        })(e, t);
        if (!n) return t;
        const i = Zl(n, e);
        return Pl(i, i.next), Pl(n, n.next);
      }
      function Gl(e, t) {
        return jl(e.prev, e, t.prev) < 0 && jl(t.next, e, e.next) < 0;
      }
      function Hl(e, t, n, i, r) {
        return (
          (e =
            1431655765 &
            ((e =
              858993459 &
              ((e =
                252645135 &
                ((e = 16711935 & ((e = ((e - n) * r) | 0) | (e << 8))) |
                  (e << 4))) |
                (e << 2))) |
              (e << 1))) |
          ((t =
            1431655765 &
            ((t =
              858993459 &
              ((t =
                252645135 &
                ((t = 16711935 & ((t = ((t - i) * r) | 0) | (t << 8))) |
                  (t << 4))) |
                (t << 2))) |
              (t << 1))) <<
            1)
        );
      }
      function zl(e) {
        let t = e,
          n = e;
        do {
          (t.x < n.x || (t.x === n.x && t.y < n.y)) && (n = t), (t = t.next);
        } while (t !== e);
        return n;
      }
      function Vl(e, t, n, i, r, s, a, o) {
        return (
          (r - a) * (t - o) >= (e - a) * (s - o) &&
          (e - a) * (i - o) >= (n - a) * (t - o) &&
          (n - a) * (s - o) >= (r - a) * (i - o)
        );
      }
      function Wl(e, t) {
        return (
          e.next.i !== t.i &&
          e.prev.i !== t.i &&
          !(function (e, t) {
            let n = e;
            do {
              if (
                n.i !== e.i &&
                n.next.i !== e.i &&
                n.i !== t.i &&
                n.next.i !== t.i &&
                Yl(n, n.next, e, t)
              )
                return !0;
              n = n.next;
            } while (n !== e);
            return !1;
          })(e, t) &&
          ((Jl(e, t) &&
            Jl(t, e) &&
            (function (e, t) {
              let n = e,
                i = !1;
              const r = (e.x + t.x) / 2,
                s = (e.y + t.y) / 2;
              do {
                n.y > s != n.next.y > s &&
                  n.next.y !== n.y &&
                  r < ((n.next.x - n.x) * (s - n.y)) / (n.next.y - n.y) + n.x &&
                  (i = !i),
                  (n = n.next);
              } while (n !== e);
              return i;
            })(e, t) &&
            (jl(e.prev, e, t.prev) || jl(e, t.prev, t))) ||
            (ql(e, t) &&
              jl(e.prev, e, e.next) > 0 &&
              jl(t.prev, t, t.next) > 0))
        );
      }
      function jl(e, t, n) {
        return (t.y - e.y) * (n.x - t.x) - (t.x - e.x) * (n.y - t.y);
      }
      function ql(e, t) {
        return e.x === t.x && e.y === t.y;
      }
      function Yl(e, t, n, i) {
        const r = Kl(jl(e, t, n)),
          s = Kl(jl(e, t, i)),
          a = Kl(jl(n, i, e)),
          o = Kl(jl(n, i, t));
        return (
          (r !== s && a !== o) ||
          !(0 !== r || !Xl(e, n, t)) ||
          !(0 !== s || !Xl(e, i, t)) ||
          !(0 !== a || !Xl(n, e, i)) ||
          !(0 !== o || !Xl(n, t, i))
        );
      }
      function Xl(e, t, n) {
        return (
          t.x <= Math.max(e.x, n.x) &&
          t.x >= Math.min(e.x, n.x) &&
          t.y <= Math.max(e.y, n.y) &&
          t.y >= Math.min(e.y, n.y)
        );
      }
      function Kl(e) {
        return e > 0 ? 1 : e < 0 ? -1 : 0;
      }
      function Jl(e, t) {
        return jl(e.prev, e, e.next) < 0
          ? jl(e, t, e.next) >= 0 && jl(e, e.prev, t) >= 0
          : jl(e, t, e.prev) < 0 || jl(e, e.next, t) < 0;
      }
      function Zl(e, t) {
        const n = new tc(e.i, e.x, e.y),
          i = new tc(t.i, t.x, t.y),
          r = e.next,
          s = t.prev;
        return (
          (e.next = t),
          (t.prev = e),
          (n.next = r),
          (r.prev = n),
          (i.next = n),
          (n.prev = i),
          (s.next = i),
          (i.prev = s),
          i
        );
      }
      function $l(e, t, n, i) {
        const r = new tc(e, t, n);
        return (
          i
            ? ((r.next = i.next), (r.prev = i), (i.next.prev = r), (i.next = r))
            : ((r.prev = r), (r.next = r)),
          r
        );
      }
      function ec(e) {
        (e.next.prev = e.prev),
          (e.prev.next = e.next),
          e.prevZ && (e.prevZ.nextZ = e.nextZ),
          e.nextZ && (e.nextZ.prevZ = e.prevZ);
      }
      function tc(e, t, n) {
        (this.i = e),
          (this.x = t),
          (this.y = n),
          (this.prev = null),
          (this.next = null),
          (this.z = 0),
          (this.prevZ = null),
          (this.nextZ = null),
          (this.steiner = !1);
      }
      class nc {
        static area(e) {
          const t = e.length;
          let n = 0;
          for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
          return 0.5 * n;
        }
        static isClockWise(e) {
          return nc.area(e) < 0;
        }
        static triangulateShape(e, t) {
          const n = [],
            i = [],
            r = [];
          ic(e), rc(n, e);
          let s = e.length;
          t.forEach(ic);
          for (let e = 0; e < t.length; e++)
            i.push(s), (s += t[e].length), rc(n, t[e]);
          const a = Rl(n, i);
          for (let e = 0; e < a.length; e += 3) r.push(a.slice(e, e + 3));
          return r;
        }
      }
      function ic(e) {
        const t = e.length;
        t > 2 && e[t - 1].equals(e[0]) && e.pop();
      }
      function rc(e, t) {
        for (let n = 0; n < t.length; n++) e.push(t[n].x), e.push(t[n].y);
      }
      class sc extends Zi {
        constructor(
          e = 1,
          t = 32,
          n = 16,
          i = 0,
          r = 2 * Math.PI,
          s = 0,
          a = Math.PI
        ) {
          super(),
            (this.type = "SphereGeometry"),
            (this.parameters = {
              radius: e,
              widthSegments: t,
              heightSegments: n,
              phiStart: i,
              phiLength: r,
              thetaStart: s,
              thetaLength: a,
            }),
            (t = Math.max(3, Math.floor(t))),
            (n = Math.max(2, Math.floor(n)));
          const o = Math.min(s + a, Math.PI);
          let l = 0;
          const c = [],
            u = new on(),
            h = new on(),
            d = [],
            p = [],
            f = [],
            A = [];
          for (let d = 0; d <= n; d++) {
            const g = [],
              m = d / n;
            let v = 0;
            0 === d && 0 === s
              ? (v = 0.5 / t)
              : d === n && o === Math.PI && (v = -0.5 / t);
            for (let n = 0; n <= t; n++) {
              const o = n / t;
              (u.x = -e * Math.cos(i + o * r) * Math.sin(s + m * a)),
                (u.y = e * Math.cos(s + m * a)),
                (u.z = e * Math.sin(i + o * r) * Math.sin(s + m * a)),
                p.push(u.x, u.y, u.z),
                h.copy(u).normalize(),
                f.push(h.x, h.y, h.z),
                A.push(o + v, 1 - m),
                g.push(l++);
            }
            c.push(g);
          }
          for (let e = 0; e < n; e++)
            for (let i = 0; i < t; i++) {
              const t = c[e][i + 1],
                r = c[e][i],
                a = c[e + 1][i],
                l = c[e + 1][i + 1];
              (0 !== e || s > 0) && d.push(t, r, l),
                (e !== n - 1 || o < Math.PI) && d.push(r, a, l);
            }
          this.setIndex(d),
            this.setAttribute("position", new Vi(p, 3)),
            this.setAttribute("normal", new Vi(f, 3)),
            this.setAttribute("uv", new Vi(A, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new sc(
            e.radius,
            e.widthSegments,
            e.heightSegments,
            e.phiStart,
            e.phiLength,
            e.thetaStart,
            e.thetaLength
          );
        }
      }
      class ac extends Zi {
        constructor(e = 1, t = 0.4, n = 12, i = 48, r = 2 * Math.PI) {
          super(),
            (this.type = "TorusGeometry"),
            (this.parameters = {
              radius: e,
              tube: t,
              radialSegments: n,
              tubularSegments: i,
              arc: r,
            }),
            (n = Math.floor(n)),
            (i = Math.floor(i));
          const s = [],
            a = [],
            o = [],
            l = [],
            c = new on(),
            u = new on(),
            h = new on();
          for (let s = 0; s <= n; s++)
            for (let d = 0; d <= i; d++) {
              const p = (d / i) * r,
                f = (s / n) * Math.PI * 2;
              (u.x = (e + t * Math.cos(f)) * Math.cos(p)),
                (u.y = (e + t * Math.cos(f)) * Math.sin(p)),
                (u.z = t * Math.sin(f)),
                a.push(u.x, u.y, u.z),
                (c.x = e * Math.cos(p)),
                (c.y = e * Math.sin(p)),
                h.subVectors(u, c).normalize(),
                o.push(h.x, h.y, h.z),
                l.push(d / i),
                l.push(s / n);
            }
          for (let e = 1; e <= n; e++)
            for (let t = 1; t <= i; t++) {
              const n = (i + 1) * e + t - 1,
                r = (i + 1) * (e - 1) + t - 1,
                a = (i + 1) * (e - 1) + t,
                o = (i + 1) * e + t;
              s.push(n, r, o), s.push(r, a, o);
            }
          this.setIndex(s),
            this.setAttribute("position", new Vi(a, 3)),
            this.setAttribute("normal", new Vi(o, 3)),
            this.setAttribute("uv", new Vi(l, 2));
        }
        copy(e) {
          return (
            super.copy(e),
            (this.parameters = Object.assign({}, e.parameters)),
            this
          );
        }
        static fromJSON(e) {
          return new ac(
            e.radius,
            e.tube,
            e.radialSegments,
            e.tubularSegments,
            e.arc
          );
        }
      }
      class oc extends Di {
        static get type() {
          return "MeshStandardMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshStandardMaterial = !0),
            (this.defines = { STANDARD: "" }),
            (this.color = new Ti(16777215)),
            (this.roughness = 1),
            (this.metalness = 0),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ti(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Rt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.roughnessMap = null),
            (this.metalnessMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new qn()),
            (this.envMapIntensity = 1),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "" }),
            this.color.copy(e.color),
            (this.roughness = e.roughness),
            (this.metalness = e.metalness),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.roughnessMap = e.roughnessMap),
            (this.metalnessMap = e.metalnessMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.envMapIntensity = e.envMapIntensity),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class lc extends oc {
        static get type() {
          return "MeshPhysicalMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhysicalMaterial = !0),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropyRotation = 0),
            (this.anisotropyMap = null),
            (this.clearcoatMap = null),
            (this.clearcoatRoughness = 0),
            (this.clearcoatRoughnessMap = null),
            (this.clearcoatNormalScale = new Rt(1, 1)),
            (this.clearcoatNormalMap = null),
            (this.ior = 1.5),
            Object.defineProperty(this, "reflectivity", {
              get: function () {
                return Ct((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
              },
              set: function (e) {
                this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
              },
            }),
            (this.iridescenceMap = null),
            (this.iridescenceIOR = 1.3),
            (this.iridescenceThicknessRange = [100, 400]),
            (this.iridescenceThicknessMap = null),
            (this.sheenColor = new Ti(0)),
            (this.sheenColorMap = null),
            (this.sheenRoughness = 1),
            (this.sheenRoughnessMap = null),
            (this.transmissionMap = null),
            (this.thickness = 0),
            (this.thicknessMap = null),
            (this.attenuationDistance = 1 / 0),
            (this.attenuationColor = new Ti(1, 1, 1)),
            (this.specularIntensity = 1),
            (this.specularIntensityMap = null),
            (this.specularColor = new Ti(1, 1, 1)),
            (this.specularColorMap = null),
            (this._anisotropy = 0),
            (this._clearcoat = 0),
            (this._dispersion = 0),
            (this._iridescence = 0),
            (this._sheen = 0),
            (this._transmission = 0),
            this.setValues(e);
        }
        get anisotropy() {
          return this._anisotropy;
        }
        set anisotropy(e) {
          this._anisotropy > 0 != e > 0 && this.version++,
            (this._anisotropy = e);
        }
        get clearcoat() {
          return this._clearcoat;
        }
        set clearcoat(e) {
          this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
        }
        get iridescence() {
          return this._iridescence;
        }
        set iridescence(e) {
          this._iridescence > 0 != e > 0 && this.version++,
            (this._iridescence = e);
        }
        get dispersion() {
          return this._dispersion;
        }
        set dispersion(e) {
          this._dispersion > 0 != e > 0 && this.version++,
            (this._dispersion = e);
        }
        get sheen() {
          return this._sheen;
        }
        set sheen(e) {
          this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
        }
        get transmission() {
          return this._transmission;
        }
        set transmission(e) {
          this._transmission > 0 != e > 0 && this.version++,
            (this._transmission = e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.defines = { STANDARD: "", PHYSICAL: "" }),
            (this.anisotropy = e.anisotropy),
            (this.anisotropyRotation = e.anisotropyRotation),
            (this.anisotropyMap = e.anisotropyMap),
            (this.clearcoat = e.clearcoat),
            (this.clearcoatMap = e.clearcoatMap),
            (this.clearcoatRoughness = e.clearcoatRoughness),
            (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
            (this.clearcoatNormalMap = e.clearcoatNormalMap),
            this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
            (this.dispersion = e.dispersion),
            (this.ior = e.ior),
            (this.iridescence = e.iridescence),
            (this.iridescenceMap = e.iridescenceMap),
            (this.iridescenceIOR = e.iridescenceIOR),
            (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
            (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
            (this.sheen = e.sheen),
            this.sheenColor.copy(e.sheenColor),
            (this.sheenColorMap = e.sheenColorMap),
            (this.sheenRoughness = e.sheenRoughness),
            (this.sheenRoughnessMap = e.sheenRoughnessMap),
            (this.transmission = e.transmission),
            (this.transmissionMap = e.transmissionMap),
            (this.thickness = e.thickness),
            (this.thicknessMap = e.thicknessMap),
            (this.attenuationDistance = e.attenuationDistance),
            this.attenuationColor.copy(e.attenuationColor),
            (this.specularIntensity = e.specularIntensity),
            (this.specularIntensityMap = e.specularIntensityMap),
            this.specularColor.copy(e.specularColor),
            (this.specularColorMap = e.specularColorMap),
            this
          );
        }
      }
      class cc extends Di {
        static get type() {
          return "MeshPhongMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshPhongMaterial = !0),
            (this.color = new Ti(16777215)),
            (this.specular = new Ti(1118481)),
            (this.shininess = 30),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ti(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Rt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new qn()),
            (this.combine = x),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            this.specular.copy(e.specular),
            (this.shininess = e.shininess),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      class uc extends Di {
        static get type() {
          return "MeshNormalMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshNormalMaterial = !0),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Rt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.flatShading = !1),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.flatShading = e.flatShading),
            this
          );
        }
      }
      class hc extends Di {
        static get type() {
          return "MeshLambertMaterial";
        }
        constructor(e) {
          super(),
            (this.isMeshLambertMaterial = !0),
            (this.color = new Ti(16777215)),
            (this.map = null),
            (this.lightMap = null),
            (this.lightMapIntensity = 1),
            (this.aoMap = null),
            (this.aoMapIntensity = 1),
            (this.emissive = new Ti(0)),
            (this.emissiveIntensity = 1),
            (this.emissiveMap = null),
            (this.bumpMap = null),
            (this.bumpScale = 1),
            (this.normalMap = null),
            (this.normalMapType = 0),
            (this.normalScale = new Rt(1, 1)),
            (this.displacementMap = null),
            (this.displacementScale = 1),
            (this.displacementBias = 0),
            (this.specularMap = null),
            (this.alphaMap = null),
            (this.envMap = null),
            (this.envMapRotation = new qn()),
            (this.combine = x),
            (this.reflectivity = 1),
            (this.refractionRatio = 0.98),
            (this.wireframe = !1),
            (this.wireframeLinewidth = 1),
            (this.wireframeLinecap = "round"),
            (this.wireframeLinejoin = "round"),
            (this.flatShading = !1),
            (this.fog = !0),
            this.setValues(e);
        }
        copy(e) {
          return (
            super.copy(e),
            this.color.copy(e.color),
            (this.map = e.map),
            (this.lightMap = e.lightMap),
            (this.lightMapIntensity = e.lightMapIntensity),
            (this.aoMap = e.aoMap),
            (this.aoMapIntensity = e.aoMapIntensity),
            this.emissive.copy(e.emissive),
            (this.emissiveMap = e.emissiveMap),
            (this.emissiveIntensity = e.emissiveIntensity),
            (this.bumpMap = e.bumpMap),
            (this.bumpScale = e.bumpScale),
            (this.normalMap = e.normalMap),
            (this.normalMapType = e.normalMapType),
            this.normalScale.copy(e.normalScale),
            (this.displacementMap = e.displacementMap),
            (this.displacementScale = e.displacementScale),
            (this.displacementBias = e.displacementBias),
            (this.specularMap = e.specularMap),
            (this.alphaMap = e.alphaMap),
            (this.envMap = e.envMap),
            this.envMapRotation.copy(e.envMapRotation),
            (this.combine = e.combine),
            (this.reflectivity = e.reflectivity),
            (this.refractionRatio = e.refractionRatio),
            (this.wireframe = e.wireframe),
            (this.wireframeLinewidth = e.wireframeLinewidth),
            (this.wireframeLinecap = e.wireframeLinecap),
            (this.wireframeLinejoin = e.wireframeLinejoin),
            (this.flatShading = e.flatShading),
            (this.fog = e.fog),
            this
          );
        }
      }
      function dc(e, t, n) {
        return !e || (!n && e.constructor === t)
          ? e
          : "number" == typeof t.BYTES_PER_ELEMENT
          ? new t(e)
          : Array.prototype.slice.call(e);
      }
      function pc(e) {
        return ArrayBuffer.isView(e) && !(e instanceof DataView);
      }
      function fc(e) {
        const t = e.length,
          n = new Array(t);
        for (let e = 0; e !== t; ++e) n[e] = e;
        return (
          n.sort(function (t, n) {
            return e[t] - e[n];
          }),
          n
        );
      }
      function Ac(e, t, n) {
        const i = e.length,
          r = new e.constructor(i);
        for (let s = 0, a = 0; a !== i; ++s) {
          const i = n[s] * t;
          for (let n = 0; n !== t; ++n) r[a++] = e[i + n];
        }
        return r;
      }
      function gc(e, t, n, i) {
        let r = 1,
          s = e[0];
        for (; void 0 !== s && void 0 === s[i]; ) s = e[r++];
        if (void 0 === s) return;
        let a = s[i];
        if (void 0 !== a)
          if (Array.isArray(a))
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push.apply(n, a)),
                (s = e[r++]);
            } while (void 0 !== s);
          else if (void 0 !== a.toArray)
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), a.toArray(n, n.length)),
                (s = e[r++]);
            } while (void 0 !== s);
          else
            do {
              (a = s[i]),
                void 0 !== a && (t.push(s.time), n.push(a)),
                (s = e[r++]);
            } while (void 0 !== s);
      }
      class mc {
        constructor(e, t, n, i) {
          (this.parameterPositions = e),
            (this._cachedIndex = 0),
            (this.resultBuffer = void 0 !== i ? i : new t.constructor(n)),
            (this.sampleValues = t),
            (this.valueSize = n),
            (this.settings = null),
            (this.DefaultSettings_ = {});
        }
        evaluate(e) {
          const t = this.parameterPositions;
          let n = this._cachedIndex,
            i = t[n],
            r = t[n - 1];
          e: {
            t: {
              let s;
              n: {
                i: if (!(e < i)) {
                  for (let s = n + 2; ; ) {
                    if (void 0 === i) {
                      if (e < r) break i;
                      return (
                        (n = t.length),
                        (this._cachedIndex = n),
                        this.copySampleValue_(n - 1)
                      );
                    }
                    if (n === s) break;
                    if (((r = i), (i = t[++n]), e < i)) break t;
                  }
                  s = t.length;
                  break n;
                }
                if (e >= r) break e;
                {
                  const a = t[1];
                  e < a && ((n = 2), (r = a));
                  for (let s = n - 2; ; ) {
                    if (void 0 === r)
                      return (this._cachedIndex = 0), this.copySampleValue_(0);
                    if (n === s) break;
                    if (((i = r), (r = t[--n - 1]), e >= r)) break t;
                  }
                  (s = n), (n = 0);
                }
              }
              for (; n < s; ) {
                const i = (n + s) >>> 1;
                e < t[i] ? (s = i) : (n = i + 1);
              }
              if (((i = t[n]), (r = t[n - 1]), void 0 === r))
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (void 0 === i)
                return (
                  (n = t.length),
                  (this._cachedIndex = n),
                  this.copySampleValue_(n - 1)
                );
            }
            (this._cachedIndex = n), this.intervalChanged_(n, r, i);
          }
          return this.interpolate_(n, r, e, i);
        }
        getSettings_() {
          return this.settings || this.DefaultSettings_;
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i;
          for (let e = 0; e !== i; ++e) t[e] = n[r + e];
          return t;
        }
        interpolate_() {
          throw new Error("call to abstract method");
        }
        intervalChanged_() {}
      }
      class vc extends mc {
        constructor(e, t, n, i) {
          super(e, t, n, i),
            (this._weightPrev = -0),
            (this._offsetPrev = -0),
            (this._weightNext = -0),
            (this._offsetNext = -0),
            (this.DefaultSettings_ = { endingStart: $e, endingEnd: $e });
        }
        intervalChanged_(e, t, n) {
          const i = this.parameterPositions;
          let r = e - 2,
            s = e + 1,
            a = i[r],
            o = i[s];
          if (void 0 === a)
            switch (this.getSettings_().endingStart) {
              case et:
                (r = e), (a = 2 * t - n);
                break;
              case tt:
                (r = i.length - 2), (a = t + i[r] - i[r + 1]);
                break;
              default:
                (r = e), (a = n);
            }
          if (void 0 === o)
            switch (this.getSettings_().endingEnd) {
              case et:
                (s = e), (o = 2 * n - t);
                break;
              case tt:
                (s = 1), (o = n + i[1] - i[0]);
                break;
              default:
                (s = e - 1), (o = t);
            }
          const l = 0.5 * (n - t),
            c = this.valueSize;
          (this._weightPrev = l / (t - a)),
            (this._weightNext = l / (o - n)),
            (this._offsetPrev = r * c),
            (this._offsetNext = s * c);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            l = o - a,
            c = this._offsetPrev,
            u = this._offsetNext,
            h = this._weightPrev,
            d = this._weightNext,
            p = (n - t) / (i - t),
            f = p * p,
            A = f * p,
            g = -h * A + 2 * h * f - h * p,
            m = (1 + h) * A + (-1.5 - 2 * h) * f + (-0.5 + h) * p + 1,
            v = (-1 - d) * A + (1.5 + d) * f + 0.5 * p,
            y = d * A - d * f;
          for (let e = 0; e !== a; ++e)
            r[e] = g * s[c + e] + m * s[l + e] + v * s[o + e] + y * s[u + e];
          return r;
        }
      }
      class yc extends mc {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = e * a,
            l = o - a,
            c = (n - t) / (i - t),
            u = 1 - c;
          for (let e = 0; e !== a; ++e) r[e] = s[l + e] * u + s[o + e] * c;
          return r;
        }
      }
      class xc extends mc {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e) {
          return this.copySampleValue_(e - 1);
        }
      }
      class _c {
        constructor(e, t, n, i) {
          if (void 0 === e)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
          if (void 0 === t || 0 === t.length)
            throw new Error(
              "THREE.KeyframeTrack: no keyframes in track named " + e
            );
          (this.name = e),
            (this.times = dc(t, this.TimeBufferType)),
            (this.values = dc(n, this.ValueBufferType)),
            this.setInterpolation(i || this.DefaultInterpolation);
        }
        static toJSON(e) {
          const t = e.constructor;
          let n;
          if (t.toJSON !== this.toJSON) n = t.toJSON(e);
          else {
            n = {
              name: e.name,
              times: dc(e.times, Array),
              values: dc(e.values, Array),
            };
            const t = e.getInterpolation();
            t !== e.DefaultInterpolation && (n.interpolation = t);
          }
          return (n.type = e.ValueTypeName), n;
        }
        InterpolantFactoryMethodDiscrete(e) {
          return new xc(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodLinear(e) {
          return new yc(this.times, this.values, this.getValueSize(), e);
        }
        InterpolantFactoryMethodSmooth(e) {
          return new vc(this.times, this.values, this.getValueSize(), e);
        }
        setInterpolation(e) {
          let t;
          switch (e) {
            case Ke:
              t = this.InterpolantFactoryMethodDiscrete;
              break;
            case Je:
              t = this.InterpolantFactoryMethodLinear;
              break;
            case Ze:
              t = this.InterpolantFactoryMethodSmooth;
          }
          if (void 0 === t) {
            const t =
              "unsupported interpolation for " +
              this.ValueTypeName +
              " keyframe track named " +
              this.name;
            if (void 0 === this.createInterpolant) {
              if (e === this.DefaultInterpolation) throw new Error(t);
              this.setInterpolation(this.DefaultInterpolation);
            }
            return console.warn("THREE.KeyframeTrack:", t), this;
          }
          return (this.createInterpolant = t), this;
        }
        getInterpolation() {
          switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
              return Ke;
            case this.InterpolantFactoryMethodLinear:
              return Je;
            case this.InterpolantFactoryMethodSmooth:
              return Ze;
          }
        }
        getValueSize() {
          return this.values.length / this.times.length;
        }
        shift(e) {
          if (0 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e;
          }
          return this;
        }
        scale(e) {
          if (1 !== e) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e;
          }
          return this;
        }
        trim(e, t) {
          const n = this.times,
            i = n.length;
          let r = 0,
            s = i - 1;
          for (; r !== i && n[r] < e; ) ++r;
          for (; -1 !== s && n[s] > t; ) --s;
          if ((++s, 0 !== r || s !== i)) {
            r >= s && ((s = Math.max(s, 1)), (r = s - 1));
            const e = this.getValueSize();
            (this.times = n.slice(r, s)),
              (this.values = this.values.slice(r * e, s * e));
          }
          return this;
        }
        validate() {
          let e = !0;
          const t = this.getValueSize();
          t - Math.floor(t) != 0 &&
            (console.error(
              "THREE.KeyframeTrack: Invalid value size in track.",
              this
            ),
            (e = !1));
          const n = this.times,
            i = this.values,
            r = n.length;
          0 === r &&
            (console.error("THREE.KeyframeTrack: Track is empty.", this),
            (e = !1));
          let s = null;
          for (let t = 0; t !== r; t++) {
            const i = n[t];
            if ("number" == typeof i && isNaN(i)) {
              console.error(
                "THREE.KeyframeTrack: Time is not a valid number.",
                this,
                t,
                i
              ),
                (e = !1);
              break;
            }
            if (null !== s && s > i) {
              console.error(
                "THREE.KeyframeTrack: Out of order keys.",
                this,
                t,
                i,
                s
              ),
                (e = !1);
              break;
            }
            s = i;
          }
          if (void 0 !== i && pc(i))
            for (let t = 0, n = i.length; t !== n; ++t) {
              const n = i[t];
              if (isNaN(n)) {
                console.error(
                  "THREE.KeyframeTrack: Value is not a valid number.",
                  this,
                  t,
                  n
                ),
                  (e = !1);
                break;
              }
            }
          return e;
        }
        optimize() {
          const e = this.times.slice(),
            t = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === Ze,
            r = e.length - 1;
          let s = 1;
          for (let a = 1; a < r; ++a) {
            let r = !1;
            const o = e[a];
            if (o !== e[a + 1] && (1 !== a || o !== e[0]))
              if (i) r = !0;
              else {
                const e = a * n,
                  i = e - n,
                  s = e + n;
                for (let a = 0; a !== n; ++a) {
                  const n = t[e + a];
                  if (n !== t[i + a] || n !== t[s + a]) {
                    r = !0;
                    break;
                  }
                }
              }
            if (r) {
              if (a !== s) {
                e[s] = e[a];
                const i = a * n,
                  r = s * n;
                for (let e = 0; e !== n; ++e) t[r + e] = t[i + e];
              }
              ++s;
            }
          }
          if (r > 0) {
            e[s] = e[r];
            for (let e = r * n, i = s * n, a = 0; a !== n; ++a)
              t[i + a] = t[e + a];
            ++s;
          }
          return (
            s !== e.length
              ? ((this.times = e.slice(0, s)),
                (this.values = t.slice(0, s * n)))
              : ((this.times = e), (this.values = t)),
            this
          );
        }
        clone() {
          const e = this.times.slice(),
            t = this.values.slice(),
            n = new (0, this.constructor)(this.name, e, t);
          return (n.createInterpolant = this.createInterpolant), n;
        }
      }
      (_c.prototype.TimeBufferType = Float32Array),
        (_c.prototype.ValueBufferType = Float32Array),
        (_c.prototype.DefaultInterpolation = Je);
      class bc extends _c {
        constructor(e, t, n) {
          super(e, t, n);
        }
      }
      (bc.prototype.ValueTypeName = "bool"),
        (bc.prototype.ValueBufferType = Array),
        (bc.prototype.DefaultInterpolation = Ke),
        (bc.prototype.InterpolantFactoryMethodLinear = void 0),
        (bc.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Ec extends _c {}
      Ec.prototype.ValueTypeName = "color";
      class wc extends _c {}
      wc.prototype.ValueTypeName = "number";
      class Cc extends mc {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = (n - t) / (i - t);
          let l = e * a;
          for (let e = l + a; l !== e; l += 4)
            an.slerpFlat(r, 0, s, l - a, s, l, o);
          return r;
        }
      }
      class Ic extends _c {
        InterpolantFactoryMethodLinear(e) {
          return new Cc(this.times, this.values, this.getValueSize(), e);
        }
      }
      (Ic.prototype.ValueTypeName = "quaternion"),
        (Ic.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Sc extends _c {
        constructor(e, t, n) {
          super(e, t, n);
        }
      }
      (Sc.prototype.ValueTypeName = "string"),
        (Sc.prototype.ValueBufferType = Array),
        (Sc.prototype.DefaultInterpolation = Ke),
        (Sc.prototype.InterpolantFactoryMethodLinear = void 0),
        (Sc.prototype.InterpolantFactoryMethodSmooth = void 0);
      class Mc extends _c {}
      Mc.prototype.ValueTypeName = "vector";
      class Tc {
        constructor(e = "", t = -1, n = [], i = nt) {
          (this.name = e),
            (this.tracks = n),
            (this.duration = t),
            (this.blendMode = i),
            (this.uuid = wt()),
            this.duration < 0 && this.resetDuration();
        }
        static parse(e) {
          const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
          for (let e = 0, r = n.length; e !== r; ++e) t.push(Bc(n[e]).scale(i));
          const r = new this(e.name, e.duration, t, e.blendMode);
          return (r.uuid = e.uuid), r;
        }
        static toJSON(e) {
          const t = [],
            n = e.tracks,
            i = {
              name: e.name,
              duration: e.duration,
              tracks: t,
              uuid: e.uuid,
              blendMode: e.blendMode,
            };
          for (let e = 0, i = n.length; e !== i; ++e) t.push(_c.toJSON(n[e]));
          return i;
        }
        static CreateFromMorphTargetSequence(e, t, n, i) {
          const r = t.length,
            s = [];
          for (let e = 0; e < r; e++) {
            let a = [],
              o = [];
            a.push((e + r - 1) % r, e, (e + 1) % r), o.push(0, 1, 0);
            const l = fc(a);
            (a = Ac(a, 1, l)),
              (o = Ac(o, 1, l)),
              i || 0 !== a[0] || (a.push(r), o.push(o[0])),
              s.push(
                new wc(".morphTargetInfluences[" + t[e].name + "]", a, o).scale(
                  1 / n
                )
              );
          }
          return new this(e, -1, s);
        }
        static findByName(e, t) {
          let n = e;
          if (!Array.isArray(e)) {
            const t = e;
            n = (t.geometry && t.geometry.animations) || t.animations;
          }
          for (let e = 0; e < n.length; e++) if (n[e].name === t) return n[e];
          return null;
        }
        static CreateClipsFromMorphTargetSequences(e, t, n) {
          const i = {},
            r = /^([\w-]*?)([\d]+)$/;
          for (let t = 0, n = e.length; t < n; t++) {
            const n = e[t],
              s = n.name.match(r);
            if (s && s.length > 1) {
              const e = s[1];
              let t = i[e];
              t || (i[e] = t = []), t.push(n);
            }
          }
          const s = [];
          for (const e in i)
            s.push(this.CreateFromMorphTargetSequence(e, i[e], t, n));
          return s;
        }
        static parseAnimation(e, t) {
          if (!e)
            return (
              console.error(
                "THREE.AnimationClip: No animation in JSONLoader data."
              ),
              null
            );
          const n = function (e, t, n, i, r) {
              if (0 !== n.length) {
                const s = [],
                  a = [];
                gc(n, s, a, i), 0 !== s.length && r.push(new e(t, s, a));
              }
            },
            i = [],
            r = e.name || "default",
            s = e.fps || 30,
            a = e.blendMode;
          let o = e.length || -1;
          const l = e.hierarchy || [];
          for (let e = 0; e < l.length; e++) {
            const r = l[e].keys;
            if (r && 0 !== r.length)
              if (r[0].morphTargets) {
                const e = {};
                let t;
                for (t = 0; t < r.length; t++)
                  if (r[t].morphTargets)
                    for (let n = 0; n < r[t].morphTargets.length; n++)
                      e[r[t].morphTargets[n]] = -1;
                for (const n in e) {
                  const e = [],
                    s = [];
                  for (let i = 0; i !== r[t].morphTargets.length; ++i) {
                    const i = r[t];
                    e.push(i.time), s.push(i.morphTarget === n ? 1 : 0);
                  }
                  i.push(new wc(".morphTargetInfluence[" + n + "]", e, s));
                }
                o = e.length * s;
              } else {
                const s = ".bones[" + t[e].name + "]";
                n(Mc, s + ".position", r, "pos", i),
                  n(Ic, s + ".quaternion", r, "rot", i),
                  n(Mc, s + ".scale", r, "scl", i);
              }
          }
          if (0 === i.length) return null;
          return new this(r, o, i, a);
        }
        resetDuration() {
          let e = 0;
          for (let t = 0, n = this.tracks.length; t !== n; ++t) {
            const n = this.tracks[t];
            e = Math.max(e, n.times[n.times.length - 1]);
          }
          return (this.duration = e), this;
        }
        trim() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
          return this;
        }
        validate() {
          let e = !0;
          for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
          return e;
        }
        optimize() {
          for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
          return this;
        }
        clone() {
          const e = [];
          for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
          return new this.constructor(
            this.name,
            this.duration,
            e,
            this.blendMode
          );
        }
        toJSON() {
          return this.constructor.toJSON(this);
        }
      }
      function Bc(e) {
        if (void 0 === e.type)
          throw new Error(
            "THREE.KeyframeTrack: track type undefined, can not parse"
          );
        const t = (function (e) {
          switch (e.toLowerCase()) {
            case "scalar":
            case "double":
            case "float":
            case "number":
            case "integer":
              return wc;
            case "vector":
            case "vector2":
            case "vector3":
            case "vector4":
              return Mc;
            case "color":
              return Ec;
            case "quaternion":
              return Ic;
            case "bool":
            case "boolean":
              return bc;
            case "string":
              return Sc;
          }
          throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
        })(e.type);
        if (void 0 === e.times) {
          const t = [],
            n = [];
          gc(e.keys, t, n, "value"), (e.times = t), (e.values = n);
        }
        return void 0 !== t.parse
          ? t.parse(e)
          : new t(e.name, e.times, e.values, e.interpolation);
      }
      const Rc = {
        enabled: !1,
        files: {},
        add: function (e, t) {
          !1 !== this.enabled && (this.files[e] = t);
        },
        get: function (e) {
          if (!1 !== this.enabled) return this.files[e];
        },
        remove: function (e) {
          delete this.files[e];
        },
        clear: function () {
          this.files = {};
        },
      };
      class Dc {
        constructor(e, t, n) {
          const i = this;
          let r,
            s = !1,
            a = 0,
            o = 0;
          const l = [];
          (this.onStart = void 0),
            (this.onLoad = e),
            (this.onProgress = t),
            (this.onError = n),
            (this.itemStart = function (e) {
              o++,
                !1 === s && void 0 !== i.onStart && i.onStart(e, a, o),
                (s = !0);
            }),
            (this.itemEnd = function (e) {
              a++,
                void 0 !== i.onProgress && i.onProgress(e, a, o),
                a === o && ((s = !1), void 0 !== i.onLoad && i.onLoad());
            }),
            (this.itemError = function (e) {
              void 0 !== i.onError && i.onError(e);
            }),
            (this.resolveURL = function (e) {
              return r ? r(e) : e;
            }),
            (this.setURLModifier = function (e) {
              return (r = e), this;
            }),
            (this.addHandler = function (e, t) {
              return l.push(e, t), this;
            }),
            (this.removeHandler = function (e) {
              const t = l.indexOf(e);
              return -1 !== t && l.splice(t, 2), this;
            }),
            (this.getHandler = function (e) {
              for (let t = 0, n = l.length; t < n; t += 2) {
                const n = l[t],
                  i = l[t + 1];
                if ((n.global && (n.lastIndex = 0), n.test(e))) return i;
              }
              return null;
            });
        }
      }
      const Pc = new Dc();
      class Lc {
        constructor(e) {
          (this.manager = void 0 !== e ? e : Pc),
            (this.crossOrigin = "anonymous"),
            (this.withCredentials = !1),
            (this.path = ""),
            (this.resourcePath = ""),
            (this.requestHeader = {});
        }
        load() {}
        loadAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.load(e, i, t, r);
          });
        }
        parse() {}
        setCrossOrigin(e) {
          return (this.crossOrigin = e), this;
        }
        setWithCredentials(e) {
          return (this.withCredentials = e), this;
        }
        setPath(e) {
          return (this.path = e), this;
        }
        setResourcePath(e) {
          return (this.resourcePath = e), this;
        }
        setRequestHeader(e) {
          return (this.requestHeader = e), this;
        }
      }
      Lc.DEFAULT_MATERIAL_NAME = "__DEFAULT";
      const Uc = {};
      class Fc extends Error {
        constructor(e, t) {
          super(e), (this.response = t);
        }
      }
      class Nc extends Lc {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = Rc.get(e);
          if (void 0 !== r)
            return (
              this.manager.itemStart(e),
              setTimeout(() => {
                t && t(r), this.manager.itemEnd(e);
              }, 0),
              r
            );
          if (void 0 !== Uc[e])
            return void Uc[e].push({ onLoad: t, onProgress: n, onError: i });
          (Uc[e] = []), Uc[e].push({ onLoad: t, onProgress: n, onError: i });
          const s = new Request(e, {
              headers: new Headers(this.requestHeader),
              credentials: this.withCredentials ? "include" : "same-origin",
            }),
            a = this.mimeType,
            o = this.responseType;
          fetch(s)
            .then((t) => {
              if (200 === t.status || 0 === t.status) {
                if (
                  (0 === t.status &&
                    console.warn("THREE.FileLoader: HTTP Status 0 received."),
                  "undefined" == typeof ReadableStream ||
                    void 0 === t.body ||
                    void 0 === t.body.getReader)
                )
                  return t;
                const n = Uc[e],
                  i = t.body.getReader(),
                  r =
                    t.headers.get("X-File-Size") ||
                    t.headers.get("Content-Length"),
                  s = r ? parseInt(r) : 0,
                  a = 0 !== s;
                let o = 0;
                const l = new ReadableStream({
                  start(e) {
                    !(function t() {
                      i.read().then(
                        ({ done: i, value: r }) => {
                          if (i) e.close();
                          else {
                            o += r.byteLength;
                            const i = new ProgressEvent("progress", {
                              lengthComputable: a,
                              loaded: o,
                              total: s,
                            });
                            for (let e = 0, t = n.length; e < t; e++) {
                              const t = n[e];
                              t.onProgress && t.onProgress(i);
                            }
                            e.enqueue(r), t();
                          }
                        },
                        (t) => {
                          e.error(t);
                        }
                      );
                    })();
                  },
                });
                return new Response(l);
              }
              throw new Fc(
                `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,
                t
              );
            })
            .then((e) => {
              switch (o) {
                case "arraybuffer":
                  return e.arrayBuffer();
                case "blob":
                  return e.blob();
                case "document":
                  return e
                    .text()
                    .then((e) => new DOMParser().parseFromString(e, a));
                case "json":
                  return e.json();
                default:
                  if (void 0 === a) return e.text();
                  {
                    const t = /charset="?([^;"\s]*)"?/i.exec(a),
                      n = t && t[1] ? t[1].toLowerCase() : void 0,
                      i = new TextDecoder(n);
                    return e.arrayBuffer().then((e) => i.decode(e));
                  }
              }
            })
            .then((t) => {
              Rc.add(e, t);
              const n = Uc[e];
              delete Uc[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onLoad && i.onLoad(t);
              }
            })
            .catch((t) => {
              const n = Uc[e];
              if (void 0 === n) throw (this.manager.itemError(e), t);
              delete Uc[e];
              for (let e = 0, i = n.length; e < i; e++) {
                const i = n[e];
                i.onError && i.onError(t);
              }
              this.manager.itemError(e);
            })
            .finally(() => {
              this.manager.itemEnd(e);
            }),
            this.manager.itemStart(e);
        }
        setResponseType(e) {
          return (this.responseType = e), this;
        }
        setMimeType(e) {
          return (this.mimeType = e), this;
        }
      }
      class Oc extends Lc {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = Rc.get(e);
          if (void 0 !== s)
            return (
              r.manager.itemStart(e),
              setTimeout(function () {
                t && t(s), r.manager.itemEnd(e);
              }, 0),
              s
            );
          const a = Ut("img");
          function o() {
            c(), Rc.add(e, this), t && t(this), r.manager.itemEnd(e);
          }
          function l(t) {
            c(), i && i(t), r.manager.itemError(e), r.manager.itemEnd(e);
          }
          function c() {
            a.removeEventListener("load", o, !1),
              a.removeEventListener("error", l, !1);
          }
          return (
            a.addEventListener("load", o, !1),
            a.addEventListener("error", l, !1),
            "data:" !== e.slice(0, 5) &&
              void 0 !== this.crossOrigin &&
              (a.crossOrigin = this.crossOrigin),
            r.manager.itemStart(e),
            (a.src = e),
            a
          );
        }
      }
      class Qc extends Lc {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = this,
            s = new Vo(),
            a = new Nc(this.manager);
          return (
            a.setResponseType("arraybuffer"),
            a.setRequestHeader(this.requestHeader),
            a.setPath(this.path),
            a.setWithCredentials(r.withCredentials),
            a.load(
              e,
              function (e) {
                let n;
                try {
                  n = r.parse(e);
                } catch (e) {
                  if (void 0 === i) return void console.error(e);
                  i(e);
                }
                void 0 !== n.image
                  ? (s.image = n.image)
                  : void 0 !== n.data &&
                    ((s.image.width = n.width),
                    (s.image.height = n.height),
                    (s.image.data = n.data)),
                  (s.wrapS = void 0 !== n.wrapS ? n.wrapS : O),
                  (s.wrapT = void 0 !== n.wrapT ? n.wrapT : O),
                  (s.magFilter = void 0 !== n.magFilter ? n.magFilter : z),
                  (s.minFilter = void 0 !== n.minFilter ? n.minFilter : z),
                  (s.anisotropy = void 0 !== n.anisotropy ? n.anisotropy : 1),
                  void 0 !== n.colorSpace && (s.colorSpace = n.colorSpace),
                  void 0 !== n.flipY && (s.flipY = n.flipY),
                  void 0 !== n.format && (s.format = n.format),
                  void 0 !== n.type && (s.type = n.type),
                  void 0 !== n.mipmaps &&
                    ((s.mipmaps = n.mipmaps), (s.minFilter = W)),
                  1 === n.mipmapCount && (s.minFilter = z),
                  void 0 !== n.generateMipmaps &&
                    (s.generateMipmaps = n.generateMipmaps),
                  (s.needsUpdate = !0),
                  t && t(s, n);
              },
              n,
              i
            ),
            s
          );
        }
      }
      class kc extends Lc {
        constructor(e) {
          super(e);
        }
        load(e, t, n, i) {
          const r = new $t(),
            s = new Oc(this.manager);
          return (
            s.setCrossOrigin(this.crossOrigin),
            s.setPath(this.path),
            s.load(
              e,
              function (e) {
                (r.image = e), (r.needsUpdate = !0), void 0 !== t && t(r);
              },
              n,
              i
            ),
            r
          );
        }
      }
      class Gc extends ui {
        constructor(e, t = 1) {
          super(),
            (this.isLight = !0),
            (this.type = "Light"),
            (this.color = new Ti(e)),
            (this.intensity = t);
        }
        dispose() {}
        copy(e, t) {
          return (
            super.copy(e, t),
            this.color.copy(e.color),
            (this.intensity = e.intensity),
            this
          );
        }
        toJSON(e) {
          const t = super.toJSON(e);
          return (
            (t.object.color = this.color.getHex()),
            (t.object.intensity = this.intensity),
            void 0 !== this.groundColor &&
              (t.object.groundColor = this.groundColor.getHex()),
            void 0 !== this.distance && (t.object.distance = this.distance),
            void 0 !== this.angle && (t.object.angle = this.angle),
            void 0 !== this.decay && (t.object.decay = this.decay),
            void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
            void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
            void 0 !== this.target && (t.object.target = this.target.uuid),
            t
          );
        }
      }
      const Hc = new Nn(),
        zc = new on(),
        Vc = new on();
      class Wc {
        constructor(e) {
          (this.camera = e),
            (this.intensity = 1),
            (this.bias = 0),
            (this.normalBias = 0),
            (this.radius = 1),
            (this.blurSamples = 8),
            (this.mapSize = new Rt(512, 512)),
            (this.map = null),
            (this.mapPass = null),
            (this.matrix = new Nn()),
            (this.autoUpdate = !0),
            (this.needsUpdate = !1),
            (this._frustum = new Pr()),
            (this._frameExtents = new Rt(1, 1)),
            (this._viewportCount = 1),
            (this._viewports = [new en(0, 0, 1, 1)]);
        }
        getViewportCount() {
          return this._viewportCount;
        }
        getFrustum() {
          return this._frustum;
        }
        updateMatrices(e) {
          const t = this.camera,
            n = this.matrix;
          zc.setFromMatrixPosition(e.matrixWorld),
            t.position.copy(zc),
            Vc.setFromMatrixPosition(e.target.matrixWorld),
            t.lookAt(Vc),
            t.updateMatrixWorld(),
            Hc.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Hc),
            n.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
            n.multiply(Hc);
        }
        getViewport(e) {
          return this._viewports[e];
        }
        getFrameExtents() {
          return this._frameExtents;
        }
        dispose() {
          this.map && this.map.dispose(),
            this.mapPass && this.mapPass.dispose();
        }
        copy(e) {
          return (
            (this.camera = e.camera.clone()),
            (this.intensity = e.intensity),
            (this.bias = e.bias),
            (this.radius = e.radius),
            this.mapSize.copy(e.mapSize),
            this
          );
        }
        clone() {
          return new this.constructor().copy(this);
        }
        toJSON() {
          const e = {};
          return (
            1 !== this.intensity && (e.intensity = this.intensity),
            0 !== this.bias && (e.bias = this.bias),
            0 !== this.normalBias && (e.normalBias = this.normalBias),
            1 !== this.radius && (e.radius = this.radius),
            (512 === this.mapSize.x && 512 === this.mapSize.y) ||
              (e.mapSize = this.mapSize.toArray()),
            (e.camera = this.camera.toJSON(!1).object),
            delete e.camera.matrix,
            e
          );
        }
      }
      class jc extends Wc {
        constructor() {
          super(new br(50, 1, 0.5, 500)),
            (this.isSpotLightShadow = !0),
            (this.focus = 1);
        }
        updateMatrices(e) {
          const t = this.camera,
            n = 2 * Et * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            r = e.distance || t.far;
          (n === t.fov && i === t.aspect && r === t.far) ||
            ((t.fov = n),
            (t.aspect = i),
            (t.far = r),
            t.updateProjectionMatrix()),
            super.updateMatrices(e);
        }
        copy(e) {
          return super.copy(e), (this.focus = e.focus), this;
        }
      }
      class qc extends Gc {
        constructor(e, t, n = 0, i = Math.PI / 3, r = 0, s = 2) {
          super(e, t),
            (this.isSpotLight = !0),
            (this.type = "SpotLight"),
            this.position.copy(ui.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new ui()),
            (this.distance = n),
            (this.angle = i),
            (this.penumbra = r),
            (this.decay = s),
            (this.map = null),
            (this.shadow = new jc());
        }
        get power() {
          return this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / Math.PI;
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.angle = e.angle),
            (this.penumbra = e.penumbra),
            (this.decay = e.decay),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      const Yc = new Nn(),
        Xc = new on(),
        Kc = new on();
      class Jc extends Wc {
        constructor() {
          super(new br(90, 1, 0.5, 500)),
            (this.isPointLightShadow = !0),
            (this._frameExtents = new Rt(4, 2)),
            (this._viewportCount = 6),
            (this._viewports = [
              new en(2, 1, 1, 1),
              new en(0, 1, 1, 1),
              new en(3, 1, 1, 1),
              new en(1, 1, 1, 1),
              new en(3, 0, 1, 1),
              new en(1, 0, 1, 1),
            ]),
            (this._cubeDirections = [
              new on(1, 0, 0),
              new on(-1, 0, 0),
              new on(0, 0, 1),
              new on(0, 0, -1),
              new on(0, 1, 0),
              new on(0, -1, 0),
            ]),
            (this._cubeUps = [
              new on(0, 1, 0),
              new on(0, 1, 0),
              new on(0, 1, 0),
              new on(0, 1, 0),
              new on(0, 0, 1),
              new on(0, 0, -1),
            ]);
        }
        updateMatrices(e, t = 0) {
          const n = this.camera,
            i = this.matrix,
            r = e.distance || n.far;
          r !== n.far && ((n.far = r), n.updateProjectionMatrix()),
            Xc.setFromMatrixPosition(e.matrixWorld),
            n.position.copy(Xc),
            Kc.copy(n.position),
            Kc.add(this._cubeDirections[t]),
            n.up.copy(this._cubeUps[t]),
            n.lookAt(Kc),
            n.updateMatrixWorld(),
            i.makeTranslation(-Xc.x, -Xc.y, -Xc.z),
            Yc.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
            this._frustum.setFromProjectionMatrix(Yc);
        }
      }
      class Zc extends Gc {
        constructor(e, t, n = 0, i = 2) {
          super(e, t),
            (this.isPointLight = !0),
            (this.type = "PointLight"),
            (this.distance = n),
            (this.decay = i),
            (this.shadow = new Jc());
        }
        get power() {
          return 4 * this.intensity * Math.PI;
        }
        set power(e) {
          this.intensity = e / (4 * Math.PI);
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e, t) {
          return (
            super.copy(e, t),
            (this.distance = e.distance),
            (this.decay = e.decay),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class $c extends Wc {
        constructor() {
          super(new Xr(-5, 5, 5, -5, 0.5, 500)),
            (this.isDirectionalLightShadow = !0);
        }
      }
      class eu extends Gc {
        constructor(e, t) {
          super(e, t),
            (this.isDirectionalLight = !0),
            (this.type = "DirectionalLight"),
            this.position.copy(ui.DEFAULT_UP),
            this.updateMatrix(),
            (this.target = new ui()),
            (this.shadow = new $c());
        }
        dispose() {
          this.shadow.dispose();
        }
        copy(e) {
          return (
            super.copy(e),
            (this.target = e.target.clone()),
            (this.shadow = e.shadow.clone()),
            this
          );
        }
      }
      class tu extends Gc {
        constructor(e, t) {
          super(e, t), (this.isAmbientLight = !0), (this.type = "AmbientLight");
        }
      }
      class nu {
        static decodeText(e) {
          if (
            (console.warn(
              "THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."
            ),
            "undefined" != typeof TextDecoder)
          )
            return new TextDecoder().decode(e);
          let t = "";
          for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
          try {
            return decodeURIComponent(escape(t));
          } catch (e) {
            return t;
          }
        }
        static extractUrlBase(e) {
          const t = e.lastIndexOf("/");
          return -1 === t ? "./" : e.slice(0, t + 1);
        }
        static resolveURL(e, t) {
          return "string" != typeof e || "" === e
            ? ""
            : (/^https?:\/\//i.test(t) &&
                /^\//.test(e) &&
                (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
              /^(https?:)?\/\//i.test(e) ||
              /^data:.*,.*$/i.test(e) ||
              /^blob:.*$/i.test(e)
                ? e
                : t + e);
        }
      }
      class iu extends Lc {
        constructor(e) {
          super(e),
            (this.isImageBitmapLoader = !0),
            "undefined" == typeof createImageBitmap &&
              console.warn(
                "THREE.ImageBitmapLoader: createImageBitmap() not supported."
              ),
            "undefined" == typeof fetch &&
              console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
            (this.options = { premultiplyAlpha: "none" });
        }
        setOptions(e) {
          return (this.options = e), this;
        }
        load(e, t, n, i) {
          void 0 === e && (e = ""),
            void 0 !== this.path && (e = this.path + e),
            (e = this.manager.resolveURL(e));
          const r = this,
            s = Rc.get(e);
          if (void 0 !== s)
            return (
              r.manager.itemStart(e),
              s.then
                ? void s
                    .then((n) => {
                      t && t(n), r.manager.itemEnd(e);
                    })
                    .catch((e) => {
                      i && i(e);
                    })
                : (setTimeout(function () {
                    t && t(s), r.manager.itemEnd(e);
                  }, 0),
                  s)
            );
          const a = {};
          (a.credentials =
            "anonymous" === this.crossOrigin ? "same-origin" : "include"),
            (a.headers = this.requestHeader);
          const o = fetch(e, a)
            .then(function (e) {
              return e.blob();
            })
            .then(function (e) {
              return createImageBitmap(
                e,
                Object.assign(r.options, { colorSpaceConversion: "none" })
              );
            })
            .then(function (n) {
              return Rc.add(e, n), t && t(n), r.manager.itemEnd(e), n;
            })
            .catch(function (t) {
              i && i(t),
                Rc.remove(e),
                r.manager.itemError(e),
                r.manager.itemEnd(e);
            });
          Rc.add(e, o), r.manager.itemStart(e);
        }
      }
      class ru {
        constructor(e = !0) {
          (this.autoStart = e),
            (this.startTime = 0),
            (this.oldTime = 0),
            (this.elapsedTime = 0),
            (this.running = !1);
        }
        start() {
          (this.startTime = su()),
            (this.oldTime = this.startTime),
            (this.elapsedTime = 0),
            (this.running = !0);
        }
        stop() {
          this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
        }
        getElapsedTime() {
          return this.getDelta(), this.elapsedTime;
        }
        getDelta() {
          let e = 0;
          if (this.autoStart && !this.running) return this.start(), 0;
          if (this.running) {
            const t = su();
            (e = (t - this.oldTime) / 1e3),
              (this.oldTime = t),
              (this.elapsedTime += e);
          }
          return e;
        }
      }
      function su() {
        return performance.now();
      }
      class au {
        constructor(e, t, n) {
          let i, r, s;
          switch (((this.binding = e), (this.valueSize = n), t)) {
            case "quaternion":
              (i = this._slerp),
                (r = this._slerpAdditive),
                (s = this._setAdditiveIdentityQuaternion),
                (this.buffer = new Float64Array(6 * n)),
                (this._workIndex = 5);
              break;
            case "string":
            case "bool":
              (i = this._select),
                (r = this._select),
                (s = this._setAdditiveIdentityOther),
                (this.buffer = new Array(5 * n));
              break;
            default:
              (i = this._lerp),
                (r = this._lerpAdditive),
                (s = this._setAdditiveIdentityNumeric),
                (this.buffer = new Float64Array(5 * n));
          }
          (this._mixBufferRegion = i),
            (this._mixBufferRegionAdditive = r),
            (this._setIdentity = s),
            (this._origIndex = 3),
            (this._addIndex = 4),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            (this.useCount = 0),
            (this.referenceCount = 0);
        }
        accumulate(e, t) {
          const n = this.buffer,
            i = this.valueSize,
            r = e * i + i;
          let s = this.cumulativeWeight;
          if (0 === s) {
            for (let e = 0; e !== i; ++e) n[r + e] = n[e];
            s = t;
          } else {
            s += t;
            const e = t / s;
            this._mixBufferRegion(n, r, 0, e, i);
          }
          this.cumulativeWeight = s;
        }
        accumulateAdditive(e) {
          const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
          0 === this.cumulativeWeightAdditive && this._setIdentity(),
            this._mixBufferRegionAdditive(t, i, 0, e, n),
            (this.cumulativeWeightAdditive += e);
        }
        apply(e) {
          const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            r = this.cumulativeWeight,
            s = this.cumulativeWeightAdditive,
            a = this.binding;
          if (
            ((this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0),
            r < 1)
          ) {
            const e = t * this._origIndex;
            this._mixBufferRegion(n, i, e, 1 - r, t);
          }
          s > 0 &&
            this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
          for (let e = t, r = t + t; e !== r; ++e)
            if (n[e] !== n[e + t]) {
              a.setValue(n, i);
              break;
            }
        }
        saveOriginalState() {
          const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
          e.getValue(t, i);
          for (let e = n, r = i; e !== r; ++e) t[e] = t[i + (e % n)];
          this._setIdentity(),
            (this.cumulativeWeight = 0),
            (this.cumulativeWeightAdditive = 0);
        }
        restoreOriginalState() {
          const e = 3 * this.valueSize;
          this.binding.setValue(this.buffer, e);
        }
        _setAdditiveIdentityNumeric() {
          const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
          for (let n = e; n < t; n++) this.buffer[n] = 0;
        }
        _setAdditiveIdentityQuaternion() {
          this._setAdditiveIdentityNumeric(),
            (this.buffer[this._addIndex * this.valueSize + 3] = 1);
        }
        _setAdditiveIdentityOther() {
          const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
          for (let n = 0; n < this.valueSize; n++)
            this.buffer[t + n] = this.buffer[e + n];
        }
        _select(e, t, n, i, r) {
          if (i >= 0.5) for (let i = 0; i !== r; ++i) e[t + i] = e[n + i];
        }
        _slerp(e, t, n, i) {
          an.slerpFlat(e, t, e, t, e, n, i);
        }
        _slerpAdditive(e, t, n, i, r) {
          const s = this._workIndex * r;
          an.multiplyQuaternionsFlat(e, s, e, t, e, n),
            an.slerpFlat(e, t, e, t, e, s, i);
        }
        _lerp(e, t, n, i, r) {
          const s = 1 - i;
          for (let a = 0; a !== r; ++a) {
            const r = t + a;
            e[r] = e[r] * s + e[n + a] * i;
          }
        }
        _lerpAdditive(e, t, n, i, r) {
          for (let s = 0; s !== r; ++s) {
            const r = t + s;
            e[r] = e[r] + e[n + s] * i;
          }
        }
      }
      const ou = "\\[\\]\\.:\\/",
        lu = new RegExp("[" + ou + "]", "g"),
        cu = "[^" + ou + "]",
        uu = "[^" + ou.replace("\\.", "") + "]",
        hu = new RegExp(
          "^" +
            /((?:WC+[\/:])*)/.source.replace("WC", cu) +
            /(WCOD+)?/.source.replace("WCOD", uu) +
            /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", cu) +
            /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", cu) +
            "$"
        ),
        du = ["material", "materials", "bones", "map"];
      class pu {
        constructor(e, t, n) {
          (this.path = t),
            (this.parsedPath = n || pu.parseTrackName(t)),
            (this.node = pu.findNode(e, this.parsedPath.nodeName)),
            (this.rootNode = e),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
        static create(e, t, n) {
          return e && e.isAnimationObjectGroup
            ? new pu.Composite(e, t, n)
            : new pu(e, t, n);
        }
        static sanitizeNodeName(e) {
          return e.replace(/\s/g, "_").replace(lu, "");
        }
        static parseTrackName(e) {
          const t = hu.exec(e);
          if (null === t)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
          const n = {
              nodeName: t[2],
              objectName: t[3],
              objectIndex: t[4],
              propertyName: t[5],
              propertyIndex: t[6],
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
          if (void 0 !== i && -1 !== i) {
            const e = n.nodeName.substring(i + 1);
            -1 !== du.indexOf(e) &&
              ((n.nodeName = n.nodeName.substring(0, i)), (n.objectName = e));
          }
          if (null === n.propertyName || 0 === n.propertyName.length)
            throw new Error(
              "PropertyBinding: can not parse propertyName from trackName: " + e
            );
          return n;
        }
        static findNode(e, t) {
          if (
            void 0 === t ||
            "" === t ||
            "." === t ||
            -1 === t ||
            t === e.name ||
            t === e.uuid
          )
            return e;
          if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (void 0 !== n) return n;
          }
          if (e.children) {
            const n = function (e) {
                for (let i = 0; i < e.length; i++) {
                  const r = e[i];
                  if (r.name === t || r.uuid === t) return r;
                  const s = n(r.children);
                  if (s) return s;
                }
                return null;
              },
              i = n(e.children);
            if (i) return i;
          }
          return null;
        }
        _getValue_unavailable() {}
        _setValue_unavailable() {}
        _getValue_direct(e, t) {
          e[t] = this.targetObject[this.propertyName];
        }
        _getValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) e[t++] = n[i];
        }
        _getValue_arrayElement(e, t) {
          e[t] = this.resolvedProperty[this.propertyIndex];
        }
        _getValue_toArray(e, t) {
          this.resolvedProperty.toArray(e, t);
        }
        _setValue_direct(e, t) {
          this.targetObject[this.propertyName] = e[t];
        }
        _setValue_direct_setNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
          (this.targetObject[this.propertyName] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_array(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
        }
        _setValue_array_setNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.needsUpdate = !0;
        }
        _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
          const n = this.resolvedProperty;
          for (let i = 0, r = n.length; i !== r; ++i) n[i] = e[t++];
          this.targetObject.matrixWorldNeedsUpdate = !0;
        }
        _setValue_arrayElement(e, t) {
          this.resolvedProperty[this.propertyIndex] = e[t];
        }
        _setValue_arrayElement_setNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
          (this.resolvedProperty[this.propertyIndex] = e[t]),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _setValue_fromArray(e, t) {
          this.resolvedProperty.fromArray(e, t);
        }
        _setValue_fromArray_setNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.needsUpdate = !0);
        }
        _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
          this.resolvedProperty.fromArray(e, t),
            (this.targetObject.matrixWorldNeedsUpdate = !0);
        }
        _getValue_unbound(e, t) {
          this.bind(), this.getValue(e, t);
        }
        _setValue_unbound(e, t) {
          this.bind(), this.setValue(e, t);
        }
        bind() {
          let e = this.node;
          const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
          let r = t.propertyIndex;
          if (
            (e ||
              ((e = pu.findNode(this.rootNode, t.nodeName)), (this.node = e)),
            (this.getValue = this._getValue_unavailable),
            (this.setValue = this._setValue_unavailable),
            !e)
          )
            return void console.warn(
              "THREE.PropertyBinding: No target node found for track: " +
                this.path +
                "."
            );
          if (n) {
            let i = t.objectIndex;
            switch (n) {
              case "materials":
                if (!e.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!e.material.materials)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
                    this
                  );
                e = e.material.materials;
                break;
              case "bones":
                if (!e.skeleton)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
                    this
                  );
                e = e.skeleton.bones;
                for (let t = 0; t < e.length; t++)
                  if (e[t].name === i) {
                    i = t;
                    break;
                  }
                break;
              case "map":
                if ("map" in e) {
                  e = e.map;
                  break;
                }
                if (!e.material)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
                    this
                  );
                if (!e.material.map)
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
                    this
                  );
                e = e.material.map;
                break;
              default:
                if (void 0 === e[n])
                  return void console.error(
                    "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
                    this
                  );
                e = e[n];
            }
            if (void 0 !== i) {
              if (void 0 === e[i])
                return void console.error(
                  "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
                  this,
                  e
                );
              e = e[i];
            }
          }
          const s = e[i];
          if (void 0 === s) {
            const n = t.nodeName;
            return void console.error(
              "THREE.PropertyBinding: Trying to update property for track: " +
                n +
                "." +
                i +
                " but it wasn't found.",
              e
            );
          }
          let a = this.Versioning.None;
          (this.targetObject = e),
            void 0 !== e.needsUpdate
              ? (a = this.Versioning.NeedsUpdate)
              : void 0 !== e.matrixWorldNeedsUpdate &&
                (a = this.Versioning.MatrixWorldNeedsUpdate);
          let o = this.BindingType.Direct;
          if (void 0 !== r) {
            if ("morphTargetInfluences" === i) {
              if (!e.geometry)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
                  this
                );
              if (!e.geometry.morphAttributes)
                return void console.error(
                  "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
                  this
                );
              void 0 !== e.morphTargetDictionary[r] &&
                (r = e.morphTargetDictionary[r]);
            }
            (o = this.BindingType.ArrayElement),
              (this.resolvedProperty = s),
              (this.propertyIndex = r);
          } else
            void 0 !== s.fromArray && void 0 !== s.toArray
              ? ((o = this.BindingType.HasFromToArray),
                (this.resolvedProperty = s))
              : Array.isArray(s)
              ? ((o = this.BindingType.EntireArray),
                (this.resolvedProperty = s))
              : (this.propertyName = i);
          (this.getValue = this.GetterByBindingType[o]),
            (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
        }
        unbind() {
          (this.node = null),
            (this.getValue = this._getValue_unbound),
            (this.setValue = this._setValue_unbound);
        }
      }
      (pu.Composite = class {
        constructor(e, t, n) {
          const i = n || pu.parseTrackName(t);
          (this._targetGroup = e), (this._bindings = e.subscribe_(t, i));
        }
        getValue(e, t) {
          this.bind();
          const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
          void 0 !== i && i.getValue(e, t);
        }
        setValue(e, t) {
          const n = this._bindings;
          for (
            let i = this._targetGroup.nCachedObjects_, r = n.length;
            i !== r;
            ++i
          )
            n[i].setValue(e, t);
        }
        bind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].bind();
        }
        unbind() {
          const e = this._bindings;
          for (
            let t = this._targetGroup.nCachedObjects_, n = e.length;
            t !== n;
            ++t
          )
            e[t].unbind();
        }
      }),
        (pu.prototype.BindingType = {
          Direct: 0,
          EntireArray: 1,
          ArrayElement: 2,
          HasFromToArray: 3,
        }),
        (pu.prototype.Versioning = {
          None: 0,
          NeedsUpdate: 1,
          MatrixWorldNeedsUpdate: 2,
        }),
        (pu.prototype.GetterByBindingType = [
          pu.prototype._getValue_direct,
          pu.prototype._getValue_array,
          pu.prototype._getValue_arrayElement,
          pu.prototype._getValue_toArray,
        ]),
        (pu.prototype.SetterByBindingTypeAndVersioning = [
          [
            pu.prototype._setValue_direct,
            pu.prototype._setValue_direct_setNeedsUpdate,
            pu.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
          ],
          [
            pu.prototype._setValue_array,
            pu.prototype._setValue_array_setNeedsUpdate,
            pu.prototype._setValue_array_setMatrixWorldNeedsUpdate,
          ],
          [
            pu.prototype._setValue_arrayElement,
            pu.prototype._setValue_arrayElement_setNeedsUpdate,
            pu.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
          ],
          [
            pu.prototype._setValue_fromArray,
            pu.prototype._setValue_fromArray_setNeedsUpdate,
            pu.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
          ],
        ]);
      class fu {
        constructor(e, t, n = null, i = t.blendMode) {
          (this._mixer = e),
            (this._clip = t),
            (this._localRoot = n),
            (this.blendMode = i);
          const r = t.tracks,
            s = r.length,
            a = new Array(s),
            o = { endingStart: $e, endingEnd: $e };
          for (let e = 0; e !== s; ++e) {
            const t = r[e].createInterpolant(null);
            (a[e] = t), (t.settings = o);
          }
          (this._interpolantSettings = o),
            (this._interpolants = a),
            (this._propertyBindings = new Array(s)),
            (this._cacheIndex = null),
            (this._byClipCacheIndex = null),
            (this._timeScaleInterpolant = null),
            (this._weightInterpolant = null),
            (this.loop = Xe),
            (this._loopCount = -1),
            (this._startTime = null),
            (this.time = 0),
            (this.timeScale = 1),
            (this._effectiveTimeScale = 1),
            (this.weight = 1),
            (this._effectiveWeight = 1),
            (this.repetitions = 1 / 0),
            (this.paused = !1),
            (this.enabled = !0),
            (this.clampWhenFinished = !1),
            (this.zeroSlopeAtStart = !0),
            (this.zeroSlopeAtEnd = !0);
        }
        play() {
          return this._mixer._activateAction(this), this;
        }
        stop() {
          return this._mixer._deactivateAction(this), this.reset();
        }
        reset() {
          return (
            (this.paused = !1),
            (this.enabled = !0),
            (this.time = 0),
            (this._loopCount = -1),
            (this._startTime = null),
            this.stopFading().stopWarping()
          );
        }
        isRunning() {
          return (
            this.enabled &&
            !this.paused &&
            0 !== this.timeScale &&
            null === this._startTime &&
            this._mixer._isActiveAction(this)
          );
        }
        isScheduled() {
          return this._mixer._isActiveAction(this);
        }
        startAt(e) {
          return (this._startTime = e), this;
        }
        setLoop(e, t) {
          return (this.loop = e), (this.repetitions = t), this;
        }
        setEffectiveWeight(e) {
          return (
            (this.weight = e),
            (this._effectiveWeight = this.enabled ? e : 0),
            this.stopFading()
          );
        }
        getEffectiveWeight() {
          return this._effectiveWeight;
        }
        fadeIn(e) {
          return this._scheduleFading(e, 0, 1);
        }
        fadeOut(e) {
          return this._scheduleFading(e, 1, 0);
        }
        crossFadeFrom(e, t, n) {
          if ((e.fadeOut(t), this.fadeIn(t), n)) {
            const n = this._clip.duration,
              i = e._clip.duration,
              r = i / n,
              s = n / i;
            e.warp(1, r, t), this.warp(s, 1, t);
          }
          return this;
        }
        crossFadeTo(e, t, n) {
          return e.crossFadeFrom(this, t, n);
        }
        stopFading() {
          const e = this._weightInterpolant;
          return (
            null !== e &&
              ((this._weightInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        setEffectiveTimeScale(e) {
          return (
            (this.timeScale = e),
            (this._effectiveTimeScale = this.paused ? 0 : e),
            this.stopWarping()
          );
        }
        getEffectiveTimeScale() {
          return this._effectiveTimeScale;
        }
        setDuration(e) {
          return (this.timeScale = this._clip.duration / e), this.stopWarping();
        }
        syncWith(e) {
          return (
            (this.time = e.time),
            (this.timeScale = e.timeScale),
            this.stopWarping()
          );
        }
        halt(e) {
          return this.warp(this._effectiveTimeScale, 0, e);
        }
        warp(e, t, n) {
          const i = this._mixer,
            r = i.time,
            s = this.timeScale;
          let a = this._timeScaleInterpolant;
          null === a &&
            ((a = i._lendControlInterpolant()),
            (this._timeScaleInterpolant = a));
          const o = a.parameterPositions,
            l = a.sampleValues;
          return (
            (o[0] = r), (o[1] = r + n), (l[0] = e / s), (l[1] = t / s), this
          );
        }
        stopWarping() {
          const e = this._timeScaleInterpolant;
          return (
            null !== e &&
              ((this._timeScaleInterpolant = null),
              this._mixer._takeBackControlInterpolant(e)),
            this
          );
        }
        getMixer() {
          return this._mixer;
        }
        getClip() {
          return this._clip;
        }
        getRoot() {
          return this._localRoot || this._mixer._root;
        }
        _update(e, t, n, i) {
          if (!this.enabled) return void this._updateWeight(e);
          const r = this._startTime;
          if (null !== r) {
            const i = (e - r) * n;
            i < 0 || 0 === n
              ? (t = 0)
              : ((this._startTime = null), (t = n * i));
          }
          t *= this._updateTimeScale(e);
          const s = this._updateTime(t),
            a = this._updateWeight(e);
          if (a > 0) {
            const e = this._interpolants,
              t = this._propertyBindings;
            if (2501 === this.blendMode)
              for (let n = 0, i = e.length; n !== i; ++n)
                e[n].evaluate(s), t[n].accumulateAdditive(a);
            else
              for (let n = 0, r = e.length; n !== r; ++n)
                e[n].evaluate(s), t[n].accumulate(i, a);
          }
        }
        _updateWeight(e) {
          let t = 0;
          if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (null !== n) {
              const i = n.evaluate(e)[0];
              (t *= i),
                e > n.parameterPositions[1] &&
                  (this.stopFading(), 0 === i && (this.enabled = !1));
            }
          }
          return (this._effectiveWeight = t), t;
        }
        _updateTimeScale(e) {
          let t = 0;
          if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (null !== n) {
              (t *= n.evaluate(e)[0]),
                e > n.parameterPositions[1] &&
                  (this.stopWarping(),
                  0 === t ? (this.paused = !0) : (this.timeScale = t));
            }
          }
          return (this._effectiveTimeScale = t), t;
        }
        _updateTime(e) {
          const t = this._clip.duration,
            n = this.loop;
          let i = this.time + e,
            r = this._loopCount;
          const s = 2202 === n;
          if (0 === e) return -1 === r || !s || 1 & ~r ? i : t - i;
          if (n === Ye) {
            -1 === r && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
            e: {
              if (i >= t) i = t;
              else {
                if (!(i < 0)) {
                  this.time = i;
                  break e;
                }
                i = 0;
              }
              this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
                (this.time = i),
                this._mixer.dispatchEvent({
                  type: "finished",
                  action: this,
                  direction: e < 0 ? -1 : 1,
                });
            }
          } else {
            if (
              (-1 === r &&
                (e >= 0
                  ? ((r = 0), this._setEndings(!0, 0 === this.repetitions, s))
                  : this._setEndings(0 === this.repetitions, !0, s)),
              i >= t || i < 0)
            ) {
              const n = Math.floor(i / t);
              (i -= t * n), (r += Math.abs(n));
              const a = this.repetitions - r;
              if (a <= 0)
                this.clampWhenFinished
                  ? (this.paused = !0)
                  : (this.enabled = !1),
                  (i = e > 0 ? t : 0),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1,
                  });
              else {
                if (1 === a) {
                  const t = e < 0;
                  this._setEndings(t, !t, s);
                } else this._setEndings(!1, !1, s);
                (this._loopCount = r),
                  (this.time = i),
                  this._mixer.dispatchEvent({
                    type: "loop",
                    action: this,
                    loopDelta: n,
                  });
              }
            } else this.time = i;
            if (s && !(1 & ~r)) return t - i;
          }
          return i;
        }
        _setEndings(e, t, n) {
          const i = this._interpolantSettings;
          n
            ? ((i.endingStart = et), (i.endingEnd = et))
            : ((i.endingStart = e ? (this.zeroSlopeAtStart ? et : $e) : tt),
              (i.endingEnd = t ? (this.zeroSlopeAtEnd ? et : $e) : tt));
        }
        _scheduleFading(e, t, n) {
          const i = this._mixer,
            r = i.time;
          let s = this._weightInterpolant;
          null === s &&
            ((s = i._lendControlInterpolant()), (this._weightInterpolant = s));
          const a = s.parameterPositions,
            o = s.sampleValues;
          return (a[0] = r), (o[0] = t), (a[1] = r + e), (o[1] = n), this;
        }
      }
      const Au = new Float32Array(1);
      class gu extends yt {
        constructor(e) {
          super(),
            (this._root = e),
            this._initMemoryManager(),
            (this._accuIndex = 0),
            (this.time = 0),
            (this.timeScale = 1);
        }
        _bindAction(e, t) {
          const n = e._localRoot || this._root,
            i = e._clip.tracks,
            r = i.length,
            s = e._propertyBindings,
            a = e._interpolants,
            o = n.uuid,
            l = this._bindingsByRootAndName;
          let c = l[o];
          void 0 === c && ((c = {}), (l[o] = c));
          for (let e = 0; e !== r; ++e) {
            const r = i[e],
              l = r.name;
            let u = c[l];
            if (void 0 !== u) ++u.referenceCount, (s[e] = u);
            else {
              if (((u = s[e]), void 0 !== u)) {
                null === u._cacheIndex &&
                  (++u.referenceCount, this._addInactiveBinding(u, o, l));
                continue;
              }
              const i = t && t._propertyBindings[e].binding.parsedPath;
              (u = new au(
                pu.create(n, l, i),
                r.ValueTypeName,
                r.getValueSize()
              )),
                ++u.referenceCount,
                this._addInactiveBinding(u, o, l),
                (s[e] = u);
            }
            a[e].resultBuffer = u.buffer;
          }
        }
        _activateAction(e) {
          if (!this._isActiveAction(e)) {
            if (null === e._cacheIndex) {
              const t = (e._localRoot || this._root).uuid,
                n = e._clip.uuid,
                i = this._actionsByClip[n];
              this._bindAction(e, i && i.knownActions[0]),
                this._addInactiveAction(e, n, t);
            }
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == n.useCount++ &&
                (this._lendBinding(n), n.saveOriginalState());
            }
            this._lendAction(e);
          }
        }
        _deactivateAction(e) {
          if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let e = 0, n = t.length; e !== n; ++e) {
              const n = t[e];
              0 == --n.useCount &&
                (n.restoreOriginalState(), this._takeBackBinding(n));
            }
            this._takeBackAction(e);
          }
        }
        _initMemoryManager() {
          (this._actions = []),
            (this._nActiveActions = 0),
            (this._actionsByClip = {}),
            (this._bindings = []),
            (this._nActiveBindings = 0),
            (this._bindingsByRootAndName = {}),
            (this._controlInterpolants = []),
            (this._nActiveControlInterpolants = 0);
          const e = this;
          this.stats = {
            actions: {
              get total() {
                return e._actions.length;
              },
              get inUse() {
                return e._nActiveActions;
              },
            },
            bindings: {
              get total() {
                return e._bindings.length;
              },
              get inUse() {
                return e._nActiveBindings;
              },
            },
            controlInterpolants: {
              get total() {
                return e._controlInterpolants.length;
              },
              get inUse() {
                return e._nActiveControlInterpolants;
              },
            },
          };
        }
        _isActiveAction(e) {
          const t = e._cacheIndex;
          return null !== t && t < this._nActiveActions;
        }
        _addInactiveAction(e, t, n) {
          const i = this._actions,
            r = this._actionsByClip;
          let s = r[t];
          if (void 0 === s)
            (s = { knownActions: [e], actionByRoot: {} }),
              (e._byClipCacheIndex = 0),
              (r[t] = s);
          else {
            const t = s.knownActions;
            (e._byClipCacheIndex = t.length), t.push(e);
          }
          (e._cacheIndex = i.length), i.push(e), (s.actionByRoot[n] = e);
        }
        _removeInactiveAction(e) {
          const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
          (n._cacheIndex = i), (t[i] = n), t.pop(), (e._cacheIndex = null);
          const r = e._clip.uuid,
            s = this._actionsByClip,
            a = s[r],
            o = a.knownActions,
            l = o[o.length - 1],
            c = e._byClipCacheIndex;
          (l._byClipCacheIndex = c),
            (o[c] = l),
            o.pop(),
            (e._byClipCacheIndex = null);
          delete a.actionByRoot[(e._localRoot || this._root).uuid],
            0 === o.length && delete s[r],
            this._removeInactiveBindingsForAction(e);
        }
        _removeInactiveBindingsForAction(e) {
          const t = e._propertyBindings;
          for (let e = 0, n = t.length; e !== n; ++e) {
            const n = t[e];
            0 == --n.referenceCount && this._removeInactiveBinding(n);
          }
        }
        _lendAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackAction(e) {
          const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _addInactiveBinding(e, t, n) {
          const i = this._bindingsByRootAndName,
            r = this._bindings;
          let s = i[t];
          void 0 === s && ((s = {}), (i[t] = s)),
            (s[n] = e),
            (e._cacheIndex = r.length),
            r.push(e);
        }
        _removeInactiveBinding(e) {
          const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            r = n.path,
            s = this._bindingsByRootAndName,
            a = s[i],
            o = t[t.length - 1],
            l = e._cacheIndex;
          (o._cacheIndex = l),
            (t[l] = o),
            t.pop(),
            delete a[r],
            0 === Object.keys(a).length && delete s[i];
        }
        _lendBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _takeBackBinding(e) {
          const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            r = t[i];
          (e._cacheIndex = i), (t[i] = e), (r._cacheIndex = n), (t[n] = r);
        }
        _lendControlInterpolant() {
          const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
          let n = e[t];
          return (
            void 0 === n &&
              ((n = new yc(new Float32Array(2), new Float32Array(2), 1, Au)),
              (n.__cacheIndex = t),
              (e[t] = n)),
            n
          );
        }
        _takeBackControlInterpolant(e) {
          const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            r = t[i];
          (e.__cacheIndex = i), (t[i] = e), (r.__cacheIndex = n), (t[n] = r);
        }
        clipAction(e, t, n) {
          const i = t || this._root,
            r = i.uuid;
          let s = "string" == typeof e ? Tc.findByName(i, e) : e;
          const a = null !== s ? s.uuid : e,
            o = this._actionsByClip[a];
          let l = null;
          if (
            (void 0 === n && (n = null !== s ? s.blendMode : nt), void 0 !== o)
          ) {
            const e = o.actionByRoot[r];
            if (void 0 !== e && e.blendMode === n) return e;
            (l = o.knownActions[0]), null === s && (s = l._clip);
          }
          if (null === s) return null;
          const c = new fu(this, s, t, n);
          return this._bindAction(c, l), this._addInactiveAction(c, a, r), c;
        }
        existingAction(e, t) {
          const n = t || this._root,
            i = n.uuid,
            r = "string" == typeof e ? Tc.findByName(n, e) : e,
            s = r ? r.uuid : e,
            a = this._actionsByClip[s];
          return (void 0 !== a && a.actionByRoot[i]) || null;
        }
        stopAllAction() {
          const e = this._actions;
          for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
          return this;
        }
        update(e) {
          e *= this.timeScale;
          const t = this._actions,
            n = this._nActiveActions,
            i = (this.time += e),
            r = Math.sign(e),
            s = (this._accuIndex ^= 1);
          for (let a = 0; a !== n; ++a) {
            t[a]._update(i, e, r, s);
          }
          const a = this._bindings,
            o = this._nActiveBindings;
          for (let e = 0; e !== o; ++e) a[e].apply(s);
          return this;
        }
        setTime(e) {
          this.time = 0;
          for (let e = 0; e < this._actions.length; e++)
            this._actions[e].time = 0;
          return this.update(e);
        }
        getRoot() {
          return this._root;
        }
        uncacheClip(e) {
          const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            r = i[n];
          if (void 0 !== r) {
            const e = r.knownActions;
            for (let n = 0, i = e.length; n !== i; ++n) {
              const i = e[n];
              this._deactivateAction(i);
              const r = i._cacheIndex,
                s = t[t.length - 1];
              (i._cacheIndex = null),
                (i._byClipCacheIndex = null),
                (s._cacheIndex = r),
                (t[r] = s),
                t.pop(),
                this._removeInactiveBindingsForAction(i);
            }
            delete i[n];
          }
        }
        uncacheRoot(e) {
          const t = e.uuid,
            n = this._actionsByClip;
          for (const e in n) {
            const i = n[e].actionByRoot[t];
            void 0 !== i &&
              (this._deactivateAction(i), this._removeInactiveAction(i));
          }
          const i = this._bindingsByRootAndName[t];
          if (void 0 !== i)
            for (const e in i) {
              const t = i[e];
              t.restoreOriginalState(), this._removeInactiveBinding(t);
            }
        }
        uncacheAction(e, t) {
          const n = this.existingAction(e, t);
          null !== n &&
            (this._deactivateAction(n), this._removeInactiveAction(n));
        }
      }
      class mu {
        constructor(e) {
          this.value = e;
        }
        clone() {
          return new mu(
            void 0 === this.value.clone ? this.value : this.value.clone()
          );
        }
      }
      const vu = new Nn();
      class yu {
        constructor(e, t, n = 0, i = 1 / 0) {
          (this.ray = new Fn(e, t)),
            (this.near = n),
            (this.far = i),
            (this.camera = null),
            (this.layers = new Yn()),
            (this.params = {
              Mesh: {},
              Line: { threshold: 1 },
              LOD: {},
              Points: { threshold: 1 },
              Sprite: {},
            });
        }
        set(e, t) {
          this.ray.set(e, t);
        }
        setFromCamera(e, t) {
          t.isPerspectiveCamera
            ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
              this.ray.direction
                .set(e.x, e.y, 0.5)
                .unproject(t)
                .sub(this.ray.origin)
                .normalize(),
              (this.camera = t))
            : t.isOrthographicCamera
            ? (this.ray.origin
                .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
                .unproject(t),
              this.ray.direction
                .set(0, 0, -1)
                .transformDirection(t.matrixWorld),
              (this.camera = t))
            : console.error(
                "THREE.Raycaster: Unsupported camera type: " + t.type
              );
        }
        setFromXRController(e) {
          return (
            vu.identity().extractRotation(e.matrixWorld),
            this.ray.origin.setFromMatrixPosition(e.matrixWorld),
            this.ray.direction.set(0, 0, -1).applyMatrix4(vu),
            this
          );
        }
        intersectObject(e, t = !0, n = []) {
          return _u(e, this, n, t), n.sort(xu), n;
        }
        intersectObjects(e, t = !0, n = []) {
          for (let i = 0, r = e.length; i < r; i++) _u(e[i], this, n, t);
          return n.sort(xu), n;
        }
      }
      function xu(e, t) {
        return e.distance - t.distance;
      }
      function _u(e, t, n, i) {
        let r = !0;
        if (e.layers.test(t.layers)) {
          !1 === e.raycast(t, n) && (r = !1);
        }
        if (!0 === r && !0 === i) {
          const i = e.children;
          for (let e = 0, r = i.length; e < r; e++) _u(i[e], t, n, !0);
        }
      }
      const bu = new Rt();
      class Eu {
        constructor(e = new Rt(1 / 0, 1 / 0), t = new Rt(-1 / 0, -1 / 0)) {
          (this.isBox2 = !0), (this.min = e), (this.max = t);
        }
        set(e, t) {
          return this.min.copy(e), this.max.copy(t), this;
        }
        setFromPoints(e) {
          this.makeEmpty();
          for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
          return this;
        }
        setFromCenterAndSize(e, t) {
          const n = bu.copy(t).multiplyScalar(0.5);
          return this.min.copy(e).sub(n), this.max.copy(e).add(n), this;
        }
        clone() {
          return new this.constructor().copy(this);
        }
        copy(e) {
          return this.min.copy(e.min), this.max.copy(e.max), this;
        }
        makeEmpty() {
          return (
            (this.min.x = this.min.y = 1 / 0),
            (this.max.x = this.max.y = -1 / 0),
            this
          );
        }
        isEmpty() {
          return this.max.x < this.min.x || this.max.y < this.min.y;
        }
        getCenter(e) {
          return this.isEmpty()
            ? e.set(0, 0)
            : e.addVectors(this.min, this.max).multiplyScalar(0.5);
        }
        getSize(e) {
          return this.isEmpty()
            ? e.set(0, 0)
            : e.subVectors(this.max, this.min);
        }
        expandByPoint(e) {
          return this.min.min(e), this.max.max(e), this;
        }
        expandByVector(e) {
          return this.min.sub(e), this.max.add(e), this;
        }
        expandByScalar(e) {
          return this.min.addScalar(-e), this.max.addScalar(e), this;
        }
        containsPoint(e) {
          return (
            e.x >= this.min.x &&
            e.x <= this.max.x &&
            e.y >= this.min.y &&
            e.y <= this.max.y
          );
        }
        containsBox(e) {
          return (
            this.min.x <= e.min.x &&
            e.max.x <= this.max.x &&
            this.min.y <= e.min.y &&
            e.max.y <= this.max.y
          );
        }
        getParameter(e, t) {
          return t.set(
            (e.x - this.min.x) / (this.max.x - this.min.x),
            (e.y - this.min.y) / (this.max.y - this.min.y)
          );
        }
        intersectsBox(e) {
          return (
            e.max.x >= this.min.x &&
            e.min.x <= this.max.x &&
            e.max.y >= this.min.y &&
            e.min.y <= this.max.y
          );
        }
        clampPoint(e, t) {
          return t.copy(e).clamp(this.min, this.max);
        }
        distanceToPoint(e) {
          return this.clampPoint(e, bu).distanceTo(e);
        }
        intersect(e) {
          return (
            this.min.max(e.min),
            this.max.min(e.max),
            this.isEmpty() && this.makeEmpty(),
            this
          );
        }
        union(e) {
          return this.min.min(e.min), this.max.max(e.max), this;
        }
        translate(e) {
          return this.min.add(e), this.max.add(e), this;
        }
        equals(e) {
          return e.min.equals(this.min) && e.max.equals(this.max);
        }
      }
      const wu = new on(),
        Cu = new on();
      class Iu {
        constructor(e = new on(), t = new on()) {
          (this.start = e), (this.end = t);
        }
        set(e, t) {
          return this.start.copy(e), this.end.copy(t), this;
        }
        copy(e) {
          return this.start.copy(e.start), this.end.copy(e.end), this;
        }
        getCenter(e) {
          return e.addVectors(this.start, this.end).multiplyScalar(0.5);
        }
        delta(e) {
          return e.subVectors(this.end, this.start);
        }
        distanceSq() {
          return this.start.distanceToSquared(this.end);
        }
        distance() {
          return this.start.distanceTo(this.end);
        }
        at(e, t) {
          return this.delta(t).multiplyScalar(e).add(this.start);
        }
        closestPointToPointParameter(e, t) {
          wu.subVectors(e, this.start), Cu.subVectors(this.end, this.start);
          const n = Cu.dot(Cu);
          let i = Cu.dot(wu) / n;
          return t && (i = Ct(i, 0, 1)), i;
        }
        closestPointToPoint(e, t, n) {
          const i = this.closestPointToPointParameter(e, t);
          return this.delta(n).multiplyScalar(i).add(this.start);
        }
        applyMatrix4(e) {
          return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this;
        }
        equals(e) {
          return e.start.equals(this.start) && e.end.equals(this.end);
        }
        clone() {
          return new this.constructor().copy(this);
        }
      }
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("register", { detail: { revision: i } })
        ),
        "undefined" != typeof window &&
          (window.__THREE__
            ? console.warn(
                "WARNING: Multiple instances of Three.js being imported."
              )
            : (window.__THREE__ = i));
    },
    7971: (e, t, n) => {
      "use strict";
      n.d(t, { a8: () => P });
      var i = Uint8Array,
        r = Uint16Array,
        s = Int32Array,
        a = new i([
          0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4,
          4, 5, 5, 5, 5, 0, 0, 0, 0,
        ]),
        o = new i([
          0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10,
          10, 11, 11, 12, 12, 13, 13, 0, 0,
        ]),
        l = new i([
          16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,
        ]),
        c = function (e, t) {
          for (var n = new r(31), i = 0; i < 31; ++i) n[i] = t += 1 << e[i - 1];
          var a = new s(n[30]);
          for (i = 1; i < 30; ++i)
            for (var o = n[i]; o < n[i + 1]; ++o) a[o] = ((o - n[i]) << 5) | i;
          return { b: n, r: a };
        },
        u = c(a, 2),
        h = u.b,
        d = u.r;
      (h[28] = 258), (d[258] = 28);
      for (
        var p = c(o, 0), f = p.b, A = (p.r, new r(32768)), g = 0;
        g < 32768;
        ++g
      ) {
        var m = ((43690 & g) >> 1) | ((21845 & g) << 1);
        (m =
          ((61680 & (m = ((52428 & m) >> 2) | ((13107 & m) << 2))) >> 4) |
          ((3855 & m) << 4)),
          (A[g] = (((65280 & m) >> 8) | ((255 & m) << 8)) >> 1);
      }
      var v = function (e, t, n) {
          for (var i = e.length, s = 0, a = new r(t); s < i; ++s)
            e[s] && ++a[e[s] - 1];
          var o,
            l = new r(t);
          for (s = 1; s < t; ++s) l[s] = (l[s - 1] + a[s - 1]) << 1;
          if (n) {
            o = new r(1 << t);
            var c = 15 - t;
            for (s = 0; s < i; ++s)
              if (e[s])
                for (
                  var u = (s << 4) | e[s],
                    h = t - e[s],
                    d = l[e[s] - 1]++ << h,
                    p = d | ((1 << h) - 1);
                  d <= p;
                  ++d
                )
                  o[A[d] >> c] = u;
          } else
            for (o = new r(i), s = 0; s < i; ++s)
              e[s] && (o[s] = A[l[e[s] - 1]++] >> (15 - e[s]));
          return o;
        },
        y = new i(288);
      for (g = 0; g < 144; ++g) y[g] = 8;
      for (g = 144; g < 256; ++g) y[g] = 9;
      for (g = 256; g < 280; ++g) y[g] = 7;
      for (g = 280; g < 288; ++g) y[g] = 8;
      var x = new i(32);
      for (g = 0; g < 32; ++g) x[g] = 5;
      var _ = v(y, 9, 1),
        b = v(x, 5, 1),
        E = function (e) {
          for (var t = e[0], n = 1; n < e.length; ++n) e[n] > t && (t = e[n]);
          return t;
        },
        w = function (e, t, n) {
          var i = (t / 8) | 0;
          return ((e[i] | (e[i + 1] << 8)) >> (7 & t)) & n;
        },
        C = function (e, t) {
          var n = (t / 8) | 0;
          return (e[n] | (e[n + 1] << 8) | (e[n + 2] << 16)) >> (7 & t);
        },
        I = function (e) {
          return ((e + 7) / 8) | 0;
        },
        S = function (e, t, n) {
          return (
            (null == t || t < 0) && (t = 0),
            (null == n || n > e.length) && (n = e.length),
            new i(e.subarray(t, n))
          );
        },
        M = [
          "unexpected EOF",
          "invalid block type",
          "invalid length/literal",
          "invalid distance",
          "stream finished",
          "no stream handler",
          ,
          "no callback",
          "invalid UTF-8 data",
          "extra field too long",
          "date not in range 1980-2099",
          "filename too long",
          "stream finishing",
          "invalid zip data",
        ],
        T = function (e, t, n) {
          var i = new Error(t || M[e]);
          if (
            ((i.code = e),
            Error.captureStackTrace && Error.captureStackTrace(i, T),
            !n)
          )
            throw i;
          return i;
        },
        B = function (e, t, n, r) {
          var s = e.length,
            c = r ? r.length : 0;
          if (!s || (t.f && !t.l)) return n || new i(0);
          var u = !n,
            d = u || 2 != t.i,
            p = t.i;
          u && (n = new i(3 * s));
          var A = function (e) {
              var t = n.length;
              if (e > t) {
                var r = new i(Math.max(2 * t, e));
                r.set(n), (n = r);
              }
            },
            g = t.f || 0,
            m = t.p || 0,
            y = t.b || 0,
            x = t.l,
            M = t.d,
            B = t.m,
            R = t.n,
            D = 8 * s;
          do {
            if (!x) {
              g = w(e, m, 1);
              var P = w(e, m + 1, 3);
              if (((m += 3), !P)) {
                var L = e[(W = I(m) + 4) - 4] | (e[W - 3] << 8),
                  U = W + L;
                if (U > s) {
                  p && T(0);
                  break;
                }
                d && A(y + L),
                  n.set(e.subarray(W, U), y),
                  (t.b = y += L),
                  (t.p = m = 8 * U),
                  (t.f = g);
                continue;
              }
              if (1 == P) (x = _), (M = b), (B = 9), (R = 5);
              else if (2 == P) {
                var F = w(e, m, 31) + 257,
                  N = w(e, m + 10, 15) + 4,
                  O = F + w(e, m + 5, 31) + 1;
                m += 14;
                for (var Q = new i(O), k = new i(19), G = 0; G < N; ++G)
                  k[l[G]] = w(e, m + 3 * G, 7);
                m += 3 * N;
                var H = E(k),
                  z = (1 << H) - 1,
                  V = v(k, H, 1);
                for (G = 0; G < O; ) {
                  var W,
                    j = V[w(e, m, z)];
                  if (((m += 15 & j), (W = j >> 4) < 16)) Q[G++] = W;
                  else {
                    var q = 0,
                      Y = 0;
                    for (
                      16 == W
                        ? ((Y = 3 + w(e, m, 3)), (m += 2), (q = Q[G - 1]))
                        : 17 == W
                        ? ((Y = 3 + w(e, m, 7)), (m += 3))
                        : 18 == W && ((Y = 11 + w(e, m, 127)), (m += 7));
                      Y--;

                    )
                      Q[G++] = q;
                  }
                }
                var X = Q.subarray(0, F),
                  K = Q.subarray(F);
                (B = E(X)), (R = E(K)), (x = v(X, B, 1)), (M = v(K, R, 1));
              } else T(1);
              if (m > D) {
                p && T(0);
                break;
              }
            }
            d && A(y + 131072);
            for (var J = (1 << B) - 1, Z = (1 << R) - 1, $ = m; ; $ = m) {
              var ee = (q = x[C(e, m) & J]) >> 4;
              if ((m += 15 & q) > D) {
                p && T(0);
                break;
              }
              if ((q || T(2), ee < 256)) n[y++] = ee;
              else {
                if (256 == ee) {
                  ($ = m), (x = null);
                  break;
                }
                var te = ee - 254;
                if (ee > 264) {
                  var ne = a[(G = ee - 257)];
                  (te = w(e, m, (1 << ne) - 1) + h[G]), (m += ne);
                }
                var ie = M[C(e, m) & Z],
                  re = ie >> 4;
                ie || T(3), (m += 15 & ie);
                K = f[re];
                if (re > 3) {
                  ne = o[re];
                  (K += C(e, m) & ((1 << ne) - 1)), (m += ne);
                }
                if (m > D) {
                  p && T(0);
                  break;
                }
                d && A(y + 131072);
                var se = y + te;
                if (y < K) {
                  var ae = c - K,
                    oe = Math.min(K, se);
                  for (ae + y < 0 && T(3); y < oe; ++y) n[y] = r[ae + y];
                }
                for (; y < se; ++y) n[y] = n[y - K];
              }
            }
            (t.l = x),
              (t.p = $),
              (t.b = y),
              (t.f = g),
              x && ((g = 1), (t.m = B), (t.d = M), (t.n = R));
          } while (!g);
          return y != n.length && u ? S(n, 0, y) : n.subarray(0, y);
        },
        R = new i(0),
        D = function (e, t) {
          return (
            (8 != (15 & e[0]) || e[0] >> 4 > 7 || ((e[0] << 8) | e[1]) % 31) &&
              T(6, "invalid zlib data"),
            ((e[1] >> 5) & 1) == +!t &&
              T(
                6,
                "invalid zlib data: " +
                  (32 & e[1] ? "need" : "unexpected") +
                  " dictionary"
              ),
            2 + ((e[1] >> 3) & 4)
          );
        };
      function P(e, t) {
        return B(
          e.subarray(D(e, t && t.dictionary), -4),
          { i: 2 },
          t && t.out,
          t && t.dictionary
        );
      }
      var L = "undefined" != typeof TextDecoder && new TextDecoder();
      try {
        L.decode(R, { stream: !0 }), 1;
      } catch (e) {}
      "function" == typeof queueMicrotask
        ? queueMicrotask
        : "function" == typeof setTimeout && setTimeout;
    },
    9167: (e, t, n) => {
      "use strict";
      n.d(t, { f: () => i });
      var i = (function () {
        var e = new Uint8Array([
            0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3,
            1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10,
            0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11,
          ]),
          t = new Uint8Array([
            32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7,
            15, 116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42,
            67, 24, 23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25,
            63, 75, 136, 108, 28, 118, 29, 73, 115,
          ]);
        if ("object" != typeof WebAssembly) return { supported: !1 };
        var n,
          i = WebAssembly.validate(e)
            ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb"
            : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
          r = WebAssembly.instantiate(s(i), {}).then(function (e) {
            (n = e.instance).exports.__wasm_call_ctors();
          });
        function s(e) {
          for (var n = new Uint8Array(e.length), i = 0; i < e.length; ++i) {
            var r = e.charCodeAt(i);
            n[i] = r > 96 ? r - 97 : r > 64 ? r - 39 : r + 4;
          }
          var s = 0;
          for (i = 0; i < e.length; ++i)
            n[s++] = n[i] < 60 ? t[n[i]] : 64 * (n[i] - 60) + n[++i];
          return n.buffer.slice(0, s);
        }
        function a(e, t, i, r, s, a) {
          var o = n.exports.sbrk,
            l = (i + 3) & -4,
            c = o(l * r),
            u = o(s.length),
            h = new Uint8Array(n.exports.memory.buffer);
          h.set(s, u);
          var d = e(c, i, r, u, s.length);
          if (
            (0 == d && a && a(c, l, r),
            t.set(h.subarray(c, c + i * r)),
            o(c - o(0)),
            0 != d)
          )
            throw new Error("Malformed buffer data: " + d);
        }
        var o = {
            NONE: "",
            OCTAHEDRAL: "meshopt_decodeFilterOct",
            QUATERNION: "meshopt_decodeFilterQuat",
            EXPONENTIAL: "meshopt_decodeFilterExp",
          },
          l = {
            ATTRIBUTES: "meshopt_decodeVertexBuffer",
            TRIANGLES: "meshopt_decodeIndexBuffer",
            INDICES: "meshopt_decodeIndexSequence",
          },
          c = [],
          u = 0;
        function h(e) {
          var t = { object: new Worker(e), pending: 0, requests: {} };
          return (
            (t.object.onmessage = function (e) {
              var n = e.data;
              (t.pending -= n.count),
                t.requests[n.id][n.action](n.value),
                delete t.requests[n.id];
            }),
            t
          );
        }
        function d(e) {
          for (
            var t =
                "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" +
                new Uint8Array(s(i)) +
                "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" +
                a.toString() +
                p.toString(),
              n = new Blob([t], { type: "text/javascript" }),
              r = URL.createObjectURL(n),
              o = 0;
            o < e;
            ++o
          )
            c[o] = h(r);
          URL.revokeObjectURL(r);
        }
        function p(e) {
          r.then(function () {
            var t = e.data;
            try {
              var i = new Uint8Array(t.count * t.size);
              a(
                n.exports[t.mode],
                i,
                t.count,
                t.size,
                t.source,
                n.exports[t.filter]
              ),
                self.postMessage(
                  { id: t.id, count: t.count, action: "resolve", value: i },
                  [i.buffer]
                );
            } catch (e) {
              self.postMessage({
                id: t.id,
                count: t.count,
                action: "reject",
                value: e,
              });
            }
          });
        }
        return {
          ready: r,
          supported: !0,
          useWorkers: function (e) {
            d(e);
          },
          decodeVertexBuffer: function (e, t, i, r, s) {
            a(
              n.exports.meshopt_decodeVertexBuffer,
              e,
              t,
              i,
              r,
              n.exports[o[s]]
            );
          },
          decodeIndexBuffer: function (e, t, i, r) {
            a(n.exports.meshopt_decodeIndexBuffer, e, t, i, r);
          },
          decodeIndexSequence: function (e, t, i, r) {
            a(n.exports.meshopt_decodeIndexSequence, e, t, i, r);
          },
          decodeGltfBuffer: function (e, t, i, r, s, c) {
            a(n.exports[l[s]], e, t, i, r, n.exports[o[c]]);
          },
          decodeGltfBufferAsync: function (e, t, i, s, h) {
            return c.length > 0
              ? (function (e, t, n, i, r) {
                  for (var s = c[0], a = 1; a < c.length; ++a)
                    c[a].pending < s.pending && (s = c[a]);
                  return new Promise(function (a, o) {
                    var l = new Uint8Array(n),
                      c = u++;
                    (s.pending += e),
                      (s.requests[c] = { resolve: a, reject: o }),
                      s.object.postMessage(
                        {
                          id: c,
                          count: e,
                          size: t,
                          source: l,
                          mode: i,
                          filter: r,
                        },
                        [l.buffer]
                      );
                  });
                })(e, t, i, l[s], o[h])
              : r.then(function () {
                  var r = new Uint8Array(e * t);
                  return a(n.exports[l[s]], r, e, t, i, n.exports[o[h]]), r;
                });
          },
        };
      })();
    },
    8087: (e, t, n) => {
      "use strict";
      n.d(t, { Z: () => s });
      var i = n(5062);
      const r = new WeakMap();
      class s extends i.aHM {
        constructor(e) {
          super(e),
            (this.decoderPath = ""),
            (this.decoderConfig = {}),
            (this.decoderBinary = null),
            (this.decoderPending = null),
            (this.workerLimit = 4),
            (this.workerPool = []),
            (this.workerNextTaskID = 1),
            (this.workerSourceURL = ""),
            (this.defaultAttributeIDs = {
              position: "POSITION",
              normal: "NORMAL",
              color: "COLOR",
              uv: "TEX_COORD",
            }),
            (this.defaultAttributeTypes = {
              position: "Float32Array",
              normal: "Float32Array",
              color: "Float32Array",
              uv: "Float32Array",
            });
        }
        setDecoderPath(e) {
          return (this.decoderPath = e), this;
        }
        setDecoderConfig(e) {
          return (this.decoderConfig = e), this;
        }
        setWorkerLimit(e) {
          return (this.workerLimit = e), this;
        }
        load(e, t, n, r) {
          const s = new i.Y9S(this.manager);
          s.setPath(this.path),
            s.setResponseType("arraybuffer"),
            s.setRequestHeader(this.requestHeader),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              (e) => {
                this.parse(e, t, r);
              },
              n,
              r
            );
        }
        parse(e, t, n = () => {}) {
          this.decodeDracoFile(e, t, null, null, i.er$, n).catch(n);
        }
        decodeDracoFile(e, t, n, r, s = i.Zr2, a = () => {}) {
          const o = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: r || this.defaultAttributeTypes,
            useUniqueIDs: !!n,
            vertexColorSpace: s,
          };
          return this.decodeGeometry(e, o).then(t).catch(a);
        }
        decodeGeometry(e, t) {
          const n = JSON.stringify(t);
          if (r.has(e)) {
            const t = r.get(e);
            if (t.key === n) return t.promise;
            if (0 === e.byteLength)
              throw new Error(
                "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
              );
          }
          let i;
          const s = this.workerNextTaskID++,
            a = e.byteLength,
            o = this._getWorker(s, a)
              .then(
                (n) => (
                  (i = n),
                  new Promise((n, r) => {
                    (i._callbacks[s] = { resolve: n, reject: r }),
                      i.postMessage(
                        { type: "decode", id: s, taskConfig: t, buffer: e },
                        [e]
                      );
                  })
                )
              )
              .then((e) => this._createGeometry(e.geometry));
          return (
            o
              .catch(() => !0)
              .then(() => {
                i && s && this._releaseTask(i, s);
              }),
            r.set(e, { key: n, promise: o }),
            o
          );
        }
        _createGeometry(e) {
          const t = new i.LoY();
          e.index && t.setIndex(new i.THS(e.index.array, 1));
          for (let n = 0; n < e.attributes.length; n++) {
            const r = e.attributes[n],
              s = r.name,
              a = r.array,
              o = r.itemSize,
              l = new i.THS(a, o);
            "color" === s &&
              (this._assignVertexColorSpace(l, r.vertexColorSpace),
              (l.normalized = a instanceof Float32Array == !1)),
              t.setAttribute(s, l);
          }
          return t;
        }
        _assignVertexColorSpace(e, t) {
          if (t !== i.er$) return;
          const n = new i.Q1f();
          for (let t = 0, r = e.count; t < r; t++)
            n.fromBufferAttribute(e, t),
              i.ppV.toWorkingColorSpace(n, i.er$),
              e.setXYZ(t, n.r, n.g, n.b);
        }
        _loadLibrary(e, t) {
          const n = new i.Y9S(this.manager);
          return (
            n.setPath(this.decoderPath),
            n.setResponseType(t),
            n.setWithCredentials(this.withCredentials),
            new Promise((t, i) => {
              n.load(e, t, void 0, i);
            })
          );
        }
        preload() {
          return this._initDecoder(), this;
        }
        _initDecoder() {
          if (this.decoderPending) return this.decoderPending;
          const e =
              "object" != typeof WebAssembly ||
              "js" === this.decoderConfig.type,
            t = [];
          return (
            e
              ? t.push(this._loadLibrary("draco_decoder.js", "text"))
              : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
                t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
            (this.decoderPending = Promise.all(t).then((t) => {
              const n = t[0];
              e || (this.decoderConfig.wasmBinary = t[1]);
              const i = a.toString(),
                r = [
                  "/* draco decoder */",
                  n,
                  "",
                  "/* worker */",
                  i.substring(i.indexOf("{") + 1, i.lastIndexOf("}")),
                ].join("\n");
              this.workerSourceURL = URL.createObjectURL(new Blob([r]));
            })),
            this.decoderPending
          );
        }
        _getWorker(e, t) {
          return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
              const e = new Worker(this.workerSourceURL);
              (e._callbacks = {}),
                (e._taskCosts = {}),
                (e._taskLoad = 0),
                e.postMessage({
                  type: "init",
                  decoderConfig: this.decoderConfig,
                }),
                (e.onmessage = function (t) {
                  const n = t.data;
                  switch (n.type) {
                    case "decode":
                      e._callbacks[n.id].resolve(n);
                      break;
                    case "error":
                      e._callbacks[n.id].reject(n);
                      break;
                    default:
                      console.error(
                        'THREE.DRACOLoader: Unexpected message, "' +
                          n.type +
                          '"'
                      );
                  }
                }),
                this.workerPool.push(e);
            } else
              this.workerPool.sort(function (e, t) {
                return e._taskLoad > t._taskLoad ? -1 : 1;
              });
            const n = this.workerPool[this.workerPool.length - 1];
            return (n._taskCosts[e] = t), (n._taskLoad += t), n;
          });
        }
        _releaseTask(e, t) {
          (e._taskLoad -= e._taskCosts[t]),
            delete e._callbacks[t],
            delete e._taskCosts[t];
        }
        debug() {
          console.log(
            "Task load: ",
            this.workerPool.map((e) => e._taskLoad)
          );
        }
        dispose() {
          for (let e = 0; e < this.workerPool.length; ++e)
            this.workerPool[e].terminate();
          return (
            (this.workerPool.length = 0),
            "" !== this.workerSourceURL &&
              URL.revokeObjectURL(this.workerSourceURL),
            this
          );
        }
      }
      function a() {
        let e, t;
        function n(e, t, n, i, r, s) {
          const a = s.num_components(),
            o = n.num_points() * a,
            l = o * r.BYTES_PER_ELEMENT,
            c = (function (e, t) {
              switch (t) {
                case Float32Array:
                  return e.DT_FLOAT32;
                case Int8Array:
                  return e.DT_INT8;
                case Int16Array:
                  return e.DT_INT16;
                case Int32Array:
                  return e.DT_INT32;
                case Uint8Array:
                  return e.DT_UINT8;
                case Uint16Array:
                  return e.DT_UINT16;
                case Uint32Array:
                  return e.DT_UINT32;
              }
            })(e, r),
            u = e._malloc(l);
          t.GetAttributeDataArrayForAllPoints(n, s, c, l, u);
          const h = new r(e.HEAPF32.buffer, u, o).slice();
          return e._free(u), { name: i, array: h, itemSize: a };
        }
        onmessage = function (i) {
          const r = i.data;
          switch (r.type) {
            case "init":
              (e = r.decoderConfig),
                (t = new Promise(function (t) {
                  (e.onModuleLoaded = function (e) {
                    t({ draco: e });
                  }),
                    DracoDecoderModule(e);
                }));
              break;
            case "decode":
              const i = r.buffer,
                s = r.taskConfig;
              t.then((e) => {
                const t = e.draco,
                  a = new t.Decoder();
                try {
                  const e = (function (e, t, i, r) {
                      const s = r.attributeIDs,
                        a = r.attributeTypes;
                      let o, l;
                      const c = t.GetEncodedGeometryType(i);
                      if (c === e.TRIANGULAR_MESH)
                        (o = new e.Mesh()),
                          (l = t.DecodeArrayToMesh(i, i.byteLength, o));
                      else {
                        if (c !== e.POINT_CLOUD)
                          throw new Error(
                            "THREE.DRACOLoader: Unexpected geometry type."
                          );
                        (o = new e.PointCloud()),
                          (l = t.DecodeArrayToPointCloud(i, i.byteLength, o));
                      }
                      if (!l.ok() || 0 === o.ptr)
                        throw new Error(
                          "THREE.DRACOLoader: Decoding failed: " + l.error_msg()
                        );
                      const u = { index: null, attributes: [] };
                      for (const i in s) {
                        const l = self[a[i]];
                        let c, h;
                        if (r.useUniqueIDs)
                          (h = s[i]), (c = t.GetAttributeByUniqueId(o, h));
                        else {
                          if (((h = t.GetAttributeId(o, e[s[i]])), -1 === h))
                            continue;
                          c = t.GetAttribute(o, h);
                        }
                        const d = n(e, t, o, i, l, c);
                        "color" === i &&
                          (d.vertexColorSpace = r.vertexColorSpace),
                          u.attributes.push(d);
                      }
                      c === e.TRIANGULAR_MESH &&
                        (u.index = (function (e, t, n) {
                          const i = n.num_faces(),
                            r = 3 * i,
                            s = 4 * r,
                            a = e._malloc(s);
                          t.GetTrianglesUInt32Array(n, s, a);
                          const o = new Uint32Array(
                            e.HEAPF32.buffer,
                            a,
                            r
                          ).slice();
                          return e._free(a), { array: o, itemSize: 1 };
                        })(e, t, o));
                      return e.destroy(o), u;
                    })(t, a, new Int8Array(i), s),
                    o = e.attributes.map((e) => e.array.buffer);
                  e.index && o.push(e.index.array.buffer),
                    self.postMessage(
                      { type: "decode", id: r.id, geometry: e },
                      o
                    );
                } catch (e) {
                  console.error(e),
                    self.postMessage({
                      type: "error",
                      id: r.id,
                      error: e.message,
                    });
                } finally {
                  t.destroy(a);
                }
              });
          }
        };
      }
    },
    2701: (e, t, n) => {
      "use strict";
      n.d(t, { H: () => s });
      var i = n(5062),
        r = n(7971);
      class s extends i.BRH {
        constructor(e) {
          super(e), (this.type = i.ix0);
        }
        parse(e) {
          const t = 65536,
            n = 14,
            s = 65537,
            a = 16384,
            o = Math.pow(2.7182818, 2.2);
          const l = { l: 0, c: 0, lc: 0 };
          function c(e, t, n, i, r) {
            for (; n < e; ) (t = (t << 8) | z(i, r)), (n += 8);
            (n -= e), (l.l = (t >> n) & ((1 << e) - 1)), (l.c = t), (l.lc = n);
          }
          const u = new Array(59);
          function h(e, t, n, i, r, a) {
            const o = t;
            let h = 0,
              d = 0;
            for (; i <= r; i++) {
              if (o.value - t.value > n) return !1;
              c(6, h, d, e, o);
              const s = l.l;
              if (((h = l.c), (d = l.lc), (a[i] = s), 63 == s)) {
                if (o.value - t.value > n)
                  throw new Error("Something wrong with hufUnpackEncTable");
                c(8, h, d, e, o);
                let s = l.l + 6;
                if (((h = l.c), (d = l.lc), i + s > r + 1))
                  throw new Error("Something wrong with hufUnpackEncTable");
                for (; s--; ) a[i++] = 0;
                i--;
              } else if (s >= 59) {
                let e = s - 59 + 2;
                if (i + e > r + 1)
                  throw new Error("Something wrong with hufUnpackEncTable");
                for (; e--; ) a[i++] = 0;
                i--;
              }
            }
            !(function (e) {
              for (let e = 0; e <= 58; ++e) u[e] = 0;
              for (let t = 0; t < s; ++t) u[e[t]] += 1;
              let t = 0;
              for (let e = 58; e > 0; --e) {
                const n = (t + u[e]) >> 1;
                (u[e] = t), (t = n);
              }
              for (let t = 0; t < s; ++t) {
                const n = e[t];
                n > 0 && (e[t] = n | (u[n]++ << 6));
              }
            })(a);
          }
          function d(e) {
            return 63 & e;
          }
          function p(e) {
            return e >> 6;
          }
          const f = { c: 0, lc: 0 };
          function A(e, t, n, i) {
            (e = (e << 8) | z(n, i)), (t += 8), (f.c = e), (f.lc = t);
          }
          const g = { c: 0, lc: 0 };
          function m(e, t, n, i, r, s, a, o, l) {
            if (e == t) {
              i < 8 && (A(n, i, r, s), (n = f.c), (i = f.lc));
              let e = n >> (i -= 8);
              if (((e = new Uint8Array([e])[0]), o.value + e > l)) return !1;
              const t = a[o.value - 1];
              for (; e-- > 0; ) a[o.value++] = t;
            } else {
              if (!(o.value < l)) return !1;
              a[o.value++] = e;
            }
            (g.c = n), (g.lc = i);
          }
          function v(e) {
            return 65535 & e;
          }
          function y(e) {
            const t = v(e);
            return t > 32767 ? t - 65536 : t;
          }
          const x = { a: 0, b: 0 };
          function _(e, t) {
            const n = y(e),
              i = y(t),
              r = n + (1 & i) + (i >> 1),
              s = r,
              a = r - i;
            (x.a = s), (x.b = a);
          }
          function b(e, t) {
            const n = v(e),
              i = v(t),
              r = (n - (i >> 1)) & 65535,
              s = (i + r - 32768) & 65535;
            (x.a = s), (x.b = r);
          }
          function E(e, t, n, i, r, s, a) {
            const o = a < 16384,
              l = n > r ? r : n;
            let c,
              u,
              h = 1;
            for (; h <= l; ) h <<= 1;
            for (h >>= 1, c = h, h >>= 1; h >= 1; ) {
              u = 0;
              const a = u + s * (r - c),
                l = s * h,
                d = s * c,
                p = i * h,
                f = i * c;
              let A, g, m, v;
              for (; u <= a; u += d) {
                let r = u;
                const s = u + i * (n - c);
                for (; r <= s; r += f) {
                  const n = r + p,
                    i = r + l,
                    s = i + p;
                  o
                    ? (_(e[r + t], e[i + t]),
                      (A = x.a),
                      (m = x.b),
                      _(e[n + t], e[s + t]),
                      (g = x.a),
                      (v = x.b),
                      _(A, g),
                      (e[r + t] = x.a),
                      (e[n + t] = x.b),
                      _(m, v),
                      (e[i + t] = x.a),
                      (e[s + t] = x.b))
                    : (b(e[r + t], e[i + t]),
                      (A = x.a),
                      (m = x.b),
                      b(e[n + t], e[s + t]),
                      (g = x.a),
                      (v = x.b),
                      b(A, g),
                      (e[r + t] = x.a),
                      (e[n + t] = x.b),
                      b(m, v),
                      (e[i + t] = x.a),
                      (e[s + t] = x.b));
                }
                if (n & h) {
                  const n = r + l;
                  o ? _(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                    (A = x.a),
                    (e[n + t] = x.b),
                    (e[r + t] = A);
                }
              }
              if (r & h) {
                let r = u;
                const s = u + i * (n - c);
                for (; r <= s; r += f) {
                  const n = r + p;
                  o ? _(e[r + t], e[n + t]) : b(e[r + t], e[n + t]),
                    (A = x.a),
                    (e[n + t] = x.b),
                    (e[r + t] = A);
                }
              }
              (c = h), (h >>= 1);
            }
            return u;
          }
          function w(e, t, i, r, o, l) {
            const c = i.value,
              u = H(t, i),
              v = H(t, i);
            i.value += 4;
            const y = H(t, i);
            if (((i.value += 4), u < 0 || u >= s || v < 0 || v >= s))
              throw new Error("Something wrong with HUF_ENCSIZE");
            const x = new Array(s),
              _ = new Array(a);
            !(function (e) {
              for (let t = 0; t < a; t++)
                (e[t] = {}), (e[t].len = 0), (e[t].lit = 0), (e[t].p = null);
            })(_);
            if (
              (h(e, i, r - (i.value - c), u, v, x), y > 8 * (r - (i.value - c)))
            )
              throw new Error("Something wrong with hufUncompress");
            !(function (e, t, i, r) {
              for (; t <= i; t++) {
                const i = p(e[t]),
                  s = d(e[t]);
                if (i >> s) throw new Error("Invalid table entry");
                if (s > n) {
                  const e = r[i >> (s - n)];
                  if (e.len) throw new Error("Invalid table entry");
                  if ((e.lit++, e.p)) {
                    const t = e.p;
                    e.p = new Array(e.lit);
                    for (let n = 0; n < e.lit - 1; ++n) e.p[n] = t[n];
                  } else e.p = new Array(1);
                  e.p[e.lit - 1] = t;
                } else if (s) {
                  let e = 0;
                  for (let a = 1 << (n - s); a > 0; a--) {
                    const a = r[(i << (n - s)) + e];
                    if (a.len || a.p) throw new Error("Invalid table entry");
                    (a.len = s), (a.lit = t), e++;
                  }
                }
              }
            })(x, u, v, _),
              (function (e, t, i, r, s, a, o, l, c) {
                let u = 0,
                  h = 0;
                const v = o,
                  y = Math.trunc(r.value + (s + 7) / 8);
                for (; r.value < y; )
                  for (A(u, h, i, r), u = f.c, h = f.lc; h >= n; ) {
                    const s = t[(u >> (h - n)) & 16383];
                    if (s.len)
                      (h -= s.len),
                        m(s.lit, a, u, h, i, r, l, c, v),
                        (u = g.c),
                        (h = g.lc);
                    else {
                      if (!s.p) throw new Error("hufDecode issues");
                      let t;
                      for (t = 0; t < s.lit; t++) {
                        const n = d(e[s.p[t]]);
                        for (; h < n && r.value < y; )
                          A(u, h, i, r), (u = f.c), (h = f.lc);
                        if (
                          h >= n &&
                          p(e[s.p[t]]) == ((u >> (h - n)) & ((1 << n) - 1))
                        ) {
                          (h -= n),
                            m(s.p[t], a, u, h, i, r, l, c, v),
                            (u = g.c),
                            (h = g.lc);
                          break;
                        }
                      }
                      if (t == s.lit) throw new Error("hufDecode issues");
                    }
                  }
                const x = (8 - s) & 7;
                for (u >>= x, h -= x; h > 0; ) {
                  const e = t[(u << (n - h)) & 16383];
                  if (!e.len) throw new Error("hufDecode issues");
                  (h -= e.len),
                    m(e.lit, a, u, h, i, r, l, c, v),
                    (u = g.c),
                    (h = g.lc);
                }
              })(x, _, e, i, y, v, l, o, { value: 0 });
          }
          function C(e) {
            for (let t = 1; t < e.length; t++) {
              const n = e[t - 1] + e[t] - 128;
              e[t] = n;
            }
          }
          function I(e, t) {
            let n = 0,
              i = Math.floor((e.length + 1) / 2),
              r = 0;
            const s = e.length - 1;
            for (; !(r > s || ((t[r++] = e[n++]), r > s)); ) t[r++] = e[i++];
          }
          function S(e) {
            let t = e.byteLength;
            const n = new Array();
            let i = 0;
            const r = new DataView(e);
            for (; t > 0; ) {
              const e = r.getInt8(i++);
              if (e < 0) {
                const s = -e;
                t -= s + 1;
                for (let e = 0; e < s; e++) n.push(r.getUint8(i++));
              } else {
                const s = e;
                t -= 2;
                const a = r.getUint8(i++);
                for (let e = 0; e < s + 1; e++) n.push(a);
              }
            }
            return n;
          }
          function M(e, t, n) {
            let i,
              r = 1;
            for (; r < 64; )
              (i = t[e.value]),
                65280 == i
                  ? (r = 64)
                  : i >> 8 == 255
                  ? (r += 255 & i)
                  : ((n[r] = i), r++),
                e.value++;
          }
          function T(e, t) {
            (t[0] = Y(e[0])),
              (t[1] = Y(e[1])),
              (t[2] = Y(e[5])),
              (t[3] = Y(e[6])),
              (t[4] = Y(e[14])),
              (t[5] = Y(e[15])),
              (t[6] = Y(e[27])),
              (t[7] = Y(e[28])),
              (t[8] = Y(e[2])),
              (t[9] = Y(e[4])),
              (t[10] = Y(e[7])),
              (t[11] = Y(e[13])),
              (t[12] = Y(e[16])),
              (t[13] = Y(e[26])),
              (t[14] = Y(e[29])),
              (t[15] = Y(e[42])),
              (t[16] = Y(e[3])),
              (t[17] = Y(e[8])),
              (t[18] = Y(e[12])),
              (t[19] = Y(e[17])),
              (t[20] = Y(e[25])),
              (t[21] = Y(e[30])),
              (t[22] = Y(e[41])),
              (t[23] = Y(e[43])),
              (t[24] = Y(e[9])),
              (t[25] = Y(e[11])),
              (t[26] = Y(e[18])),
              (t[27] = Y(e[24])),
              (t[28] = Y(e[31])),
              (t[29] = Y(e[40])),
              (t[30] = Y(e[44])),
              (t[31] = Y(e[53])),
              (t[32] = Y(e[10])),
              (t[33] = Y(e[19])),
              (t[34] = Y(e[23])),
              (t[35] = Y(e[32])),
              (t[36] = Y(e[39])),
              (t[37] = Y(e[45])),
              (t[38] = Y(e[52])),
              (t[39] = Y(e[54])),
              (t[40] = Y(e[20])),
              (t[41] = Y(e[22])),
              (t[42] = Y(e[33])),
              (t[43] = Y(e[38])),
              (t[44] = Y(e[46])),
              (t[45] = Y(e[51])),
              (t[46] = Y(e[55])),
              (t[47] = Y(e[60])),
              (t[48] = Y(e[21])),
              (t[49] = Y(e[34])),
              (t[50] = Y(e[37])),
              (t[51] = Y(e[47])),
              (t[52] = Y(e[50])),
              (t[53] = Y(e[56])),
              (t[54] = Y(e[59])),
              (t[55] = Y(e[61])),
              (t[56] = Y(e[35])),
              (t[57] = Y(e[36])),
              (t[58] = Y(e[48])),
              (t[59] = Y(e[49])),
              (t[60] = Y(e[57])),
              (t[61] = Y(e[58])),
              (t[62] = Y(e[62])),
              (t[63] = Y(e[63]));
          }
          function B(e) {
            const t = 0.5 * Math.cos(0.7853975),
              n = 0.5 * Math.cos(3.14159 / 16),
              i = 0.5 * Math.cos(3.14159 / 8),
              r = 0.5 * Math.cos((3 * 3.14159) / 16),
              s = 0.5 * Math.cos(0.981746875),
              a = 0.5 * Math.cos((3 * 3.14159) / 8),
              o = 0.5 * Math.cos(1.374445625),
              l = new Array(4),
              c = new Array(4),
              u = new Array(4),
              h = new Array(4);
            for (let d = 0; d < 8; ++d) {
              const p = 8 * d;
              (l[0] = i * e[p + 2]),
                (l[1] = a * e[p + 2]),
                (l[2] = i * e[p + 6]),
                (l[3] = a * e[p + 6]),
                (c[0] =
                  n * e[p + 1] + r * e[p + 3] + s * e[p + 5] + o * e[p + 7]),
                (c[1] =
                  r * e[p + 1] - o * e[p + 3] - n * e[p + 5] - s * e[p + 7]),
                (c[2] =
                  s * e[p + 1] - n * e[p + 3] + o * e[p + 5] + r * e[p + 7]),
                (c[3] =
                  o * e[p + 1] - s * e[p + 3] + r * e[p + 5] - n * e[p + 7]),
                (u[0] = t * (e[p + 0] + e[p + 4])),
                (u[3] = t * (e[p + 0] - e[p + 4])),
                (u[1] = l[0] + l[3]),
                (u[2] = l[1] - l[2]),
                (h[0] = u[0] + u[1]),
                (h[1] = u[3] + u[2]),
                (h[2] = u[3] - u[2]),
                (h[3] = u[0] - u[1]),
                (e[p + 0] = h[0] + c[0]),
                (e[p + 1] = h[1] + c[1]),
                (e[p + 2] = h[2] + c[2]),
                (e[p + 3] = h[3] + c[3]),
                (e[p + 4] = h[3] - c[3]),
                (e[p + 5] = h[2] - c[2]),
                (e[p + 6] = h[1] - c[1]),
                (e[p + 7] = h[0] - c[0]);
            }
            for (let d = 0; d < 8; ++d)
              (l[0] = i * e[16 + d]),
                (l[1] = a * e[16 + d]),
                (l[2] = i * e[48 + d]),
                (l[3] = a * e[48 + d]),
                (c[0] =
                  n * e[8 + d] + r * e[24 + d] + s * e[40 + d] + o * e[56 + d]),
                (c[1] =
                  r * e[8 + d] - o * e[24 + d] - n * e[40 + d] - s * e[56 + d]),
                (c[2] =
                  s * e[8 + d] - n * e[24 + d] + o * e[40 + d] + r * e[56 + d]),
                (c[3] =
                  o * e[8 + d] - s * e[24 + d] + r * e[40 + d] - n * e[56 + d]),
                (u[0] = t * (e[d] + e[32 + d])),
                (u[3] = t * (e[d] - e[32 + d])),
                (u[1] = l[0] + l[3]),
                (u[2] = l[1] - l[2]),
                (h[0] = u[0] + u[1]),
                (h[1] = u[3] + u[2]),
                (h[2] = u[3] - u[2]),
                (h[3] = u[0] - u[1]),
                (e[0 + d] = h[0] + c[0]),
                (e[8 + d] = h[1] + c[1]),
                (e[16 + d] = h[2] + c[2]),
                (e[24 + d] = h[3] + c[3]),
                (e[32 + d] = h[3] - c[3]),
                (e[40 + d] = h[2] - c[2]),
                (e[48 + d] = h[1] - c[1]),
                (e[56 + d] = h[0] - c[0]);
          }
          function R(e) {
            for (let t = 0; t < 64; ++t) {
              const n = e[0][t],
                i = e[1][t],
                r = e[2][t];
              (e[0][t] = n + 1.5747 * r),
                (e[1][t] = n - 0.1873 * i - 0.4682 * r),
                (e[2][t] = n + 1.8556 * i);
            }
          }
          function D(e, t, n) {
            for (let r = 0; r < 64; ++r) t[n + r] = i.GxU.toHalfFloat(P(e[r]));
          }
          function P(e) {
            return e <= 1
              ? Math.sign(e) * Math.pow(Math.abs(e), 2.2)
              : Math.sign(e) * Math.pow(o, Math.abs(e) - 1);
          }
          function L(e) {
            return new DataView(e.array.buffer, e.offset.value, e.size);
          }
          function U(e) {
            const t = e.viewer.buffer.slice(
                e.offset.value,
                e.offset.value + e.size
              ),
              n = new Uint8Array(S(t)),
              i = new Uint8Array(n.length);
            return C(n), I(n, i), new DataView(i.buffer);
          }
          function F(e) {
            const t = e.array.slice(e.offset.value, e.offset.value + e.size),
              n = r.a8(t),
              i = new Uint8Array(n.length);
            return C(n), I(n, i), new DataView(i.buffer);
          }
          function N(e) {
            const n = e.viewer,
              i = { value: e.offset.value },
              r = new Uint16Array(
                e.columns * e.lines * (e.inputChannels.length * e.type)
              ),
              s = new Uint8Array(8192);
            let a = 0;
            const o = new Array(e.inputChannels.length);
            for (let t = 0, n = e.inputChannels.length; t < n; t++)
              (o[t] = {}),
                (o[t].start = a),
                (o[t].end = o[t].start),
                (o[t].nx = e.columns),
                (o[t].ny = e.lines),
                (o[t].size = e.type),
                (a += o[t].nx * o[t].ny * o[t].size);
            const l = X(n, i),
              c = X(n, i);
            if (c >= 8192)
              throw new Error(
                "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE"
              );
            if (l <= c) for (let e = 0; e < c - l + 1; e++) s[e + l] = V(n, i);
            const u = new Uint16Array(t),
              h = (function (e, n) {
                let i = 0;
                for (let r = 0; r < t; ++r)
                  (0 == r || e[r >> 3] & (1 << (7 & r))) && (n[i++] = r);
                const r = i - 1;
                for (; i < t; ) n[i++] = 0;
                return r;
              })(s, u),
              d = H(n, i);
            w(e.array, n, i, d, r, a);
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const e = o[t];
              for (let n = 0; n < o[t].size; ++n)
                E(r, e.start + n, e.nx, e.size, e.ny, e.nx * e.size, h);
            }
            !(function (e, t, n) {
              for (let i = 0; i < n; ++i) t[i] = e[t[i]];
            })(u, r, a);
            let p = 0;
            const f = new Uint8Array(r.buffer.byteLength);
            for (let t = 0; t < e.lines; t++)
              for (let t = 0; t < e.inputChannels.length; t++) {
                const e = o[t],
                  n = e.nx * e.size,
                  i = new Uint8Array(r.buffer, 2 * e.end, 2 * n);
                f.set(i, p), (p += 2 * n), (e.end += n);
              }
            return new DataView(f.buffer);
          }
          function O(e) {
            const t = e.array.slice(e.offset.value, e.offset.value + e.size),
              n = r.a8(t),
              i = e.inputChannels.length * e.lines * e.columns * e.totalBytes,
              s = new ArrayBuffer(i),
              a = new DataView(s);
            let o = 0,
              l = 0;
            const c = new Array(4);
            for (let t = 0; t < e.lines; t++)
              for (let t = 0; t < e.inputChannels.length; t++) {
                let i = 0;
                switch (e.inputChannels[t].pixelType) {
                  case 1:
                    (c[0] = o),
                      (c[1] = c[0] + e.columns),
                      (o = c[1] + e.columns);
                    for (let t = 0; t < e.columns; ++t) {
                      (i += (n[c[0]++] << 8) | n[c[1]++]),
                        a.setUint16(l, i, !0),
                        (l += 2);
                    }
                    break;
                  case 2:
                    (c[0] = o),
                      (c[1] = c[0] + e.columns),
                      (c[2] = c[1] + e.columns),
                      (o = c[2] + e.columns);
                    for (let t = 0; t < e.columns; ++t) {
                      (i +=
                        (n[c[0]++] << 24) |
                        (n[c[1]++] << 16) |
                        (n[c[2]++] << 8)),
                        a.setUint32(l, i, !0),
                        (l += 4);
                    }
                }
              }
            return a;
          }
          function Q(e) {
            const t = e.viewer,
              n = { value: e.offset.value },
              i = new Uint8Array(
                e.columns * e.lines * (e.inputChannels.length * e.type * 2)
              ),
              s = {
                version: W(t, n),
                unknownUncompressedSize: W(t, n),
                unknownCompressedSize: W(t, n),
                acCompressedSize: W(t, n),
                dcCompressedSize: W(t, n),
                rleCompressedSize: W(t, n),
                rleUncompressedSize: W(t, n),
                rleRawSize: W(t, n),
                totalAcUncompressedCount: W(t, n),
                totalDcUncompressedCount: W(t, n),
                acCompression: W(t, n),
              };
            if (s.version < 2)
              throw new Error(
                "EXRLoader.parse: " +
                  se.compression +
                  " version " +
                  s.version +
                  " is unsupported"
              );
            const a = new Array();
            let o = X(t, n) - 2;
            for (; o > 0; ) {
              const e = k(t.buffer, n),
                i = V(t, n),
                r = (i >> 2) & 3,
                s = new Int8Array([(i >> 4) - 1])[0],
                l = V(t, n);
              a.push({ name: e, index: s, type: l, compression: r }),
                (o -= e.length + 3);
            }
            const l = se.channels,
              c = new Array(e.inputChannels.length);
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const n = (c[t] = {}),
                i = l[t];
              (n.name = i.name),
                (n.compression = 0),
                (n.decoded = !1),
                (n.type = i.pixelType),
                (n.pLinear = i.pLinear),
                (n.width = e.columns),
                (n.height = e.lines);
            }
            const u = { idx: new Array(3) };
            for (let t = 0; t < e.inputChannels.length; ++t) {
              const e = c[t];
              for (let n = 0; n < a.length; ++n) {
                const i = a[n];
                e.name == i.name &&
                  ((e.compression = i.compression),
                  i.index >= 0 && (u.idx[i.index] = t),
                  (e.offset = t));
              }
            }
            let h, d, p;
            if (s.acCompressedSize > 0)
              switch (s.acCompression) {
                case 0:
                  (h = new Uint16Array(s.totalAcUncompressedCount)),
                    w(
                      e.array,
                      t,
                      n,
                      s.acCompressedSize,
                      h,
                      s.totalAcUncompressedCount
                    );
                  break;
                case 1:
                  const i = e.array.slice(
                      n.value,
                      n.value + s.totalAcUncompressedCount
                    ),
                    a = r.a8(i);
                  (h = new Uint16Array(a.buffer)),
                    (n.value += s.totalAcUncompressedCount);
              }
            if (s.dcCompressedSize > 0) {
              const t = { array: e.array, offset: n, size: s.dcCompressedSize };
              (d = new Uint16Array(F(t).buffer)),
                (n.value += s.dcCompressedSize);
            }
            if (s.rleRawSize > 0) {
              const t = e.array.slice(n.value, n.value + s.rleCompressedSize);
              (p = S(r.a8(t).buffer)), (n.value += s.rleCompressedSize);
            }
            let f = 0;
            const A = new Array(c.length);
            for (let e = 0; e < A.length; ++e) A[e] = new Array();
            for (let t = 0; t < e.lines; ++t)
              for (let t = 0; t < c.length; ++t)
                A[t].push(f), (f += c[t].width * e.type * 2);
            !(function (e, t, n, i, r, s) {
              let a = new DataView(s.buffer);
              const o = n[e.idx[0]].width,
                l = n[e.idx[0]].height,
                c = Math.floor(o / 8),
                u = Math.ceil(o / 8),
                h = Math.ceil(l / 8),
                d = o - 8 * (u - 1),
                p = l - 8 * (h - 1),
                f = { value: 0 },
                A = new Array(3),
                g = new Array(3),
                m = new Array(3),
                v = new Array(3),
                y = new Array(3);
              for (let n = 0; n < 3; ++n)
                (y[n] = t[e.idx[n]]),
                  (A[n] = n < 1 ? 0 : A[n - 1] + u * h),
                  (g[n] = new Float32Array(64)),
                  (m[n] = new Uint16Array(64)),
                  (v[n] = new Uint16Array(64 * u));
              for (let t = 0; t < h; ++t) {
                let s = 8;
                t == h - 1 && (s = p);
                let o = 8;
                for (let e = 0; e < u; ++e) {
                  e == u - 1 && (o = d);
                  for (let e = 0; e < 3; ++e)
                    m[e].fill(0),
                      (m[e][0] = r[A[e]++]),
                      M(f, i, m[e]),
                      T(m[e], g[e]),
                      B(g[e]);
                  R(g);
                  for (let t = 0; t < 3; ++t) D(g[t], v[t], 64 * e);
                }
                let l = 0;
                for (let i = 0; i < 3; ++i) {
                  const r = n[e.idx[i]].type;
                  for (let e = 8 * t; e < 8 * t + s; ++e) {
                    l = y[i][e];
                    for (let t = 0; t < c; ++t) {
                      const n = 64 * t + 8 * (7 & e);
                      a.setUint16(l + 0 * r, v[i][n + 0], !0),
                        a.setUint16(l + 2 * r, v[i][n + 1], !0),
                        a.setUint16(l + 4 * r, v[i][n + 2], !0),
                        a.setUint16(l + 6 * r, v[i][n + 3], !0),
                        a.setUint16(l + 8 * r, v[i][n + 4], !0),
                        a.setUint16(l + 10 * r, v[i][n + 5], !0),
                        a.setUint16(l + 12 * r, v[i][n + 6], !0),
                        a.setUint16(l + 14 * r, v[i][n + 7], !0),
                        (l += 16 * r);
                    }
                  }
                  if (c != u)
                    for (let e = 8 * t; e < 8 * t + s; ++e) {
                      const t = y[i][e] + 8 * c * 2 * r,
                        n = 64 * c + 8 * (7 & e);
                      for (let e = 0; e < o; ++e)
                        a.setUint16(t + 2 * e * r, v[i][n + e], !0);
                    }
                }
              }
              const x = new Uint16Array(o);
              a = new DataView(s.buffer);
              for (let t = 0; t < 3; ++t) {
                n[e.idx[t]].decoded = !0;
                const i = n[e.idx[t]].type;
                if (2 == n[t].type)
                  for (let e = 0; e < l; ++e) {
                    const n = y[t][e];
                    for (let e = 0; e < o; ++e)
                      x[e] = a.getUint16(n + 2 * e * i, !0);
                    for (let e = 0; e < o; ++e)
                      a.setFloat32(n + 2 * e * i, Y(x[e]), !0);
                  }
              }
            })(u, A, c, h, d, i);
            for (let t = 0; t < c.length; ++t) {
              const n = c[t];
              if (!n.decoded) {
                if (2 !== n.compression)
                  throw new Error(
                    "EXRLoader.parse: unsupported channel compression"
                  );
                {
                  let r = 0,
                    s = 0;
                  for (let a = 0; a < e.lines; ++a) {
                    let e = A[t][r];
                    for (let t = 0; t < n.width; ++t) {
                      for (let t = 0; t < 2 * n.type; ++t)
                        i[e++] = p[s + t * n.width * n.height];
                      s++;
                    }
                    r++;
                  }
                }
              }
            }
            return new DataView(i.buffer);
          }
          function k(e, t) {
            const n = new Uint8Array(e);
            let i = 0;
            for (; 0 != n[t.value + i]; ) i += 1;
            const r = new TextDecoder().decode(n.slice(t.value, t.value + i));
            return (t.value = t.value + i + 1), r;
          }
          function G(e, t) {
            const n = e.getInt32(t.value, !0);
            return (t.value = t.value + 4), n;
          }
          function H(e, t) {
            const n = e.getUint32(t.value, !0);
            return (t.value = t.value + 4), n;
          }
          function z(e, t) {
            const n = e[t.value];
            return (t.value = t.value + 1), n;
          }
          function V(e, t) {
            const n = e.getUint8(t.value);
            return (t.value = t.value + 1), n;
          }
          const W = function (e, t) {
            let n;
            return (
              (n =
                "getBigInt64" in DataView.prototype
                  ? Number(e.getBigInt64(t.value, !0))
                  : e.getUint32(t.value + 4, !0) +
                    Number(e.getUint32(t.value, !0) << 32)),
              (t.value += 8),
              n
            );
          };
          function j(e, t) {
            const n = e.getFloat32(t.value, !0);
            return (t.value += 4), n;
          }
          function q(e, t) {
            return i.GxU.toHalfFloat(j(e, t));
          }
          function Y(e) {
            const t = (31744 & e) >> 10,
              n = 1023 & e;
            return (
              (e >> 15 ? -1 : 1) *
              (t
                ? 31 === t
                  ? n
                    ? NaN
                    : 1 / 0
                  : Math.pow(2, t - 15) * (1 + n / 1024)
                : (n / 1024) * 6103515625e-14)
            );
          }
          function X(e, t) {
            const n = e.getUint16(t.value, !0);
            return (t.value += 2), n;
          }
          function K(e, t) {
            return Y(X(e, t));
          }
          function J(e, t, n, i, r) {
            return "string" === i || "stringvector" === i || "iccProfile" === i
              ? (function (e, t, n) {
                  const i = new TextDecoder().decode(
                    new Uint8Array(e).slice(t.value, t.value + n)
                  );
                  return (t.value = t.value + n), i;
                })(t, n, r)
              : "chlist" === i
              ? (function (e, t, n, i) {
                  const r = n.value,
                    s = [];
                  for (; n.value < r + i - 1; ) {
                    const i = k(t, n),
                      r = G(e, n),
                      a = V(e, n);
                    n.value += 3;
                    const o = G(e, n),
                      l = G(e, n);
                    s.push({
                      name: i,
                      pixelType: r,
                      pLinear: a,
                      xSampling: o,
                      ySampling: l,
                    });
                  }
                  return (n.value += 1), s;
                })(e, t, n, r)
              : "chromaticities" === i
              ? (function (e, t) {
                  return {
                    redX: j(e, t),
                    redY: j(e, t),
                    greenX: j(e, t),
                    greenY: j(e, t),
                    blueX: j(e, t),
                    blueY: j(e, t),
                    whiteX: j(e, t),
                    whiteY: j(e, t),
                  };
                })(e, n)
              : "compression" === i
              ? (function (e, t) {
                  return [
                    "NO_COMPRESSION",
                    "RLE_COMPRESSION",
                    "ZIPS_COMPRESSION",
                    "ZIP_COMPRESSION",
                    "PIZ_COMPRESSION",
                    "PXR24_COMPRESSION",
                    "B44_COMPRESSION",
                    "B44A_COMPRESSION",
                    "DWAA_COMPRESSION",
                    "DWAB_COMPRESSION",
                  ][V(e, t)];
                })(e, n)
              : "box2i" === i
              ? (function (e, t) {
                  return {
                    xMin: G(e, t),
                    yMin: G(e, t),
                    xMax: G(e, t),
                    yMax: G(e, t),
                  };
                })(e, n)
              : "envmap" === i
              ? (function (e, t) {
                  return ["ENVMAP_LATLONG", "ENVMAP_CUBE"][V(e, t)];
                })(e, n)
              : "tiledesc" === i
              ? (function (e, t) {
                  const n = H(e, t),
                    i = H(e, t),
                    r = V(e, t);
                  return {
                    xSize: n,
                    ySize: i,
                    levelMode: ["ONE_LEVEL", "MIPMAP_LEVELS", "RIPMAP_LEVELS"][
                      15 & r
                    ],
                    roundingMode: ["ROUND_DOWN", "ROUND_UP"][r >> 4],
                  };
                })(e, n)
              : "lineOrder" === i
              ? (function (e, t) {
                  return ["INCREASING_Y", "DECREASING_Y", "RANDOM_Y"][V(e, t)];
                })(e, n)
              : "float" === i
              ? j(e, n)
              : "v2f" === i
              ? (function (e, t) {
                  return [j(e, t), j(e, t)];
                })(e, n)
              : "v3f" === i
              ? (function (e, t) {
                  return [j(e, t), j(e, t), j(e, t)];
                })(e, n)
              : "int" === i
              ? G(e, n)
              : "rational" === i
              ? (function (e, t) {
                  return [G(e, t), H(e, t)];
                })(e, n)
              : "timecode" === i
              ? (function (e, t) {
                  return [H(e, t), H(e, t)];
                })(e, n)
              : "preview" === i
              ? ((n.value += r), "skipped")
              : void (n.value += r);
          }
          function Z(e, t, n) {
            let i = 0;
            switch (e.levelMode) {
              case "ONE_LEVEL":
                i = 1;
                break;
              case "MIPMAP_LEVELS":
                i =
                  (function (e, t) {
                    const n = Math.log2(e);
                    return "ROUND_DOWN" == t ? Math.floor(n) : Math.ceil(n);
                  })(Math.max(t, n), e.roundingMode) + 1;
                break;
              case "RIPMAP_LEVELS":
                throw new Error(
                  "THREE.EXRLoader: RIPMAP_LEVELS tiles currently unsupported."
                );
            }
            return i;
          }
          function $(e, t, n, i) {
            const r = new Array(e);
            for (let s = 0; s < e; s++) {
              const e = 1 << s;
              let a = (t / e) | 0;
              "ROUND_UP" == i && a * e < t && (a += 1);
              const o = Math.max(a, 1);
              r[s] = ((o + n - 1) / n) | 0;
            }
            return r;
          }
          function ee() {
            const e = this,
              t = e.offset,
              n = { value: 0 };
            for (let i = 0; i < e.tileCount; i++) {
              const i = G(e.viewer, t),
                r = G(e.viewer, t);
              (t.value += 8), (e.size = H(e.viewer, t));
              const s = i * e.blockWidth,
                a = r * e.blockHeight;
              (e.columns =
                s + e.blockWidth > e.width ? e.width - s : e.blockWidth),
                (e.lines =
                  a + e.blockHeight > e.height ? e.height - a : e.blockHeight);
              const o = e.columns * e.totalBytes,
                l = e.size < e.lines * o ? e.uncompress(e) : L(e);
              t.value += e.size;
              for (let t = 0; t < e.lines; t++) {
                const i = t * e.columns * e.totalBytes;
                for (let r = 0; r < e.inputChannels.length; r++) {
                  const o = se.channels[r].name,
                    c = e.channelByteOffsets[o] * e.columns,
                    u = e.decodeChannels[o];
                  if (void 0 === u) continue;
                  n.value = i + c;
                  const h = (e.height - (1 + a + t)) * e.outLineWidth;
                  for (let t = 0; t < e.columns; t++) {
                    const i = h + (t + s) * e.outputChannels + u;
                    e.byteArray[i] = e.getter(l, n);
                  }
                }
              }
            }
          }
          function te() {
            const e = this,
              t = e.offset,
              n = { value: 0 };
            for (let i = 0; i < e.height / e.blockHeight; i++) {
              const r = G(e.viewer, t) - se.dataWindow.yMin;
              (e.size = H(e.viewer, t)),
                (e.lines =
                  r + e.blockHeight > e.height ? e.height - r : e.blockHeight);
              const s = e.columns * e.totalBytes,
                a = e.size < e.lines * s ? e.uncompress(e) : L(e);
              t.value += e.size;
              for (let t = 0; t < e.blockHeight; t++) {
                const r = i * e.blockHeight,
                  o = t + e.scanOrder(r);
                if (o >= e.height) continue;
                const l = t * s,
                  c = (e.height - 1 - o) * e.outLineWidth;
                for (let t = 0; t < e.inputChannels.length; t++) {
                  const i = se.channels[t].name,
                    r = e.channelByteOffsets[i] * e.columns,
                    s = e.decodeChannels[i];
                  if (void 0 !== s) {
                    n.value = l + r;
                    for (let t = 0; t < e.columns; t++) {
                      const i = c + t * e.outputChannels + s;
                      e.byteArray[i] = e.getter(a, n);
                    }
                  }
                }
              }
            }
          }
          const ne = { value: 0 },
            ie = new DataView(e),
            re = new Uint8Array(e),
            se = (function (e, t, n) {
              const i = {};
              if (20000630 != e.getUint32(0, !0))
                throw new Error(
                  "THREE.EXRLoader: Provided file doesn't appear to be in OpenEXR format."
                );
              i.version = e.getUint8(4);
              const r = e.getUint8(5);
              (i.spec = {
                singleTile: !!(2 & r),
                longName: !!(4 & r),
                deepFormat: !!(8 & r),
                multiPart: !!(16 & r),
              }),
                (n.value = 8);
              let s = !0;
              for (; s; ) {
                const r = k(t, n);
                if (0 == r) s = !1;
                else {
                  const s = k(t, n),
                    a = J(e, t, n, s, H(e, n));
                  void 0 === a
                    ? console.warn(
                        `THREE.EXRLoader: Skipped unknown header attribute type '${s}'.`
                      )
                    : (i[r] = a);
                }
              }
              if (-7 & r)
                throw (
                  (console.error("THREE.EXRHeader:", i),
                  new Error(
                    "THREE.EXRLoader: Provided file is currently unsupported."
                  ))
                );
              return i;
            })(ie, e, ne),
            ae = (function (e, t, n, r, s) {
              const a = {
                size: 0,
                viewer: t,
                array: n,
                offset: r,
                width: e.dataWindow.xMax - e.dataWindow.xMin + 1,
                height: e.dataWindow.yMax - e.dataWindow.yMin + 1,
                inputChannels: e.channels,
                channelByteOffsets: {},
                scanOrder: null,
                totalBytes: null,
                columns: null,
                lines: null,
                type: null,
                uncompress: null,
                getter: null,
                format: null,
                colorSpace: i.Zr2,
              };
              switch (e.compression) {
                case "NO_COMPRESSION":
                  (a.blockHeight = 1), (a.uncompress = L);
                  break;
                case "RLE_COMPRESSION":
                  (a.blockHeight = 1), (a.uncompress = U);
                  break;
                case "ZIPS_COMPRESSION":
                  (a.blockHeight = 1), (a.uncompress = F);
                  break;
                case "ZIP_COMPRESSION":
                  (a.blockHeight = 16), (a.uncompress = F);
                  break;
                case "PIZ_COMPRESSION":
                  (a.blockHeight = 32), (a.uncompress = N);
                  break;
                case "PXR24_COMPRESSION":
                  (a.blockHeight = 16), (a.uncompress = O);
                  break;
                case "DWAA_COMPRESSION":
                  (a.blockHeight = 32), (a.uncompress = Q);
                  break;
                case "DWAB_COMPRESSION":
                  (a.blockHeight = 256), (a.uncompress = Q);
                  break;
                default:
                  throw new Error(
                    "EXRLoader.parse: " + e.compression + " is unsupported"
                  );
              }
              const o = {};
              for (const t of e.channels)
                switch (t.name) {
                  case "Y":
                  case "R":
                  case "G":
                  case "B":
                  case "A":
                    (o[t.name] = !0), (a.type = t.pixelType);
                }
              let l = !1;
              if (o.R && o.G && o.B)
                (l = !o.A),
                  (a.outputChannels = 4),
                  (a.decodeChannels = { R: 0, G: 1, B: 2, A: 3 });
              else {
                if (!o.Y)
                  throw new Error(
                    "EXRLoader.parse: file contains unsupported data channels."
                  );
                (a.outputChannels = 1), (a.decodeChannels = { Y: 0 });
              }
              if (1 == a.type)
                switch (s) {
                  case i.RQf:
                    a.getter = K;
                    break;
                  case i.ix0:
                    a.getter = X;
                }
              else {
                if (2 != a.type)
                  throw new Error(
                    "EXRLoader.parse: unsupported pixelType " +
                      a.type +
                      " for " +
                      e.compression +
                      "."
                  );
                switch (s) {
                  case i.RQf:
                    a.getter = j;
                    break;
                  case i.ix0:
                    a.getter = q;
                }
              }
              a.columns = a.width;
              const c = a.width * a.height * a.outputChannels;
              switch (s) {
                case i.RQf:
                  (a.byteArray = new Float32Array(c)),
                    l && a.byteArray.fill(1, 0, c);
                  break;
                case i.ix0:
                  (a.byteArray = new Uint16Array(c)),
                    l && a.byteArray.fill(15360, 0, c);
                  break;
                default:
                  console.error("THREE.EXRLoader: unsupported type: ", s);
              }
              let u = 0;
              for (const t of e.channels)
                void 0 !== a.decodeChannels[t.name] &&
                  (a.channelByteOffsets[t.name] = u),
                  (u += 2 * t.pixelType);
              if (
                ((a.totalBytes = u),
                (a.outLineWidth = a.width * a.outputChannels),
                "INCREASING_Y" === e.lineOrder
                  ? (a.scanOrder = (e) => e)
                  : (a.scanOrder = (e) => a.height - 1 - e),
                4 == a.outputChannels
                  ? ((a.format = i.GWd), (a.colorSpace = i.Zr2))
                  : ((a.format = i.VT0), (a.colorSpace = i.jf0)),
                e.spec.singleTile)
              ) {
                (a.blockHeight = e.tiles.ySize), (a.blockWidth = e.tiles.xSize);
                const n = Z(e.tiles, a.width, a.height),
                  i = $(n, a.width, e.tiles.xSize, e.tiles.roundingMode),
                  s = $(n, a.height, e.tiles.ySize, e.tiles.roundingMode);
                a.tileCount = i[0] * s[0];
                for (let e = 0; e < n; e++)
                  for (let n = 0; n < s[e]; n++)
                    for (let n = 0; n < i[e]; n++) W(t, r);
                a.decode = ee.bind(a);
              } else {
                a.blockWidth = a.width;
                const e = Math.ceil(a.height / a.blockHeight);
                for (let n = 0; n < e; n++) W(t, r);
                a.decode = te.bind(a);
              }
              return a;
            })(se, ie, re, ne, this.type);
          return (
            ae.decode(),
            {
              header: se,
              width: ae.width,
              height: ae.height,
              data: ae.byteArray,
              format: ae.format,
              colorSpace: ae.colorSpace,
              type: this.type,
            }
          );
        }
        setDataType(e) {
          return (this.type = e), this;
        }
        load(e, t, n, r) {
          return super.load(
            e,
            function (e, n) {
              (e.colorSpace = n.colorSpace),
                (e.minFilter = i.k6q),
                (e.magFilter = i.k6q),
                (e.generateMipmaps = !1),
                (e.flipY = !1),
                t && t(e, n);
            },
            n,
            r
          );
        }
      }
    },
    8003: (e, t, n) => {
      "use strict";
      n.d(t, { w: () => p });
      var i = n(5062),
        r = n(7971);
      function s(e, t, n) {
        const i = n.length - e - 1;
        if (t >= n[i]) return i - 1;
        if (t <= n[e]) return e;
        let r = e,
          s = i,
          a = Math.floor((r + s) / 2);
        for (; t < n[a] || t >= n[a + 1]; )
          t < n[a] ? (s = a) : (r = a), (a = Math.floor((r + s) / 2));
        return a;
      }
      function a(e, t, n, i) {
        const r = [],
          s = [],
          a = [];
        r[0] = 1;
        for (let o = 1; o <= n; ++o) {
          (s[o] = t - i[e + 1 - o]), (a[o] = i[e + o] - t);
          let n = 0;
          for (let e = 0; e < o; ++e) {
            const t = a[e + 1],
              i = s[o - e],
              l = r[e] / (t + i);
            (r[e] = n + t * l), (n = i * l);
          }
          r[o] = n;
        }
        return r;
      }
      function o(e, t) {
        let n = 1;
        for (let t = 2; t <= e; ++t) n *= t;
        let i = 1;
        for (let e = 2; e <= t; ++e) i *= e;
        for (let n = 2; n <= e - t; ++n) i *= n;
        return n / i;
      }
      function l(e, t, n, r, a) {
        const l = (function (e, t, n, r, a) {
          const o = a < e ? a : e,
            l = [],
            c = s(e, r, t),
            u = (function (e, t, n, i, r) {
              const s = [];
              for (let e = 0; e <= n; ++e) s[e] = 0;
              const a = [];
              for (let e = 0; e <= i; ++e) a[e] = s.slice(0);
              const o = [];
              for (let e = 0; e <= n; ++e) o[e] = s.slice(0);
              o[0][0] = 1;
              const l = s.slice(0),
                c = s.slice(0);
              for (let i = 1; i <= n; ++i) {
                (l[i] = t - r[e + 1 - i]), (c[i] = r[e + i] - t);
                let n = 0;
                for (let e = 0; e < i; ++e) {
                  const t = c[e + 1],
                    r = l[i - e];
                  o[i][e] = t + r;
                  const s = o[e][i - 1] / o[i][e];
                  (o[e][i] = n + t * s), (n = r * s);
                }
                o[i][i] = n;
              }
              for (let e = 0; e <= n; ++e) a[0][e] = o[e][n];
              for (let e = 0; e <= n; ++e) {
                let t = 0,
                  r = 1;
                const l = [];
                for (let e = 0; e <= n; ++e) l[e] = s.slice(0);
                l[0][0] = 1;
                for (let s = 1; s <= i; ++s) {
                  let i = 0;
                  const c = e - s,
                    u = n - s;
                  e >= s &&
                    ((l[r][0] = l[t][0] / o[u + 1][c]),
                    (i = l[r][0] * o[c][u]));
                  const h = e - 1 <= u ? s - 1 : n - e;
                  for (let e = c >= -1 ? 1 : -c; e <= h; ++e)
                    (l[r][e] = (l[t][e] - l[t][e - 1]) / o[u + 1][c + e]),
                      (i += l[r][e] * o[c + e][u]);
                  e <= u &&
                    ((l[r][s] = -l[t][s - 1] / o[u + 1][e]),
                    (i += l[r][s] * o[e][u])),
                    (a[s][e] = i);
                  const d = t;
                  (t = r), (r = d);
                }
              }
              let u = n;
              for (let e = 1; e <= i; ++e) {
                for (let t = 0; t <= n; ++t) a[e][t] *= u;
                u *= n - e;
              }
              return a;
            })(c, r, e, o, t),
            h = [];
          for (let e = 0; e < n.length; ++e) {
            const t = n[e].clone(),
              i = t.w;
            (t.x *= i), (t.y *= i), (t.z *= i), (h[e] = t);
          }
          for (let t = 0; t <= o; ++t) {
            const n = h[c - e].clone().multiplyScalar(u[t][0]);
            for (let i = 1; i <= e; ++i)
              n.add(h[c - e + i].clone().multiplyScalar(u[t][i]));
            l[t] = n;
          }
          for (let e = o + 1; e <= a + 1; ++e) l[e] = new i.IUQ(0, 0, 0);
          return l;
        })(e, t, n, r, a);
        return (function (e) {
          const t = e.length,
            n = [],
            r = [];
          for (let s = 0; s < t; ++s) {
            const t = e[s];
            (n[s] = new i.Pq0(t.x, t.y, t.z)), (r[s] = t.w);
          }
          const s = [];
          for (let e = 0; e < t; ++e) {
            const t = n[e].clone();
            for (let n = 1; n <= e; ++n)
              t.sub(s[e - n].clone().multiplyScalar(o(e, n) * r[n]));
            s[e] = t.divideScalar(r[0]);
          }
          return s;
        })(l);
      }
      class c extends i.Ipv {
        constructor(e, t, n, r, s) {
          super();
          const a = t ? t.length - 1 : 0,
            o = n ? n.length : 0;
          (this.degree = e),
            (this.knots = t),
            (this.controlPoints = []),
            (this.startKnot = r || 0),
            (this.endKnot = s || a);
          for (let e = 0; e < o; ++e) {
            const t = n[e];
            this.controlPoints[e] = new i.IUQ(t.x, t.y, t.z, t.w);
          }
        }
        getPoint(e, t = new i.Pq0()) {
          const n = t,
            r =
              this.knots[this.startKnot] +
              e * (this.knots[this.endKnot] - this.knots[this.startKnot]),
            o = (function (e, t, n, r) {
              const o = s(e, r, t),
                l = a(o, r, e, t),
                c = new i.IUQ(0, 0, 0, 0);
              for (let t = 0; t <= e; ++t) {
                const i = n[o - e + t],
                  r = l[t],
                  s = i.w * r;
                (c.x += i.x * s),
                  (c.y += i.y * s),
                  (c.z += i.z * s),
                  (c.w += i.w * r);
              }
              return c;
            })(this.degree, this.knots, this.controlPoints, r);
          return 1 !== o.w && o.divideScalar(o.w), n.set(o.x, o.y, o.z);
        }
        getTangent(e, t = new i.Pq0()) {
          const n = t,
            r =
              this.knots[0] +
              e * (this.knots[this.knots.length - 1] - this.knots[0]),
            s = l(this.degree, this.knots, this.controlPoints, r, 1);
          return n.copy(s[1]).normalize(), n;
        }
        toJSON() {
          const e = super.toJSON();
          return (
            (e.degree = this.degree),
            (e.knots = [...this.knots]),
            (e.controlPoints = this.controlPoints.map((e) => e.toArray())),
            (e.startKnot = this.startKnot),
            (e.endKnot = this.endKnot),
            e
          );
        }
        fromJSON(e) {
          return (
            super.fromJSON(e),
            (this.degree = e.degree),
            (this.knots = [...e.knots]),
            (this.controlPoints = e.controlPoints.map(
              (e) => new i.IUQ(e[0], e[1], e[2], e[3])
            )),
            (this.startKnot = e.startKnot),
            (this.endKnot = e.endKnot),
            this
          );
        }
      }
      let u, h, d;
      class p extends i.aHM {
        constructor(e) {
          super(e);
        }
        load(e, t, n, r) {
          const s = this,
            a = "" === s.path ? i.r6x.extractUrlBase(e) : s.path,
            o = new i.Y9S(this.manager);
          o.setPath(s.path),
            o.setResponseType("arraybuffer"),
            o.setRequestHeader(s.requestHeader),
            o.setWithCredentials(s.withCredentials),
            o.load(
              e,
              function (n) {
                try {
                  t(s.parse(n, a));
                } catch (t) {
                  r ? r(t) : console.error(t), s.manager.itemError(e);
                }
              },
              n,
              r
            );
        }
        parse(e, t) {
          if (
            (function (e) {
              const t = "Kaydara FBX Binary  \0";
              return e.byteLength >= t.length && t === B(e, 0, t.length);
            })(e)
          )
            u = new v().parse(e);
          else {
            const t = B(e);
            if (
              !(function (e) {
                const t = [
                  "K",
                  "a",
                  "y",
                  "d",
                  "a",
                  "r",
                  "a",
                  "\\",
                  "F",
                  "B",
                  "X",
                  "\\",
                  "B",
                  "i",
                  "n",
                  "a",
                  "r",
                  "y",
                  "\\",
                  "\\",
                ];
                let n = 0;
                function i(t) {
                  const i = e[t - 1];
                  return (e = e.slice(n + t)), n++, i;
                }
                for (let e = 0; e < t.length; ++e) {
                  if (i(1) === t[e]) return !1;
                }
                return !0;
              })(t)
            )
              throw new Error("THREE.FBXLoader: Unknown format.");
            if (_(t) < 7e3)
              throw new Error(
                "THREE.FBXLoader: FBX version not supported, FileVersion: " +
                  _(t)
              );
            u = new m().parse(t);
          }
          const n = new i.Tap(this.manager)
            .setPath(this.resourcePath || t)
            .setCrossOrigin(this.crossOrigin);
          return new f(n, this.manager).parse(u);
        }
      }
      class f {
        constructor(e, t) {
          (this.textureLoader = e), (this.manager = t);
        }
        parse() {
          h = this.parseConnections();
          const e = this.parseImages(),
            t = this.parseTextures(e),
            n = this.parseMaterials(t),
            i = this.parseDeformers(),
            r = new A().parse(i);
          return this.parseScene(i, r, n), d;
        }
        parseConnections() {
          const e = new Map();
          if ("Connections" in u) {
            u.Connections.connections.forEach(function (t) {
              const n = t[0],
                i = t[1],
                r = t[2];
              e.has(n) || e.set(n, { parents: [], children: [] });
              const s = { ID: i, relationship: r };
              e.get(n).parents.push(s),
                e.has(i) || e.set(i, { parents: [], children: [] });
              const a = { ID: n, relationship: r };
              e.get(i).children.push(a);
            });
          }
          return e;
        }
        parseImages() {
          const e = {},
            t = {};
          if ("Video" in u.Objects) {
            const n = u.Objects.Video;
            for (const i in n) {
              const r = n[i];
              if (
                ((e[parseInt(i)] = r.RelativeFilename || r.Filename),
                "Content" in r)
              ) {
                const e =
                    r.Content instanceof ArrayBuffer &&
                    r.Content.byteLength > 0,
                  s = "string" == typeof r.Content && "" !== r.Content;
                if (e || s) {
                  const e = this.parseImage(n[i]);
                  t[r.RelativeFilename || r.Filename] = e;
                }
              }
            }
          }
          for (const n in e) {
            const i = e[n];
            void 0 !== t[i] ? (e[n] = t[i]) : (e[n] = e[n].split("\\").pop());
          }
          return e;
        }
        parseImage(e) {
          const t = e.Content,
            n = e.RelativeFilename || e.Filename,
            i = n.slice(n.lastIndexOf(".") + 1).toLowerCase();
          let r;
          switch (i) {
            case "bmp":
              r = "image/bmp";
              break;
            case "jpg":
            case "jpeg":
              r = "image/jpeg";
              break;
            case "png":
              r = "image/png";
              break;
            case "tif":
              r = "image/tiff";
              break;
            case "tga":
              null === this.manager.getHandler(".tga") &&
                console.warn("FBXLoader: TGA loader not found, skipping ", n),
                (r = "image/tga");
              break;
            default:
              return void console.warn(
                'FBXLoader: Image type "' + i + '" is not supported.'
              );
          }
          if ("string" == typeof t) return "data:" + r + ";base64," + t;
          {
            const e = new Uint8Array(t);
            return window.URL.createObjectURL(new Blob([e], { type: r }));
          }
        }
        parseTextures(e) {
          const t = new Map();
          if ("Texture" in u.Objects) {
            const n = u.Objects.Texture;
            for (const i in n) {
              const r = this.parseTexture(n[i], e);
              t.set(parseInt(i), r);
            }
          }
          return t;
        }
        parseTexture(e, t) {
          const n = this.loadTexture(e, t);
          (n.ID = e.id), (n.name = e.attrName);
          const r = e.WrapModeU,
            s = e.WrapModeV,
            a = void 0 !== r ? r.value : 0,
            o = void 0 !== s ? s.value : 0;
          if (
            ((n.wrapS = 0 === a ? i.GJx : i.ghU),
            (n.wrapT = 0 === o ? i.GJx : i.ghU),
            "Scaling" in e)
          ) {
            const t = e.Scaling.value;
            (n.repeat.x = t[0]), (n.repeat.y = t[1]);
          }
          if ("Translation" in e) {
            const t = e.Translation.value;
            (n.offset.x = t[0]), (n.offset.y = t[1]);
          }
          return n;
        }
        loadTexture(e, t) {
          const n = new Set([
              "tga",
              "tif",
              "tiff",
              "exr",
              "dds",
              "hdr",
              "ktx2",
            ]),
            r = e.FileName.split(".").pop().toLowerCase(),
            s = n.has(r)
              ? this.manager.getHandler(`.${r}`)
              : this.textureLoader;
          if (!s)
            return (
              console.warn(
                `FBXLoader: ${r.toUpperCase()} loader not found, creating placeholder texture for`,
                e.RelativeFilename
              ),
              new i.gPd()
            );
          const a = s.path;
          a || s.setPath(this.textureLoader.path);
          const o = h.get(e.id).children;
          let l;
          void 0 !== o &&
            o.length > 0 &&
            void 0 !== t[o[0].ID] &&
            ((l = t[o[0].ID]),
            (0 !== l.indexOf("blob:") && 0 !== l.indexOf("data:")) ||
              s.setPath(void 0));
          const c = s.load(l);
          return s.setPath(a), c;
        }
        parseMaterials(e) {
          const t = new Map();
          if ("Material" in u.Objects) {
            const n = u.Objects.Material;
            for (const i in n) {
              const r = this.parseMaterial(n[i], e);
              null !== r && t.set(parseInt(i), r);
            }
          }
          return t;
        }
        parseMaterial(e, t) {
          const n = e.id,
            r = e.attrName;
          let s = e.ShadingModel;
          if (("object" == typeof s && (s = s.value), !h.has(n))) return null;
          const a = this.parseParameters(e, t, n);
          let o;
          switch (s.toLowerCase()) {
            case "phong":
              o = new i.tXL();
              break;
            case "lambert":
              o = new i.G_z();
              break;
            default:
              console.warn(
                'THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',
                s
              ),
                (o = new i.tXL());
          }
          return o.setValues(a), (o.name = r), o;
        }
        parseParameters(e, t, n) {
          const r = {};
          e.BumpFactor && (r.bumpScale = e.BumpFactor.value),
            e.Diffuse
              ? (r.color = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.Diffuse.value),
                  i.er$
                ))
              : !e.DiffuseColor ||
                ("Color" !== e.DiffuseColor.type &&
                  "ColorRGB" !== e.DiffuseColor.type) ||
                (r.color = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.DiffuseColor.value),
                  i.er$
                )),
            e.DisplacementFactor &&
              (r.displacementScale = e.DisplacementFactor.value),
            e.Emissive
              ? (r.emissive = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.Emissive.value),
                  i.er$
                ))
              : !e.EmissiveColor ||
                ("Color" !== e.EmissiveColor.type &&
                  "ColorRGB" !== e.EmissiveColor.type) ||
                (r.emissive = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.EmissiveColor.value),
                  i.er$
                )),
            e.EmissiveFactor &&
              (r.emissiveIntensity = parseFloat(e.EmissiveFactor.value)),
            (r.opacity =
              1 -
              (e.TransparencyFactor
                ? parseFloat(e.TransparencyFactor.value)
                : 0)),
            (1 !== r.opacity && 0 !== r.opacity) ||
              ((r.opacity = e.Opacity ? parseFloat(e.Opacity.value) : null),
              null === r.opacity &&
                (r.opacity =
                  1 -
                  (e.TransparentColor
                    ? parseFloat(e.TransparentColor.value[0])
                    : 0))),
            r.opacity < 1 && (r.transparent = !0),
            e.ReflectionFactor && (r.reflectivity = e.ReflectionFactor.value),
            e.Shininess && (r.shininess = e.Shininess.value),
            e.Specular
              ? (r.specular = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.Specular.value),
                  i.er$
                ))
              : e.SpecularColor &&
                "Color" === e.SpecularColor.type &&
                (r.specular = i.ppV.toWorkingColorSpace(
                  new i.Q1f().fromArray(e.SpecularColor.value),
                  i.er$
                ));
          const s = this;
          return (
            h.get(n).children.forEach(function (e) {
              const n = e.relationship;
              switch (n) {
                case "Bump":
                  r.bumpMap = s.getTexture(t, e.ID);
                  break;
                case "Maya|TEX_ao_map":
                  r.aoMap = s.getTexture(t, e.ID);
                  break;
                case "DiffuseColor":
                case "Maya|TEX_color_map":
                  (r.map = s.getTexture(t, e.ID)),
                    void 0 !== r.map && (r.map.colorSpace = i.er$);
                  break;
                case "DisplacementColor":
                  r.displacementMap = s.getTexture(t, e.ID);
                  break;
                case "EmissiveColor":
                  (r.emissiveMap = s.getTexture(t, e.ID)),
                    void 0 !== r.emissiveMap &&
                      (r.emissiveMap.colorSpace = i.er$);
                  break;
                case "NormalMap":
                case "Maya|TEX_normal_map":
                  r.normalMap = s.getTexture(t, e.ID);
                  break;
                case "ReflectionColor":
                  (r.envMap = s.getTexture(t, e.ID)),
                    void 0 !== r.envMap &&
                      ((r.envMap.mapping = i.wfO),
                      (r.envMap.colorSpace = i.er$));
                  break;
                case "SpecularColor":
                  (r.specularMap = s.getTexture(t, e.ID)),
                    void 0 !== r.specularMap &&
                      (r.specularMap.colorSpace = i.er$);
                  break;
                case "TransparentColor":
                case "TransparencyFactor":
                  (r.alphaMap = s.getTexture(t, e.ID)), (r.transparent = !0);
                  break;
                default:
                  console.warn(
                    "THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",
                    n
                  );
              }
            }),
            r
          );
        }
        getTexture(e, t) {
          return (
            "LayeredTexture" in u.Objects &&
              t in u.Objects.LayeredTexture &&
              (console.warn(
                "THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."
              ),
              (t = h.get(t).children[0].ID)),
            e.get(t)
          );
        }
        parseDeformers() {
          const e = {},
            t = {};
          if ("Deformer" in u.Objects) {
            const n = u.Objects.Deformer;
            for (const i in n) {
              const r = n[i],
                s = h.get(parseInt(i));
              if ("Skin" === r.attrType) {
                const t = this.parseSkeleton(s, n);
                (t.ID = i),
                  s.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: skeleton attached to more than one geometry is not supported."
                    ),
                  (t.geometryID = s.parents[0].ID),
                  (e[i] = t);
              } else if ("BlendShape" === r.attrType) {
                const e = { id: i };
                (e.rawTargets = this.parseMorphTargets(s, n)),
                  (e.id = i),
                  s.parents.length > 1 &&
                    console.warn(
                      "THREE.FBXLoader: morph target attached to more than one geometry is not supported."
                    ),
                  (t[i] = e);
              }
            }
          }
          return { skeletons: e, morphTargets: t };
        }
        parseSkeleton(e, t) {
          const n = [];
          return (
            e.children.forEach(function (e) {
              const r = t[e.ID];
              if ("Cluster" !== r.attrType) return;
              const s = {
                ID: e.ID,
                indices: [],
                weights: [],
                transformLink: new i.kn4().fromArray(r.TransformLink.a),
              };
              "Indexes" in r &&
                ((s.indices = r.Indexes.a), (s.weights = r.Weights.a)),
                n.push(s);
            }),
            { rawBones: n, bones: [] }
          );
        }
        parseMorphTargets(e, t) {
          const n = [];
          for (let i = 0; i < e.children.length; i++) {
            const r = e.children[i],
              s = t[r.ID],
              a = {
                name: s.attrName,
                initialWeight: s.DeformPercent,
                id: s.id,
                fullWeights: s.FullWeights.a,
              };
            if ("BlendShapeChannel" !== s.attrType) return;
            (a.geoID = h.get(parseInt(r.ID)).children.filter(function (e) {
              return void 0 === e.relationship;
            })[0].ID),
              n.push(a);
          }
          return n;
        }
        parseScene(e, t, n) {
          d = new i.YJl();
          const r = this.parseModels(e.skeletons, t, n),
            s = u.Objects.Model,
            a = this;
          r.forEach(function (e) {
            const t = s[e.ID];
            a.setLookAtProperties(e, t);
            h.get(e.ID).parents.forEach(function (t) {
              const n = r.get(t.ID);
              void 0 !== n && n.add(e);
            }),
              null === e.parent && d.add(e);
          }),
            this.bindSkeleton(e.skeletons, t, r),
            this.addGlobalSceneSettings(),
            d.traverse(function (e) {
              if (e.userData.transformData) {
                e.parent &&
                  ((e.userData.transformData.parentMatrix = e.parent.matrix),
                  (e.userData.transformData.parentMatrixWorld =
                    e.parent.matrixWorld));
                const t = S(e.userData.transformData);
                e.applyMatrix4(t), e.updateWorldMatrix();
              }
            });
          const o = new g().parse();
          1 === d.children.length &&
            d.children[0].isGroup &&
            ((d.children[0].animations = o), (d = d.children[0])),
            (d.animations = o);
        }
        parseModels(e, t, n) {
          const r = new Map(),
            s = u.Objects.Model;
          for (const a in s) {
            const o = parseInt(a),
              l = s[a],
              c = h.get(o);
            let u = this.buildSkeleton(c, e, o, l.attrName);
            if (!u) {
              switch (l.attrType) {
                case "Camera":
                  u = this.createCamera(c);
                  break;
                case "Light":
                  u = this.createLight(c);
                  break;
                case "Mesh":
                  u = this.createMesh(c, t, n);
                  break;
                case "NurbsCurve":
                  u = this.createCurve(c, t);
                  break;
                case "LimbNode":
                case "Root":
                  u = new i.$Kf();
                  break;
                default:
                  u = new i.YJl();
              }
              (u.name = l.attrName ? i.Nwf.sanitizeNodeName(l.attrName) : ""),
                (u.userData.originalName = l.attrName),
                (u.ID = o);
            }
            this.getTransformData(u, l), r.set(o, u);
          }
          return r;
        }
        buildSkeleton(e, t, n, r) {
          let s = null;
          return (
            e.parents.forEach(function (e) {
              for (const a in t) {
                const o = t[a];
                o.rawBones.forEach(function (t, a) {
                  if (t.ID === e.ID) {
                    const e = s;
                    (s = new i.$Kf()),
                      s.matrixWorld.copy(t.transformLink),
                      (s.name = r ? i.Nwf.sanitizeNodeName(r) : ""),
                      (s.userData.originalName = r),
                      (s.ID = n),
                      (o.bones[a] = s),
                      null !== e && s.add(e);
                  }
                });
              }
            }),
            s
          );
        }
        createCamera(e) {
          let t, n;
          if (
            (e.children.forEach(function (e) {
              const t = u.Objects.NodeAttribute[e.ID];
              void 0 !== t && (n = t);
            }),
            void 0 === n)
          )
            t = new i.B69();
          else {
            let e = 0;
            void 0 !== n.CameraProjectionType &&
              1 === n.CameraProjectionType.value &&
              (e = 1);
            let r = 1;
            void 0 !== n.NearPlane && (r = n.NearPlane.value / 1e3);
            let s = 1e3;
            void 0 !== n.FarPlane && (s = n.FarPlane.value / 1e3);
            let a = window.innerWidth,
              o = window.innerHeight;
            void 0 !== n.AspectWidth &&
              void 0 !== n.AspectHeight &&
              ((a = n.AspectWidth.value), (o = n.AspectHeight.value));
            const l = a / o;
            let c = 45;
            void 0 !== n.FieldOfView && (c = n.FieldOfView.value);
            const u = n.FocalLength ? n.FocalLength.value : null;
            switch (e) {
              case 0:
                (t = new i.ubm(c, l, r, s)), null !== u && t.setFocalLength(u);
                break;
              case 1:
                console.warn(
                  "THREE.FBXLoader: Orthographic cameras not supported yet."
                ),
                  (t = new i.B69());
                break;
              default:
                console.warn("THREE.FBXLoader: Unknown camera type " + e + "."),
                  (t = new i.B69());
            }
          }
          return t;
        }
        createLight(e) {
          let t, n;
          if (
            (e.children.forEach(function (e) {
              const t = u.Objects.NodeAttribute[e.ID];
              void 0 !== t && (n = t);
            }),
            void 0 === n)
          )
            t = new i.B69();
          else {
            let e;
            e = void 0 === n.LightType ? 0 : n.LightType.value;
            let r = 16777215;
            void 0 !== n.Color &&
              (r = i.ppV.toWorkingColorSpace(
                new i.Q1f().fromArray(n.Color.value),
                i.er$
              ));
            let s = void 0 === n.Intensity ? 1 : n.Intensity.value / 100;
            void 0 !== n.CastLightOnObject &&
              0 === n.CastLightOnObject.value &&
              (s = 0);
            let a = 0;
            void 0 !== n.FarAttenuationEnd &&
              (a =
                void 0 !== n.EnableFarAttenuation &&
                0 === n.EnableFarAttenuation.value
                  ? 0
                  : n.FarAttenuationEnd.value);
            const o = 1;
            switch (e) {
              case 0:
                t = new i.HiM(r, s, a, o);
                break;
              case 1:
                t = new i.ZyN(r, s);
                break;
              case 2:
                let e = Math.PI / 3;
                void 0 !== n.InnerAngle &&
                  (e = i.cj9.degToRad(n.InnerAngle.value));
                let l = 0;
                void 0 !== n.OuterAngle &&
                  ((l = i.cj9.degToRad(n.OuterAngle.value)),
                  (l = Math.max(l, 1))),
                  (t = new i.nCl(r, s, a, e, l, o));
                break;
              default:
                console.warn(
                  "THREE.FBXLoader: Unknown light type " +
                    n.LightType.value +
                    ", defaulting to a PointLight."
                ),
                  (t = new i.HiM(r, s));
            }
            void 0 !== n.CastShadows &&
              1 === n.CastShadows.value &&
              (t.castShadow = !0);
          }
          return t;
        }
        createMesh(e, t, n) {
          let r,
            s = null,
            a = null;
          const o = [];
          return (
            e.children.forEach(function (e) {
              t.has(e.ID) && (s = t.get(e.ID)),
                n.has(e.ID) && o.push(n.get(e.ID));
            }),
            o.length > 1
              ? (a = o)
              : o.length > 0
              ? (a = o[0])
              : ((a = new i.tXL({
                  name: i.aHM.DEFAULT_MATERIAL_NAME,
                  color: 13421772,
                })),
                o.push(a)),
            "color" in s.attributes &&
              o.forEach(function (e) {
                e.vertexColors = !0;
              }),
            s.FBX_Deformer
              ? ((r = new i.I46(s, a)), r.normalizeSkinWeights())
              : (r = new i.eaF(s, a)),
            r
          );
        }
        createCurve(e, t) {
          const n = e.children.reduce(function (e, n) {
              return t.has(n.ID) && (e = t.get(n.ID)), e;
            }, null),
            r = new i.mrM({
              name: i.aHM.DEFAULT_MATERIAL_NAME,
              color: 3342591,
              linewidth: 1,
            });
          return new i.N1A(n, r);
        }
        getTransformData(e, t) {
          const n = {};
          "InheritType" in t && (n.inheritType = parseInt(t.InheritType.value)),
            (n.eulerOrder = M(
              "RotationOrder" in t ? t.RotationOrder.value : 0
            )),
            "Lcl_Translation" in t && (n.translation = t.Lcl_Translation.value),
            "PreRotation" in t && (n.preRotation = t.PreRotation.value),
            "Lcl_Rotation" in t && (n.rotation = t.Lcl_Rotation.value),
            "PostRotation" in t && (n.postRotation = t.PostRotation.value),
            "Lcl_Scaling" in t && (n.scale = t.Lcl_Scaling.value),
            "ScalingOffset" in t && (n.scalingOffset = t.ScalingOffset.value),
            "ScalingPivot" in t && (n.scalingPivot = t.ScalingPivot.value),
            "RotationOffset" in t &&
              (n.rotationOffset = t.RotationOffset.value),
            "RotationPivot" in t && (n.rotationPivot = t.RotationPivot.value),
            (e.userData.transformData = n);
        }
        setLookAtProperties(e, t) {
          if ("LookAtProperty" in t) {
            h.get(e.ID).children.forEach(function (t) {
              if ("LookAtProperty" === t.relationship) {
                const n = u.Objects.Model[t.ID];
                if ("Lcl_Translation" in n) {
                  const t = n.Lcl_Translation.value;
                  void 0 !== e.target
                    ? (e.target.position.fromArray(t), d.add(e.target))
                    : e.lookAt(new i.Pq0().fromArray(t));
                }
              }
            });
          }
        }
        bindSkeleton(e, t, n) {
          const r = this.parsePoseNodes();
          for (const s in e) {
            const a = e[s];
            h.get(parseInt(a.ID)).parents.forEach(function (e) {
              if (t.has(e.ID)) {
                const t = e.ID;
                h.get(t).parents.forEach(function (e) {
                  if (n.has(e.ID)) {
                    n.get(e.ID).bind(new i.EAD(a.bones), r[e.ID]);
                  }
                });
              }
            });
          }
        }
        parsePoseNodes() {
          const e = {};
          if ("Pose" in u.Objects) {
            const t = u.Objects.Pose;
            for (const n in t)
              if ("BindPose" === t[n].attrType && t[n].NbPoseNodes > 0) {
                const r = t[n].PoseNode;
                Array.isArray(r)
                  ? r.forEach(function (t) {
                      e[t.Node] = new i.kn4().fromArray(t.Matrix.a);
                    })
                  : (e[r.Node] = new i.kn4().fromArray(r.Matrix.a));
              }
          }
          return e;
        }
        addGlobalSceneSettings() {
          if ("GlobalSettings" in u) {
            if ("AmbientColor" in u.GlobalSettings) {
              const e = u.GlobalSettings.AmbientColor.value,
                t = e[0],
                n = e[1],
                r = e[2];
              if (0 !== t || 0 !== n || 0 !== r) {
                const e = new i.Q1f().setRGB(t, n, r, i.er$);
                d.add(new i.$p8(e, 1));
              }
            }
            "UnitScaleFactor" in u.GlobalSettings &&
              (d.userData.unitScaleFactor =
                u.GlobalSettings.UnitScaleFactor.value);
          }
        }
      }
      class A {
        constructor() {
          this.negativeMaterialIndices = !1;
        }
        parse(e) {
          const t = new Map();
          if ("Geometry" in u.Objects) {
            const n = u.Objects.Geometry;
            for (const i in n) {
              const r = h.get(parseInt(i)),
                s = this.parseGeometry(r, n[i], e);
              t.set(parseInt(i), s);
            }
          }
          return (
            !0 === this.negativeMaterialIndices &&
              console.warn(
                "THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."
              ),
            t
          );
        }
        parseGeometry(e, t, n) {
          switch (t.attrType) {
            case "Mesh":
              return this.parseMeshGeometry(e, t, n);
            case "NurbsCurve":
              return this.parseNurbsGeometry(t);
          }
        }
        parseMeshGeometry(e, t, n) {
          const i = n.skeletons,
            r = [],
            s = e.parents.map(function (e) {
              return u.Objects.Model[e.ID];
            });
          if (0 === s.length) return;
          const a = e.children.reduce(function (e, t) {
            return void 0 !== i[t.ID] && (e = i[t.ID]), e;
          }, null);
          e.children.forEach(function (e) {
            void 0 !== n.morphTargets[e.ID] && r.push(n.morphTargets[e.ID]);
          });
          const o = s[0],
            l = {};
          "RotationOrder" in o && (l.eulerOrder = M(o.RotationOrder.value)),
            "InheritType" in o &&
              (l.inheritType = parseInt(o.InheritType.value)),
            "GeometricTranslation" in o &&
              (l.translation = o.GeometricTranslation.value),
            "GeometricRotation" in o &&
              (l.rotation = o.GeometricRotation.value),
            "GeometricScaling" in o && (l.scale = o.GeometricScaling.value);
          const c = S(l);
          return this.genGeometry(t, a, r, c);
        }
        genGeometry(e, t, n, r) {
          const s = new i.LoY();
          e.attrName && (s.name = e.attrName);
          const a = this.parseGeoNode(e, t),
            o = this.genBuffers(a),
            l = new i.qtW(o.vertex, 3);
          if (
            (l.applyMatrix4(r),
            s.setAttribute("position", l),
            o.colors.length > 0 &&
              s.setAttribute("color", new i.qtW(o.colors, 3)),
            t &&
              (s.setAttribute("skinIndex", new i.A$4(o.weightsIndices, 4)),
              s.setAttribute("skinWeight", new i.qtW(o.vertexWeights, 4)),
              (s.FBX_Deformer = t)),
            o.normal.length > 0)
          ) {
            const e = new i.dwI().getNormalMatrix(r),
              t = new i.qtW(o.normal, 3);
            t.applyNormalMatrix(e), s.setAttribute("normal", t);
          }
          if (
            (o.uvs.forEach(function (e, t) {
              const n = 0 === t ? "uv" : `uv${t}`;
              s.setAttribute(n, new i.qtW(o.uvs[t], 2));
            }),
            a.material && "AllSame" !== a.material.mappingType)
          ) {
            let e = o.materialIndex[0],
              t = 0;
            if (
              (o.materialIndex.forEach(function (n, i) {
                n !== e && (s.addGroup(t, i - t, e), (e = n), (t = i));
              }),
              s.groups.length > 0)
            ) {
              const t = s.groups[s.groups.length - 1],
                n = t.start + t.count;
              n !== o.materialIndex.length &&
                s.addGroup(n, o.materialIndex.length - n, e);
            }
            0 === s.groups.length &&
              s.addGroup(0, o.materialIndex.length, o.materialIndex[0]);
          }
          return this.addMorphTargets(s, e, n, r), s;
        }
        parseGeoNode(e, t) {
          const n = {};
          if (
            ((n.vertexPositions = void 0 !== e.Vertices ? e.Vertices.a : []),
            (n.vertexIndices =
              void 0 !== e.PolygonVertexIndex ? e.PolygonVertexIndex.a : []),
            e.LayerElementColor &&
              (n.color = this.parseVertexColors(e.LayerElementColor[0])),
            e.LayerElementMaterial &&
              (n.material = this.parseMaterialIndices(
                e.LayerElementMaterial[0]
              )),
            e.LayerElementNormal &&
              (n.normal = this.parseNormals(e.LayerElementNormal[0])),
            e.LayerElementUV)
          ) {
            n.uv = [];
            let t = 0;
            for (; e.LayerElementUV[t]; )
              e.LayerElementUV[t].UV &&
                n.uv.push(this.parseUVs(e.LayerElementUV[t])),
                t++;
          }
          return (
            (n.weightTable = {}),
            null !== t &&
              ((n.skeleton = t),
              t.rawBones.forEach(function (e, t) {
                e.indices.forEach(function (i, r) {
                  void 0 === n.weightTable[i] && (n.weightTable[i] = []),
                    n.weightTable[i].push({ id: t, weight: e.weights[r] });
                });
              })),
            n
          );
        }
        genBuffers(e) {
          const t = {
            vertex: [],
            normal: [],
            colors: [],
            uvs: [],
            materialIndex: [],
            vertexWeights: [],
            weightsIndices: [],
          };
          let n = 0,
            i = 0,
            r = !1,
            s = [],
            a = [],
            o = [],
            l = [],
            c = [],
            u = [];
          const h = this;
          return (
            e.vertexIndices.forEach(function (d, p) {
              let f,
                A = !1;
              d < 0 && ((d = ~d), (A = !0));
              let g = [],
                m = [];
              if ((s.push(3 * d, 3 * d + 1, 3 * d + 2), e.color)) {
                const t = w(p, n, d, e.color);
                o.push(t[0], t[1], t[2]);
              }
              if (e.skeleton) {
                if (
                  (void 0 !== e.weightTable[d] &&
                    e.weightTable[d].forEach(function (e) {
                      m.push(e.weight), g.push(e.id);
                    }),
                  m.length > 4)
                ) {
                  r ||
                    (console.warn(
                      "THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."
                    ),
                    (r = !0));
                  const e = [0, 0, 0, 0],
                    t = [0, 0, 0, 0];
                  m.forEach(function (n, i) {
                    let r = n,
                      s = g[i];
                    t.forEach(function (t, n, i) {
                      if (r > t) {
                        (i[n] = r), (r = t);
                        const a = e[n];
                        (e[n] = s), (s = a);
                      }
                    });
                  }),
                    (g = e),
                    (m = t);
                }
                for (; m.length < 4; ) m.push(0), g.push(0);
                for (let e = 0; e < 4; ++e) c.push(m[e]), u.push(g[e]);
              }
              if (e.normal) {
                const t = w(p, n, d, e.normal);
                a.push(t[0], t[1], t[2]);
              }
              e.material &&
                "AllSame" !== e.material.mappingType &&
                ((f = w(p, n, d, e.material)[0]),
                f < 0 && ((h.negativeMaterialIndices = !0), (f = 0))),
                e.uv &&
                  e.uv.forEach(function (e, t) {
                    const i = w(p, n, d, e);
                    void 0 === l[t] && (l[t] = []),
                      l[t].push(i[0]),
                      l[t].push(i[1]);
                  }),
                i++,
                A &&
                  (h.genFace(t, e, s, f, a, o, l, c, u, i),
                  n++,
                  (i = 0),
                  (s = []),
                  (a = []),
                  (o = []),
                  (l = []),
                  (c = []),
                  (u = []));
            }),
            t
          );
        }
        getNormalNewell(e) {
          const t = new i.Pq0(0, 0, 0);
          for (let n = 0; n < e.length; n++) {
            const i = e[n],
              r = e[(n + 1) % e.length];
            (t.x += (i.y - r.y) * (i.z + r.z)),
              (t.y += (i.z - r.z) * (i.x + r.x)),
              (t.z += (i.x - r.x) * (i.y + r.y));
          }
          return t.normalize(), t;
        }
        getNormalTangentAndBitangent(e) {
          const t = this.getNormalNewell(e),
            n = (Math.abs(t.z) > 0.5 ? new i.Pq0(0, 1, 0) : new i.Pq0(0, 0, 1))
              .cross(t)
              .normalize(),
            r = t.clone().cross(n).normalize();
          return { normal: t, tangent: n, bitangent: r };
        }
        flattenVertex(e, t, n) {
          return new i.I9Y(e.dot(t), e.dot(n));
        }
        genFace(e, t, n, r, s, a, o, l, c, u) {
          let h;
          if (u > 3) {
            const e = [],
              r = t.baseVertexPositions || t.vertexPositions;
            for (let t = 0; t < n.length; t += 3)
              e.push(new i.Pq0(r[n[t]], r[n[t + 1]], r[n[t + 2]]));
            const { tangent: s, bitangent: a } =
                this.getNormalTangentAndBitangent(e),
              o = [];
            for (const t of e) o.push(this.flattenVertex(t, s, a));
            h = i.xJ6.triangulateShape(o, []);
          } else h = [[0, 1, 2]];
          for (const [i, u, d] of h)
            e.vertex.push(t.vertexPositions[n[3 * i]]),
              e.vertex.push(t.vertexPositions[n[3 * i + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * i + 2]]),
              e.vertex.push(t.vertexPositions[n[3 * u]]),
              e.vertex.push(t.vertexPositions[n[3 * u + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * u + 2]]),
              e.vertex.push(t.vertexPositions[n[3 * d]]),
              e.vertex.push(t.vertexPositions[n[3 * d + 1]]),
              e.vertex.push(t.vertexPositions[n[3 * d + 2]]),
              t.skeleton &&
                (e.vertexWeights.push(l[4 * i]),
                e.vertexWeights.push(l[4 * i + 1]),
                e.vertexWeights.push(l[4 * i + 2]),
                e.vertexWeights.push(l[4 * i + 3]),
                e.vertexWeights.push(l[4 * u]),
                e.vertexWeights.push(l[4 * u + 1]),
                e.vertexWeights.push(l[4 * u + 2]),
                e.vertexWeights.push(l[4 * u + 3]),
                e.vertexWeights.push(l[4 * d]),
                e.vertexWeights.push(l[4 * d + 1]),
                e.vertexWeights.push(l[4 * d + 2]),
                e.vertexWeights.push(l[4 * d + 3]),
                e.weightsIndices.push(c[4 * i]),
                e.weightsIndices.push(c[4 * i + 1]),
                e.weightsIndices.push(c[4 * i + 2]),
                e.weightsIndices.push(c[4 * i + 3]),
                e.weightsIndices.push(c[4 * u]),
                e.weightsIndices.push(c[4 * u + 1]),
                e.weightsIndices.push(c[4 * u + 2]),
                e.weightsIndices.push(c[4 * u + 3]),
                e.weightsIndices.push(c[4 * d]),
                e.weightsIndices.push(c[4 * d + 1]),
                e.weightsIndices.push(c[4 * d + 2]),
                e.weightsIndices.push(c[4 * d + 3])),
              t.color &&
                (e.colors.push(a[3 * i]),
                e.colors.push(a[3 * i + 1]),
                e.colors.push(a[3 * i + 2]),
                e.colors.push(a[3 * u]),
                e.colors.push(a[3 * u + 1]),
                e.colors.push(a[3 * u + 2]),
                e.colors.push(a[3 * d]),
                e.colors.push(a[3 * d + 1]),
                e.colors.push(a[3 * d + 2])),
              t.material &&
                "AllSame" !== t.material.mappingType &&
                (e.materialIndex.push(r),
                e.materialIndex.push(r),
                e.materialIndex.push(r)),
              t.normal &&
                (e.normal.push(s[3 * i]),
                e.normal.push(s[3 * i + 1]),
                e.normal.push(s[3 * i + 2]),
                e.normal.push(s[3 * u]),
                e.normal.push(s[3 * u + 1]),
                e.normal.push(s[3 * u + 2]),
                e.normal.push(s[3 * d]),
                e.normal.push(s[3 * d + 1]),
                e.normal.push(s[3 * d + 2])),
              t.uv &&
                t.uv.forEach(function (t, n) {
                  void 0 === e.uvs[n] && (e.uvs[n] = []),
                    e.uvs[n].push(o[n][2 * i]),
                    e.uvs[n].push(o[n][2 * i + 1]),
                    e.uvs[n].push(o[n][2 * u]),
                    e.uvs[n].push(o[n][2 * u + 1]),
                    e.uvs[n].push(o[n][2 * d]),
                    e.uvs[n].push(o[n][2 * d + 1]);
                });
        }
        addMorphTargets(e, t, n, i) {
          if (0 === n.length) return;
          (e.morphTargetsRelative = !0), (e.morphAttributes.position = []);
          const r = this;
          n.forEach(function (n) {
            n.rawTargets.forEach(function (n) {
              const s = u.Objects.Geometry[n.geoID];
              void 0 !== s && r.genMorphGeometry(e, t, s, i, n.name);
            });
          });
        }
        genMorphGeometry(e, t, n, r, s) {
          const a = void 0 !== t.Vertices ? t.Vertices.a : [],
            o = void 0 !== t.PolygonVertexIndex ? t.PolygonVertexIndex.a : [],
            l = void 0 !== n.Vertices ? n.Vertices.a : [],
            c = void 0 !== n.Indexes ? n.Indexes.a : [],
            u = 3 * e.attributes.position.count,
            h = new Float32Array(u);
          for (let e = 0; e < c.length; e++) {
            const t = 3 * c[e];
            (h[t] = l[3 * e]),
              (h[t + 1] = l[3 * e + 1]),
              (h[t + 2] = l[3 * e + 2]);
          }
          const d = {
              vertexIndices: o,
              vertexPositions: h,
              baseVertexPositions: a,
            },
            p = this.genBuffers(d),
            f = new i.qtW(p.vertex, 3);
          (f.name = s || n.attrName),
            f.applyMatrix4(r),
            e.morphAttributes.position.push(f);
        }
        parseNormals(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.Normals.a;
          let r = [];
          return (
            "IndexToDirect" === n &&
              ("NormalIndex" in e
                ? (r = e.NormalIndex.a)
                : "NormalsIndex" in e && (r = e.NormalsIndex.a)),
            {
              dataSize: 3,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        }
        parseUVs(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            i = e.UV.a;
          let r = [];
          return (
            "IndexToDirect" === n && (r = e.UVIndex.a),
            {
              dataSize: 2,
              buffer: i,
              indices: r,
              mappingType: t,
              referenceType: n,
            }
          );
        }
        parseVertexColors(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType,
            r = e.Colors.a;
          let s = [];
          "IndexToDirect" === n && (s = e.ColorIndex.a);
          for (let e = 0, t = new i.Q1f(); e < r.length; e += 4)
            t.fromArray(r, e),
              i.ppV.toWorkingColorSpace(t, i.er$),
              t.toArray(r, e);
          return {
            dataSize: 4,
            buffer: r,
            indices: s,
            mappingType: t,
            referenceType: n,
          };
        }
        parseMaterialIndices(e) {
          const t = e.MappingInformationType,
            n = e.ReferenceInformationType;
          if ("NoMappingInformation" === t)
            return {
              dataSize: 1,
              buffer: [0],
              indices: [0],
              mappingType: "AllSame",
              referenceType: n,
            };
          const i = e.Materials.a,
            r = [];
          for (let e = 0; e < i.length; ++e) r.push(e);
          return {
            dataSize: 1,
            buffer: i,
            indices: r,
            mappingType: t,
            referenceType: n,
          };
        }
        parseNurbsGeometry(e) {
          const t = parseInt(e.Order);
          if (isNaN(t))
            return (
              console.error(
                "THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",
                e.Order,
                e.id
              ),
              new i.LoY()
            );
          const n = t - 1,
            r = e.KnotVector.a,
            s = [],
            a = e.Points.a;
          for (let e = 0, t = a.length; e < t; e += 4)
            s.push(new i.IUQ().fromArray(a, e));
          let o, l;
          if ("Closed" === e.Form) s.push(s[0]);
          else if ("Periodic" === e.Form) {
            (o = n), (l = r.length - 1 - o);
            for (let e = 0; e < n; ++e) s.push(s[e]);
          }
          const u = new c(n, r, s, o, l).getPoints(12 * s.length);
          return new i.LoY().setFromPoints(u);
        }
      }
      class g {
        parse() {
          const e = [],
            t = this.parseClips();
          if (void 0 !== t)
            for (const n in t) {
              const i = t[n],
                r = this.addClip(i);
              e.push(r);
            }
          return e;
        }
        parseClips() {
          if (void 0 === u.Objects.AnimationCurve) return;
          const e = this.parseAnimationCurveNodes();
          this.parseAnimationCurves(e);
          const t = this.parseAnimationLayers(e);
          return this.parseAnimStacks(t);
        }
        parseAnimationCurveNodes() {
          const e = u.Objects.AnimationCurveNode,
            t = new Map();
          for (const n in e) {
            const i = e[n];
            if (null !== i.attrName.match(/S|R|T|DeformPercent/)) {
              const e = { id: i.id, attr: i.attrName, curves: {} };
              t.set(e.id, e);
            }
          }
          return t;
        }
        parseAnimationCurves(e) {
          const t = u.Objects.AnimationCurve;
          for (const n in t) {
            const i = {
                id: t[n].id,
                times: t[n].KeyTime.a.map(b),
                values: t[n].KeyValueFloat.a,
              },
              r = h.get(i.id);
            if (void 0 !== r) {
              const t = r.parents[0].ID,
                n = r.parents[0].relationship;
              n.match(/X/)
                ? (e.get(t).curves.x = i)
                : n.match(/Y/)
                ? (e.get(t).curves.y = i)
                : n.match(/Z/)
                ? (e.get(t).curves.z = i)
                : n.match(/DeformPercent/) &&
                  e.has(t) &&
                  (e.get(t).curves.morph = i);
            }
          }
        }
        parseAnimationLayers(e) {
          const t = u.Objects.AnimationLayer,
            n = new Map();
          for (const r in t) {
            const t = [],
              s = h.get(parseInt(r));
            if (void 0 !== s) {
              s.children.forEach(function (n, r) {
                if (e.has(n.ID)) {
                  const s = e.get(n.ID);
                  if (
                    void 0 !== s.curves.x ||
                    void 0 !== s.curves.y ||
                    void 0 !== s.curves.z
                  ) {
                    if (void 0 === t[r]) {
                      const e = h.get(n.ID).parents.filter(function (e) {
                        return void 0 !== e.relationship;
                      })[0].ID;
                      if (void 0 !== e) {
                        const s = u.Objects.Model[e.toString()];
                        if (void 0 === s)
                          return void console.warn(
                            "THREE.FBXLoader: Encountered a unused curve.",
                            n
                          );
                        const a = {
                          modelName: s.attrName
                            ? i.Nwf.sanitizeNodeName(s.attrName)
                            : "",
                          ID: s.id,
                          initialPosition: [0, 0, 0],
                          initialRotation: [0, 0, 0],
                          initialScale: [1, 1, 1],
                        };
                        d.traverse(function (e) {
                          e.ID === s.id &&
                            ((a.transform = e.matrix),
                            e.userData.transformData &&
                              (a.eulerOrder =
                                e.userData.transformData.eulerOrder));
                        }),
                          a.transform || (a.transform = new i.kn4()),
                          "PreRotation" in s &&
                            (a.preRotation = s.PreRotation.value),
                          "PostRotation" in s &&
                            (a.postRotation = s.PostRotation.value),
                          (t[r] = a);
                      }
                    }
                    t[r] && (t[r][s.attr] = s);
                  } else if (void 0 !== s.curves.morph) {
                    if (void 0 === t[r]) {
                      const e = h.get(n.ID).parents.filter(function (e) {
                          return void 0 !== e.relationship;
                        })[0].ID,
                        s = h.get(e).parents[0].ID,
                        a = h.get(s).parents[0].ID,
                        o = h.get(a).parents[0].ID,
                        l = u.Objects.Model[o],
                        c = {
                          modelName: l.attrName
                            ? i.Nwf.sanitizeNodeName(l.attrName)
                            : "",
                          morphName: u.Objects.Deformer[e].attrName,
                        };
                      t[r] = c;
                    }
                    t[r][s.attr] = s;
                  }
                }
              }),
                n.set(parseInt(r), t);
            }
          }
          return n;
        }
        parseAnimStacks(e) {
          const t = u.Objects.AnimationStack,
            n = {};
          for (const i in t) {
            const r = h.get(parseInt(i)).children;
            r.length > 1 &&
              console.warn(
                "THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers."
              );
            const s = e.get(r[0].ID);
            n[i] = { name: t[i].attrName, layer: s };
          }
          return n;
        }
        addClip(e) {
          let t = [];
          const n = this;
          return (
            e.layer.forEach(function (e) {
              t = t.concat(n.generateTracks(e));
            }),
            new i.tz3(e.name, -1, t)
          );
        }
        generateTracks(e) {
          const t = [];
          let n = new i.Pq0(),
            r = new i.Pq0();
          if (
            (e.transform && e.transform.decompose(n, new i.PTz(), r),
            (n = n.toArray()),
            (r = r.toArray()),
            void 0 !== e.T && Object.keys(e.T.curves).length > 0)
          ) {
            const i = this.generateVectorTrack(
              e.modelName,
              e.T.curves,
              n,
              "position"
            );
            void 0 !== i && t.push(i);
          }
          if (void 0 !== e.R && Object.keys(e.R.curves).length > 0) {
            const n = this.generateRotationTrack(
              e.modelName,
              e.R.curves,
              e.preRotation,
              e.postRotation,
              e.eulerOrder
            );
            void 0 !== n && t.push(n);
          }
          if (void 0 !== e.S && Object.keys(e.S.curves).length > 0) {
            const n = this.generateVectorTrack(
              e.modelName,
              e.S.curves,
              r,
              "scale"
            );
            void 0 !== n && t.push(n);
          }
          if (void 0 !== e.DeformPercent) {
            const n = this.generateMorphTrack(e);
            void 0 !== n && t.push(n);
          }
          return t;
        }
        generateVectorTrack(e, t, n, r) {
          const s = this.getTimesForAllAxes(t),
            a = this.getKeyframeTrackValues(s, t, n);
          return new i.RiT(e + "." + r, s, a);
        }
        generateRotationTrack(e, t, n, r, s) {
          let a, o;
          if (void 0 !== t.x && void 0 !== t.y && void 0 !== t.z) {
            const e = this.interpolateRotations(t.x, t.y, t.z, s);
            (a = e[0]), (o = e[1]);
          }
          const l = M(0);
          void 0 !== n &&
            ((n = n.map(i.cj9.degToRad)).push(l),
            (n = new i.O9p().fromArray(n)),
            (n = new i.PTz().setFromEuler(n))),
            void 0 !== r &&
              ((r = r.map(i.cj9.degToRad)).push(l),
              (r = new i.O9p().fromArray(r)),
              (r = new i.PTz().setFromEuler(r).invert()));
          const c = new i.PTz(),
            u = new i.O9p(),
            h = [];
          if (!o || !a) return new i.MBL(e + ".quaternion", [0], [0]);
          for (let e = 0; e < o.length; e += 3) {
            if (
              (u.set(o[e], o[e + 1], o[e + 2], s),
              c.setFromEuler(u),
              void 0 !== n && c.premultiply(n),
              void 0 !== r && c.multiply(r),
              e > 2)
            ) {
              new i.PTz().fromArray(h, ((e - 3) / 3) * 4).dot(c) < 0 &&
                c.set(-c.x, -c.y, -c.z, -c.w);
            }
            c.toArray(h, (e / 3) * 4);
          }
          return new i.MBL(e + ".quaternion", a, h);
        }
        generateMorphTrack(e) {
          const t = e.DeformPercent.curves.morph,
            n = t.values.map(function (e) {
              return e / 100;
            }),
            r = d.getObjectByName(e.modelName).morphTargetDictionary[
              e.morphName
            ];
          return new i.Hit(
            e.modelName + ".morphTargetInfluences[" + r + "]",
            t.times,
            n
          );
        }
        getTimesForAllAxes(e) {
          let t = [];
          if (
            (void 0 !== e.x && (t = t.concat(e.x.times)),
            void 0 !== e.y && (t = t.concat(e.y.times)),
            void 0 !== e.z && (t = t.concat(e.z.times)),
            (t = t.sort(function (e, t) {
              return e - t;
            })),
            t.length > 1)
          ) {
            let e = 1,
              n = t[0];
            for (let i = 1; i < t.length; i++) {
              const r = t[i];
              r !== n && ((t[e] = r), (n = r), e++);
            }
            t = t.slice(0, e);
          }
          return t;
        }
        getKeyframeTrackValues(e, t, n) {
          const i = n,
            r = [];
          let s = -1,
            a = -1,
            o = -1;
          return (
            e.forEach(function (e) {
              if (
                (t.x && (s = t.x.times.indexOf(e)),
                t.y && (a = t.y.times.indexOf(e)),
                t.z && (o = t.z.times.indexOf(e)),
                -1 !== s)
              ) {
                const e = t.x.values[s];
                r.push(e), (i[0] = e);
              } else r.push(i[0]);
              if (-1 !== a) {
                const e = t.y.values[a];
                r.push(e), (i[1] = e);
              } else r.push(i[1]);
              if (-1 !== o) {
                const e = t.z.values[o];
                r.push(e), (i[2] = e);
              } else r.push(i[2]);
            }),
            r
          );
        }
        interpolateRotations(e, t, n, r) {
          const s = [],
            a = [];
          s.push(e.times[0]),
            a.push(i.cj9.degToRad(e.values[0])),
            a.push(i.cj9.degToRad(t.values[0])),
            a.push(i.cj9.degToRad(n.values[0]));
          for (let o = 1; o < e.values.length; o++) {
            const l = [e.values[o - 1], t.values[o - 1], n.values[o - 1]];
            if (isNaN(l[0]) || isNaN(l[1]) || isNaN(l[2])) continue;
            const c = l.map(i.cj9.degToRad),
              u = [e.values[o], t.values[o], n.values[o]];
            if (isNaN(u[0]) || isNaN(u[1]) || isNaN(u[2])) continue;
            const h = u.map(i.cj9.degToRad),
              d = [u[0] - l[0], u[1] - l[1], u[2] - l[2]],
              p = [Math.abs(d[0]), Math.abs(d[1]), Math.abs(d[2])];
            if (p[0] >= 180 || p[1] >= 180 || p[2] >= 180) {
              const t = Math.max(...p) / 180,
                n = new i.O9p(...c, r),
                l = new i.O9p(...h, r),
                u = new i.PTz().setFromEuler(n),
                d = new i.PTz().setFromEuler(l);
              u.dot(d) && d.set(-d.x, -d.y, -d.z, -d.w);
              const f = e.times[o - 1],
                A = e.times[o] - f,
                g = new i.PTz(),
                m = new i.O9p();
              for (let e = 0; e < 1; e += 1 / t)
                g.copy(u.clone().slerp(d.clone(), e)),
                  s.push(f + e * A),
                  m.setFromQuaternion(g, r),
                  a.push(m.x),
                  a.push(m.y),
                  a.push(m.z);
            } else
              s.push(e.times[o]),
                a.push(i.cj9.degToRad(e.values[o])),
                a.push(i.cj9.degToRad(t.values[o])),
                a.push(i.cj9.degToRad(n.values[o]));
          }
          return [s, a];
        }
      }
      class m {
        getPrevNode() {
          return this.nodeStack[this.currentIndent - 2];
        }
        getCurrentNode() {
          return this.nodeStack[this.currentIndent - 1];
        }
        getCurrentProp() {
          return this.currentProp;
        }
        pushStack(e) {
          this.nodeStack.push(e), (this.currentIndent += 1);
        }
        popStack() {
          this.nodeStack.pop(), (this.currentIndent -= 1);
        }
        setCurrentProp(e, t) {
          (this.currentProp = e), (this.currentPropName = t);
        }
        parse(e) {
          (this.currentIndent = 0),
            (this.allNodes = new x()),
            (this.nodeStack = []),
            (this.currentProp = []),
            (this.currentPropName = "");
          const t = this,
            n = e.split(/[\r\n]+/);
          return (
            n.forEach(function (e, i) {
              const r = e.match(/^[\s\t]*;/),
                s = e.match(/^[\s\t]*$/);
              if (r || s) return;
              const a = e.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):(.*){",
                  ""
                ),
                o = e.match(
                  "^\\t{" + t.currentIndent + "}(\\w+):[\\s\\t\\r\\n](.*)"
                ),
                l = e.match("^\\t{" + (t.currentIndent - 1) + "}}");
              a
                ? t.parseNodeBegin(e, a)
                : o
                ? t.parseNodeProperty(e, o, n[++i])
                : l
                ? t.popStack()
                : e.match(/^[^\s\t}]/) && t.parseNodePropertyContinued(e);
            }),
            this.allNodes
          );
        }
        parseNodeBegin(e, t) {
          const n = t[1].trim().replace(/^"/, "").replace(/"$/, ""),
            i = t[2].split(",").map(function (e) {
              return e.trim().replace(/^"/, "").replace(/"$/, "");
            }),
            r = { name: n },
            s = this.parseNodeAttr(i),
            a = this.getCurrentNode();
          0 === this.currentIndent
            ? this.allNodes.add(n, r)
            : n in a
            ? ("PoseNode" === n
                ? a.PoseNode.push(r)
                : void 0 !== a[n].id && ((a[n] = {}), (a[n][a[n].id] = a[n])),
              "" !== s.id && (a[n][s.id] = r))
            : "number" == typeof s.id
            ? ((a[n] = {}), (a[n][s.id] = r))
            : "Properties70" !== n && (a[n] = "PoseNode" === n ? [r] : r),
            "number" == typeof s.id && (r.id = s.id),
            "" !== s.name && (r.attrName = s.name),
            "" !== s.type && (r.attrType = s.type),
            this.pushStack(r);
        }
        parseNodeAttr(e) {
          let t = e[0];
          "" !== e[0] && ((t = parseInt(e[0])), isNaN(t) && (t = e[0]));
          let n = "",
            i = "";
          return (
            e.length > 1 && ((n = e[1].replace(/^(\w+)::/, "")), (i = e[2])),
            { id: t, name: n, type: i }
          );
        }
        parseNodeProperty(e, t, n) {
          let i = t[1].replace(/^"/, "").replace(/"$/, "").trim(),
            r = t[2].replace(/^"/, "").replace(/"$/, "").trim();
          "Content" === i &&
            "," === r &&
            (r = n.replace(/"/g, "").replace(/,$/, "").trim());
          const s = this.getCurrentNode();
          if ("Properties70" !== s.name) {
            if ("C" === i) {
              const e = r.split(",").slice(1),
                t = parseInt(e[0]),
                n = parseInt(e[1]);
              let a = r.split(",").slice(3);
              (a = a.map(function (e) {
                return e.trim().replace(/^"/, "");
              })),
                (i = "connections"),
                (r = [t, n]),
                (function (e, t) {
                  for (let n = 0, i = e.length, r = t.length; n < r; n++, i++)
                    e[i] = t[n];
                })(r, a),
                void 0 === s[i] && (s[i] = []);
            }
            "Node" === i && (s.id = r),
              i in s && Array.isArray(s[i])
                ? s[i].push(r)
                : "a" !== i
                ? (s[i] = r)
                : (s.a = r),
              this.setCurrentProp(s, i),
              "a" === i && "," !== r.slice(-1) && (s.a = T(r));
          } else this.parseNodeSpecialProperty(e, i, r);
        }
        parseNodePropertyContinued(e) {
          const t = this.getCurrentNode();
          (t.a += e), "," !== e.slice(-1) && (t.a = T(t.a));
        }
        parseNodeSpecialProperty(e, t, n) {
          const i = n.split('",').map(function (e) {
              return e.trim().replace(/^\"/, "").replace(/\s/, "_");
            }),
            r = i[0],
            s = i[1],
            a = i[2],
            o = i[3];
          let l = i[4];
          switch (s) {
            case "int":
            case "enum":
            case "bool":
            case "ULongLong":
            case "double":
            case "Number":
            case "FieldOfView":
              l = parseFloat(l);
              break;
            case "Color":
            case "ColorRGB":
            case "Vector3D":
            case "Lcl_Translation":
            case "Lcl_Rotation":
            case "Lcl_Scaling":
              l = T(l);
          }
          (this.getPrevNode()[r] = { type: s, type2: a, flag: o, value: l }),
            this.setCurrentProp(this.getPrevNode(), r);
        }
      }
      class v {
        parse(e) {
          const t = new y(e);
          t.skip(23);
          const n = t.getUint32();
          if (n < 6400)
            throw new Error(
              "THREE.FBXLoader: FBX version not supported, FileVersion: " + n
            );
          const i = new x();
          for (; !this.endOfContent(t); ) {
            const e = this.parseNode(t, n);
            null !== e && i.add(e.name, e);
          }
          return i;
        }
        endOfContent(e) {
          return e.size() % 16 == 0
            ? ((e.getOffset() + 160 + 16) & -16) >= e.size()
            : e.getOffset() + 160 + 16 >= e.size();
        }
        parseNode(e, t) {
          const n = {},
            i = t >= 7500 ? e.getUint64() : e.getUint32(),
            r = t >= 7500 ? e.getUint64() : e.getUint32();
          t >= 7500 ? e.getUint64() : e.getUint32();
          const s = e.getUint8(),
            a = e.getString(s);
          if (0 === i) return null;
          const o = [];
          for (let t = 0; t < r; t++) o.push(this.parseProperty(e));
          const l = o.length > 0 ? o[0] : "",
            c = o.length > 1 ? o[1] : "",
            u = o.length > 2 ? o[2] : "";
          for (
            n.singleProperty = 1 === r && e.getOffset() === i;
            i > e.getOffset();

          ) {
            const i = this.parseNode(e, t);
            null !== i && this.parseSubNode(a, n, i);
          }
          return (
            (n.propertyList = o),
            "number" == typeof l && (n.id = l),
            "" !== c && (n.attrName = c),
            "" !== u && (n.attrType = u),
            "" !== a && (n.name = a),
            n
          );
        }
        parseSubNode(e, t, n) {
          if (!0 === n.singleProperty) {
            const e = n.propertyList[0];
            Array.isArray(e) ? ((t[n.name] = n), (n.a = e)) : (t[n.name] = e);
          } else if ("Connections" === e && "C" === n.name) {
            const e = [];
            n.propertyList.forEach(function (t, n) {
              0 !== n && e.push(t);
            }),
              void 0 === t.connections && (t.connections = []),
              t.connections.push(e);
          } else if ("Properties70" === n.name) {
            Object.keys(n).forEach(function (e) {
              t[e] = n[e];
            });
          } else if ("Properties70" === e && "P" === n.name) {
            let e = n.propertyList[0],
              i = n.propertyList[1];
            const r = n.propertyList[2],
              s = n.propertyList[3];
            let a;
            0 === e.indexOf("Lcl ") && (e = e.replace("Lcl ", "Lcl_")),
              0 === i.indexOf("Lcl ") && (i = i.replace("Lcl ", "Lcl_")),
              (a =
                "Color" === i ||
                "ColorRGB" === i ||
                "Vector" === i ||
                "Vector3D" === i ||
                0 === i.indexOf("Lcl_")
                  ? [n.propertyList[4], n.propertyList[5], n.propertyList[6]]
                  : n.propertyList[4]),
              (t[e] = { type: i, type2: r, flag: s, value: a });
          } else
            void 0 === t[n.name]
              ? "number" == typeof n.id
                ? ((t[n.name] = {}), (t[n.name][n.id] = n))
                : (t[n.name] = n)
              : "PoseNode" === n.name
              ? (Array.isArray(t[n.name]) || (t[n.name] = [t[n.name]]),
                t[n.name].push(n))
              : void 0 === t[n.name][n.id] && (t[n.name][n.id] = n);
        }
        parseProperty(e) {
          const t = e.getString(1);
          let n;
          switch (t) {
            case "C":
              return e.getBoolean();
            case "D":
              return e.getFloat64();
            case "F":
              return e.getFloat32();
            case "I":
              return e.getInt32();
            case "L":
              return e.getInt64();
            case "R":
              return (n = e.getUint32()), e.getArrayBuffer(n);
            case "S":
              return (n = e.getUint32()), e.getString(n);
            case "Y":
              return e.getInt16();
            case "b":
            case "c":
            case "d":
            case "f":
            case "i":
            case "l":
              const i = e.getUint32(),
                s = e.getUint32(),
                a = e.getUint32();
              if (0 === s)
                switch (t) {
                  case "b":
                  case "c":
                    return e.getBooleanArray(i);
                  case "d":
                    return e.getFloat64Array(i);
                  case "f":
                    return e.getFloat32Array(i);
                  case "i":
                    return e.getInt32Array(i);
                  case "l":
                    return e.getInt64Array(i);
                }
              const o = r.a8(new Uint8Array(e.getArrayBuffer(a))),
                l = new y(o.buffer);
              switch (t) {
                case "b":
                case "c":
                  return l.getBooleanArray(i);
                case "d":
                  return l.getFloat64Array(i);
                case "f":
                  return l.getFloat32Array(i);
                case "i":
                  return l.getInt32Array(i);
                case "l":
                  return l.getInt64Array(i);
              }
              break;
            default:
              throw new Error("THREE.FBXLoader: Unknown property type " + t);
          }
        }
      }
      class y {
        constructor(e, t) {
          (this.dv = new DataView(e)),
            (this.offset = 0),
            (this.littleEndian = void 0 === t || t),
            (this._textDecoder = new TextDecoder());
        }
        getOffset() {
          return this.offset;
        }
        size() {
          return this.dv.buffer.byteLength;
        }
        skip(e) {
          this.offset += e;
        }
        getBoolean() {
          return !(1 & ~this.getUint8());
        }
        getBooleanArray(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getBoolean());
          return t;
        }
        getUint8() {
          const e = this.dv.getUint8(this.offset);
          return (this.offset += 1), e;
        }
        getInt16() {
          const e = this.dv.getInt16(this.offset, this.littleEndian);
          return (this.offset += 2), e;
        }
        getInt32() {
          const e = this.dv.getInt32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt32Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getInt32());
          return t;
        }
        getUint32() {
          const e = this.dv.getUint32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getInt64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            2147483648 & t
              ? ((t = 4294967295 & ~t),
                (e = 4294967295 & ~e),
                4294967295 === e && (t = (t + 1) & 4294967295),
                (e = (e + 1) & 4294967295),
                -(4294967296 * t + e))
              : 4294967296 * t + e
          );
        }
        getInt64Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getInt64());
          return t;
        }
        getUint64() {
          let e, t;
          return (
            this.littleEndian
              ? ((e = this.getUint32()), (t = this.getUint32()))
              : ((t = this.getUint32()), (e = this.getUint32())),
            4294967296 * t + e
          );
        }
        getFloat32() {
          const e = this.dv.getFloat32(this.offset, this.littleEndian);
          return (this.offset += 4), e;
        }
        getFloat32Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getFloat32());
          return t;
        }
        getFloat64() {
          const e = this.dv.getFloat64(this.offset, this.littleEndian);
          return (this.offset += 8), e;
        }
        getFloat64Array(e) {
          const t = [];
          for (let n = 0; n < e; n++) t.push(this.getFloat64());
          return t;
        }
        getArrayBuffer(e) {
          const t = this.dv.buffer.slice(this.offset, this.offset + e);
          return (this.offset += e), t;
        }
        getString(e) {
          const t = this.offset;
          let n = new Uint8Array(this.dv.buffer, t, e);
          this.skip(e);
          const i = n.indexOf(0);
          return (
            i >= 0 && (n = new Uint8Array(this.dv.buffer, t, i)),
            this._textDecoder.decode(n)
          );
        }
      }
      class x {
        add(e, t) {
          this[e] = t;
        }
      }
      function _(e) {
        const t = e.match(/FBXVersion: (\d+)/);
        if (t) {
          return parseInt(t[1]);
        }
        throw new Error(
          "THREE.FBXLoader: Cannot find the version number for the file given."
        );
      }
      function b(e) {
        return e / 46186158e3;
      }
      const E = [];
      function w(e, t, n, i) {
        let r;
        switch (i.mappingType) {
          case "ByPolygonVertex":
            r = e;
            break;
          case "ByPolygon":
            r = t;
            break;
          case "ByVertice":
            r = n;
            break;
          case "AllSame":
            r = i.indices[0];
            break;
          default:
            console.warn(
              "THREE.FBXLoader: unknown attribute mapping type " + i.mappingType
            );
        }
        "IndexToDirect" === i.referenceType && (r = i.indices[r]);
        const s = r * i.dataSize,
          a = s + i.dataSize;
        return (function (e, t, n, i) {
          for (let r = n, s = 0; r < i; r++, s++) e[s] = t[r];
          return e;
        })(E, i.buffer, s, a);
      }
      const C = new i.O9p(),
        I = new i.Pq0();
      function S(e) {
        const t = new i.kn4(),
          n = new i.kn4(),
          r = new i.kn4(),
          s = new i.kn4(),
          a = new i.kn4(),
          o = new i.kn4(),
          l = new i.kn4(),
          c = new i.kn4(),
          u = new i.kn4(),
          h = new i.kn4(),
          d = new i.kn4(),
          p = new i.kn4(),
          f = e.inheritType ? e.inheritType : 0;
        e.translation && t.setPosition(I.fromArray(e.translation));
        const A = M(0);
        if (e.preRotation) {
          const t = e.preRotation.map(i.cj9.degToRad);
          t.push(A), n.makeRotationFromEuler(C.fromArray(t));
        }
        if (e.rotation) {
          const t = e.rotation.map(i.cj9.degToRad);
          t.push(e.eulerOrder || A), r.makeRotationFromEuler(C.fromArray(t));
        }
        if (e.postRotation) {
          const t = e.postRotation.map(i.cj9.degToRad);
          t.push(A), s.makeRotationFromEuler(C.fromArray(t)), s.invert();
        }
        e.scale && a.scale(I.fromArray(e.scale)),
          e.scalingOffset && l.setPosition(I.fromArray(e.scalingOffset)),
          e.scalingPivot && o.setPosition(I.fromArray(e.scalingPivot)),
          e.rotationOffset && c.setPosition(I.fromArray(e.rotationOffset)),
          e.rotationPivot && u.setPosition(I.fromArray(e.rotationPivot)),
          e.parentMatrixWorld &&
            (d.copy(e.parentMatrix), h.copy(e.parentMatrixWorld));
        const g = n.clone().multiply(r).multiply(s),
          m = new i.kn4();
        m.extractRotation(h);
        const v = new i.kn4();
        v.copyPosition(h);
        const y = v.clone().invert().multiply(h),
          x = m.clone().invert().multiply(y),
          _ = a,
          b = new i.kn4();
        if (0 === f) b.copy(m).multiply(g).multiply(x).multiply(_);
        else if (1 === f) b.copy(m).multiply(x).multiply(g).multiply(_);
        else {
          const e = new i.kn4()
              .scale(new i.Pq0().setFromMatrixScale(d))
              .clone()
              .invert(),
            t = x.clone().multiply(e);
          b.copy(m).multiply(g).multiply(t).multiply(_);
        }
        const E = u.clone().invert(),
          w = o.clone().invert();
        let S = t
          .clone()
          .multiply(c)
          .multiply(u)
          .multiply(n)
          .multiply(r)
          .multiply(s)
          .multiply(E)
          .multiply(l)
          .multiply(o)
          .multiply(a)
          .multiply(w);
        const T = new i.kn4().copyPosition(S),
          B = h.clone().multiply(T);
        return (
          p.copyPosition(B),
          (S = p.clone().multiply(b)),
          S.premultiply(h.invert()),
          S
        );
      }
      function M(e) {
        const t = ["ZYX", "YZX", "XZY", "ZXY", "YXZ", "XYZ"];
        return 6 === (e = e || 0)
          ? (console.warn(
              "THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."
            ),
            t[0])
          : t[e];
      }
      function T(e) {
        return e.split(",").map(function (e) {
          return parseFloat(e);
        });
      }
      function B(e, t, n) {
        return (
          void 0 === t && (t = 0),
          void 0 === n && (n = e.byteLength),
          new TextDecoder().decode(new Uint8Array(e, t, n))
        );
      }
    },
    9511: (e, t, n) => {
      "use strict";
      n.d(t, { B: () => s });
      var i = n(5062);
      function r(e, t) {
        if (t === i.RJ4)
          return (
            console.warn(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
            ),
            e
          );
        if (t === i.rYR || t === i.O49) {
          let n = e.getIndex();
          if (null === n) {
            const t = [],
              i = e.getAttribute("position");
            if (void 0 === i)
              return (
                console.error(
                  "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
                ),
                e
              );
            for (let e = 0; e < i.count; e++) t.push(e);
            e.setIndex(t), (n = e.getIndex());
          }
          const r = n.count - 2,
            s = [];
          if (t === i.rYR)
            for (let e = 1; e <= r; e++)
              s.push(n.getX(0)), s.push(n.getX(e)), s.push(n.getX(e + 1));
          else
            for (let e = 0; e < r; e++)
              e % 2 == 0
                ? (s.push(n.getX(e)),
                  s.push(n.getX(e + 1)),
                  s.push(n.getX(e + 2)))
                : (s.push(n.getX(e + 2)),
                  s.push(n.getX(e + 1)),
                  s.push(n.getX(e)));
          s.length / 3 !== r &&
            console.error(
              "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
            );
          const a = e.clone();
          return a.setIndex(s), a.clearGroups(), a;
        }
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
            t
          ),
          e
        );
      }
      class s extends i.aHM {
        constructor(e) {
          super(e),
            (this.dracoLoader = null),
            (this.ktx2Loader = null),
            (this.meshoptDecoder = null),
            (this.pluginCallbacks = []),
            this.register(function (e) {
              return new h(e);
            }),
            this.register(function (e) {
              return new d(e);
            }),
            this.register(function (e) {
              return new _(e);
            }),
            this.register(function (e) {
              return new b(e);
            }),
            this.register(function (e) {
              return new E(e);
            }),
            this.register(function (e) {
              return new f(e);
            }),
            this.register(function (e) {
              return new A(e);
            }),
            this.register(function (e) {
              return new g(e);
            }),
            this.register(function (e) {
              return new m(e);
            }),
            this.register(function (e) {
              return new u(e);
            }),
            this.register(function (e) {
              return new v(e);
            }),
            this.register(function (e) {
              return new p(e);
            }),
            this.register(function (e) {
              return new x(e);
            }),
            this.register(function (e) {
              return new y(e);
            }),
            this.register(function (e) {
              return new l(e);
            }),
            this.register(function (e) {
              return new w(e);
            }),
            this.register(function (e) {
              return new C(e);
            });
        }
        load(e, t, n, r) {
          const s = this;
          let a;
          if ("" !== this.resourcePath) a = this.resourcePath;
          else if ("" !== this.path) {
            const t = i.r6x.extractUrlBase(e);
            a = i.r6x.resolveURL(t, this.path);
          } else a = i.r6x.extractUrlBase(e);
          this.manager.itemStart(e);
          const o = function (t) {
              r ? r(t) : console.error(t),
                s.manager.itemError(e),
                s.manager.itemEnd(e);
            },
            l = new i.Y9S(this.manager);
          l.setPath(this.path),
            l.setResponseType("arraybuffer"),
            l.setRequestHeader(this.requestHeader),
            l.setWithCredentials(this.withCredentials),
            l.load(
              e,
              function (n) {
                try {
                  s.parse(
                    n,
                    a,
                    function (n) {
                      t(n), s.manager.itemEnd(e);
                    },
                    o
                  );
                } catch (e) {
                  o(e);
                }
              },
              n,
              o
            );
        }
        setDRACOLoader(e) {
          return (this.dracoLoader = e), this;
        }
        setKTX2Loader(e) {
          return (this.ktx2Loader = e), this;
        }
        setMeshoptDecoder(e) {
          return (this.meshoptDecoder = e), this;
        }
        register(e) {
          return (
            -1 === this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.push(e),
            this
          );
        }
        unregister(e) {
          return (
            -1 !== this.pluginCallbacks.indexOf(e) &&
              this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
            this
          );
        }
        parse(e, t, n, i) {
          let r;
          const s = {},
            a = {},
            l = new TextDecoder();
          if ("string" == typeof e) r = JSON.parse(e);
          else if (e instanceof ArrayBuffer) {
            if (l.decode(new Uint8Array(e, 0, 4)) === I) {
              try {
                s[o.KHR_BINARY_GLTF] = new T(e);
              } catch (e) {
                return void (i && i(e));
              }
              r = JSON.parse(s[o.KHR_BINARY_GLTF].content);
            } else r = JSON.parse(l.decode(e));
          } else r = e;
          if (void 0 === r.asset || r.asset.version[0] < 2)
            return void (
              i &&
              i(
                new Error(
                  "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
                )
              )
            );
          const u = new ee(r, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder,
          });
          u.fileLoader.setRequestHeader(this.requestHeader);
          for (let e = 0; e < this.pluginCallbacks.length; e++) {
            const t = this.pluginCallbacks[e](u);
            t.name ||
              console.error(
                "THREE.GLTFLoader: Invalid plugin found: missing name"
              ),
              (a[t.name] = t),
              (s[t.name] = !0);
          }
          if (r.extensionsUsed)
            for (let e = 0; e < r.extensionsUsed.length; ++e) {
              const t = r.extensionsUsed[e],
                n = r.extensionsRequired || [];
              switch (t) {
                case o.KHR_MATERIALS_UNLIT:
                  s[t] = new c();
                  break;
                case o.KHR_DRACO_MESH_COMPRESSION:
                  s[t] = new B(r, this.dracoLoader);
                  break;
                case o.KHR_TEXTURE_TRANSFORM:
                  s[t] = new R();
                  break;
                case o.KHR_MESH_QUANTIZATION:
                  s[t] = new D();
                  break;
                default:
                  n.indexOf(t) >= 0 &&
                    void 0 === a[t] &&
                    console.warn(
                      'THREE.GLTFLoader: Unknown extension "' + t + '".'
                    );
              }
            }
          u.setExtensions(s), u.setPlugins(a), u.parse(n, i);
        }
        parseAsync(e, t) {
          const n = this;
          return new Promise(function (i, r) {
            n.parse(e, t, i, r);
          });
        }
      }
      function a() {
        let e = {};
        return {
          get: function (t) {
            return e[t];
          },
          add: function (t, n) {
            e[t] = n;
          },
          remove: function (t) {
            delete e[t];
          },
          removeAll: function () {
            e = {};
          },
        };
      }
      const o = {
        KHR_BINARY_GLTF: "KHR_binary_glTF",
        KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
        KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
        KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
        KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
        KHR_MATERIALS_IOR: "KHR_materials_ior",
        KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
        KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
        KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
        KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
        KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
        KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
        KHR_MATERIALS_VOLUME: "KHR_materials_volume",
        KHR_TEXTURE_BASISU: "KHR_texture_basisu",
        KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
        KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
        KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
        EXT_MATERIALS_BUMP: "EXT_materials_bump",
        EXT_TEXTURE_WEBP: "EXT_texture_webp",
        EXT_TEXTURE_AVIF: "EXT_texture_avif",
        EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
        EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
      };
      class l {
        constructor(e) {
          (this.parser = e),
            (this.name = o.KHR_LIGHTS_PUNCTUAL),
            (this.cache = { refs: {}, uses: {} });
        }
        _markDefs() {
          const e = this.parser,
            t = this.parser.json.nodes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n];
            i.extensions &&
              i.extensions[this.name] &&
              void 0 !== i.extensions[this.name].light &&
              e._addNodeRef(this.cache, i.extensions[this.name].light);
          }
        }
        _loadLight(e) {
          const t = this.parser,
            n = "light:" + e;
          let r = t.cache.get(n);
          if (r) return r;
          const s = t.json,
            a = (((s.extensions && s.extensions[this.name]) || {}).lights ||
              [])[e];
          let o;
          const l = new i.Q1f(16777215);
          void 0 !== a.color &&
            l.setRGB(a.color[0], a.color[1], a.color[2], i.Zr2);
          const c = void 0 !== a.range ? a.range : 0;
          switch (a.type) {
            case "directional":
              (o = new i.ZyN(l)),
                o.target.position.set(0, 0, -1),
                o.add(o.target);
              break;
            case "point":
              (o = new i.HiM(l)), (o.distance = c);
              break;
            case "spot":
              (o = new i.nCl(l)),
                (o.distance = c),
                (a.spot = a.spot || {}),
                (a.spot.innerConeAngle =
                  void 0 !== a.spot.innerConeAngle ? a.spot.innerConeAngle : 0),
                (a.spot.outerConeAngle =
                  void 0 !== a.spot.outerConeAngle
                    ? a.spot.outerConeAngle
                    : Math.PI / 4),
                (o.angle = a.spot.outerConeAngle),
                (o.penumbra =
                  1 - a.spot.innerConeAngle / a.spot.outerConeAngle),
                o.target.position.set(0, 0, -1),
                o.add(o.target);
              break;
            default:
              throw new Error(
                "THREE.GLTFLoader: Unexpected light type: " + a.type
              );
          }
          return (
            o.position.set(0, 0, 0),
            (o.decay = 2),
            Y(o, a),
            void 0 !== a.intensity && (o.intensity = a.intensity),
            (o.name = t.createUniqueName(a.name || "light_" + e)),
            (r = Promise.resolve(o)),
            t.cache.add(n, r),
            r
          );
        }
        getDependency(e, t) {
          if ("light" === e) return this._loadLight(t);
        }
        createNodeAttachment(e) {
          const t = this,
            n = this.parser,
            i = n.json.nodes[e],
            r = ((i.extensions && i.extensions[this.name]) || {}).light;
          return void 0 === r
            ? null
            : this._loadLight(r).then(function (e) {
                return n._getNodeRef(t.cache, r, e);
              });
        }
      }
      class c {
        constructor() {
          this.name = o.KHR_MATERIALS_UNLIT;
        }
        getMaterialType() {
          return i.V9B;
        }
        extendParams(e, t, n) {
          const r = [];
          (e.color = new i.Q1f(1, 1, 1)), (e.opacity = 1);
          const s = t.pbrMetallicRoughness;
          if (s) {
            if (Array.isArray(s.baseColorFactor)) {
              const t = s.baseColorFactor;
              e.color.setRGB(t[0], t[1], t[2], i.Zr2), (e.opacity = t[3]);
            }
            void 0 !== s.baseColorTexture &&
              r.push(n.assignTexture(e, "map", s.baseColorTexture, i.er$));
          }
          return Promise.all(r);
        }
      }
      class u {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_EMISSIVE_STRENGTH);
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name].emissiveStrength;
          return void 0 !== i && (t.emissiveIntensity = i), Promise.resolve();
        }
      }
      class h {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_CLEARCOAT);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            r = n.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            a = r.extensions[this.name];
          if (
            (void 0 !== a.clearcoatFactor && (t.clearcoat = a.clearcoatFactor),
            void 0 !== a.clearcoatTexture &&
              s.push(n.assignTexture(t, "clearcoatMap", a.clearcoatTexture)),
            void 0 !== a.clearcoatRoughnessFactor &&
              (t.clearcoatRoughness = a.clearcoatRoughnessFactor),
            void 0 !== a.clearcoatRoughnessTexture &&
              s.push(
                n.assignTexture(
                  t,
                  "clearcoatRoughnessMap",
                  a.clearcoatRoughnessTexture
                )
              ),
            void 0 !== a.clearcoatNormalTexture &&
              (s.push(
                n.assignTexture(
                  t,
                  "clearcoatNormalMap",
                  a.clearcoatNormalTexture
                )
              ),
              void 0 !== a.clearcoatNormalTexture.scale))
          ) {
            const e = a.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new i.I9Y(e, e);
          }
          return Promise.all(s);
        }
      }
      class d {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_DISPERSION);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name];
          return (
            (t.dispersion = void 0 !== i.dispersion ? i.dispersion : 0),
            Promise.resolve()
          );
        }
      }
      class p {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_IRIDESCENCE);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.iridescenceFactor &&
              (t.iridescence = s.iridescenceFactor),
            void 0 !== s.iridescenceTexture &&
              r.push(
                n.assignTexture(t, "iridescenceMap", s.iridescenceTexture)
              ),
            void 0 !== s.iridescenceIor &&
              (t.iridescenceIOR = s.iridescenceIor),
            void 0 === t.iridescenceThicknessRange &&
              (t.iridescenceThicknessRange = [100, 400]),
            void 0 !== s.iridescenceThicknessMinimum &&
              (t.iridescenceThicknessRange[0] = s.iridescenceThicknessMinimum),
            void 0 !== s.iridescenceThicknessMaximum &&
              (t.iridescenceThicknessRange[1] = s.iridescenceThicknessMaximum),
            void 0 !== s.iridescenceThicknessTexture &&
              r.push(
                n.assignTexture(
                  t,
                  "iridescenceThicknessMap",
                  s.iridescenceThicknessTexture
                )
              ),
            Promise.all(r)
          );
        }
      }
      class f {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_SHEEN);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            r = n.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [];
          (t.sheenColor = new i.Q1f(0, 0, 0)),
            (t.sheenRoughness = 0),
            (t.sheen = 1);
          const a = r.extensions[this.name];
          if (void 0 !== a.sheenColorFactor) {
            const e = a.sheenColorFactor;
            t.sheenColor.setRGB(e[0], e[1], e[2], i.Zr2);
          }
          return (
            void 0 !== a.sheenRoughnessFactor &&
              (t.sheenRoughness = a.sheenRoughnessFactor),
            void 0 !== a.sheenColorTexture &&
              s.push(
                n.assignTexture(t, "sheenColorMap", a.sheenColorTexture, i.er$)
              ),
            void 0 !== a.sheenRoughnessTexture &&
              s.push(
                n.assignTexture(t, "sheenRoughnessMap", a.sheenRoughnessTexture)
              ),
            Promise.all(s)
          );
        }
      }
      class A {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_TRANSMISSION);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.transmissionFactor &&
              (t.transmission = s.transmissionFactor),
            void 0 !== s.transmissionTexture &&
              r.push(
                n.assignTexture(t, "transmissionMap", s.transmissionTexture)
              ),
            Promise.all(r)
          );
        }
      }
      class g {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_VOLUME);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            r = n.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            a = r.extensions[this.name];
          (t.thickness = void 0 !== a.thicknessFactor ? a.thicknessFactor : 0),
            void 0 !== a.thicknessTexture &&
              s.push(n.assignTexture(t, "thicknessMap", a.thicknessTexture)),
            (t.attenuationDistance = a.attenuationDistance || 1 / 0);
          const o = a.attenuationColor || [1, 1, 1];
          return (
            (t.attenuationColor = new i.Q1f().setRGB(o[0], o[1], o[2], i.Zr2)),
            Promise.all(s)
          );
        }
      }
      class m {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_IOR);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser.json.materials[e];
          if (!n.extensions || !n.extensions[this.name])
            return Promise.resolve();
          const i = n.extensions[this.name];
          return (t.ior = void 0 !== i.ior ? i.ior : 1.5), Promise.resolve();
        }
      }
      class v {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_SPECULAR);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            r = n.json.materials[e];
          if (!r.extensions || !r.extensions[this.name])
            return Promise.resolve();
          const s = [],
            a = r.extensions[this.name];
          (t.specularIntensity =
            void 0 !== a.specularFactor ? a.specularFactor : 1),
            void 0 !== a.specularTexture &&
              s.push(
                n.assignTexture(t, "specularIntensityMap", a.specularTexture)
              );
          const o = a.specularColorFactor || [1, 1, 1];
          return (
            (t.specularColor = new i.Q1f().setRGB(o[0], o[1], o[2], i.Zr2)),
            void 0 !== a.specularColorTexture &&
              s.push(
                n.assignTexture(
                  t,
                  "specularColorMap",
                  a.specularColorTexture,
                  i.er$
                )
              ),
            Promise.all(s)
          );
        }
      }
      class y {
        constructor(e) {
          (this.parser = e), (this.name = o.EXT_MATERIALS_BUMP);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            (t.bumpScale = void 0 !== s.bumpFactor ? s.bumpFactor : 1),
            void 0 !== s.bumpTexture &&
              r.push(n.assignTexture(t, "bumpMap", s.bumpTexture)),
            Promise.all(r)
          );
        }
      }
      class x {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_MATERIALS_ANISOTROPY);
        }
        getMaterialType(e) {
          const t = this.parser.json.materials[e];
          return t.extensions && t.extensions[this.name] ? i.uSd : null;
        }
        extendMaterialParams(e, t) {
          const n = this.parser,
            i = n.json.materials[e];
          if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
          const r = [],
            s = i.extensions[this.name];
          return (
            void 0 !== s.anisotropyStrength &&
              (t.anisotropy = s.anisotropyStrength),
            void 0 !== s.anisotropyRotation &&
              (t.anisotropyRotation = s.anisotropyRotation),
            void 0 !== s.anisotropyTexture &&
              r.push(n.assignTexture(t, "anisotropyMap", s.anisotropyTexture)),
            Promise.all(r)
          );
        }
      }
      class _ {
        constructor(e) {
          (this.parser = e), (this.name = o.KHR_TEXTURE_BASISU);
        }
        loadTexture(e) {
          const t = this.parser,
            n = t.json,
            i = n.textures[e];
          if (!i.extensions || !i.extensions[this.name]) return null;
          const r = i.extensions[this.name],
            s = t.options.ktx2Loader;
          if (!s) {
            if (
              n.extensionsRequired &&
              n.extensionsRequired.indexOf(this.name) >= 0
            )
              throw new Error(
                "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
              );
            return null;
          }
          return t.loadTextureImage(e, r.source, s);
        }
      }
      class b {
        constructor(e) {
          (this.parser = e),
            (this.name = o.EXT_TEXTURE_WEBP),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const s = r.extensions[t],
            a = i.images[s.source];
          let o = n.textureLoader;
          if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (o = e);
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(e, s.source, o);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: WebP required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class E {
        constructor(e) {
          (this.parser = e),
            (this.name = o.EXT_TEXTURE_AVIF),
            (this.isSupported = null);
        }
        loadTexture(e) {
          const t = this.name,
            n = this.parser,
            i = n.json,
            r = i.textures[e];
          if (!r.extensions || !r.extensions[t]) return null;
          const s = r.extensions[t],
            a = i.images[s.source];
          let o = n.textureLoader;
          if (a.uri) {
            const e = n.options.manager.getHandler(a.uri);
            null !== e && (o = e);
          }
          return this.detectSupport().then(function (r) {
            if (r) return n.loadTextureImage(e, s.source, o);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
              throw new Error(
                "THREE.GLTFLoader: AVIF required by asset but unsupported."
              );
            return n.loadTexture(e);
          });
        }
        detectSupport() {
          return (
            this.isSupported ||
              (this.isSupported = new Promise(function (e) {
                const t = new Image();
                (t.src =
                  "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
                  (t.onload = t.onerror =
                    function () {
                      e(1 === t.height);
                    });
              })),
            this.isSupported
          );
        }
      }
      class w {
        constructor(e) {
          (this.name = o.EXT_MESHOPT_COMPRESSION), (this.parser = e);
        }
        loadBufferView(e) {
          const t = this.parser.json,
            n = t.bufferViews[e];
          if (n.extensions && n.extensions[this.name]) {
            const e = n.extensions[this.name],
              i = this.parser.getDependency("buffer", e.buffer),
              r = this.parser.options.meshoptDecoder;
            if (!r || !r.supported) {
              if (
                t.extensionsRequired &&
                t.extensionsRequired.indexOf(this.name) >= 0
              )
                throw new Error(
                  "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
                );
              return null;
            }
            return i.then(function (t) {
              const n = e.byteOffset || 0,
                i = e.byteLength || 0,
                s = e.count,
                a = e.byteStride,
                o = new Uint8Array(t, n, i);
              return r.decodeGltfBufferAsync
                ? r
                    .decodeGltfBufferAsync(s, a, o, e.mode, e.filter)
                    .then(function (e) {
                      return e.buffer;
                    })
                : r.ready.then(function () {
                    const t = new ArrayBuffer(s * a);
                    return (
                      r.decodeGltfBuffer(
                        new Uint8Array(t),
                        s,
                        a,
                        o,
                        e.mode,
                        e.filter
                      ),
                      t
                    );
                  });
            });
          }
          return null;
        }
      }
      class C {
        constructor(e) {
          (this.name = o.EXT_MESH_GPU_INSTANCING), (this.parser = e);
        }
        createNodeMesh(e) {
          const t = this.parser.json,
            n = t.nodes[e];
          if (!n.extensions || !n.extensions[this.name] || void 0 === n.mesh)
            return null;
          const r = t.meshes[n.mesh];
          for (const e of r.primitives)
            if (
              e.mode !== F.TRIANGLES &&
              e.mode !== F.TRIANGLE_STRIP &&
              e.mode !== F.TRIANGLE_FAN &&
              void 0 !== e.mode
            )
              return null;
          const s = n.extensions[this.name].attributes,
            a = [],
            o = {};
          for (const e in s)
            a.push(
              this.parser
                .getDependency("accessor", s[e])
                .then((t) => ((o[e] = t), o[e]))
            );
          return a.length < 1
            ? null
            : (a.push(this.parser.createNodeMesh(e)),
              Promise.all(a).then((e) => {
                const t = e.pop(),
                  n = t.isGroup ? t.children : [t],
                  r = e[0].count,
                  s = [];
                for (const e of n) {
                  const t = new i.kn4(),
                    n = new i.Pq0(),
                    a = new i.PTz(),
                    l = new i.Pq0(1, 1, 1),
                    c = new i.ZLX(e.geometry, e.material, r);
                  for (let e = 0; e < r; e++)
                    o.TRANSLATION && n.fromBufferAttribute(o.TRANSLATION, e),
                      o.ROTATION && a.fromBufferAttribute(o.ROTATION, e),
                      o.SCALE && l.fromBufferAttribute(o.SCALE, e),
                      c.setMatrixAt(e, t.compose(n, a, l));
                  for (const t in o)
                    if ("_COLOR_0" === t) {
                      const e = o[t];
                      c.instanceColor = new i.uWO(
                        e.array,
                        e.itemSize,
                        e.normalized
                      );
                    } else
                      "TRANSLATION" !== t &&
                        "ROTATION" !== t &&
                        "SCALE" !== t &&
                        e.geometry.setAttribute(t, o[t]);
                  i.B69.prototype.copy.call(c, e),
                    this.parser.assignFinalMaterial(c),
                    s.push(c);
                }
                return t.isGroup ? (t.clear(), t.add(...s), t) : s[0];
              }));
        }
      }
      const I = "glTF",
        S = 1313821514,
        M = 5130562;
      class T {
        constructor(e) {
          (this.name = o.KHR_BINARY_GLTF),
            (this.content = null),
            (this.body = null);
          const t = new DataView(e, 0, 12),
            n = new TextDecoder();
          if (
            ((this.header = {
              magic: n.decode(new Uint8Array(e.slice(0, 4))),
              version: t.getUint32(4, !0),
              length: t.getUint32(8, !0),
            }),
            this.header.magic !== I)
          )
            throw new Error(
              "THREE.GLTFLoader: Unsupported glTF-Binary header."
            );
          if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
          const i = this.header.length - 12,
            r = new DataView(e, 12);
          let s = 0;
          for (; s < i; ) {
            const t = r.getUint32(s, !0);
            s += 4;
            const i = r.getUint32(s, !0);
            if (((s += 4), i === S)) {
              const i = new Uint8Array(e, 12 + s, t);
              this.content = n.decode(i);
            } else if (i === M) {
              const n = 12 + s;
              this.body = e.slice(n, n + t);
            }
            s += t;
          }
          if (null === this.content)
            throw new Error("THREE.GLTFLoader: JSON content not found.");
        }
      }
      class B {
        constructor(e, t) {
          if (!t)
            throw new Error(
              "THREE.GLTFLoader: No DRACOLoader instance provided."
            );
          (this.name = o.KHR_DRACO_MESH_COMPRESSION),
            (this.json = e),
            (this.dracoLoader = t),
            this.dracoLoader.preload();
        }
        decodePrimitive(e, t) {
          const n = this.json,
            r = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            a = e.extensions[this.name].attributes,
            o = {},
            l = {},
            c = {};
          for (const e in a) {
            const t = G[e] || e.toLowerCase();
            o[t] = a[e];
          }
          for (const t in e.attributes) {
            const i = G[t] || t.toLowerCase();
            if (void 0 !== a[t]) {
              const r = n.accessors[e.attributes[t]],
                s = N[r.componentType];
              (c[i] = s.name), (l[i] = !0 === r.normalized);
            }
          }
          return t.getDependency("bufferView", s).then(function (e) {
            return new Promise(function (t, n) {
              r.decodeDracoFile(
                e,
                function (e) {
                  for (const t in e.attributes) {
                    const n = e.attributes[t],
                      i = l[t];
                    void 0 !== i && (n.normalized = i);
                  }
                  t(e);
                },
                o,
                c,
                i.Zr2,
                n
              );
            });
          });
        }
      }
      class R {
        constructor() {
          this.name = o.KHR_TEXTURE_TRANSFORM;
        }
        extendTexture(e, t) {
          return (void 0 !== t.texCoord && t.texCoord !== e.channel) ||
            void 0 !== t.offset ||
            void 0 !== t.rotation ||
            void 0 !== t.scale
            ? ((e = e.clone()),
              void 0 !== t.texCoord && (e.channel = t.texCoord),
              void 0 !== t.offset && e.offset.fromArray(t.offset),
              void 0 !== t.rotation && (e.rotation = t.rotation),
              void 0 !== t.scale && e.repeat.fromArray(t.scale),
              (e.needsUpdate = !0),
              e)
            : e;
        }
      }
      class D {
        constructor() {
          this.name = o.KHR_MESH_QUANTIZATION;
        }
      }
      class P extends i.lGw {
        constructor(e, t, n, i) {
          super(e, t, n, i);
        }
        copySampleValue_(e) {
          const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            r = e * i * 3 + i;
          for (let e = 0; e !== i; e++) t[e] = n[r + e];
          return t;
        }
        interpolate_(e, t, n, i) {
          const r = this.resultBuffer,
            s = this.sampleValues,
            a = this.valueSize,
            o = 2 * a,
            l = 3 * a,
            c = i - t,
            u = (n - t) / c,
            h = u * u,
            d = h * u,
            p = e * l,
            f = p - l,
            A = -2 * d + 3 * h,
            g = d - h,
            m = 1 - A,
            v = g - h + u;
          for (let e = 0; e !== a; e++) {
            const t = s[f + e + a],
              n = s[f + e + o] * c,
              i = s[p + e + a],
              l = s[p + e] * c;
            r[e] = m * t + v * n + A * i + g * l;
          }
          return r;
        }
      }
      const L = new i.PTz();
      class U extends P {
        interpolate_(e, t, n, i) {
          const r = super.interpolate_(e, t, n, i);
          return L.fromArray(r).normalize().toArray(r), r;
        }
      }
      const F = {
          FLOAT: 5126,
          FLOAT_MAT3: 35675,
          FLOAT_MAT4: 35676,
          FLOAT_VEC2: 35664,
          FLOAT_VEC3: 35665,
          FLOAT_VEC4: 35666,
          LINEAR: 9729,
          REPEAT: 10497,
          SAMPLER_2D: 35678,
          POINTS: 0,
          LINES: 1,
          LINE_LOOP: 2,
          LINE_STRIP: 3,
          TRIANGLES: 4,
          TRIANGLE_STRIP: 5,
          TRIANGLE_FAN: 6,
          UNSIGNED_BYTE: 5121,
          UNSIGNED_SHORT: 5123,
        },
        N = {
          5120: Int8Array,
          5121: Uint8Array,
          5122: Int16Array,
          5123: Uint16Array,
          5125: Uint32Array,
          5126: Float32Array,
        },
        O = {
          9728: i.hxR,
          9729: i.k6q,
          9984: i.pHI,
          9985: i.kRr,
          9986: i.Cfg,
          9987: i.$_I,
        },
        Q = { 33071: i.ghU, 33648: i.kTW, 10497: i.GJx },
        k = {
          SCALAR: 1,
          VEC2: 2,
          VEC3: 3,
          VEC4: 4,
          MAT2: 4,
          MAT3: 9,
          MAT4: 16,
        },
        G = {
          POSITION: "position",
          NORMAL: "normal",
          TANGENT: "tangent",
          TEXCOORD_0: "uv",
          TEXCOORD_1: "uv1",
          TEXCOORD_2: "uv2",
          TEXCOORD_3: "uv3",
          COLOR_0: "color",
          WEIGHTS_0: "skinWeight",
          JOINTS_0: "skinIndex",
        },
        H = {
          scale: "scale",
          translation: "position",
          rotation: "quaternion",
          weights: "morphTargetInfluences",
        },
        z = { CUBICSPLINE: void 0, LINEAR: i.PJ3, STEP: i.ljd },
        V = "OPAQUE",
        W = "MASK",
        j = "BLEND";
      function q(e, t, n) {
        for (const i in n.extensions)
          void 0 === e[i] &&
            ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
            (t.userData.gltfExtensions[i] = n.extensions[i]));
      }
      function Y(e, t) {
        void 0 !== t.extras &&
          ("object" == typeof t.extras
            ? Object.assign(e.userData, t.extras)
            : console.warn(
                "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
              ));
      }
      function X(e, t) {
        if ((e.updateMorphTargets(), void 0 !== t.weights))
          for (let n = 0, i = t.weights.length; n < i; n++)
            e.morphTargetInfluences[n] = t.weights[n];
        if (t.extras && Array.isArray(t.extras.targetNames)) {
          const n = t.extras.targetNames;
          if (e.morphTargetInfluences.length === n.length) {
            e.morphTargetDictionary = {};
            for (let t = 0, i = n.length; t < i; t++)
              e.morphTargetDictionary[n[t]] = t;
          } else
            console.warn(
              "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
            );
        }
      }
      function K(e) {
        let t;
        const n = e.extensions && e.extensions[o.KHR_DRACO_MESH_COMPRESSION];
        if (
          ((t = n
            ? "draco:" + n.bufferView + ":" + n.indices + ":" + J(n.attributes)
            : e.indices + ":" + J(e.attributes) + ":" + e.mode),
          void 0 !== e.targets)
        )
          for (let n = 0, i = e.targets.length; n < i; n++)
            t += ":" + J(e.targets[n]);
        return t;
      }
      function J(e) {
        let t = "";
        const n = Object.keys(e).sort();
        for (let i = 0, r = n.length; i < r; i++)
          t += n[i] + ":" + e[n[i]] + ";";
        return t;
      }
      function Z(e) {
        switch (e) {
          case Int8Array:
            return 1 / 127;
          case Uint8Array:
            return 1 / 255;
          case Int16Array:
            return 1 / 32767;
          case Uint16Array:
            return 1 / 65535;
          default:
            throw new Error(
              "THREE.GLTFLoader: Unsupported normalized accessor component type."
            );
        }
      }
      const $ = new i.kn4();
      class ee {
        constructor(e = {}, t = {}) {
          (this.json = e),
            (this.extensions = {}),
            (this.plugins = {}),
            (this.options = t),
            (this.cache = new a()),
            (this.associations = new Map()),
            (this.primitiveCache = {}),
            (this.nodeCache = {}),
            (this.meshCache = { refs: {}, uses: {} }),
            (this.cameraCache = { refs: {}, uses: {} }),
            (this.lightCache = { refs: {}, uses: {} }),
            (this.sourceCache = {}),
            (this.textureCache = {}),
            (this.nodeNamesUsed = {});
          let n = !1,
            r = -1,
            s = !1,
            o = -1;
          if ("undefined" != typeof navigator) {
            const e = navigator.userAgent;
            n = !0 === /^((?!chrome|android).)*safari/i.test(e);
            const t = e.match(/Version\/(\d+)/);
            (r = n && t ? parseInt(t[1], 10) : -1),
              (s = e.indexOf("Firefox") > -1),
              (o = s ? e.match(/Firefox\/([0-9]+)\./)[1] : -1);
          }
          "undefined" == typeof createImageBitmap ||
          (n && r < 17) ||
          (s && o < 98)
            ? (this.textureLoader = new i.Tap(this.options.manager))
            : (this.textureLoader = new i.Kzg(this.options.manager)),
            this.textureLoader.setCrossOrigin(this.options.crossOrigin),
            this.textureLoader.setRequestHeader(this.options.requestHeader),
            (this.fileLoader = new i.Y9S(this.options.manager)),
            this.fileLoader.setResponseType("arraybuffer"),
            "use-credentials" === this.options.crossOrigin &&
              this.fileLoader.setWithCredentials(!0);
        }
        setExtensions(e) {
          this.extensions = e;
        }
        setPlugins(e) {
          this.plugins = e;
        }
        parse(e, t) {
          const n = this,
            i = this.json,
            r = this.extensions;
          this.cache.removeAll(),
            (this.nodeCache = {}),
            this._invokeAll(function (e) {
              return e._markDefs && e._markDefs();
            }),
            Promise.all(
              this._invokeAll(function (e) {
                return e.beforeRoot && e.beforeRoot();
              })
            )
              .then(function () {
                return Promise.all([
                  n.getDependencies("scene"),
                  n.getDependencies("animation"),
                  n.getDependencies("camera"),
                ]);
              })
              .then(function (t) {
                const s = {
                  scene: t[0][i.scene || 0],
                  scenes: t[0],
                  animations: t[1],
                  cameras: t[2],
                  asset: i.asset,
                  parser: n,
                  userData: {},
                };
                return (
                  q(r, s, i),
                  Y(s, i),
                  Promise.all(
                    n._invokeAll(function (e) {
                      return e.afterRoot && e.afterRoot(s);
                    })
                  ).then(function () {
                    for (const e of s.scenes) e.updateMatrixWorld();
                    e(s);
                  })
                );
              })
              .catch(t);
        }
        _markDefs() {
          const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
          for (let n = 0, i = t.length; n < i; n++) {
            const i = t[n].joints;
            for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
          }
          for (let t = 0, i = e.length; t < i; t++) {
            const i = e[t];
            void 0 !== i.mesh &&
              (this._addNodeRef(this.meshCache, i.mesh),
              void 0 !== i.skin && (n[i.mesh].isSkinnedMesh = !0)),
              void 0 !== i.camera &&
                this._addNodeRef(this.cameraCache, i.camera);
          }
        }
        _addNodeRef(e, t) {
          void 0 !== t &&
            (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
        }
        _getNodeRef(e, t, n) {
          if (e.refs[t] <= 1) return n;
          const i = n.clone(),
            r = (e, t) => {
              const n = this.associations.get(e);
              null != n && this.associations.set(t, n);
              for (const [n, i] of e.children.entries()) r(i, t.children[n]);
            };
          return r(n, i), (i.name += "_instance_" + e.uses[t]++), i;
        }
        _invokeOne(e) {
          const t = Object.values(this.plugins);
          t.push(this);
          for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i;
          }
          return null;
        }
        _invokeAll(e) {
          const t = Object.values(this.plugins);
          t.unshift(this);
          const n = [];
          for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r);
          }
          return n;
        }
        getDependency(e, t) {
          const n = e + ":" + t;
          let i = this.cache.get(n);
          if (!i) {
            switch (e) {
              case "scene":
                i = this.loadScene(t);
                break;
              case "node":
                i = this._invokeOne(function (e) {
                  return e.loadNode && e.loadNode(t);
                });
                break;
              case "mesh":
                i = this._invokeOne(function (e) {
                  return e.loadMesh && e.loadMesh(t);
                });
                break;
              case "accessor":
                i = this.loadAccessor(t);
                break;
              case "bufferView":
                i = this._invokeOne(function (e) {
                  return e.loadBufferView && e.loadBufferView(t);
                });
                break;
              case "buffer":
                i = this.loadBuffer(t);
                break;
              case "material":
                i = this._invokeOne(function (e) {
                  return e.loadMaterial && e.loadMaterial(t);
                });
                break;
              case "texture":
                i = this._invokeOne(function (e) {
                  return e.loadTexture && e.loadTexture(t);
                });
                break;
              case "skin":
                i = this.loadSkin(t);
                break;
              case "animation":
                i = this._invokeOne(function (e) {
                  return e.loadAnimation && e.loadAnimation(t);
                });
                break;
              case "camera":
                i = this.loadCamera(t);
                break;
              default:
                if (
                  ((i = this._invokeOne(function (n) {
                    return (
                      n != this && n.getDependency && n.getDependency(e, t)
                    );
                  })),
                  !i)
                )
                  throw new Error("Unknown type: " + e);
            }
            this.cache.add(n, i);
          }
          return i;
        }
        getDependencies(e) {
          let t = this.cache.get(e);
          if (!t) {
            const n = this,
              i = this.json[e + ("mesh" === e ? "es" : "s")] || [];
            (t = Promise.all(
              i.map(function (t, i) {
                return n.getDependency(e, i);
              })
            )),
              this.cache.add(e, t);
          }
          return t;
        }
        loadBuffer(e) {
          const t = this.json.buffers[e],
            n = this.fileLoader;
          if (t.type && "arraybuffer" !== t.type)
            throw new Error(
              "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
            );
          if (void 0 === t.uri && 0 === e)
            return Promise.resolve(this.extensions[o.KHR_BINARY_GLTF].body);
          const r = this.options;
          return new Promise(function (e, s) {
            n.load(i.r6x.resolveURL(t.uri, r.path), e, void 0, function () {
              s(
                new Error(
                  'THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'
                )
              );
            });
          });
        }
        loadBufferView(e) {
          const t = this.json.bufferViews[e];
          return this.getDependency("buffer", t.buffer).then(function (e) {
            const n = t.byteLength || 0,
              i = t.byteOffset || 0;
            return e.slice(i, i + n);
          });
        }
        loadAccessor(e) {
          const t = this,
            n = this.json,
            r = this.json.accessors[e];
          if (void 0 === r.bufferView && void 0 === r.sparse) {
            const e = k[r.type],
              t = N[r.componentType],
              n = !0 === r.normalized,
              s = new t(r.count * e);
            return Promise.resolve(new i.THS(s, e, n));
          }
          const s = [];
          return (
            void 0 !== r.bufferView
              ? s.push(this.getDependency("bufferView", r.bufferView))
              : s.push(null),
            void 0 !== r.sparse &&
              (s.push(
                this.getDependency("bufferView", r.sparse.indices.bufferView)
              ),
              s.push(
                this.getDependency("bufferView", r.sparse.values.bufferView)
              )),
            Promise.all(s).then(function (e) {
              const s = e[0],
                a = k[r.type],
                o = N[r.componentType],
                l = o.BYTES_PER_ELEMENT,
                c = l * a,
                u = r.byteOffset || 0,
                h =
                  void 0 !== r.bufferView
                    ? n.bufferViews[r.bufferView].byteStride
                    : void 0,
                d = !0 === r.normalized;
              let p, f;
              if (h && h !== c) {
                const e = Math.floor(u / h),
                  n =
                    "InterleavedBuffer:" +
                    r.bufferView +
                    ":" +
                    r.componentType +
                    ":" +
                    e +
                    ":" +
                    r.count;
                let c = t.cache.get(n);
                c ||
                  ((p = new o(s, e * h, (r.count * h) / l)),
                  (c = new i.eB$(p, h / l)),
                  t.cache.add(n, c)),
                  (f = new i.eHs(c, a, (u % h) / l, d));
              } else (p = null === s ? new o(r.count * a) : new o(s, u, r.count * a)), (f = new i.THS(p, a, d));
              if (void 0 !== r.sparse) {
                const t = k.SCALAR,
                  n = N[r.sparse.indices.componentType],
                  l = r.sparse.indices.byteOffset || 0,
                  c = r.sparse.values.byteOffset || 0,
                  u = new n(e[1], l, r.sparse.count * t),
                  h = new o(e[2], c, r.sparse.count * a);
                null !== s &&
                  (f = new i.THS(f.array.slice(), f.itemSize, f.normalized)),
                  (f.normalized = !1);
                for (let e = 0, t = u.length; e < t; e++) {
                  const t = u[e];
                  if (
                    (f.setX(t, h[e * a]),
                    a >= 2 && f.setY(t, h[e * a + 1]),
                    a >= 3 && f.setZ(t, h[e * a + 2]),
                    a >= 4 && f.setW(t, h[e * a + 3]),
                    a >= 5)
                  )
                    throw new Error(
                      "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
                    );
                }
                f.normalized = d;
              }
              return f;
            })
          );
        }
        loadTexture(e) {
          const t = this.json,
            n = this.options,
            i = t.textures[e].source,
            r = t.images[i];
          let s = this.textureLoader;
          if (r.uri) {
            const e = n.manager.getHandler(r.uri);
            null !== e && (s = e);
          }
          return this.loadTextureImage(e, i, s);
        }
        loadTextureImage(e, t, n) {
          const r = this,
            s = this.json,
            a = s.textures[e],
            o = s.images[t],
            l = (o.uri || o.bufferView) + ":" + a.sampler;
          if (this.textureCache[l]) return this.textureCache[l];
          const c = this.loadImageSource(t, n)
            .then(function (t) {
              (t.flipY = !1),
                (t.name = a.name || o.name || ""),
                "" === t.name &&
                  "string" == typeof o.uri &&
                  !1 === o.uri.startsWith("data:image/") &&
                  (t.name = o.uri);
              const n = (s.samplers || {})[a.sampler] || {};
              return (
                (t.magFilter = O[n.magFilter] || i.k6q),
                (t.minFilter = O[n.minFilter] || i.$_I),
                (t.wrapS = Q[n.wrapS] || i.GJx),
                (t.wrapT = Q[n.wrapT] || i.GJx),
                (t.generateMipmaps =
                  !t.isCompressedTexture &&
                  t.minFilter !== i.hxR &&
                  t.minFilter !== i.k6q),
                r.associations.set(t, { textures: e }),
                t
              );
            })
            .catch(function () {
              return null;
            });
          return (this.textureCache[l] = c), c;
        }
        loadImageSource(e, t) {
          const n = this,
            r = this.json,
            s = this.options;
          if (void 0 !== this.sourceCache[e])
            return this.sourceCache[e].then((e) => e.clone());
          const a = r.images[e],
            o = self.URL || self.webkitURL;
          let l = a.uri || "",
            c = !1;
          if (void 0 !== a.bufferView)
            l = n.getDependency("bufferView", a.bufferView).then(function (e) {
              c = !0;
              const t = new Blob([e], { type: a.mimeType });
              return (l = o.createObjectURL(t)), l;
            });
          else if (void 0 === a.uri)
            throw new Error(
              "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
            );
          const u = Promise.resolve(l)
            .then(function (e) {
              return new Promise(function (n, r) {
                let a = n;
                !0 === t.isImageBitmapLoader &&
                  (a = function (e) {
                    const t = new i.gPd(e);
                    (t.needsUpdate = !0), n(t);
                  }),
                  t.load(i.r6x.resolveURL(e, s.path), a, void 0, r);
              });
            })
            .then(function (e) {
              var t;
              return (
                !0 === c && o.revokeObjectURL(l),
                Y(e, a),
                (e.userData.mimeType =
                  a.mimeType ||
                  ((t = a.uri).search(/\.jpe?g($|\?)/i) > 0 ||
                  0 === t.search(/^data\:image\/jpeg/)
                    ? "image/jpeg"
                    : t.search(/\.webp($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/webp/)
                    ? "image/webp"
                    : t.search(/\.ktx2($|\?)/i) > 0 ||
                      0 === t.search(/^data\:image\/ktx2/)
                    ? "image/ktx2"
                    : "image/png")),
                e
              );
            })
            .catch(function (e) {
              throw (
                (console.error("THREE.GLTFLoader: Couldn't load texture", l), e)
              );
            });
          return (this.sourceCache[e] = u), u;
        }
        assignTexture(e, t, n, i) {
          const r = this;
          return this.getDependency("texture", n.index).then(function (s) {
            if (!s) return null;
            if (
              (void 0 !== n.texCoord &&
                n.texCoord > 0 &&
                ((s = s.clone()).channel = n.texCoord),
              r.extensions[o.KHR_TEXTURE_TRANSFORM])
            ) {
              const e =
                void 0 !== n.extensions
                  ? n.extensions[o.KHR_TEXTURE_TRANSFORM]
                  : void 0;
              if (e) {
                const t = r.associations.get(s);
                (s = r.extensions[o.KHR_TEXTURE_TRANSFORM].extendTexture(s, e)),
                  r.associations.set(s, t);
              }
            }
            return void 0 !== i && (s.colorSpace = i), (e[t] = s), s;
          });
        }
        assignFinalMaterial(e) {
          const t = e.geometry;
          let n = e.material;
          const r = void 0 === t.attributes.tangent,
            s = void 0 !== t.attributes.color,
            a = void 0 === t.attributes.normal;
          if (e.isPoints) {
            const e = "PointsMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t ||
              ((t = new i.BH$()),
              i.imn.prototype.copy.call(t, n),
              t.color.copy(n.color),
              (t.map = n.map),
              (t.sizeAttenuation = !1),
              this.cache.add(e, t)),
              (n = t);
          } else if (e.isLine) {
            const e = "LineBasicMaterial:" + n.uuid;
            let t = this.cache.get(e);
            t ||
              ((t = new i.mrM()),
              i.imn.prototype.copy.call(t, n),
              t.color.copy(n.color),
              (t.map = n.map),
              this.cache.add(e, t)),
              (n = t);
          }
          if (r || s || a) {
            let e = "ClonedMaterial:" + n.uuid + ":";
            r && (e += "derivative-tangents:"),
              s && (e += "vertex-colors:"),
              a && (e += "flat-shading:");
            let t = this.cache.get(e);
            t ||
              ((t = n.clone()),
              s && (t.vertexColors = !0),
              a && (t.flatShading = !0),
              r &&
                (t.normalScale && (t.normalScale.y *= -1),
                t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
              this.cache.add(e, t),
              this.associations.set(t, this.associations.get(n))),
              (n = t);
          }
          e.material = n;
        }
        getMaterialType() {
          return i._4j;
        }
        loadMaterial(e) {
          const t = this,
            n = this.json,
            r = this.extensions,
            s = n.materials[e];
          let a;
          const l = {},
            c = [];
          if ((s.extensions || {})[o.KHR_MATERIALS_UNLIT]) {
            const e = r[o.KHR_MATERIALS_UNLIT];
            (a = e.getMaterialType()), c.push(e.extendParams(l, s, t));
          } else {
            const n = s.pbrMetallicRoughness || {};
            if (
              ((l.color = new i.Q1f(1, 1, 1)),
              (l.opacity = 1),
              Array.isArray(n.baseColorFactor))
            ) {
              const e = n.baseColorFactor;
              l.color.setRGB(e[0], e[1], e[2], i.Zr2), (l.opacity = e[3]);
            }
            void 0 !== n.baseColorTexture &&
              c.push(t.assignTexture(l, "map", n.baseColorTexture, i.er$)),
              (l.metalness =
                void 0 !== n.metallicFactor ? n.metallicFactor : 1),
              (l.roughness =
                void 0 !== n.roughnessFactor ? n.roughnessFactor : 1),
              void 0 !== n.metallicRoughnessTexture &&
                (c.push(
                  t.assignTexture(l, "metalnessMap", n.metallicRoughnessTexture)
                ),
                c.push(
                  t.assignTexture(l, "roughnessMap", n.metallicRoughnessTexture)
                )),
              (a = this._invokeOne(function (t) {
                return t.getMaterialType && t.getMaterialType(e);
              })),
              c.push(
                Promise.all(
                  this._invokeAll(function (t) {
                    return (
                      t.extendMaterialParams && t.extendMaterialParams(e, l)
                    );
                  })
                )
              );
          }
          !0 === s.doubleSided && (l.side = i.$EB);
          const u = s.alphaMode || V;
          if (
            (u === j
              ? ((l.transparent = !0), (l.depthWrite = !1))
              : ((l.transparent = !1),
                u === W &&
                  (l.alphaTest =
                    void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
            void 0 !== s.normalTexture &&
              a !== i.V9B &&
              (c.push(t.assignTexture(l, "normalMap", s.normalTexture)),
              (l.normalScale = new i.I9Y(1, 1)),
              void 0 !== s.normalTexture.scale))
          ) {
            const e = s.normalTexture.scale;
            l.normalScale.set(e, e);
          }
          if (
            (void 0 !== s.occlusionTexture &&
              a !== i.V9B &&
              (c.push(t.assignTexture(l, "aoMap", s.occlusionTexture)),
              void 0 !== s.occlusionTexture.strength &&
                (l.aoMapIntensity = s.occlusionTexture.strength)),
            void 0 !== s.emissiveFactor && a !== i.V9B)
          ) {
            const e = s.emissiveFactor;
            l.emissive = new i.Q1f().setRGB(e[0], e[1], e[2], i.Zr2);
          }
          return (
            void 0 !== s.emissiveTexture &&
              a !== i.V9B &&
              c.push(
                t.assignTexture(l, "emissiveMap", s.emissiveTexture, i.er$)
              ),
            Promise.all(c).then(function () {
              const n = new a(l);
              return (
                s.name && (n.name = s.name),
                Y(n, s),
                t.associations.set(n, { materials: e }),
                s.extensions && q(r, n, s),
                n
              );
            })
          );
        }
        createUniqueName(e) {
          const t = i.Nwf.sanitizeNodeName(e || "");
          return t in this.nodeNamesUsed
            ? t + "_" + ++this.nodeNamesUsed[t]
            : ((this.nodeNamesUsed[t] = 0), t);
        }
        loadGeometries(e) {
          const t = this,
            n = this.extensions,
            r = this.primitiveCache;
          function s(e) {
            return n[o.KHR_DRACO_MESH_COMPRESSION]
              .decodePrimitive(e, t)
              .then(function (n) {
                return te(n, e, t);
              });
          }
          const a = [];
          for (let n = 0, l = e.length; n < l; n++) {
            const l = e[n],
              c = K(l),
              u = r[c];
            if (u) a.push(u.promise);
            else {
              let e;
              (e =
                l.extensions && l.extensions[o.KHR_DRACO_MESH_COMPRESSION]
                  ? s(l)
                  : te(new i.LoY(), l, t)),
                (r[c] = { primitive: l, promise: e }),
                a.push(e);
            }
          }
          return Promise.all(a);
        }
        loadMesh(e) {
          const t = this,
            n = this.json,
            s = this.extensions,
            a = n.meshes[e],
            o = a.primitives,
            l = [];
          for (let e = 0, t = o.length; e < t; e++) {
            const t =
              void 0 === o[e].material
                ? (void 0 === (c = this.cache).DefaultMaterial &&
                    (c.DefaultMaterial = new i._4j({
                      color: 16777215,
                      emissive: 0,
                      metalness: 1,
                      roughness: 1,
                      transparent: !1,
                      depthTest: !0,
                      side: i.hB5,
                    })),
                  c.DefaultMaterial)
                : this.getDependency("material", o[e].material);
            l.push(t);
          }
          var c;
          return (
            l.push(t.loadGeometries(o)),
            Promise.all(l).then(function (n) {
              const l = n.slice(0, n.length - 1),
                c = n[n.length - 1],
                u = [];
              for (let n = 0, h = c.length; n < h; n++) {
                const h = c[n],
                  d = o[n];
                let p;
                const f = l[n];
                if (
                  d.mode === F.TRIANGLES ||
                  d.mode === F.TRIANGLE_STRIP ||
                  d.mode === F.TRIANGLE_FAN ||
                  void 0 === d.mode
                )
                  (p =
                    !0 === a.isSkinnedMesh ? new i.I46(h, f) : new i.eaF(h, f)),
                    !0 === p.isSkinnedMesh && p.normalizeSkinWeights(),
                    d.mode === F.TRIANGLE_STRIP
                      ? (p.geometry = r(p.geometry, i.O49))
                      : d.mode === F.TRIANGLE_FAN &&
                        (p.geometry = r(p.geometry, i.rYR));
                else if (d.mode === F.LINES) p = new i.DXC(h, f);
                else if (d.mode === F.LINE_STRIP) p = new i.N1A(h, f);
                else if (d.mode === F.LINE_LOOP) p = new i.FCc(h, f);
                else {
                  if (d.mode !== F.POINTS)
                    throw new Error(
                      "THREE.GLTFLoader: Primitive mode unsupported: " + d.mode
                    );
                  p = new i.ONl(h, f);
                }
                Object.keys(p.geometry.morphAttributes).length > 0 && X(p, a),
                  (p.name = t.createUniqueName(a.name || "mesh_" + e)),
                  Y(p, a),
                  d.extensions && q(s, p, d),
                  t.assignFinalMaterial(p),
                  u.push(p);
              }
              for (let n = 0, i = u.length; n < i; n++)
                t.associations.set(u[n], { meshes: e, primitives: n });
              if (1 === u.length) return a.extensions && q(s, u[0], a), u[0];
              const h = new i.YJl();
              a.extensions && q(s, h, a), t.associations.set(h, { meshes: e });
              for (let e = 0, t = u.length; e < t; e++) h.add(u[e]);
              return h;
            })
          );
        }
        loadCamera(e) {
          let t;
          const n = this.json.cameras[e],
            r = n[n.type];
          if (r)
            return (
              "perspective" === n.type
                ? (t = new i.ubm(
                    i.cj9.radToDeg(r.yfov),
                    r.aspectRatio || 1,
                    r.znear || 1,
                    r.zfar || 2e6
                  ))
                : "orthographic" === n.type &&
                  (t = new i.qUd(
                    -r.xmag,
                    r.xmag,
                    r.ymag,
                    -r.ymag,
                    r.znear,
                    r.zfar
                  )),
              n.name && (t.name = this.createUniqueName(n.name)),
              Y(t, n),
              Promise.resolve(t)
            );
          console.warn("THREE.GLTFLoader: Missing camera parameters.");
        }
        loadSkin(e) {
          const t = this.json.skins[e],
            n = [];
          for (let e = 0, i = t.joints.length; e < i; e++)
            n.push(this._loadNodeShallow(t.joints[e]));
          return (
            void 0 !== t.inverseBindMatrices
              ? n.push(this.getDependency("accessor", t.inverseBindMatrices))
              : n.push(null),
            Promise.all(n).then(function (e) {
              const n = e.pop(),
                r = e,
                s = [],
                a = [];
              for (let e = 0, o = r.length; e < o; e++) {
                const o = r[e];
                if (o) {
                  s.push(o);
                  const t = new i.kn4();
                  null !== n && t.fromArray(n.array, 16 * e), a.push(t);
                } else
                  console.warn(
                    'THREE.GLTFLoader: Joint "%s" could not be found.',
                    t.joints[e]
                  );
              }
              return new i.EAD(s, a);
            })
          );
        }
        loadAnimation(e) {
          const t = this.json,
            n = this,
            r = t.animations[e],
            s = r.name ? r.name : "animation_" + e,
            a = [],
            o = [],
            l = [],
            c = [],
            u = [];
          for (let e = 0, t = r.channels.length; e < t; e++) {
            const t = r.channels[e],
              n = r.samplers[t.sampler],
              i = t.target,
              s = i.node,
              h = void 0 !== r.parameters ? r.parameters[n.input] : n.input,
              d = void 0 !== r.parameters ? r.parameters[n.output] : n.output;
            void 0 !== i.node &&
              (a.push(this.getDependency("node", s)),
              o.push(this.getDependency("accessor", h)),
              l.push(this.getDependency("accessor", d)),
              c.push(n),
              u.push(i));
          }
          return Promise.all([
            Promise.all(a),
            Promise.all(o),
            Promise.all(l),
            Promise.all(c),
            Promise.all(u),
          ]).then(function (e) {
            const t = e[0],
              r = e[1],
              a = e[2],
              o = e[3],
              l = e[4],
              c = [];
            for (let e = 0, i = t.length; e < i; e++) {
              const i = t[e],
                s = r[e],
                u = a[e],
                h = o[e],
                d = l[e];
              if (void 0 === i) continue;
              i.updateMatrix && i.updateMatrix();
              const p = n._createAnimationTracks(i, s, u, h, d);
              if (p) for (let e = 0; e < p.length; e++) c.push(p[e]);
            }
            return new i.tz3(s, void 0, c);
          });
        }
        createNodeMesh(e) {
          const t = this.json,
            n = this,
            i = t.nodes[e];
          return void 0 === i.mesh
            ? null
            : n.getDependency("mesh", i.mesh).then(function (e) {
                const t = n._getNodeRef(n.meshCache, i.mesh, e);
                return (
                  void 0 !== i.weights &&
                    t.traverse(function (e) {
                      if (e.isMesh)
                        for (let t = 0, n = i.weights.length; t < n; t++)
                          e.morphTargetInfluences[t] = i.weights[t];
                    }),
                  t
                );
              });
        }
        loadNode(e) {
          const t = this,
            n = this.json.nodes[e],
            i = t._loadNodeShallow(e),
            r = [],
            s = n.children || [];
          for (let e = 0, n = s.length; e < n; e++)
            r.push(t.getDependency("node", s[e]));
          const a =
            void 0 === n.skin
              ? Promise.resolve(null)
              : t.getDependency("skin", n.skin);
          return Promise.all([i, Promise.all(r), a]).then(function (e) {
            const t = e[0],
              n = e[1],
              i = e[2];
            null !== i &&
              t.traverse(function (e) {
                e.isSkinnedMesh && e.bind(i, $);
              });
            for (let e = 0, i = n.length; e < i; e++) t.add(n[e]);
            return t;
          });
        }
        _loadNodeShallow(e) {
          const t = this.json,
            n = this.extensions,
            r = this;
          if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
          const s = t.nodes[e],
            a = s.name ? r.createUniqueName(s.name) : "",
            o = [],
            l = r._invokeOne(function (t) {
              return t.createNodeMesh && t.createNodeMesh(e);
            });
          return (
            l && o.push(l),
            void 0 !== s.camera &&
              o.push(
                r.getDependency("camera", s.camera).then(function (e) {
                  return r._getNodeRef(r.cameraCache, s.camera, e);
                })
              ),
            r
              ._invokeAll(function (t) {
                return t.createNodeAttachment && t.createNodeAttachment(e);
              })
              .forEach(function (e) {
                o.push(e);
              }),
            (this.nodeCache[e] = Promise.all(o).then(function (t) {
              let o;
              if (
                ((o =
                  !0 === s.isBone
                    ? new i.$Kf()
                    : t.length > 1
                    ? new i.YJl()
                    : 1 === t.length
                    ? t[0]
                    : new i.B69()),
                o !== t[0])
              )
                for (let e = 0, n = t.length; e < n; e++) o.add(t[e]);
              if (
                (s.name && ((o.userData.name = s.name), (o.name = a)),
                Y(o, s),
                s.extensions && q(n, o, s),
                void 0 !== s.matrix)
              ) {
                const e = new i.kn4();
                e.fromArray(s.matrix), o.applyMatrix4(e);
              } else void 0 !== s.translation && o.position.fromArray(s.translation), void 0 !== s.rotation && o.quaternion.fromArray(s.rotation), void 0 !== s.scale && o.scale.fromArray(s.scale);
              return (
                r.associations.has(o) || r.associations.set(o, {}),
                (r.associations.get(o).nodes = e),
                o
              );
            })),
            this.nodeCache[e]
          );
        }
        loadScene(e) {
          const t = this.extensions,
            n = this.json.scenes[e],
            r = this,
            s = new i.YJl();
          n.name && (s.name = r.createUniqueName(n.name)),
            Y(s, n),
            n.extensions && q(t, s, n);
          const a = n.nodes || [],
            o = [];
          for (let e = 0, t = a.length; e < t; e++)
            o.push(r.getDependency("node", a[e]));
          return Promise.all(o).then(function (e) {
            for (let t = 0, n = e.length; t < n; t++) s.add(e[t]);
            return (
              (r.associations = ((e) => {
                const t = new Map();
                for (const [e, n] of r.associations)
                  (e instanceof i.imn || e instanceof i.gPd) && t.set(e, n);
                return (
                  e.traverse((e) => {
                    const n = r.associations.get(e);
                    null != n && t.set(e, n);
                  }),
                  t
                );
              })(s)),
              s
            );
          });
        }
        _createAnimationTracks(e, t, n, r, s) {
          const a = [],
            o = e.name ? e.name : e.uuid,
            l = [];
          let c;
          switch (
            (H[s.path] === H.weights
              ? e.traverse(function (e) {
                  e.morphTargetInfluences && l.push(e.name ? e.name : e.uuid);
                })
              : l.push(o),
            H[s.path])
          ) {
            case H.weights:
              c = i.Hit;
              break;
            case H.rotation:
              c = i.MBL;
              break;
            case H.position:
            case H.scale:
              c = i.RiT;
              break;
            default:
              if (1 === n.itemSize) c = i.Hit;
              else c = i.RiT;
          }
          const u = void 0 !== r.interpolation ? z[r.interpolation] : i.PJ3,
            h = this._getArrayFromAccessor(n);
          for (let e = 0, n = l.length; e < n; e++) {
            const n = new c(l[e] + "." + H[s.path], t.array, h, u);
            "CUBICSPLINE" === r.interpolation &&
              this._createCubicSplineTrackInterpolant(n),
              a.push(n);
          }
          return a;
        }
        _getArrayFromAccessor(e) {
          let t = e.array;
          if (e.normalized) {
            const e = Z(t.constructor),
              n = new Float32Array(t.length);
            for (let i = 0, r = t.length; i < r; i++) n[i] = t[i] * e;
            t = n;
          }
          return t;
        }
        _createCubicSplineTrackInterpolant(e) {
          (e.createInterpolant = function (e) {
            return new (this instanceof i.MBL ? U : P)(
              this.times,
              this.values,
              this.getValueSize() / 3,
              e
            );
          }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0);
        }
      }
      function te(e, t, n) {
        const r = t.attributes,
          s = [];
        function a(t, i) {
          return n.getDependency("accessor", t).then(function (t) {
            e.setAttribute(i, t);
          });
        }
        for (const t in r) {
          const n = G[t] || t.toLowerCase();
          n in e.attributes || s.push(a(r[t], n));
        }
        if (void 0 !== t.indices && !e.index) {
          const i = n.getDependency("accessor", t.indices).then(function (t) {
            e.setIndex(t);
          });
          s.push(i);
        }
        return (
          i.ppV.workingColorSpace !== i.Zr2 &&
            "COLOR_0" in r &&
            console.warn(
              `THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${i.ppV.workingColorSpace}" not supported.`
            ),
          Y(e, t),
          (function (e, t, n) {
            const r = t.attributes,
              s = new i.NRn();
            if (void 0 === r.POSITION) return;
            {
              const e = n.json.accessors[r.POSITION],
                t = e.min,
                a = e.max;
              if (void 0 === t || void 0 === a)
                return void console.warn(
                  "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                );
              if (
                (s.set(
                  new i.Pq0(t[0], t[1], t[2]),
                  new i.Pq0(a[0], a[1], a[2])
                ),
                e.normalized)
              ) {
                const t = Z(N[e.componentType]);
                s.min.multiplyScalar(t), s.max.multiplyScalar(t);
              }
            }
            const a = t.targets;
            if (void 0 !== a) {
              const e = new i.Pq0(),
                t = new i.Pq0();
              for (let i = 0, r = a.length; i < r; i++) {
                const r = a[i];
                if (void 0 !== r.POSITION) {
                  const i = n.json.accessors[r.POSITION],
                    s = i.min,
                    a = i.max;
                  if (void 0 !== s && void 0 !== a) {
                    if (
                      (t.setX(Math.max(Math.abs(s[0]), Math.abs(a[0]))),
                      t.setY(Math.max(Math.abs(s[1]), Math.abs(a[1]))),
                      t.setZ(Math.max(Math.abs(s[2]), Math.abs(a[2]))),
                      i.normalized)
                    ) {
                      const e = Z(N[i.componentType]);
                      t.multiplyScalar(e);
                    }
                    e.max(t);
                  } else
                    console.warn(
                      "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
                    );
                }
              }
              s.expandByVector(e);
            }
            e.boundingBox = s;
            const o = new i.iyt();
            s.getCenter(o.center),
              (o.radius = s.min.distanceTo(s.max) / 2),
              (e.boundingSphere = o);
          })(e, t, n),
          Promise.all(s).then(function () {
            return void 0 !== t.targets
              ? (function (e, t, n) {
                  let i = !1,
                    r = !1,
                    s = !1;
                  for (let e = 0, n = t.length; e < n; e++) {
                    const n = t[e];
                    if (
                      (void 0 !== n.POSITION && (i = !0),
                      void 0 !== n.NORMAL && (r = !0),
                      void 0 !== n.COLOR_0 && (s = !0),
                      i && r && s)
                    )
                      break;
                  }
                  if (!i && !r && !s) return Promise.resolve(e);
                  const a = [],
                    o = [],
                    l = [];
                  for (let c = 0, u = t.length; c < u; c++) {
                    const u = t[c];
                    if (i) {
                      const t =
                        void 0 !== u.POSITION
                          ? n.getDependency("accessor", u.POSITION)
                          : e.attributes.position;
                      a.push(t);
                    }
                    if (r) {
                      const t =
                        void 0 !== u.NORMAL
                          ? n.getDependency("accessor", u.NORMAL)
                          : e.attributes.normal;
                      o.push(t);
                    }
                    if (s) {
                      const t =
                        void 0 !== u.COLOR_0
                          ? n.getDependency("accessor", u.COLOR_0)
                          : e.attributes.color;
                      l.push(t);
                    }
                  }
                  return Promise.all([
                    Promise.all(a),
                    Promise.all(o),
                    Promise.all(l),
                  ]).then(function (t) {
                    const n = t[0],
                      a = t[1],
                      o = t[2];
                    return (
                      i && (e.morphAttributes.position = n),
                      r && (e.morphAttributes.normal = a),
                      s && (e.morphAttributes.color = o),
                      (e.morphTargetsRelative = !0),
                      e
                    );
                  });
                })(e, t.targets, n)
              : e;
          })
        );
      }
    },
    9174: (e, t, n) => {
      "use strict";
      n.d(t, { p: () => C });
      var i = n(5062);
      class r {
        constructor(e = 4) {
          (this.pool = e),
            (this.queue = []),
            (this.workers = []),
            (this.workersResolve = []),
            (this.workerStatus = 0);
        }
        _initWorker(e) {
          if (!this.workers[e]) {
            const t = this.workerCreator();
            t.addEventListener("message", this._onMessage.bind(this, e)),
              (this.workers[e] = t);
          }
        }
        _getIdleWorker() {
          for (let e = 0; e < this.pool; e++)
            if (!(this.workerStatus & (1 << e))) return e;
          return -1;
        }
        _onMessage(e, t) {
          const n = this.workersResolve[e];
          if ((n && n(t), this.queue.length)) {
            const { resolve: t, msg: n, transfer: i } = this.queue.shift();
            (this.workersResolve[e] = t), this.workers[e].postMessage(n, i);
          } else this.workerStatus ^= 1 << e;
        }
        setWorkerCreator(e) {
          this.workerCreator = e;
        }
        setWorkerLimit(e) {
          this.pool = e;
        }
        postMessage(e, t) {
          return new Promise((n) => {
            const i = this._getIdleWorker();
            -1 !== i
              ? (this._initWorker(i),
                (this.workerStatus |= 1 << i),
                (this.workersResolve[i] = n),
                this.workers[i].postMessage(e, t))
              : this.queue.push({ resolve: n, msg: e, transfer: t });
          });
        }
        dispose() {
          this.workers.forEach((e) => e.terminate()),
            (this.workersResolve.length = 0),
            (this.workers.length = 0),
            (this.queue.length = 0),
            (this.workerStatus = 0);
        }
      }
      const s = 2,
        a = 0,
        o = 1,
        l = 10,
        c = 1000066e3;
      class u {
        constructor() {
          (this.vkFormat = 0),
            (this.typeSize = 1),
            (this.pixelWidth = 0),
            (this.pixelHeight = 0),
            (this.pixelDepth = 0),
            (this.layerCount = 0),
            (this.faceCount = 1),
            (this.supercompressionScheme = 0),
            (this.levels = []),
            (this.dataFormatDescriptor = [
              {
                vendorId: 0,
                descriptorType: 0,
                descriptorBlockSize: 0,
                versionNumber: 2,
                colorModel: 0,
                colorPrimaries: 1,
                transferFunction: 2,
                flags: 0,
                texelBlockDimension: [0, 0, 0, 0],
                bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
                samples: [],
              },
            ]),
            (this.keyValue = {}),
            (this.globalData = null);
        }
      }
      class h {
        constructor(e, t, n, i) {
          (this._dataView = void 0),
            (this._littleEndian = void 0),
            (this._offset = void 0),
            (this._dataView = new DataView(e.buffer, e.byteOffset + t, n)),
            (this._littleEndian = i),
            (this._offset = 0);
        }
        _nextUint8() {
          const e = this._dataView.getUint8(this._offset);
          return (this._offset += 1), e;
        }
        _nextUint16() {
          const e = this._dataView.getUint16(this._offset, this._littleEndian);
          return (this._offset += 2), e;
        }
        _nextUint32() {
          const e = this._dataView.getUint32(this._offset, this._littleEndian);
          return (this._offset += 4), e;
        }
        _nextUint64() {
          const e =
            this._dataView.getUint32(this._offset, this._littleEndian) +
            2 ** 32 *
              this._dataView.getUint32(this._offset + 4, this._littleEndian);
          return (this._offset += 8), e;
        }
        _nextInt32() {
          const e = this._dataView.getInt32(this._offset, this._littleEndian);
          return (this._offset += 4), e;
        }
        _nextUint8Array(e) {
          const t = new Uint8Array(
            this._dataView.buffer,
            this._dataView.byteOffset + this._offset,
            e
          );
          return (this._offset += e), t;
        }
        _skip(e) {
          return (this._offset += e), this;
        }
        _scan(e, t) {
          void 0 === t && (t = 0);
          const n = this._offset;
          let i = 0;
          for (; this._dataView.getUint8(this._offset) !== t && i < e; )
            i++, this._offset++;
          return (
            i < e && this._offset++,
            new Uint8Array(
              this._dataView.buffer,
              this._dataView.byteOffset + n,
              i
            )
          );
        }
      }
      new Uint8Array([0]);
      const d = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
      function p(e) {
        return new TextDecoder().decode(e);
      }
      let f, A, g;
      const m = {
        env: {
          emscripten_notify_memory_growth: function (e) {
            g = new Uint8Array(A.exports.memory.buffer);
          },
        },
      };
      class v {
        init() {
          return (
            f ||
            ((f =
              "undefined" != typeof fetch
                ? fetch("data:application/wasm;base64," + y)
                    .then((e) => e.arrayBuffer())
                    .then((e) => WebAssembly.instantiate(e, m))
                    .then(this._init)
                : WebAssembly.instantiate(Buffer.from(y, "base64"), m).then(
                    this._init
                  )),
            f)
          );
        }
        _init(e) {
          (A = e.instance), m.env.emscripten_notify_memory_growth(0);
        }
        decode(e, t = 0) {
          if (!A)
            throw new Error("ZSTDDecoder: Await .init() before decoding.");
          const n = e.byteLength,
            i = A.exports.malloc(n);
          g.set(e, i),
            (t = t || Number(A.exports.ZSTD_findDecompressedSize(i, n)));
          const r = A.exports.malloc(t),
            s = A.exports.ZSTD_decompress(r, t, i, n),
            a = g.slice(r, r + s);
          return A.exports.free(i), A.exports.free(r), a;
        }
      }
      const y =
          "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IAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQh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ASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigC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C0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdB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IAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY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wOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEE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",
        x = "display-p3",
        _ = "display-p3-linear",
        b = (i.KLL, i.VxR, i.VxR, new WeakMap());
      let E,
        w = 0;
      class C extends i.aHM {
        constructor(e) {
          super(e),
            (this.transcoderPath = ""),
            (this.transcoderBinary = null),
            (this.transcoderPending = null),
            (this.workerPool = new r()),
            (this.workerSourceURL = ""),
            (this.workerConfig = null),
            "undefined" != typeof MSC_TRANSCODER &&
              console.warn(
                'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
              );
        }
        setTranscoderPath(e) {
          return (this.transcoderPath = e), this;
        }
        setWorkerLimit(e) {
          return this.workerPool.setWorkerLimit(e), this;
        }
        async detectSupportAsync(e) {
          return (
            (this.workerConfig = {
              astcSupported: await e.hasFeatureAsync(
                "texture-compression-astc"
              ),
              astcHDRSupported: !1,
              etc1Supported: await e.hasFeatureAsync(
                "texture-compression-etc1"
              ),
              etc2Supported: await e.hasFeatureAsync(
                "texture-compression-etc2"
              ),
              dxtSupported: await e.hasFeatureAsync("texture-compression-bc"),
              bptcSupported: await e.hasFeatureAsync(
                "texture-compression-bptc"
              ),
              pvrtcSupported: await e.hasFeatureAsync(
                "texture-compression-pvrtc"
              ),
            }),
            this
          );
        }
        detectSupport(e) {
          return (
            !0 === e.isWebGPURenderer
              ? (this.workerConfig = {
                  astcSupported: e.hasFeature("texture-compression-astc"),
                  astcHDRSupported: !1,
                  etc1Supported: e.hasFeature("texture-compression-etc1"),
                  etc2Supported: e.hasFeature("texture-compression-etc2"),
                  dxtSupported: e.hasFeature("texture-compression-bc"),
                  bptcSupported: e.hasFeature("texture-compression-bptc"),
                  pvrtcSupported: e.hasFeature("texture-compression-pvrtc"),
                })
              : (this.workerConfig = {
                  astcSupported: e.extensions.has(
                    "WEBGL_compressed_texture_astc"
                  ),
                  astcHDRSupported:
                    e.extensions.has("WEBGL_compressed_texture_astc") &&
                    e.extensions
                      .get("WEBGL_compressed_texture_astc")
                      .getSupportedProfiles()
                      .includes("hdr"),
                  etc1Supported: e.extensions.has(
                    "WEBGL_compressed_texture_etc1"
                  ),
                  etc2Supported: e.extensions.has(
                    "WEBGL_compressed_texture_etc"
                  ),
                  dxtSupported: e.extensions.has(
                    "WEBGL_compressed_texture_s3tc"
                  ),
                  bptcSupported: e.extensions.has(
                    "EXT_texture_compression_bptc"
                  ),
                  pvrtcSupported:
                    e.extensions.has("WEBGL_compressed_texture_pvrtc") ||
                    e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc"),
                }),
            this
          );
        }
        init() {
          if (!this.transcoderPending) {
            const e = new i.Y9S(this.manager);
            e.setPath(this.transcoderPath),
              e.setWithCredentials(this.withCredentials);
            const t = e.loadAsync("basis_transcoder.js"),
              n = new i.Y9S(this.manager);
            n.setPath(this.transcoderPath),
              n.setResponseType("arraybuffer"),
              n.setWithCredentials(this.withCredentials);
            const r = n.loadAsync("basis_transcoder.wasm");
            (this.transcoderPending = Promise.all([t, r]).then(([e, t]) => {
              const n = C.BasisWorker.toString(),
                i = [
                  "/* constants */",
                  "let _EngineFormat = " + JSON.stringify(C.EngineFormat),
                  "let _EngineType = " + JSON.stringify(C.EngineType),
                  "let _TranscoderFormat = " +
                    JSON.stringify(C.TranscoderFormat),
                  "let _BasisFormat = " + JSON.stringify(C.BasisFormat),
                  "/* basis_transcoder.js */",
                  e,
                  "/* worker */",
                  n.substring(n.indexOf("{") + 1, n.lastIndexOf("}")),
                ].join("\n");
              (this.workerSourceURL = URL.createObjectURL(new Blob([i]))),
                (this.transcoderBinary = t),
                this.workerPool.setWorkerCreator(() => {
                  const e = new Worker(this.workerSourceURL),
                    t = this.transcoderBinary.slice(0);
                  return (
                    e.postMessage(
                      {
                        type: "init",
                        config: this.workerConfig,
                        transcoderBinary: t,
                      },
                      [t]
                    ),
                    e
                  );
                });
            })),
              w > 0 &&
                console.warn(
                  "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
                ),
              w++;
          }
          return this.transcoderPending;
        }
        load(e, t, n, r) {
          if (null === this.workerConfig)
            throw new Error(
              "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
            );
          const s = new i.Y9S(this.manager);
          s.setResponseType("arraybuffer"),
            s.setWithCredentials(this.withCredentials),
            s.load(
              e,
              (e) => {
                this.parse(e, t, r);
              },
              n,
              r
            );
        }
        parse(e, t, n) {
          if (null === this.workerConfig)
            throw new Error(
              "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
            );
          if (b.has(e)) {
            return b.get(e).promise.then(t).catch(n);
          }
          this._createTexture(e)
            .then((e) => (t ? t(e) : null))
            .catch(n);
        }
        _createTextureFrom(e, t) {
          const {
            type: n,
            error: r,
            data: {
              faces: s,
              width: a,
              height: o,
              format: l,
              type: c,
              dfdFlags: u,
            },
          } = e;
          if ("error" === n) return Promise.reject(r);
          let h;
          if (6 === t.faceCount) h = new i.c5h(s, l, c);
          else {
            const e = s[0].mipmaps;
            h =
              t.layerCount > 1
                ? new i.iOZ(e, a, o, t.layerCount, l, c)
                : new i.FvD(e, a, o, l, c);
          }
          return (
            (h.minFilter = 1 === s[0].mipmaps.length ? i.k6q : i.$_I),
            (h.magFilter = i.k6q),
            (h.generateMipmaps = !1),
            (h.needsUpdate = !0),
            (h.colorSpace = T(t)),
            (h.premultiplyAlpha = !!(1 & u)),
            h
          );
        }
        async _createTexture(e, t = {}) {
          const n = (function (e) {
              const t = new Uint8Array(e.buffer, e.byteOffset, d.length);
              if (
                t[0] !== d[0] ||
                t[1] !== d[1] ||
                t[2] !== d[2] ||
                t[3] !== d[3] ||
                t[4] !== d[4] ||
                t[5] !== d[5] ||
                t[6] !== d[6] ||
                t[7] !== d[7] ||
                t[8] !== d[8] ||
                t[9] !== d[9] ||
                t[10] !== d[10] ||
                t[11] !== d[11]
              )
                throw new Error("Missing KTX 2.0 identifier.");
              const n = new u(),
                i = 17 * Uint32Array.BYTES_PER_ELEMENT,
                r = new h(e, d.length, i, !0);
              (n.vkFormat = r._nextUint32()),
                (n.typeSize = r._nextUint32()),
                (n.pixelWidth = r._nextUint32()),
                (n.pixelHeight = r._nextUint32()),
                (n.pixelDepth = r._nextUint32()),
                (n.layerCount = r._nextUint32()),
                (n.faceCount = r._nextUint32());
              const s = r._nextUint32();
              n.supercompressionScheme = r._nextUint32();
              const a = r._nextUint32(),
                o = r._nextUint32(),
                l = r._nextUint32(),
                c = r._nextUint32(),
                f = r._nextUint64(),
                A = r._nextUint64(),
                g = new h(e, d.length + i, 3 * s * 8, !0);
              for (let t = 0; t < s; t++)
                n.levels.push({
                  levelData: new Uint8Array(
                    e.buffer,
                    e.byteOffset + g._nextUint64(),
                    g._nextUint64()
                  ),
                  uncompressedByteLength: g._nextUint64(),
                });
              const m = new h(e, a, o, !0),
                v = {
                  vendorId: m._skip(4)._nextUint16(),
                  descriptorType: m._nextUint16(),
                  versionNumber: m._nextUint16(),
                  descriptorBlockSize: m._nextUint16(),
                  colorModel: m._nextUint8(),
                  colorPrimaries: m._nextUint8(),
                  transferFunction: m._nextUint8(),
                  flags: m._nextUint8(),
                  texelBlockDimension: [
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                  ],
                  bytesPlane: [
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                  ],
                  samples: [],
                },
                y = (v.descriptorBlockSize / 4 - 6) / 4;
              for (let e = 0; e < y; e++) {
                const t = {
                  bitOffset: m._nextUint16(),
                  bitLength: m._nextUint8(),
                  channelType: m._nextUint8(),
                  samplePosition: [
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                    m._nextUint8(),
                  ],
                  sampleLower: -1 / 0,
                  sampleUpper: 1 / 0,
                };
                64 & t.channelType
                  ? ((t.sampleLower = m._nextInt32()),
                    (t.sampleUpper = m._nextInt32()))
                  : ((t.sampleLower = m._nextUint32()),
                    (t.sampleUpper = m._nextUint32())),
                  (v.samples[e] = t);
              }
              (n.dataFormatDescriptor.length = 0),
                n.dataFormatDescriptor.push(v);
              const x = new h(e, l, c, !0);
              for (; x._offset < c; ) {
                const e = x._nextUint32(),
                  t = x._scan(e),
                  i = p(t);
                if (
                  ((n.keyValue[i] = x._nextUint8Array(e - t.byteLength - 1)),
                  i.match(/^ktx/i))
                ) {
                  const e = p(n.keyValue[i]);
                  n.keyValue[i] = e.substring(0, e.lastIndexOf("\0"));
                }
                x._skip(e % 4 ? 4 - (e % 4) : 0);
              }
              if (A <= 0) return n;
              const _ = new h(e, f, A, !0),
                b = _._nextUint16(),
                E = _._nextUint16(),
                w = _._nextUint32(),
                C = _._nextUint32(),
                I = _._nextUint32(),
                S = _._nextUint32(),
                M = [];
              for (let e = 0; e < s; e++)
                M.push({
                  imageFlags: _._nextUint32(),
                  rgbSliceByteOffset: _._nextUint32(),
                  rgbSliceByteLength: _._nextUint32(),
                  alphaSliceByteOffset: _._nextUint32(),
                  alphaSliceByteLength: _._nextUint32(),
                });
              const T = f + _._offset,
                B = T + w,
                R = B + C,
                D = R + I,
                P = new Uint8Array(e.buffer, e.byteOffset + T, w),
                L = new Uint8Array(e.buffer, e.byteOffset + B, C),
                U = new Uint8Array(e.buffer, e.byteOffset + R, I),
                F = new Uint8Array(e.buffer, e.byteOffset + D, S);
              return (
                (n.globalData = {
                  endpointCount: b,
                  selectorCount: E,
                  imageDescs: M,
                  endpointsData: P,
                  selectorsData: L,
                  tablesData: U,
                  extendedData: F,
                }),
                n
              );
            })(new Uint8Array(e)),
            r =
              n.vkFormat === c && 167 === n.dataFormatDescriptor[0].colorModel;
          if (!(0 === n.vkFormat || (r && !this.workerConfig.astcHDRSupported)))
            return (async function (e) {
              const { vkFormat: t } = e;
              if (void 0 === S[t])
                throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
              let n;
              2 === e.supercompressionScheme &&
                (E ||
                  (E = new Promise(async (e) => {
                    const t = new v();
                    await t.init(), e(t);
                  })),
                (n = await E));
              const r = [];
              for (let s = 0; s < e.levels.length; s++) {
                const a = Math.max(1, e.pixelWidth >> s),
                  o = Math.max(1, e.pixelHeight >> s),
                  l = e.pixelDepth ? Math.max(1, e.pixelDepth >> s) : 0,
                  c = e.levels[s];
                let u, h;
                if (0 === e.supercompressionScheme) u = c.levelData;
                else {
                  if (2 !== e.supercompressionScheme)
                    throw new Error(
                      "THREE.KTX2Loader: Unsupported supercompressionScheme."
                    );
                  u = n.decode(c.levelData, c.uncompressedByteLength);
                }
                (h =
                  M[t] === i.RQf
                    ? new Float32Array(
                        u.buffer,
                        u.byteOffset,
                        u.byteLength / Float32Array.BYTES_PER_ELEMENT
                      )
                    : M[t] === i.ix0
                    ? new Uint16Array(
                        u.buffer,
                        u.byteOffset,
                        u.byteLength / Uint16Array.BYTES_PER_ELEMENT
                      )
                    : u),
                  r.push({ data: h, width: a, height: o, depth: l });
              }
              let s;
              if (I.has(S[t]))
                s =
                  0 === e.pixelDepth
                    ? new i.GYF(r[0].data, e.pixelWidth, e.pixelHeight)
                    : new i.dYF(
                        r[0].data,
                        e.pixelWidth,
                        e.pixelHeight,
                        e.pixelDepth
                      );
              else {
                if (e.pixelDepth > 0)
                  throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
                s = new i.FvD(r, e.pixelWidth, e.pixelHeight);
              }
              return (
                (s.mipmaps = r),
                (s.type = M[t]),
                (s.format = S[t]),
                (s.colorSpace = T(e)),
                (s.needsUpdate = !0),
                Promise.resolve(s)
              );
            })(n);
          const s = t,
            a = this.init()
              .then(() =>
                this.workerPool.postMessage(
                  { type: "transcode", buffer: e, taskConfig: s },
                  [e]
                )
              )
              .then((e) => this._createTextureFrom(e.data, n));
          return b.set(e, { promise: a }), a;
        }
        dispose() {
          return (
            this.workerPool.dispose(),
            this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
            w--,
            this
          );
        }
      }
      (C.BasisFormat = { ETC1S: 0, UASTC: 1, UASTC_HDR: 2 }),
        (C.TranscoderFormat = {
          ETC1: 0,
          ETC2: 1,
          BC1: 2,
          BC3: 3,
          BC4: 4,
          BC5: 5,
          BC7_M6_OPAQUE_ONLY: 6,
          BC7_M5: 7,
          PVRTC1_4_RGB: 8,
          PVRTC1_4_RGBA: 9,
          ASTC_4x4: 10,
          ATC_RGB: 11,
          ATC_RGBA_INTERPOLATED_ALPHA: 12,
          RGBA32: 13,
          RGB565: 14,
          BGR565: 15,
          RGBA4444: 16,
          BC6H: 22,
          RGB_HALF: 24,
          RGBA_HALF: 25,
        }),
        (C.EngineFormat = {
          RGBAFormat: i.GWd,
          RGBA_ASTC_4x4_Format: i.qa3,
          RGB_BPTC_UNSIGNED_Format: i.W9U,
          RGBA_BPTC_Format: i.Fn,
          RGBA_ETC2_EAC_Format: i.KDk,
          RGBA_PVRTC_4BPPV1_Format: i.HXV,
          RGBA_S3TC_DXT5_Format: i.BXX,
          RGB_ETC1_Format: i.CVz,
          RGB_ETC2_Format: i.Riy,
          RGB_PVRTC_4BPPV1_Format: i.k6Q,
          RGBA_S3TC_DXT1_Format: i.Nz6,
        }),
        (C.EngineType = {
          UnsignedByteType: i.OUM,
          HalfFloatType: i.ix0,
          FloatType: i.RQf,
        }),
        (C.BasisWorker = function () {
          let e, t, n;
          const i = _EngineFormat,
            r = _EngineType,
            s = _TranscoderFormat,
            a = _BasisFormat;
          self.addEventListener("message", function (i) {
            const s = i.data;
            switch (s.type) {
              case "init":
                (e = s.config),
                  (o = s.transcoderBinary),
                  (t = new Promise((e) => {
                    (n = { wasmBinary: o, onRuntimeInitialized: e }), BASIS(n);
                  }).then(() => {
                    n.initializeBasis(),
                      void 0 === n.KTX2File &&
                        console.warn(
                          "THREE.KTX2Loader: Please update Basis Universal transcoder."
                        );
                  }));
                break;
              case "transcode":
                t.then(() => {
                  try {
                    const {
                      faces: t,
                      buffers: i,
                      width: o,
                      height: h,
                      hasAlpha: d,
                      format: p,
                      type: f,
                      dfdFlags: A,
                    } = (function (t) {
                      const i = new n.KTX2File(new Uint8Array(t));
                      function s() {
                        i.close(), i.delete();
                      }
                      if (!i.isValid())
                        throw (
                          (s(),
                          new Error(
                            "THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file"
                          ))
                        );
                      let o;
                      if (i.isUASTC()) o = a.UASTC;
                      else if (i.isETC1S()) o = a.ETC1S;
                      else {
                        if (!i.isHDR())
                          throw new Error(
                            "THREE.KTX2Loader: Unknown Basis encoding"
                          );
                        o = a.UASTC_HDR;
                      }
                      const h = i.getWidth(),
                        d = i.getHeight(),
                        p = i.getLayers() || 1,
                        f = i.getLevels(),
                        A = i.getFaces(),
                        g = i.getHasAlpha(),
                        m = i.getDFDFlags(),
                        {
                          transcoderFormat: v,
                          engineFormat: y,
                          engineType: x,
                        } = (function (t, n, i, r) {
                          const s = l[t];
                          for (let a = 0; a < s.length; a++) {
                            const o = s[a];
                            if (o.if && !e[o.if]) continue;
                            if (!o.basisFormat.includes(t)) continue;
                            if (r && o.transcoderFormat.length < 2) continue;
                            if (o.needsPowerOfTwo && (!c(n) || !c(i))) continue;
                            return {
                              transcoderFormat: o.transcoderFormat[r ? 1 : 0],
                              engineFormat: o.engineFormat[r ? 1 : 0],
                              engineType: o.engineType[0],
                            };
                          }
                          throw new Error(
                            "THREE.KTX2Loader: Failed to identify transcoding target."
                          );
                        })(o, h, d, g);
                      if (!h || !d || !f)
                        throw (
                          (s(), new Error("THREE.KTX2Loader:\tInvalid texture"))
                        );
                      if (!i.startTranscoding())
                        throw (
                          (s(),
                          new Error(
                            "THREE.KTX2Loader: .startTranscoding failed"
                          ))
                        );
                      const _ = [],
                        b = [];
                      for (let e = 0; e < A; e++) {
                        const t = [];
                        for (let n = 0; n < f; n++) {
                          const a = [];
                          let o, l;
                          for (let t = 0; t < p; t++) {
                            const c = i.getImageLevelInfo(n, t, e);
                            0 !== e ||
                              0 !== n ||
                              0 !== t ||
                              (c.origWidth % 4 == 0 && c.origHeight % 4 == 0) ||
                              console.warn(
                                "THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."
                              ),
                              f > 1
                                ? ((o = c.origWidth), (l = c.origHeight))
                                : ((o = c.width), (l = c.height));
                            let u = new Uint8Array(
                              i.getImageTranscodedSizeInBytes(n, t, 0, v)
                            );
                            const h = i.transcodeImage(
                              u,
                              n,
                              t,
                              e,
                              v,
                              0,
                              -1,
                              -1
                            );
                            if (
                              (x === r.HalfFloatType &&
                                (u = new Uint16Array(
                                  u.buffer,
                                  u.byteOffset,
                                  u.byteLength / Uint16Array.BYTES_PER_ELEMENT
                                )),
                              !h)
                            )
                              throw (
                                (s(),
                                new Error(
                                  "THREE.KTX2Loader: .transcodeImage failed."
                                ))
                              );
                            a.push(u);
                          }
                          const c = u(a);
                          t.push({ data: c, width: o, height: l }),
                            b.push(c.buffer);
                        }
                        _.push({
                          mipmaps: t,
                          width: h,
                          height: d,
                          format: y,
                          type: x,
                        });
                      }
                      return (
                        s(),
                        {
                          faces: _,
                          buffers: b,
                          width: h,
                          height: d,
                          hasAlpha: g,
                          dfdFlags: m,
                          format: y,
                          type: x,
                        }
                      );
                    })(s.buffer);
                    self.postMessage(
                      {
                        type: "transcode",
                        id: s.id,
                        data: {
                          faces: t,
                          width: o,
                          height: h,
                          hasAlpha: d,
                          format: p,
                          type: f,
                          dfdFlags: A,
                        },
                      },
                      i
                    );
                  } catch (e) {
                    console.error(e),
                      self.postMessage({
                        type: "error",
                        id: s.id,
                        error: e.message,
                      });
                  }
                });
            }
            var o;
          });
          const o = [
              {
                if: "astcSupported",
                basisFormat: [a.UASTC],
                transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
                engineFormat: [i.RGBA_ASTC_4x4_Format, i.RGBA_ASTC_4x4_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1 / 0,
                priorityUASTC: 1,
                needsPowerOfTwo: !1,
              },
              {
                if: "bptcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC7_M5, s.BC7_M5],
                engineFormat: [i.RGBA_BPTC_Format, i.RGBA_BPTC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 3,
                priorityUASTC: 2,
                needsPowerOfTwo: !1,
              },
              {
                if: "dxtSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.BC1, s.BC3],
                engineFormat: [
                  i.RGBA_S3TC_DXT1_Format,
                  i.RGBA_S3TC_DXT5_Format,
                ],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 4,
                priorityUASTC: 5,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc2Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1, s.ETC2],
                engineFormat: [i.RGB_ETC2_Format, i.RGBA_ETC2_EAC_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 1,
                priorityUASTC: 3,
                needsPowerOfTwo: !1,
              },
              {
                if: "etc1Supported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.ETC1],
                engineFormat: [i.RGB_ETC1_Format],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 2,
                priorityUASTC: 4,
                needsPowerOfTwo: !1,
              },
              {
                if: "pvrtcSupported",
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
                engineFormat: [
                  i.RGB_PVRTC_4BPPV1_Format,
                  i.RGBA_PVRTC_4BPPV1_Format,
                ],
                engineType: [r.UnsignedByteType],
                priorityETC1S: 5,
                priorityUASTC: 6,
                needsPowerOfTwo: !0,
              },
              {
                if: "bptcSupported",
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.BC6H],
                engineFormat: [i.RGB_BPTC_UNSIGNED_Format],
                engineType: [r.HalfFloatType],
                priorityHDR: 1,
                needsPowerOfTwo: !1,
              },
              {
                basisFormat: [a.ETC1S, a.UASTC],
                transcoderFormat: [s.RGBA32, s.RGBA32],
                engineFormat: [i.RGBAFormat, i.RGBAFormat],
                engineType: [r.UnsignedByteType, r.UnsignedByteType],
                priorityETC1S: 100,
                priorityUASTC: 100,
                needsPowerOfTwo: !1,
              },
              {
                basisFormat: [a.UASTC_HDR],
                transcoderFormat: [s.RGBA_HALF],
                engineFormat: [i.RGBAFormat],
                engineType: [r.HalfFloatType],
                priorityHDR: 100,
                needsPowerOfTwo: !1,
              },
            ],
            l = {
              [a.ETC1S]: o
                .filter((e) => e.basisFormat.includes(a.ETC1S))
                .sort((e, t) => e.priorityUASTC - t.priorityUASTC),
              [a.UASTC]: o
                .filter((e) => e.basisFormat.includes(a.UASTC))
                .sort((e, t) => e.priorityUASTC - t.priorityUASTC),
              [a.UASTC_HDR]: o
                .filter((e) => e.basisFormat.includes(a.UASTC_HDR))
                .sort((e, t) => e.priorityHDR - t.priorityHDR),
            };
          function c(e) {
            return e <= 2 || (!(e & (e - 1)) && 0 !== e);
          }
          function u(e) {
            if (1 === e.length) return e[0];
            let t = 0;
            for (let n = 0; n < e.length; n++) {
              t += e[n].byteLength;
            }
            const n = new Uint8Array(t);
            let i = 0;
            for (let t = 0; t < e.length; t++) {
              const r = e[t];
              n.set(r, i), (i += r.byteLength);
            }
            return n;
          }
        });
      const I = new Set([i.GWd, i.paN, i.VT0]),
        S = {
          109: i.GWd,
          97: i.GWd,
          37: i.GWd,
          43: i.GWd,
          103: i.paN,
          83: i.paN,
          16: i.paN,
          22: i.paN,
          100: i.VT0,
          76: i.VT0,
          15: i.VT0,
          9: i.VT0,
          [c]: i.qa3,
          166: i.Qrf,
          165: i.Qrf,
        },
        M = {
          109: i.RQf,
          97: i.ix0,
          37: i.OUM,
          43: i.OUM,
          103: i.RQf,
          83: i.ix0,
          16: i.OUM,
          22: i.OUM,
          100: i.RQf,
          76: i.ix0,
          15: i.OUM,
          9: i.OUM,
          [c]: i.ix0,
          166: i.OUM,
          165: i.OUM,
        };
      function T(e) {
        const t = e.dataFormatDescriptor[0];
        return t.colorPrimaries === o
          ? t.transferFunction === s
            ? i.er$
            : i.Zr2
          : t.colorPrimaries === l
          ? t.transferFunction === s
            ? x
            : _
          : (t.colorPrimaries === a ||
              console.warn(
                `THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`
              ),
            i.jf0);
      }
    },
    5837: (e, t, n) => {
      "use strict";
      n.d(t, { L: () => g });
      var i = n(5062);
      const r = /^[og]\s*(.+)?/,
        s = /^mtllib /,
        a = /^usemtl /,
        o = /^usemap /,
        l = /\s+/,
        c = new i.Pq0(),
        u = new i.Pq0(),
        h = new i.Pq0(),
        d = new i.Pq0(),
        p = new i.Pq0(),
        f = new i.Q1f();
      function A() {
        const e = {
          objects: [],
          object: {},
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          materials: {},
          materialLibraries: [],
          startObject: function (e, t) {
            if (this.object && !1 === this.object.fromDeclaration)
              return (
                (this.object.name = e),
                void (this.object.fromDeclaration = !1 !== t)
              );
            const n =
              this.object && "function" == typeof this.object.currentMaterial
                ? this.object.currentMaterial()
                : void 0;
            if (
              (this.object &&
                "function" == typeof this.object._finalize &&
                this.object._finalize(!0),
              (this.object = {
                name: e || "",
                fromDeclaration: !1 !== t,
                geometry: {
                  vertices: [],
                  normals: [],
                  colors: [],
                  uvs: [],
                  hasUVIndices: !1,
                },
                materials: [],
                smooth: !0,
                startMaterial: function (e, t) {
                  const n = this._finalize(!1);
                  n &&
                    (n.inherited || n.groupCount <= 0) &&
                    this.materials.splice(n.index, 1);
                  const i = {
                    index: this.materials.length,
                    name: e || "",
                    mtllib:
                      Array.isArray(t) && t.length > 0 ? t[t.length - 1] : "",
                    smooth: void 0 !== n ? n.smooth : this.smooth,
                    groupStart: void 0 !== n ? n.groupEnd : 0,
                    groupEnd: -1,
                    groupCount: -1,
                    inherited: !1,
                    clone: function (e) {
                      const t = {
                        index: "number" == typeof e ? e : this.index,
                        name: this.name,
                        mtllib: this.mtllib,
                        smooth: this.smooth,
                        groupStart: 0,
                        groupEnd: -1,
                        groupCount: -1,
                        inherited: !1,
                      };
                      return (t.clone = this.clone.bind(t)), t;
                    },
                  };
                  return this.materials.push(i), i;
                },
                currentMaterial: function () {
                  if (this.materials.length > 0)
                    return this.materials[this.materials.length - 1];
                },
                _finalize: function (e) {
                  const t = this.currentMaterial();
                  if (
                    (t &&
                      -1 === t.groupEnd &&
                      ((t.groupEnd = this.geometry.vertices.length / 3),
                      (t.groupCount = t.groupEnd - t.groupStart),
                      (t.inherited = !1)),
                    e && this.materials.length > 1)
                  )
                    for (let e = this.materials.length - 1; e >= 0; e--)
                      this.materials[e].groupCount <= 0 &&
                        this.materials.splice(e, 1);
                  return (
                    e &&
                      0 === this.materials.length &&
                      this.materials.push({ name: "", smooth: this.smooth }),
                    t
                  );
                },
              }),
              n && n.name && "function" == typeof n.clone)
            ) {
              const e = n.clone(0);
              (e.inherited = !0), this.object.materials.push(e);
            }
            this.objects.push(this.object);
          },
          finalize: function () {
            this.object &&
              "function" == typeof this.object._finalize &&
              this.object._finalize(!0);
          },
          parseVertexIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 3 * (n >= 0 ? n - 1 : n + t / 3);
          },
          parseNormalIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 3 * (n >= 0 ? n - 1 : n + t / 3);
          },
          parseUVIndex: function (e, t) {
            const n = parseInt(e, 10);
            return 2 * (n >= 0 ? n - 1 : n + t / 2);
          },
          addVertex: function (e, t, n) {
            const i = this.vertices,
              r = this.object.geometry.vertices;
            r.push(i[e + 0], i[e + 1], i[e + 2]),
              r.push(i[t + 0], i[t + 1], i[t + 2]),
              r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addVertexPoint: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
          },
          addVertexLine: function (e) {
            const t = this.vertices;
            this.object.geometry.vertices.push(t[e + 0], t[e + 1], t[e + 2]);
          },
          addNormal: function (e, t, n) {
            const i = this.normals,
              r = this.object.geometry.normals;
            r.push(i[e + 0], i[e + 1], i[e + 2]),
              r.push(i[t + 0], i[t + 1], i[t + 2]),
              r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addFaceNormal: function (e, t, n) {
            const i = this.vertices,
              r = this.object.geometry.normals;
            c.fromArray(i, e),
              u.fromArray(i, t),
              h.fromArray(i, n),
              p.subVectors(h, u),
              d.subVectors(c, u),
              p.cross(d),
              p.normalize(),
              r.push(p.x, p.y, p.z),
              r.push(p.x, p.y, p.z),
              r.push(p.x, p.y, p.z);
          },
          addColor: function (e, t, n) {
            const i = this.colors,
              r = this.object.geometry.colors;
            void 0 !== i[e] && r.push(i[e + 0], i[e + 1], i[e + 2]),
              void 0 !== i[t] && r.push(i[t + 0], i[t + 1], i[t + 2]),
              void 0 !== i[n] && r.push(i[n + 0], i[n + 1], i[n + 2]);
          },
          addUV: function (e, t, n) {
            const i = this.uvs,
              r = this.object.geometry.uvs;
            r.push(i[e + 0], i[e + 1]),
              r.push(i[t + 0], i[t + 1]),
              r.push(i[n + 0], i[n + 1]);
          },
          addDefaultUV: function () {
            const e = this.object.geometry.uvs;
            e.push(0, 0), e.push(0, 0), e.push(0, 0);
          },
          addUVLine: function (e) {
            const t = this.uvs;
            this.object.geometry.uvs.push(t[e + 0], t[e + 1]);
          },
          addFace: function (e, t, n, i, r, s, a, o, l) {
            const c = this.vertices.length;
            let u = this.parseVertexIndex(e, c),
              h = this.parseVertexIndex(t, c),
              d = this.parseVertexIndex(n, c);
            if (
              (this.addVertex(u, h, d),
              this.addColor(u, h, d),
              void 0 !== a && "" !== a)
            ) {
              const e = this.normals.length;
              (u = this.parseNormalIndex(a, e)),
                (h = this.parseNormalIndex(o, e)),
                (d = this.parseNormalIndex(l, e)),
                this.addNormal(u, h, d);
            } else this.addFaceNormal(u, h, d);
            if (void 0 !== i && "" !== i) {
              const e = this.uvs.length;
              (u = this.parseUVIndex(i, e)),
                (h = this.parseUVIndex(r, e)),
                (d = this.parseUVIndex(s, e)),
                this.addUV(u, h, d),
                (this.object.geometry.hasUVIndices = !0);
            } else this.addDefaultUV();
          },
          addPointGeometry: function (e) {
            this.object.geometry.type = "Points";
            const t = this.vertices.length;
            for (let n = 0, i = e.length; n < i; n++) {
              const i = this.parseVertexIndex(e[n], t);
              this.addVertexPoint(i), this.addColor(i);
            }
          },
          addLineGeometry: function (e, t) {
            this.object.geometry.type = "Line";
            const n = this.vertices.length,
              i = this.uvs.length;
            for (let t = 0, i = e.length; t < i; t++)
              this.addVertexLine(this.parseVertexIndex(e[t], n));
            for (let e = 0, n = t.length; e < n; e++)
              this.addUVLine(this.parseUVIndex(t[e], i));
          },
        };
        return e.startObject("", !1), e;
      }
      class g extends i.aHM {
        constructor(e) {
          super(e), (this.materials = null);
        }
        load(e, t, n, r) {
          const s = this,
            a = new i.Y9S(this.manager);
          a.setPath(this.path),
            a.setRequestHeader(this.requestHeader),
            a.setWithCredentials(this.withCredentials),
            a.load(
              e,
              function (n) {
                try {
                  t(s.parse(n));
                } catch (t) {
                  r ? r(t) : console.error(t), s.manager.itemError(e);
                }
              },
              n,
              r
            );
        }
        setMaterials(e) {
          return (this.materials = e), this;
        }
        parse(e) {
          const t = new A();
          -1 !== e.indexOf("\r\n") && (e = e.replace(/\r\n/g, "\n")),
            -1 !== e.indexOf("\\\n") && (e = e.replace(/\\\n/g, ""));
          const n = e.split("\n");
          let c = [];
          for (let e = 0, u = n.length; e < u; e++) {
            const u = n[e].trimStart();
            if (0 === u.length) continue;
            const h = u.charAt(0);
            if ("#" !== h)
              if ("v" === h) {
                const e = u.split(l);
                switch (e[0]) {
                  case "v":
                    t.vertices.push(
                      parseFloat(e[1]),
                      parseFloat(e[2]),
                      parseFloat(e[3])
                    ),
                      e.length >= 7
                        ? (f.setRGB(
                            parseFloat(e[4]),
                            parseFloat(e[5]),
                            parseFloat(e[6]),
                            i.er$
                          ),
                          t.colors.push(f.r, f.g, f.b))
                        : t.colors.push(void 0, void 0, void 0);
                    break;
                  case "vn":
                    t.normals.push(
                      parseFloat(e[1]),
                      parseFloat(e[2]),
                      parseFloat(e[3])
                    );
                    break;
                  case "vt":
                    t.uvs.push(parseFloat(e[1]), parseFloat(e[2]));
                }
              } else if ("f" === h) {
                const e = u.slice(1).trim().split(l),
                  n = [];
                for (let t = 0, i = e.length; t < i; t++) {
                  const i = e[t];
                  if (i.length > 0) {
                    const e = i.split("/");
                    n.push(e);
                  }
                }
                const i = n[0];
                for (let e = 1, r = n.length - 1; e < r; e++) {
                  const r = n[e],
                    s = n[e + 1];
                  t.addFace(
                    i[0],
                    r[0],
                    s[0],
                    i[1],
                    r[1],
                    s[1],
                    i[2],
                    r[2],
                    s[2]
                  );
                }
              } else if ("l" === h) {
                const e = u.substring(1).trim().split(" ");
                let n = [];
                const i = [];
                if (-1 === u.indexOf("/")) n = e;
                else
                  for (let t = 0, r = e.length; t < r; t++) {
                    const r = e[t].split("/");
                    "" !== r[0] && n.push(r[0]), "" !== r[1] && i.push(r[1]);
                  }
                t.addLineGeometry(n, i);
              } else if ("p" === h) {
                const e = u.slice(1).trim().split(" ");
                t.addPointGeometry(e);
              } else if (null !== (c = r.exec(u))) {
                const e = (" " + c[0].slice(1).trim()).slice(1);
                t.startObject(e);
              } else if (a.test(u))
                t.object.startMaterial(
                  u.substring(7).trim(),
                  t.materialLibraries
                );
              else if (s.test(u))
                t.materialLibraries.push(u.substring(7).trim());
              else if (o.test(u))
                console.warn(
                  'THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.'
                );
              else if ("s" === h) {
                if (((c = u.split(" ")), c.length > 1)) {
                  const e = c[1].trim().toLowerCase();
                  t.object.smooth = "0" !== e && "off" !== e;
                } else t.object.smooth = !0;
                const e = t.object.currentMaterial();
                e && (e.smooth = t.object.smooth);
              } else {
                if ("\0" === u) continue;
                console.warn('THREE.OBJLoader: Unexpected line: "' + u + '"');
              }
          }
          t.finalize();
          const u = new i.YJl();
          u.materialLibraries = [].concat(t.materialLibraries);
          if (
            !0 ===
            !(
              1 === t.objects.length &&
              0 === t.objects[0].geometry.vertices.length
            )
          )
            for (let e = 0, n = t.objects.length; e < n; e++) {
              const n = t.objects[e],
                r = n.geometry,
                s = n.materials,
                a = "Line" === r.type,
                o = "Points" === r.type;
              let l = !1;
              if (0 === r.vertices.length) continue;
              const c = new i.LoY();
              c.setAttribute("position", new i.qtW(r.vertices, 3)),
                r.normals.length > 0 &&
                  c.setAttribute("normal", new i.qtW(r.normals, 3)),
                r.colors.length > 0 &&
                  ((l = !0), c.setAttribute("color", new i.qtW(r.colors, 3))),
                !0 === r.hasUVIndices &&
                  c.setAttribute("uv", new i.qtW(r.uvs, 2));
              const h = [];
              for (let e = 0, n = s.length; e < n; e++) {
                const n = s[e],
                  r = n.name + "_" + n.smooth + "_" + l;
                let c = t.materials[r];
                if (null !== this.materials)
                  if (
                    ((c = this.materials.create(n.name)),
                    !a || !c || c instanceof i.mrM)
                  ) {
                    if (o && c && !(c instanceof i.BH$)) {
                      const e = new i.BH$({ size: 10, sizeAttenuation: !1 });
                      i.imn.prototype.copy.call(e, c),
                        e.color.copy(c.color),
                        (e.map = c.map),
                        (c = e);
                    }
                  } else {
                    const e = new i.mrM();
                    i.imn.prototype.copy.call(e, c),
                      e.color.copy(c.color),
                      (c = e);
                  }
                void 0 === c &&
                  ((c = a
                    ? new i.mrM()
                    : o
                    ? new i.BH$({ size: 1, sizeAttenuation: !1 })
                    : new i.tXL()),
                  (c.name = n.name),
                  (c.flatShading = !n.smooth),
                  (c.vertexColors = l),
                  (t.materials[r] = c)),
                  h.push(c);
              }
              let d;
              if (h.length > 1) {
                for (let e = 0, t = s.length; e < t; e++) {
                  const t = s[e];
                  c.addGroup(t.groupStart, t.groupCount, e);
                }
                d = a ? new i.DXC(c, h) : o ? new i.ONl(c, h) : new i.eaF(c, h);
              } else
                d = a
                  ? new i.DXC(c, h[0])
                  : o
                  ? new i.ONl(c, h[0])
                  : new i.eaF(c, h[0]);
              (d.name = n.name), u.add(d);
            }
          else if (t.vertices.length > 0) {
            const e = new i.BH$({ size: 1, sizeAttenuation: !1 }),
              n = new i.LoY();
            n.setAttribute("position", new i.qtW(t.vertices, 3)),
              t.colors.length > 0 &&
                void 0 !== t.colors[0] &&
                (n.setAttribute("color", new i.qtW(t.colors, 3)),
                (e.vertexColors = !0));
            const r = new i.ONl(n, e);
            u.add(r);
          }
          return u;
        }
      }
    },
    3206: (e, t, n) => {
      "use strict";
      n.d(t, { Y: () => r });
      var i = n(5062);
      class r extends i.BRH {
        constructor(e) {
          super(e), (this.type = i.ix0);
        }
        parse(e) {
          const t = function (e, t) {
              switch (e) {
                case 1:
                  throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
                case 2:
                  throw new Error(
                    "THREE.RGBELoader: Write Error: " + (t || "")
                  );
                case 3:
                  throw new Error(
                    "THREE.RGBELoader: Bad File Format: " + (t || "")
                  );
                default:
                  throw new Error(
                    "THREE.RGBELoader: Memory Error: " + (t || "")
                  );
              }
            },
            n = function (e, t, n) {
              t = t || 1024;
              let i = e.pos,
                r = -1,
                s = 0,
                a = "",
                o = String.fromCharCode.apply(
                  null,
                  new Uint16Array(e.subarray(i, i + 128))
                );
              for (; 0 > (r = o.indexOf("\n")) && s < t && i < e.byteLength; )
                (a += o),
                  (s += o.length),
                  (i += 128),
                  (o += String.fromCharCode.apply(
                    null,
                    new Uint16Array(e.subarray(i, i + 128))
                  ));
              return (
                -1 < r && (!1 !== n && (e.pos += s + r + 1), a + o.slice(0, r))
              );
            },
            r = function (e, t, n, i) {
              const r = e[t + 3],
                s = Math.pow(2, r - 128) / 255;
              (n[i + 0] = e[t + 0] * s),
                (n[i + 1] = e[t + 1] * s),
                (n[i + 2] = e[t + 2] * s),
                (n[i + 3] = 1);
            },
            s = function (e, t, n, r) {
              const s = e[t + 3],
                a = Math.pow(2, s - 128) / 255;
              (n[r + 0] = i.GxU.toHalfFloat(Math.min(e[t + 0] * a, 65504))),
                (n[r + 1] = i.GxU.toHalfFloat(Math.min(e[t + 1] * a, 65504))),
                (n[r + 2] = i.GxU.toHalfFloat(Math.min(e[t + 2] * a, 65504))),
                (n[r + 3] = i.GxU.toHalfFloat(1));
            },
            a = new Uint8Array(e);
          a.pos = 0;
          const o = (function (e) {
              const i = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                r = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                s = /^\s*FORMAT=(\S+)\s*$/,
                a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                o = {
                  valid: 0,
                  string: "",
                  comments: "",
                  programtype: "RGBE",
                  format: "",
                  gamma: 1,
                  exposure: 1,
                  width: 0,
                  height: 0,
                };
              let l, c;
              for (
                (e.pos >= e.byteLength || !(l = n(e))) &&
                  t(1, "no header found"),
                  (c = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"),
                  o.valid |= 1,
                  o.programtype = c[1],
                  o.string += l + "\n";
                (l = n(e)), !1 !== l;

              )
                if (((o.string += l + "\n"), "#" !== l.charAt(0))) {
                  if (
                    ((c = l.match(i)) && (o.gamma = parseFloat(c[1])),
                    (c = l.match(r)) && (o.exposure = parseFloat(c[1])),
                    (c = l.match(s)) && ((o.valid |= 2), (o.format = c[1])),
                    (c = l.match(a)) &&
                      ((o.valid |= 4),
                      (o.height = parseInt(c[1], 10)),
                      (o.width = parseInt(c[2], 10))),
                    2 & o.valid && 4 & o.valid)
                  )
                    break;
                } else o.comments += l + "\n";
              return (
                2 & o.valid || t(3, "missing format specifier"),
                4 & o.valid || t(3, "missing image size specifier"),
                o
              );
            })(a),
            l = o.width,
            c = o.height,
            u = (function (e, n, i) {
              const r = n;
              if (r < 8 || r > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
                return new Uint8Array(e);
              r !== ((e[2] << 8) | e[3]) && t(3, "wrong scanline width");
              const s = new Uint8Array(4 * n * i);
              s.length || t(4, "unable to allocate buffer space");
              let a = 0,
                o = 0;
              const l = 4 * r,
                c = new Uint8Array(4),
                u = new Uint8Array(l);
              let h = i;
              for (; h > 0 && o < e.byteLength; ) {
                o + 4 > e.byteLength && t(1),
                  (c[0] = e[o++]),
                  (c[1] = e[o++]),
                  (c[2] = e[o++]),
                  (c[3] = e[o++]),
                  (2 == c[0] && 2 == c[1] && ((c[2] << 8) | c[3]) == r) ||
                    t(3, "bad rgbe scanline format");
                let n,
                  i = 0;
                for (; i < l && o < e.byteLength; ) {
                  n = e[o++];
                  const r = n > 128;
                  if (
                    (r && (n -= 128),
                    (0 === n || i + n > l) && t(3, "bad scanline data"),
                    r)
                  ) {
                    const t = e[o++];
                    for (let e = 0; e < n; e++) u[i++] = t;
                  } else u.set(e.subarray(o, o + n), i), (i += n), (o += n);
                }
                const d = r;
                for (let e = 0; e < d; e++) {
                  let t = 0;
                  (s[a] = u[e + t]),
                    (t += r),
                    (s[a + 1] = u[e + t]),
                    (t += r),
                    (s[a + 2] = u[e + t]),
                    (t += r),
                    (s[a + 3] = u[e + t]),
                    (a += 4);
                }
                h--;
              }
              return s;
            })(a.subarray(a.pos), l, c);
          let h, d, p;
          switch (this.type) {
            case i.RQf:
              p = u.length / 4;
              const e = new Float32Array(4 * p);
              for (let t = 0; t < p; t++) r(u, 4 * t, e, 4 * t);
              (h = e), (d = i.RQf);
              break;
            case i.ix0:
              p = u.length / 4;
              const t = new Uint16Array(4 * p);
              for (let e = 0; e < p; e++) s(u, 4 * e, t, 4 * e);
              (h = t), (d = i.ix0);
              break;
            default:
              throw new Error(
                "THREE.RGBELoader: Unsupported type: " + this.type
              );
          }
          return {
            width: l,
            height: c,
            data: h,
            header: o.string,
            gamma: o.gamma,
            exposure: o.exposure,
            type: d,
          };
        }
        setDataType(e) {
          return (this.type = e), this;
        }
        load(e, t, n, r) {
          return super.load(
            e,
            function (e, n) {
              switch (e.type) {
                case i.RQf:
                case i.ix0:
                  (e.colorSpace = i.Zr2),
                    (e.minFilter = i.k6q),
                    (e.magFilter = i.k6q),
                    (e.generateMipmaps = !1),
                    (e.flipY = !0);
              }
              t && t(e, n);
            },
            n,
            r
          );
        }
      }
    },
    739: (e, t, n) => {
      "use strict";
      n.d(t, { J: () => r });
      var i = n(5062);
      class r extends i.eaF {
        constructor(e, t = {}) {
          super(e),
            (this.isReflector = !0),
            (this.type = "Reflector"),
            (this.camera = new i.ubm());
          const n = this,
            s = void 0 !== t.color ? new i.Q1f(t.color) : new i.Q1f(8355711),
            a = t.textureWidth || 512,
            o = t.textureHeight || 512,
            l = t.clipBias || 0,
            c = t.shader || r.ReflectorShader,
            u = void 0 !== t.multisample ? t.multisample : 4,
            h = new i.Zcv(),
            d = new i.Pq0(),
            p = new i.Pq0(),
            f = new i.Pq0(),
            A = new i.kn4(),
            g = new i.Pq0(0, 0, -1),
            m = new i.IUQ(),
            v = new i.Pq0(),
            y = new i.Pq0(),
            x = new i.IUQ(),
            _ = new i.kn4(),
            b = this.camera,
            E = new i.nWS(a, o, { samples: u, type: i.ix0 }),
            w = new i.BKk({
              name: void 0 !== c.name ? c.name : "unspecified",
              uniforms: i.LlO.clone(c.uniforms),
              fragmentShader: c.fragmentShader,
              vertexShader: c.vertexShader,
            });
          (w.uniforms.tDiffuse.value = E.texture),
            (w.uniforms.color.value = s),
            (w.uniforms.textureMatrix.value = _),
            (this.material = w),
            (this.onBeforeRender = function (e, t, i) {
              if (
                (p.setFromMatrixPosition(n.matrixWorld),
                f.setFromMatrixPosition(i.matrixWorld),
                A.extractRotation(n.matrixWorld),
                d.set(0, 0, 1),
                d.applyMatrix4(A),
                v.subVectors(p, f),
                v.dot(d) > 0)
              )
                return;
              v.reflect(d).negate(),
                v.add(p),
                A.extractRotation(i.matrixWorld),
                g.set(0, 0, -1),
                g.applyMatrix4(A),
                g.add(f),
                y.subVectors(p, g),
                y.reflect(d).negate(),
                y.add(p),
                b.position.copy(v),
                b.up.set(0, 1, 0),
                b.up.applyMatrix4(A),
                b.up.reflect(d),
                b.lookAt(y),
                (b.far = i.far),
                b.updateMatrixWorld(),
                b.projectionMatrix.copy(i.projectionMatrix),
                _.set(
                  0.5,
                  0,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0,
                  0.5,
                  0.5,
                  0,
                  0,
                  0,
                  1
                ),
                _.multiply(b.projectionMatrix),
                _.multiply(b.matrixWorldInverse),
                _.multiply(n.matrixWorld),
                h.setFromNormalAndCoplanarPoint(d, p),
                h.applyMatrix4(b.matrixWorldInverse),
                m.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
              const r = b.projectionMatrix;
              (x.x = (Math.sign(m.x) + r.elements[8]) / r.elements[0]),
                (x.y = (Math.sign(m.y) + r.elements[9]) / r.elements[5]),
                (x.z = -1),
                (x.w = (1 + r.elements[10]) / r.elements[14]),
                m.multiplyScalar(2 / m.dot(x)),
                (r.elements[2] = m.x),
                (r.elements[6] = m.y),
                (r.elements[10] = m.z + 1 - l),
                (r.elements[14] = m.w),
                (n.visible = !1);
              const s = e.getRenderTarget(),
                a = e.xr.enabled,
                o = e.shadowMap.autoUpdate;
              (e.xr.enabled = !1),
                (e.shadowMap.autoUpdate = !1),
                e.setRenderTarget(E),
                e.state.buffers.depth.setMask(!0),
                !1 === e.autoClear && e.clear(),
                e.render(t, b),
                (e.xr.enabled = a),
                (e.shadowMap.autoUpdate = o),
                e.setRenderTarget(s);
              const c = i.viewport;
              void 0 !== c && e.state.viewport(c), (n.visible = !0);
            }),
            (this.getRenderTarget = function () {
              return E;
            }),
            (this.dispose = function () {
              E.dispose(), n.material.dispose();
            });
        }
      }
      r.ReflectorShader = {
        name: "ReflectorShader",
        uniforms: {
          color: { value: null },
          tDiffuse: { value: null },
          textureMatrix: { value: null },
        },
        vertexShader:
          "\n\t\tuniform mat4 textureMatrix;\n\t\tvarying vec4 vUv;\n\n\t\t#include <common>\n\t\t#include <logdepthbuf_pars_vertex>\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t\t#include <logdepthbuf_vertex>\n\n\t\t}",
        fragmentShader:
          "\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\t\tvarying vec4 vUv;\n\n\t\t#include <logdepthbuf_pars_fragment>\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#include <logdepthbuf_fragment>\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}",
      };
    },
    2445: (e, t, n) => {
      "use strict";
      n.d(t, { N: () => r });
      var i = n(5062);
      class r extends i.eaF {
        constructor(e, t = {}) {
          super(e),
            (this.isRefractor = !0),
            (this.type = "Refractor"),
            (this.camera = new i.ubm());
          const n = this,
            s = void 0 !== t.color ? new i.Q1f(t.color) : new i.Q1f(8355711),
            a = t.textureWidth || 512,
            o = t.textureHeight || 512,
            l = t.clipBias || 0,
            c = t.shader || r.RefractorShader,
            u = void 0 !== t.multisample ? t.multisample : 4,
            h = this.camera;
          (h.matrixAutoUpdate = !1), (h.userData.refractor = !0);
          const d = new i.Zcv(),
            p = new i.kn4(),
            f = new i.nWS(a, o, { samples: u, type: i.ix0 });
          (this.material = new i.BKk({
            name: void 0 !== c.name ? c.name : "unspecified",
            uniforms: i.LlO.clone(c.uniforms),
            vertexShader: c.vertexShader,
            fragmentShader: c.fragmentShader,
            transparent: !0,
          })),
            (this.material.uniforms.color.value = s),
            (this.material.uniforms.tDiffuse.value = f.texture),
            (this.material.uniforms.textureMatrix.value = p);
          const A = (function () {
              const e = new i.Pq0(),
                t = new i.Pq0(),
                r = new i.kn4(),
                s = new i.Pq0(),
                a = new i.Pq0();
              return function (i) {
                return (
                  e.setFromMatrixPosition(n.matrixWorld),
                  t.setFromMatrixPosition(i.matrixWorld),
                  s.subVectors(e, t),
                  r.extractRotation(n.matrixWorld),
                  a.set(0, 0, 1),
                  a.applyMatrix4(r),
                  s.dot(a) < 0
                );
              };
            })(),
            g = (function () {
              const e = new i.Pq0(),
                t = new i.Pq0(),
                r = new i.PTz(),
                s = new i.Pq0();
              return function () {
                n.matrixWorld.decompose(t, r, s),
                  e.set(0, 0, 1).applyQuaternion(r).normalize(),
                  e.negate(),
                  d.setFromNormalAndCoplanarPoint(e, t);
              };
            })(),
            m = (function () {
              const e = new i.Zcv(),
                t = new i.IUQ(),
                n = new i.IUQ();
              return function (i) {
                h.matrixWorld.copy(i.matrixWorld),
                  h.matrixWorldInverse.copy(h.matrixWorld).invert(),
                  h.projectionMatrix.copy(i.projectionMatrix),
                  (h.far = i.far),
                  e.copy(d),
                  e.applyMatrix4(h.matrixWorldInverse),
                  t.set(e.normal.x, e.normal.y, e.normal.z, e.constant);
                const r = h.projectionMatrix;
                (n.x = (Math.sign(t.x) + r.elements[8]) / r.elements[0]),
                  (n.y = (Math.sign(t.y) + r.elements[9]) / r.elements[5]),
                  (n.z = -1),
                  (n.w = (1 + r.elements[10]) / r.elements[14]),
                  t.multiplyScalar(2 / t.dot(n)),
                  (r.elements[2] = t.x),
                  (r.elements[6] = t.y),
                  (r.elements[10] = t.z + 1 - l),
                  (r.elements[14] = t.w);
              };
            })();
          (this.onBeforeRender = function (e, t, i) {
            !0 !== i.userData.refractor &&
              !0 != !A(i) &&
              (g(),
              (function (e) {
                p.set(
                  0.5,
                  0,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0.5,
                  0,
                  0,
                  0.5,
                  0.5,
                  0,
                  0,
                  0,
                  1
                ),
                  p.multiply(e.projectionMatrix),
                  p.multiply(e.matrixWorldInverse),
                  p.multiply(n.matrixWorld);
              })(i),
              m(i),
              (function (e, t, i) {
                n.visible = !1;
                const r = e.getRenderTarget(),
                  s = e.xr.enabled,
                  a = e.shadowMap.autoUpdate;
                (e.xr.enabled = !1),
                  (e.shadowMap.autoUpdate = !1),
                  e.setRenderTarget(f),
                  !1 === e.autoClear && e.clear(),
                  e.render(t, h),
                  (e.xr.enabled = s),
                  (e.shadowMap.autoUpdate = a),
                  e.setRenderTarget(r);
                const o = i.viewport;
                void 0 !== o && e.state.viewport(o), (n.visible = !0);
              })(e, t, i));
          }),
            (this.getRenderTarget = function () {
              return f;
            }),
            (this.dispose = function () {
              f.dispose(), n.material.dispose();
            });
        }
      }
      r.RefractorShader = {
        name: "RefractorShader",
        uniforms: {
          color: { value: null },
          tDiffuse: { value: null },
          textureMatrix: { value: null },
        },
        vertexShader:
          "\n\n\t\tuniform mat4 textureMatrix;\n\n\t\tvarying vec4 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = textureMatrix * vec4( position, 1.0 );\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
        fragmentShader:
          "\n\n\t\tuniform vec3 color;\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec4 vUv;\n\n\t\tfloat blendOverlay( float base, float blend ) {\n\n\t\t\treturn( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );\n\n\t\t}\n\n\t\tvec3 blendOverlay( vec3 base, vec3 blend ) {\n\n\t\t\treturn vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvec4 base = texture2DProj( tDiffuse, vUv );\n\t\t\tgl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <colorspace_fragment>\n\n\t\t}",
      };
    },
    1358: (e, t, n) => {
      "use strict";
      function i(e) {
        const t = new Map(),
          n = new Map(),
          i = e.clone();
        return (
          r(e, i, function (e, i) {
            t.set(i, e), n.set(e, i);
          }),
          i.traverse(function (e) {
            if (!e.isSkinnedMesh) return;
            const i = e,
              r = t.get(e),
              s = r.skeleton.bones;
            (i.skeleton = r.skeleton.clone()),
              i.bindMatrix.copy(r.bindMatrix),
              (i.skeleton.bones = s.map(function (e) {
                return n.get(e);
              })),
              i.bind(i.skeleton, i.bindMatrix);
          }),
          i
        );
      }
      function r(e, t, n) {
        n(e, t);
        for (let i = 0; i < e.children.length; i++)
          r(e.children[i], t.children[i], n);
      }
      n.d(t, { o8: () => i });
    },
    20: (e, t, n) => {
      "use strict";
      n.d(t, { qE: () => i });
      Math.PI, Math.PI;
      function i(e, t, n) {
        return Math.max(t, Math.min(n, e));
      }
    },
  },
]);
